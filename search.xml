<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>限流基本原理</title>
    <url>/blog/design/theory/flow-limit-theory/</url>
    <content><![CDATA[<h1 id="限流基本原理"><a class="markdownIt-Anchor" href="#限流基本原理"></a> 限流基本原理</h1>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#%E9%99%90%E6%B5%81%E6%96%B9%E6%B3%95">限流方法</a>
<ul>
<li><a href="#%E8%AE%A1%E6%95%B0%E5%99%A8">计数器</a></li>
<li><a href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">滑动窗口</a></li>
<li><a href="#%E4%BB%A4%E7%89%8C%E6%A1%B6token-bucket">令牌桶（Token Bucket）</a></li>
<li><a href="#%E6%BC%8F%E6%A1%B6">漏桶</a></li>
</ul>
</li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- /TOC -->
<p>限流可以认为是服务降级的一种。限流就是<strong>限制系统的输入和输出流量已达到保护系统的目的</strong>。一般来说系统的吞吐量是可以被测算的，为了保证系统的稳定运行，一旦达到的需要限制的阈值，就需要限制流量并采取一些措施以完成限制流量的目的。比如：延迟处理，拒绝处理，或者部分拒绝处理等等。</p>
<h2 id="限流方法"><a class="markdownIt-Anchor" href="#限流方法"></a> 限流方法</h2>
<h3 id="计数器"><a class="markdownIt-Anchor" href="#计数器"></a> 计数器</h3>
<p>控制单位时间的请求数量。使用 <code>AtomicInteger</code> 进行统计。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大访问数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> limit = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 访问时间差</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timeout = <span class="number">1000</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> time;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前计数器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger reqCount = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">limit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">if</span> (now &lt; time + timeout) &#123;</span><br><span class="line">            <span class="comment">// 单位时间内</span></span><br><span class="line">            reqCount.addAndGet(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> reqCount.get() &lt;= limit;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 超出单位时间</span></span><br><span class="line">            time = now;</span><br><span class="line">            reqCount = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="滑动窗口"><a class="markdownIt-Anchor" href="#滑动窗口"></a> 滑动窗口</h3>
<p>滑动窗口是对计数器方式的改进，增加一个时间粒度的度量单位 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentLinkedQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeWindow</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ConcurrentLinkedQueue&lt;Long&gt; queue = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;Long&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 间隔秒数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> seconds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大限流</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> max;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TimeWindow</span><span class="params">(<span class="keyword">int</span> max, <span class="keyword">int</span> seconds)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.seconds = seconds;</span><br><span class="line">        <span class="keyword">this</span>.max = max;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 永续线程执行清理queue 任务</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 等待 间隔秒数-1 执行清理操作</span></span><br><span class="line">                    Thread.sleep((seconds - <span class="number">1</span>) * <span class="number">1000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                clean();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> TimeWindow timeWindow = <span class="keyword">new</span> TimeWindow(<span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试3个线程</span></span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">3</span>).forEach((i) -&gt; &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">20</span>) * <span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    timeWindow.take();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;).start();</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取令牌，并且添加时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">take</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> size = sizeOfValid();</span><br><span class="line">            <span class="keyword">if</span> (size &gt; max) &#123;</span><br><span class="line">                System.err.println(<span class="string">"超限"</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sizeOfValid() &gt; max) &#123;</span><br><span class="line">                    System.err.println(<span class="string">"超限"</span>);</span><br><span class="line">                    System.err.println(<span class="string">"queue中有 "</span> + queue.size() + <span class="string">" 最大数量 "</span> + max);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">this</span>.queue.offer(System.currentTimeMillis());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"queue中有 "</span> + queue.size() + <span class="string">" 最大数量 "</span> + max);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sizeOfValid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Iterator&lt;Long&gt; it = queue.iterator();</span><br><span class="line">        Long ms = System.currentTimeMillis() - seconds * <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">long</span> t = it.next();</span><br><span class="line">            <span class="keyword">if</span> (t &gt; ms) &#123;</span><br><span class="line">                <span class="comment">// 在当前的统计时间范围内</span></span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清理过期的时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Long c = System.currentTimeMillis() - seconds * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">        Long tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((tl = queue.peek()) != <span class="keyword">null</span> &amp;&amp; tl &lt; c) &#123;</span><br><span class="line">            System.out.println(<span class="string">"清理数据"</span>);</span><br><span class="line">            queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="令牌桶token-bucket"><a class="markdownIt-Anchor" href="#令牌桶token-bucket"></a> 令牌桶（Token Bucket）</h3>
<p>规定固定容量的桶,token 以固定速度往桶内填充,当桶满时 token 不会被继续放入,每过来一个请求把 token 从桶中移除,如果桶中没有 token 不能请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenBucket</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> time;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 总量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Double total;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * token 放入速度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Double rate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前总量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Double nowSize;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">limit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">        nowSize = Math.min(total, nowSize + (now - time) * rate);</span><br><span class="line">        time = now;</span><br><span class="line">        <span class="keyword">if</span> (nowSize &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 桶里没有token</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 存在token</span></span><br><span class="line">            nowSize -= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="漏桶"><a class="markdownIt-Anchor" href="#漏桶"></a> 漏桶</h3>
<p>规定固定容量的桶，有水进入，有水流出。对于流进的水我们无法估计进来的数量、速度，对于流出的水我们可以控制速度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeakBucket</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> time;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 总量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Double total;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 水流出去的速度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Double rate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前总量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Double nowSize;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">limit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">        nowSize = Math.max(<span class="number">0</span>, (nowSize - (now - time) * rate));</span><br><span class="line">        time = now;</span><br><span class="line">        <span class="keyword">if</span> ((nowSize + <span class="number">1</span>) &lt; total) &#123;</span><br><span class="line">            nowSize++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li>《大型网站技术架构》</li>
<li><a href="https://www.jianshu.com/p/76cc8ba5ca91" target="_blank" rel="noopener">谈谈限流算法的几种实现</a></li>
<li><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/huifer-how-to-limit-current.md" target="_blank" rel="noopener">如何限流？在工作中是怎么做的？说一下具体的实现？</a></li>
</ul>
]]></content>
      <categories>
        <category>设计</category>
        <category>系统原理</category>
      </categories>
      <tags>
        <tag>设计</tag>
        <tag>系统原理</tag>
        <tag>限流</tag>
      </tags>
  </entry>
  <entry>
    <title>测试技术原理</title>
    <url>/blog/design/architecture/test-architecture/</url>
    <content><![CDATA[<h1 id="测试技术原理"><a class="markdownIt-Anchor" href="#测试技术原理"></a> 测试技术原理</h1>
<blockquote>
<p>软件测试描述一种用来促进鉴定软件的正确性、完整性、安全性和质量的过程。软件测试的经典定义是：在规定的条件下对程序进行操作，以发现程序错误，衡量软件质量，并对其是否能满足设计要求进行评估的过程。</p>
<p>现代软件开发项目中，分工明确，基本上都会有研发、测试、QA 等角色。不同角色由于关注的视角不同，测试目标和测试方法也不完全相同。本文主要从研发、测试的视角去考量软件测试技术。</p>
<p>注意：</p>
<ul>
<li>为了方便，只有测试人员需要关注的测试点用【测试】标注；</li>
<li>而只有研发人员需要关注的测试点用【研发】标注；</li>
<li>都需要关注的测试点则不作标注。</li>
</ul>
</blockquote>
<h2 id="测试方法分类"><a class="markdownIt-Anchor" href="#测试方法分类"></a> 测试方法分类</h2>
<h3 id="从测试设计方法分类"><a class="markdownIt-Anchor" href="#从测试设计方法分类"></a> 从测试设计方法分类</h3>
<ul>
<li><strong>黑盒测试【测试】</strong> - 把软件系统当作一个“黑箱”，无法了解或使用系统的内部结构及知识。从软件的行为，而不是内部结构出发来设计测试。</li>
<li><strong>白盒测试【研发】</strong> - 设计者可以看到软件系统的内部结构，并且使用软件的内部知识来指导测试数据及方法的选择。</li>
<li><strong>灰盒测试</strong> - 介于黑盒和白盒之间。</li>
</ul>
<blockquote>
<p>小结：</p>
<ul>
<li>黑河测试通常针对的是软件的行为或功能，一般是测试人员主要关注的。</li>
<li>白盒测试通常则需要对软件有一定程度的了解，一般是开发人员所关注的。</li>
<li>灰盒测试通常是为了测试软件在特定的场景下的表现，而非主场景。</li>
</ul>
</blockquote>
<h3 id="从测试的目的分类"><a class="markdownIt-Anchor" href="#从测试的目的分类"></a> 从测试的目的分类</h3>
<h4 id="功能测试"><a class="markdownIt-Anchor" href="#功能测试"></a> 功能测试</h4>
<ul>
<li><strong>单元测试（Unit Test）</strong> - 在最低粒度的功能/参数上验证程序的准确性，比如测试一个函数的正确性。【研发】
<ul>
<li>常用技术：<a href="https://github.com/junit-team/junit4" target="_blank" rel="noopener"><strong>junit4</strong></a>、<a href="https://github.com/junit-team/junit5" target="_blank" rel="noopener"><strong>junit5</strong></a>、<a href="https://github.com/mockito/mockito" target="_blank" rel="noopener"><strong>mockito</strong></a>、<a href="https://github.com/joel-costigliola/assertj-core" target="_blank" rel="noopener"><strong>assertj-core</strong></a></li>
</ul>
</li>
<li><strong>功能测试（Functional Test）</strong> - 验证模块的功能。【测试】</li>
<li><strong>集成测试（Integration Test）</strong> - 验证几个互相有依赖关系的模块的功能。【测试】</li>
<li><strong>场景测试（Scenario Test）</strong>- 验证几个模块是否能完成一个用户场景。【测试】</li>
<li><strong>系统测试（System Test）</strong> - 对于整个系统功能的测试。【测试】</li>
<li><strong>Alpha 测试</strong> - 软件测试人员在真实用户环境中对软件进行全面的测试。【测试】</li>
<li><strong>Beta 测试</strong> - 也叫公测，是真实的用户在真实的环境中进行的测试。</li>
</ul>
<h4 id="非功能测试"><a class="markdownIt-Anchor" href="#非功能测试"></a> 非功能测试</h4>
<ul>
<li><strong>压力测试（Stress test）</strong> - 验证软件在超过负载设计的情况下仍能返回正确的结果，没有崩溃</li>
<li><strong>负载测试（Load test）</strong> - 测试软件在负载情况下能否正常工作</li>
<li><strong>性能测试（Performance test）</strong> - 测试软件的效能，是否提供满意的服务质量。
<ul>
<li>常用技术：<a href="https://jmeter.apache.org/" target="_blank" rel="noopener"><strong>JMeter</strong></a>、JMH。</li>
</ul>
</li>
<li><strong>软件辅助功能测试（Accessibility test</strong>） - 测试软件是否向残疾用户提供足够的辅助功能</li>
<li><strong>本地化/全球化测试（Localization/Globalization</strong>）</li>
<li><strong>兼容性测试（Compatibility Test）</strong></li>
<li><strong>配置测试（Configuration Test）</strong> - 测试软件在各种配置下能否正常工作</li>
<li><strong>可用性测试（Usability Test）</strong> – 测试软件是否好用</li>
<li><strong>安全性测试（Security Test）</strong></li>
</ul>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><a href="https://www.cnblogs.com/TankXiao/archive/2012/02/20/2347016.html" target="_blank" rel="noopener">软件测试 (一) 软件测试方法大汇总</a></li>
<li><a href="https://www.xncoding.com/2018/01/07/java/jmh.html" target="_blank" rel="noopener">Java微基准测试框架JMH</a></li>
</ul>
]]></content>
      <categories>
        <category>设计</category>
        <category>系统原理</category>
      </categories>
      <tags>
        <tag>设计</tag>
        <tag>系统原理</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>design/architecture/system-architecture-interview</title>
    <url>/blog/design/architecture/system-architecture-interview/</url>
    <content><![CDATA[<h1 id="系统架构面试"><a class="markdownIt-Anchor" href="#系统架构面试"></a> 系统架构面试</h1>
<h2 id="如何设计一个秒杀系统"><a class="markdownIt-Anchor" href="#如何设计一个秒杀系统"></a> 如何设计一个秒杀系统？</h2>
<h3 id="秒杀系统的挑战"><a class="markdownIt-Anchor" href="#秒杀系统的挑战"></a> 秒杀系统的挑战</h3>
<p>秒杀的核心问题就是<strong>极高并发处理</strong>，由于系统要在瞬时承受平时数十倍甚至上百倍的流量，这往往超出系统上限，因此处理秒杀的<strong>核心思路是限流和缓存</strong>。</p>
<h3 id="秒杀系统的解决思路"><a class="markdownIt-Anchor" href="#秒杀系统的解决思路"></a> 秒杀系统的解决思路</h3>
<ul>
<li>系统上有拦截流量：尽可能在上游拦截和限制请求，限制流入后端的量，保证后端系统正常。 因为无论多少人参与秒杀，实际成交往往是有限的，而且远小于参加秒杀的人数，因此可以通过前端系统进行拦截，限制最终流入系统的请求数量，来保证系统正常进行。</li>
<li>充分利用缓存：这是一个典型的读多写少的应用场景（一趟火车其实只有2000张票，200w个人来买，最多2000个人下单成功，其他人都是查询库存，写比例只有0.1%，读比例占99.9%），非常适合使用缓存。</li>
</ul>
<h3 id="秒杀系统的解决方案"><a class="markdownIt-Anchor" href="#秒杀系统的解决方案"></a> 秒杀系统的解决方案</h3>
<p>秒杀系统具体方案如下：</p>
<p><strong>（1）浏览器、客户端拦截重复请求</strong></p>
<ul>
<li>用户点击查询或购买按钮后，禁用按钮，避免用户重复提交请求。</li>
<li>JS 代码中限制用户在限定时间内只允许提交一次请求</li>
</ul>
<p>基于此，大部分流量已被拦截。</p>
<p><strong>（2）应用层拦截请求</strong></p>
<p>浏览器、客户端拦截重复请求只能应付通过浏览器访问的用户。如果有人通过程序发送 http 请求，则无法拦截。针对这种情况的方案是：</p>
<p>以页面缓存的方式，针对短时间内的同一个访问源（如同一个IP、同一个 Session、同一个用户 ID多次发送HTTP请求）或同样的查询请求（如大量请求都是查询某类商品的库存），都返回相同的展示页面。</p>
<p>如此限流，又有大部分的流量被拦截</p>
<p>（3）服务层请求拦截与数据缓存</p>
<p>加入有黑客，控制了10w台肉鸡（并且假设买票不需要实名认证），前面的的限制都不起作用了。这时应该怎么办？</p>
<ul>
<li>
<p>读请求（查库存） - 对于读请求，直接使用缓存即可，一般缓存服务器单机处理每秒10w个请求应该没什么问题。</p>
</li>
<li>
<p>写请求（下单） - 由于服务层清楚的知道库存数量，所以完全可以根据库存数量进行限流。具体来说，就是把所有下单请求都丢该消息队列中，每次只取有限的写请求去数据层处理。当这些写请求处理完，更新一下缓存中的库存数，再去取下一批写请求，如果库存数不够，则消息队列的写请求全部返回&quot;已售罄&quot;的结果。</p>
</li>
</ul>
<blockquote>
<p>参考：</p>
<ul>
<li><a href="https://www.zhihu.com/question/54895548/answer/146924420" target="_blank" rel="noopener">如何设计秒杀系统？ - 阿里云云栖社区的回答 - 知乎</a></li>
<li><a href="https://www.zhihu.com/question/54895548/answer/259218876" target="_blank" rel="noopener">如何设计秒杀系统？ - 网易云的回答 - 知乎</a></li>
</ul>
</blockquote>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><a href="https://www.zhihu.com/question/54895548/answer/146924420" target="_blank" rel="noopener">如何设计秒杀系统？ - 阿里云云栖社区的回答 - 知乎</a></li>
<li><a href="https://www.zhihu.com/question/54895548/answer/259218876" target="_blank" rel="noopener">如何设计秒杀系统？ - 网易云的回答 - 知乎</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>bigdata/README</title>
    <url>/blog/bigdata/README/</url>
    <content><![CDATA[<h1 id="大数据"><a class="markdownIt-Anchor" href="#大数据"></a> 大数据</h1>
<h2 id="知识点"><a class="markdownIt-Anchor" href="#知识点"></a> 📝 知识点</h2>
<ul>
<li><a href="MapReduce.md">MapReduce</a></li>
<li><a href="HDFS.md">HDFS</a></li>
<li><a href="YARN.md">YARN</a></li>
<li><a href="hbase">HBase</a>
<ul>
<li><a href="hbase/hbase-cli.md">HBase 命令</a></li>
<li><a href="hbase/hbase-ops.md">HBase 配置</a></li>
</ul>
</li>
</ul>
<h2 id="学习资源"><a class="markdownIt-Anchor" href="#学习资源"></a> 📚 学习资源</h2>
<h3 id="书"><a class="markdownIt-Anchor" href="#书"></a> 书</h3>
<p><a href="https://book.douban.com/subject/6523762/" target="_blank" rel="noopener">Hadoop 权威指南</a></p>
<h2 id="传送门"><a class="markdownIt-Anchor" href="#传送门"></a> 🚪 传送门</h2>
<p>| <a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">回首頁</a> |</p>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>分库分表基本原理</title>
    <url>/blog/design/theory/sharding-theory/</url>
    <content><![CDATA[<h1 id="分库分表基本原理"><a class="markdownIt-Anchor" href="#分库分表基本原理"></a> 分库分表基本原理</h1>
<p>分片（Sharding）的基本思想就要把一个数据库切分成多个部分，存储在不同的数据库(server)上，从而缓解单一数据库的性能问题。</p>
<h2 id="1-数据分片"><a class="markdownIt-Anchor" href="#1-数据分片"></a> 1. 数据分片</h2>
<p>数据分片指按照某个维度将存放在单一数据库中的数据分散地存放至多个数据库或表中以达到提升性能瓶颈以及可用性的效果。 数据分片的有效手段是对关系型数据库进行分库和分表。分库和分表均可以有效的避免由数据量超过可承受阈值而产生的查询瓶颈。 除此之外，分库还能够用于有效的分散对数据库单点的访问量；分表虽然无法缓解数据库压力，但却能够提供尽量将分布式事务转化为本地事务的可能，一旦涉及到跨库的更新操作，分布式事务往往会使问题变得复杂。 使用多主多从的分片方式，可以有效的避免数据单点，从而提升数据架构的可用性。</p>
<p>通过分库和分表进行数据的拆分来使得各个表的数据量保持在阈值以下，以及对流量进行疏导应对高访问量，是应对高并发和海量数据系统的有效手段。 数据分片的拆分方式又分为垂直分片和水平分片。</p>
<h3 id="11-垂直分片"><a class="markdownIt-Anchor" href="#11-垂直分片"></a> 1.1. 垂直分片</h3>
<p><strong>按照业务拆分的方式称为垂直分片</strong>，又称为纵向拆分，它的核心理念是专库专用。</p>
<p>在拆分之前，一个数据库由多个数据表构成，每个表对应着不同的业务。而拆分之后，则是<strong>按照业务将表进行归类，分布到不同的数据库中</strong>，从而将压力分散至不同的数据库。下图展示了根据业务需要，将用户表和订单表垂直分片到不同的数据库的方案。</p>
<p><img src="https://shardingsphere.apache.org/document/current/img/sharding/vertical_sharding.png" alt="垂直分片" /></p>
<p>垂直分片往往需要对架构和设计进行调整。通常来讲，是来不及应对互联网业务需求快速变化的；而且，它也并无法真正的解决单点瓶颈。<strong>垂直拆分可以缓解数据量和访问量带来的问题，但无法根治。如果垂直拆分之后，表中的数据量依然超过单节点所能承载的阈值，则需要水平分片来进一步处理</strong>。</p>
<h3 id="12-水平分片"><a class="markdownIt-Anchor" href="#12-水平分片"></a> 1.2. 水平分片</h3>
<p>水平分片又称为横向拆分。 相对于垂直分片，<strong>水平分片不再将数据根据业务逻辑分类，而是通过某个字段（或某几个字段），根据某种规则将数据分散至多个库或表中，每个分片仅包含数据的一部分</strong>。 例如：根据主键分片，偶数主键的记录放入 0 库（或表），奇数主键的记录放入 1 库（或表），如下图所示。</p>
<p><img src="https://shardingsphere.apache.org/document/current/img/sharding/horizontal_sharding.png" alt="水平分片" /></p>
<p><strong>水平分片从理论上突破了单机数据量处理的瓶颈，并且扩展相对自由，是分库分表的标准解决方案</strong>。</p>
<h2 id="2-分库分表的问题"><a class="markdownIt-Anchor" href="#2-分库分表的问题"></a> 2. 分库分表的问题</h2>
<h3 id="21-事务问题"><a class="markdownIt-Anchor" href="#21-事务问题"></a> 2.1. 事务问题</h3>
<p>解决事务问题目前有两种可行的方案：分布式事务和通过应用程序与数据库共同控制实现事务下面对两套方案进行一个简单的对比。</p>
<ul>
<li>方案一：使用分布式事务
<ul>
<li>优点：交由数据库管理，简单有效</li>
<li>缺点：性能代价高，特别是 sharding 越来越多时</li>
</ul>
</li>
<li>方案二：由应用程序和数据库共同控制
<ul>
<li>原理：将一个跨多个数据库的分布式事务分拆成多个仅处于单个数据库上面的小事务，并通过应用程序来总控各个小事务。</li>
<li>优点：性能上有优势</li>
<li>缺点：需要应用程序在事务控制上做灵活设计。如果使用 了<a href="http://lib.csdn.net/base/javaee" target="_blank" rel="noopener">spring</a>的事务管理，改动起来会面临一定的困难。</li>
</ul>
</li>
</ul>
<p>跨库事务也是分布式的数据库集群要面对的棘手事情。 合理采用分表，可以在降低单表数据量的情况下，尽量使用本地事务，善于使用同库不同表可有效避免分布式事务带来的麻烦。在不能避免跨库事务的场景，有些业务仍然需要保持事务的一致性。 而基于 XA 的分布式事务由于在并发度高的场景中性能无法满足需要，并未被互联网巨头大规模使用，他们大多采用最终一致性的柔性事务代替强一致事务。</p>
<h3 id="22-跨节点-join-的问题"><a class="markdownIt-Anchor" href="#22-跨节点-join-的问题"></a> 2.2. 跨节点 Join 的问题</h3>
<p>只要是进行切分，跨节点 Join 的问题是不可避免的。但是良好的设计和切分却可以减少此类情况的发生。解决这一问题的普遍做法是分两次查询实现。在第一次查询的结果集中找出关联数据的 id，根据这些 id 发起第二次请求得到关联数据。</p>
<h3 id="23-跨节点的-countorder-bygroup-by-以及聚合函数问题"><a class="markdownIt-Anchor" href="#23-跨节点的-countorder-bygroup-by-以及聚合函数问题"></a> 2.3. 跨节点的 count,order by,group by 以及聚合函数问题</h3>
<p>这些是一类问题，因为它们都需要基于全部数据集合进行计算。多数的代理都不会自动处理合并工作。解决方案：与解决跨节点 join 问题的类似，分别在各个节点上得到结果后在应用程序端进行合并。和 join 不同的是每个结点的查询可以并行执行，因此很多时候它的速度要比单一大表快很多。但如果结果集很大，对应用程序内存的消耗是一个问题。</p>
<h3 id="24-数据迁移容量规划扩容等问题"><a class="markdownIt-Anchor" href="#24-数据迁移容量规划扩容等问题"></a> 2.4. 数据迁移，容量规划，扩容等问题</h3>
<p>来自淘宝综合业务平台团队，它利用对 2 的倍数取余具有向前兼容的特性（如对 4 取余得 1 的数对 2 取余也是 1）来分配数据，避免了<strong>行级别的数据迁移</strong>，但是依然需要进行<strong>表级别的迁移</strong>，同时对扩容规模和分表数量都有限制。总得来说，这些方案都不是十分的理想，多多少少都存在一些缺点，这也从一个侧面反映出了 Sharding 扩容的难度。</p>
<h3 id="25-id-问题"><a class="markdownIt-Anchor" href="#25-id-问题"></a> 2.5. ID 问题</h3>
<p>一旦数据库被切分到多个物理结点上，我们将不能再依赖数据库自身的主键生成机制。一方面，某个分区数据库自生成的 ID 无法保证在全局上是唯一的；另一方面，应用程序在插入数据之前需要先获得 ID,以便进行 SQL 路由. 一些常见的主键生成策略</p>
<h4 id="251-uuid"><a class="markdownIt-Anchor" href="#251-uuid"></a> 2.5.1. UUID</h4>
<p>使用 UUID 作主键是最简单的方案，但是缺点也是非常明显的。由于 UUID 非常的长，除占用大量存储空间外，最主要的问题是在索引上，在建立索引和基于索引进行查询时都存在性能问题。</p>
<h4 id="252-结合数据库维护一个-sequence-表"><a class="markdownIt-Anchor" href="#252-结合数据库维护一个-sequence-表"></a> 2.5.2. 结合数据库维护一个 Sequence 表</h4>
<p>此方案的思路也很简单，在数据库中建立一个 Sequence 表，表的结构类似于：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`SEQUENCE`</span> (</span><br><span class="line">    <span class="string">`table_name`</span> <span class="built_in">varchar</span>(<span class="number">18</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`nextid`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`table_name`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span></span><br></pre></td></tr></table></figure>
<p>每当需要为某个表的新纪录生成 ID 时就从 Sequence 表中取出对应表的 nextid,并将 nextid 的值加 1 后更新到数据库中以备下次使用。此方案也较简单，但缺点同样明显：由于所有插入任何都需要访问该表，该表很容易成为系统性能瓶颈，同时它也存在单点问题，一旦该表数据库失效，整个应用程序将无法工作。有人提出使用 Master-Slave 进行主从同步，但这也只能解决单点问题，并不能解决读写比为 1:1 的访问压力问题。</p>
<h4 id="253-twitter-的分布式自增-id-算法-snowflake"><a class="markdownIt-Anchor" href="#253-twitter-的分布式自增-id-算法-snowflake"></a> 2.5.3. <a href="http://blog.sina.com.cn/s/blog_6b7c2e660102vbi2.html" target="_blank" rel="noopener">Twitter 的分布式自增 ID 算法 Snowflake</a></h4>
<p>在分布式系统中，需要生成全局 UID 的场合还是比较多的，twitter 的 snowflake 解决了这种需求，实现也还是很简单的，除去配置信息，核心代码就是毫秒级时间 41 位 机器 ID 10 位 毫秒内序列 12 位。</p>
<ul>
<li>10—0000000000 0000000000 0000000000 0000000000 0 — 00000 —00000 —000000000000 在上面的字符串中，第一位为未使用（实际上也可作为 long 的符号位），接下来的 41 位为毫秒级时间，然后 5 位 datacenter 标识位，5 位机器 ID（并不算标识符，实际是为线程标识），然后 12 位该毫秒内的当前毫秒内的计数，加起来刚好 64 位，为一个 Long 型。</li>
</ul>
<p>这样的好处是，整体上按照时间自增排序，并且整个分布式系统内不会产生 ID 碰撞（由 datacenter 和机器 ID 作区分），并且效率较高，经测试，snowflake 每秒能够产生 26 万 ID 左右，完全满足需要。</p>
<h3 id="26-跨分片的排序分页"><a class="markdownIt-Anchor" href="#26-跨分片的排序分页"></a> 2.6. 跨分片的排序分页</h3>
<p>一般来讲，分页时需要按照指定字段进行排序。当排序字段就是分片字段的时候，我们通过分片规则可以比较容易定位到指定的分片，而当排序字段非分片字段的时候，情况就会变得比较复杂了。为了最终结果的准确性，我们需要在不同的分片节点中将数据进行排序并返回，并将不同分片返回的结果集进行汇总和再次排序，最后再返回给用户。如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3710706-925381b9a478c8df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640/format/webp" alt="img" /></p>
<p>上面图中所描述的只是最简单的一种情况（取第一页数据），看起来对性能的影响并不大。但是，如果想取出第 10 页数据，情况又将变得复杂很多，如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3710706-9a7cfbdb95bb9b70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640/format/webp" alt="img" /></p>
<p>有些读者可能并不太理解，为什么不能像获取第一页数据那样简单处理（排序取出前 10 条再合并、排序）。其实并不难理解，因为各分片节点中的数据可能是随机的，为了排序的准确性，必须把所有分片节点的前 N 页数据都排序好后做合并，最后再进行整体的排序。很显然，这样的操作是比较消耗资源的，用户越往后翻页，系统性能将会越差。</p>
<p>那如何解决分库情况下的分页问题呢？有以下几种办法：</p>
<p>如果是在前台应用提供分页，则限定用户只能看前面 n 页，这个限制在业务上也是合理的，一般看后面的分页意义不大（如果一定要看，可以要求用户缩小范围重新查询）。</p>
<p>如果是后台批处理任务要求分批获取数据，则可以加大 page size，比如每次获取 5000 条记录，有效减少分页数（当然离线访问一般走备库，避免冲击主库）。</p>
<p>分库设计时，一般还有配套大数据平台汇总所有分库的记录，有些分页查询可以考虑走大数据平台。</p>
<h3 id="27-分库策略"><a class="markdownIt-Anchor" href="#27-分库策略"></a> 2.7. 分库策略</h3>
<ul>
<li>根据数值范围，比如用户 Id 为 1-9999 的记录分到第一个库，10000-20000 的分到第二个库，以此类推。</li>
<li>根据数值取模，比如用户 Id mod n，余数为 0 的记录放到第一个库，余数为 1 的放到第二个库，以此类推。</li>
</ul>
<p>优劣比较：评价指标按照范围分库按照 Mod 分库库数量前期数目比较小，可以随用户/业务按需增长前期即根据 mode 因子确定库数量，数目一般比较大访问性能前期库数量小，全库查询消耗资源少，单库查询性能略差前期库数量大，全库查询消耗资源多，单库查询性能略好调整库数量比较容易，一般只需为新用户增加库，老库拆分也只影响单个库困难，改变 mod 因子导致数据在所有库之间迁移数据热点新旧用户购物频率有差异，有数据热点问题新旧用户均匀到分布到各个库，无热点实践中，为了处理简单，选择 mod 分库的比较多。同时二次分库时，为了数据迁移方便，一般是按倍数增加，比如初始 4 个库，二次分裂为 8 个，再 16 个。这样对于某个库的数据，一半数据移到新库，剩余不动，对比每次只增加一个库，所有数据都要大规模变动。补充下，mod 分库一般每个库记录数比较均匀，但也有些数据库，存在超级 Id，这些 Id 的记录远远超过其他 Id，比如在广告场景下，某个大广告主的广告数可能占总体很大比例。如果按照广告主 Id 取模分库，某些库的记录数会特别多，对于这些超级 Id，需要提供单独库来存储记录。</p>
<h3 id="28-分库数量"><a class="markdownIt-Anchor" href="#28-分库数量"></a> 2.8. 分库数量</h3>
<p>分库数量首先和单库能处理的记录数有关，一般来说，Mysql 单库超过 5000 万条记录，Oracle 单库超过 1 亿条记录，DB 压力就很大(当然处理能力和字段数量/访问模式/记录长度有进一步关系)。</p>
<p>在满足上述前提下，如果分库数量少，达不到分散存储和减轻 DB 性能压力的目的；如果分库的数量多，好处是每个库记录少，单库访问性能好，但对于跨多个库的访问，应用程序需要访问多个库，如果是并发模式，要消耗宝贵的线程资源；如果是串行模式，执行时间会急剧增加。</p>
<p>最后分库数量还直接影响硬件的投入，一般每个分库跑在单独物理机上，多一个库意味多一台设备。所以具体分多少个库，要综合评估，一般初次分库建议分 4-8 个库。</p>
<h2 id="3-读写分离"><a class="markdownIt-Anchor" href="#3-读写分离"></a> 3. 读写分离</h2>
<p>面对日益增加的系统访问量，数据库的吞吐量面临着巨大瓶颈。 对于同一时刻有大量并发读操作和较少写操作类型的应用系统来说，将数据库拆分为主库和从库，主库负责处理事务性的增删改操作，从库负责处理查询操作，能够有效的避免由数据更新导致的行锁，使得整个系统的查询性能得到极大的改善。</p>
<p>通过一主多从的配置方式，可以将查询请求均匀的分散到多个数据副本，能够进一步的提升系统的处理能力。 使用多主多从的方式，不但能够提升系统的吞吐量，还能够提升系统的可用性，可以达到在任何一个数据库宕机，甚至磁盘物理损坏的情况下仍然不影响系统的正常运行。</p>
<p>与将数据根据分片键打散至各个数据节点的水平分片不同，读写分离则是根据 SQL 语义的分析，将读操作和写操作分别路由至主库与从库。</p>
<p><img src="https://shardingsphere.apache.org/document/current/img/read-write-split/read-write-split.png" alt="读写分离" /></p>
<p>读写分离的数据节点中的数据内容是一致的，而水平分片的每个数据节点的数据内容却并不相同。将水平分片和读写分离联合使用，能够更加有效的提升系统性能。</p>
<h3 id="31-挑战"><a class="markdownIt-Anchor" href="#31-挑战"></a> 3.1. 挑战</h3>
<p>读写分离虽然可以提升系统的吞吐量和可用性，但同时也带来了数据不一致的问题。 这包括多个主库之间的数据一致性，以及主库与从库之间的数据一致性的问题。 并且，读写分离也带来了与数据分片同样的问题，它同样会使得应用开发和运维人员对数据库的操作和运维变得更加复杂。 下图展现了将分库分表与读写分离一同使用时，应用程序与数据库集群之间的复杂拓扑关系。</p>
<p><img src="https://shardingsphere.apache.org/document/current/img/read-write-split/sharding-read-write-split.png" alt="数据分片 + 读写分离" /></p>
<h2 id="4-参考资料"><a class="markdownIt-Anchor" href="#4-参考资料"></a> 4. 参考资料</h2>
<ul>
<li><a href="https://shardingsphere.apache.org/document/current/cn/overview/" target="_blank" rel="noopener">ShardingSphere 官方文档</a></li>
<li><a href="https://juejin.im/post/5bf778ef5188251b8a26ed8b" target="_blank" rel="noopener">“分库分表&quot; ？选型和流程要慎重，否则会失控</a></li>
<li><a href="https://www.jianshu.com/p/32b3e91aa22c" target="_blank" rel="noopener">分库分表需要考虑的问题及方案</a></li>
</ul>
]]></content>
      <categories>
        <category>设计</category>
        <category>系统原理</category>
      </categories>
      <tags>
        <tag>设计</tag>
        <tag>系统原理</tag>
        <tag>分片</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式存储基本原理</title>
    <url>/blog/design/theory/distributed-storage-theory/</url>
    <content><![CDATA[<h1 id="分布式存储基本原理"><a class="markdownIt-Anchor" href="#分布式存储基本原理"></a> 分布式存储基本原理</h1>
<h2 id="1-分区规则"><a class="markdownIt-Anchor" href="#1-分区规则"></a> 1. 分区规则</h2>
<p><strong>分布式数据库</strong> 首先要解决把 <strong>整个数据集</strong> 按照 <strong>分区规则</strong> 映射到 <strong>多个节点</strong> 的问题，即把 <strong>数据集</strong> 划分到 <strong>多个节点</strong> 上，每个节点负责 <strong>整体数据</strong> 的一个 <strong>子集</strong>。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/partition-rule.png!zp" />
</div>
<p>数据分布通常有 <strong>哈希分区</strong> 和 <strong>顺序分区</strong> 两种方式，对比如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">分区方式</th>
<th style="text-align:left">特点</th>
<th style="text-align:left">相关产品</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">哈希分区</td>
<td style="text-align:left">离散程度好，数据分布与业务无关，无法顺序访问</td>
<td style="text-align:left">Redis Cluster，Cassandra，Dynamo</td>
</tr>
<tr>
<td style="text-align:left">顺序分区</td>
<td style="text-align:left">离散程度易倾斜，数据分布与业务相关，可以顺序访问</td>
<td style="text-align:left">BigTable，HBase，Hypertable</td>
</tr>
</tbody>
</table>
<p>由于 <code>Redis Cluster</code> 采用 <strong>哈希分区规则</strong>，这里重点讨论 <strong>哈希分区</strong>。常见的 <strong>哈希分区</strong> 规则有几种，下面分别介绍：</p>
<h3 id="11-节点取余分区"><a class="markdownIt-Anchor" href="#11-节点取余分区"></a> 1.1. 节点取余分区</h3>
<p>使用特定的数据，如 <code>Redis</code> 的 <strong>键</strong> 或 <strong>用户</strong> <code>ID</code>，再根据 <strong>节点数量</strong> <code>N</code> 使用公式：<code>hash（key）% N</code> 计算出 <strong>哈希值</strong>，用来决定数据 <strong>映射</strong> 到哪一个节点上。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/partition-hash-mod.png!zp" />
</div>
<ul>
<li><strong>优点</strong></li>
</ul>
<p>这种方式的突出优点是 <strong>简单性</strong>，常用于 <strong>数据库</strong> 的 <strong>分库分表规则</strong>。一般采用 <strong>预分区</strong> 的方式，提前根据 <strong>数据量</strong> 规划好 <strong>分区数</strong>，比如划分为 <code>512</code> 或 <code>1024</code> 张表，保证可支撑未来一段时间的 <strong>数据容量</strong>，再根据 <strong>负载情况</strong> 将 <strong>表</strong> 迁移到其他 <strong>数据库</strong> 中。扩容时通常采用 <strong>翻倍扩容</strong>，避免 <strong>数据映射</strong> 全部被 <strong>打乱</strong>，导致 <strong>全量迁移</strong> 的情况。</p>
<ul>
<li><strong>缺点</strong></li>
</ul>
<p>当 <strong>节点数量</strong> 变化时，如 <strong>扩容</strong> 或 <strong>收缩</strong> 节点，数据节点 <strong>映射关系</strong> 需要重新计算，会导致数据的 <strong>重新迁移</strong>。</p>
<h3 id="12-一致性哈希分区"><a class="markdownIt-Anchor" href="#12-一致性哈希分区"></a> 1.2. 一致性哈希分区</h3>
<p><strong>一致性哈希</strong> 可以很好的解决 <strong>稳定性问题</strong>，可以将所有的 <strong>存储节点</strong> 排列在 <strong>首尾相接</strong> 的 <code>Hash</code> 环上，每个 <code>key</code> 在计算 <code>Hash</code> 后会 <strong>顺时针</strong> 找到 <strong>临接</strong> 的 <strong>存储节点</strong> 存放。而当有节点 <strong>加入</strong> 或 <strong>退出</strong> 时，仅影响该节点在 <code>Hash</code> 环上 <strong>顺时针相邻</strong> 的 <strong>后续节点</strong>。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/partition-consistent-hash.png!zp" />
</div>
<ul>
<li><strong>优点</strong></li>
</ul>
<p><strong>加入</strong> 和 <strong>删除</strong> 节点只影响 <strong>哈希环</strong> 中 <strong>顺时针方向</strong> 的 <strong>相邻的节点</strong>，对其他节点无影响。</p>
<ul>
<li><strong>缺点</strong></li>
</ul>
<p><strong>加减节点</strong> 会造成 <strong>哈希环</strong> 中部分数据 <strong>无法命中</strong>。当使用 <strong>少量节点</strong> 时，<strong>节点变化</strong> 将大范围影响 <strong>哈希环</strong> 中 <strong>数据映射</strong>，不适合 <strong>少量数据节点</strong> 的分布式方案。<strong>普通</strong> 的 <strong>一致性哈希分区</strong> 在增减节点时需要 <strong>增加一倍</strong> 或 <strong>减去一半</strong> 节点才能保证 <strong>数据</strong> 和 <strong>负载的均衡</strong>。</p>
<blockquote>
<p><strong>注意</strong>：因为 <strong>一致性哈希分区</strong> 的这些缺点，一些分布式系统采用 <strong>虚拟槽</strong> 对 <strong>一致性哈希</strong> 进行改进，比如 <code>Dynamo</code> 系统。</p>
</blockquote>
<h3 id="13-虚拟槽分区"><a class="markdownIt-Anchor" href="#13-虚拟槽分区"></a> 1.3. 虚拟槽分区</h3>
<p><strong>虚拟槽分区</strong> 巧妙地使用了 <strong>哈希空间</strong>，使用 <strong>分散度良好</strong> 的 <strong>哈希函数</strong> 把所有数据 <strong>映射</strong> 到一个 <strong>固定范围</strong> 的 <strong>整数集合</strong> 中，整数定义为 <strong>槽</strong>（<code>slot</code>）。这个范围一般 <strong>远远大于</strong> 节点数，比如 <code>Redis Cluster</code> 槽范围是 <code>0 ~ 16383</code>。<strong>槽</strong> 是集群内 <strong>数据管理</strong> 和 <strong>迁移</strong> 的 <strong>基本单位</strong>。采用 <strong>大范围槽</strong> 的主要目的是为了方便 <strong>数据拆分</strong> 和 <strong>集群扩展</strong>。每个节点会负责 <strong>一定数量的槽</strong>，如图所示：</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/partition-hash-slot.png!zp" />
</div>
当前集群有 `3` 个节点，每个节点平均大约负责 `5460` 个 **槽**。由于采用 **高质量** 的 **哈希算法**，每个槽所映射的数据通常比较 **均匀**，将数据平均划分到 `3` 个节点进行 **数据分区**。`Redis Cluster` 就是采用 **虚拟槽分区**。
<p>集群中的每个节点负责一部分哈希槽，比如集群中有３个节点，则：</p>
<ul>
<li>节点Ａ存储的哈希槽范围是：0 – 5460</li>
<li>节点Ｂ存储的哈希槽范围是：5461 – 10922</li>
<li>节点Ｃ存储的哈希槽范围是：10923 – 16383</li>
</ul>
<p>这种结构很容易 <strong>添加</strong> 或者 <strong>删除</strong> 节点。如果 <strong>增加</strong> 一个节点 <code>4</code>，就需要从节点 <code>1 ~ 3</code> 获得部分 <strong>槽</strong> 分配到节点 <code>4</code> 上。如果想 <strong>移除</strong> 节点 <code>1</code>，需要将节点 <code>1</code> 中的 <strong>槽</strong> 移到节点 <code>2 ~ 3</code> 上，然后将 <strong>没有任何槽</strong> 的节点 <code>1</code> 从集群中 <strong>移除</strong> 即可。</p>
<blockquote>
<p>由于从一个节点将 <strong>哈希槽</strong> 移动到另一个节点并不会 <strong>停止服务</strong>，所以无论 <strong>添加删除</strong> 或者 <strong>改变</strong> 某个节点的 <strong>哈希槽的数量</strong> 都不会造成 <strong>集群不可用</strong> 的状态.</p>
</blockquote>
<h2 id="2-参考资料"><a class="markdownIt-Anchor" href="#2-参考资料"></a> 2. 参考资料</h2>
<ul>
<li><a href="https://juejin.im/post/5b8fc5536fb9a05d2d01fb11" target="_blank" rel="noopener">深入剖析 Redis 系列(三) - Redis 集群模式搭建与原理详解</a></li>
</ul>
]]></content>
      <categories>
        <category>设计</category>
        <category>系统原理</category>
      </categories>
      <tags>
        <tag>设计</tag>
        <tag>系统原理</tag>
        <tag>存储</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式 ID 基本原理</title>
    <url>/blog/design/theory/distributed-id-theory/</url>
    <content><![CDATA[<h1 id="分布式-id-基本原理"><a class="markdownIt-Anchor" href="#分布式-id-基本原理"></a> 分布式 ID 基本原理</h1>
<blockquote>
<p>传统数据库软件开发中，主键自动生成技术是基本需求。而各个数据库对于该需求也提供了相应的支持，比如 MySQL 的自增键，Oracle 的自增序列等。</p>
<p>数据分片后，不同数据节点生成全局唯一主键是非常棘手的问题。同一个逻辑表内的不同实际表之间的自增键由于无法互相感知而产生重复主键。 虽然可通过约束自增主键初始值和步长的方式避免碰撞，但需引入额外的运维规则，使解决方案缺乏完整性和可扩展性。</p>
<p>为此，需要使用分布式 ID 来解决此问题。本文总结业界常用的分布式 ID 解决方案。</p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#1-%E7%AE%80%E4%BB%8B">1. 简介</a></li>
<li><a href="#2-uuid">2. UUID</a>
<ul>
<li><a href="#21-uuid-%E7%9A%84%E4%BC%98%E7%82%B9">2.1. UUID 的优点</a></li>
<li><a href="#22-uuid-%E7%9A%84%E7%BC%BA%E7%82%B9">2.2. UUID 的缺点</a></li>
<li><a href="#23-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">2.3. 适用场景</a></li>
</ul>
</li>
<li><a href="#3-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%87%AA%E5%A2%9E%E9%94%AE">3. 数据库自增键</a>
<ul>
<li><a href="#31-%E4%BC%98%E7%82%B9">3.1. 优点</a></li>
<li><a href="#32-%E7%BC%BA%E7%82%B9">3.2. 缺点</a></li>
<li><a href="#33-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">3.3. 适用场景</a></li>
<li><a href="#34-%E6%94%B9%E8%BF%9B">3.4. 改进</a></li>
</ul>
</li>
<li><a href="#4-%E5%88%A9%E7%94%A8-redis-%E7%94%9F%E6%88%90%E9%94%AE">4. 利用 Redis 生成键</a>
<ul>
<li><a href="#41-%E4%BC%98%E7%82%B9">4.1. 优点</a></li>
<li><a href="#42-%E7%BC%BA%E7%82%B9">4.2. 缺点</a></li>
<li><a href="#43-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">4.3. 适用场景</a></li>
</ul>
</li>
<li><a href="#5-%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95snowflake">5. 雪花算法（Snowflake）</a>
<ul>
<li><a href="#51-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86">5.1. 基本原理</a></li>
<li><a href="#52-%E4%BC%98%E7%82%B9">5.2. 优点</a></li>
<li><a href="#53-%E7%BC%BA%E7%82%B9">5.3. 缺点</a></li>
<li><a href="#54-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">5.4. 适用场景</a></li>
<li><a href="#55-%E9%98%B2%E6%AD%A2%E6%97%B6%E9%92%9F%E5%9B%9E%E6%8B%A8">5.5. 防止时钟回拨</a></li>
</ul>
</li>
<li><a href="#6-leaf">6. Leaf</a>
<ul>
<li><a href="#61-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86">6.1. 基本原理</a></li>
<li><a href="#62-%E4%BC%98%E7%82%B9">6.2. 优点</a></li>
<li><a href="#63-%E7%BC%BA%E7%82%B9">6.3. 缺点</a></li>
<li><a href="#64-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">6.4. 适用场景</a></li>
</ul>
</li>
<li><a href="#7-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">7. 参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="1-简介"><a class="markdownIt-Anchor" href="#1-简介"></a> 1. 简介</h2>
<p>首先，分布式 ID 应该具备哪些特性呢？</p>
<ol>
<li><strong>全局唯一性</strong> - 不能出现重复的 ID 号，既然是唯一标识，这是最基本的要求。</li>
<li><strong>趋势递增</strong> - 在 MySQL InnoDB 引擎中使用的是聚集索引，由于多数 RDBMS 使用 B-tree 的数据结构来存储索引数据，在主键的选择上面我们应该尽量使用有序的主键保证写入性能。</li>
<li><strong>单调递增</strong> - 保证下一个 ID 一定大于上一个 ID，例如事务版本号、IM 增量消息、排序等特殊需求。</li>
<li><strong>信息安全</strong> - 如果 ID 是连续的，恶意用户的扒取工作就非常容易做了，直接按照顺序下载指定 URL 即可；如果是订单号就更危险了，竞对可以直接知道我们一天的单量。所以在一些应用场景下，会需要 ID 无规则、不规则。</li>
</ol>
<h2 id="2-uuid"><a class="markdownIt-Anchor" href="#2-uuid"></a> 2. UUID</h2>
<p>UUID 是通用唯一识别码（Universally Unique Identifier)的缩写，开放软件基金会(OSF)规范定义了包括网卡 MAC 地址、时间戳、名字空间（Namespace）、随机或伪随机数、时序等元素。利用这些元素来生成 UUID。</p>
<p>UUID 是由 128 位二进制组成，一般转换成十六进制，然后用 String 表示。在 java 中有个 UUID 类,在他的注释中我们看见这里有 4 种不同的 UUID 的生成策略:</p>
<ul>
<li>random - 基于随机数生成 UUID，由于 Java 中的随机数是伪随机数，其重复的概率是可以被计算出来的。这个一般我们用下面的代码获取基于随机数的 UUID:</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String id = UUID.randomUUID().toString();</span><br></pre></td></tr></table></figure>
<ul>
<li>time-based - 基于时间的 UUID,这个一般是通过当前时间，随机数，和本地 Mac 地址来计算出来，自带的 JDK 包并没有这个算法的我们在一些 UUIDUtil 中，比如我们的 log4j.core.util，会重新定义 UUID 的高位和低位。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UUID <span class="title">getTimeBasedUuid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> time = System.currentTimeMillis() * <span class="number">10000L</span> + <span class="number">122192928000000000L</span> + (<span class="keyword">long</span>)(COUNT.incrementAndGet() % <span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">long</span> timeLow = (time &amp; <span class="number">4294967295L</span>) &lt;&lt; <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">long</span> timeMid = (time &amp; <span class="number">281470681743360L</span>) &gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">long</span> timeHi = (time &amp; <span class="number">1152640029630136320L</span>) &gt;&gt; <span class="number">48</span>;</span><br><span class="line">    <span class="keyword">long</span> most = timeLow | timeMid | <span class="number">4096L</span> | timeHi;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UUID(most, LEAST);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>DCE security - DCE 安全的 UUID。</p>
</li>
<li>
<p>name-based - 基于名字的 UUID，通过计算名字和名字空间的 MD5 来计算 UUID。</p>
</li>
</ul>
<h3 id="21-uuid-的优点"><a class="markdownIt-Anchor" href="#21-uuid-的优点"></a> 2.1. UUID 的优点</h3>
<ul>
<li>通过本地生成，没有经过网络 I/O，性能较快</li>
</ul>
<h3 id="22-uuid-的缺点"><a class="markdownIt-Anchor" href="#22-uuid-的缺点"></a> 2.2. UUID 的缺点</h3>
<ul>
<li><strong>长度过长</strong> - UUID 太长，16 字节 128 位，通常以 36 长度的字符串表示，很多场景不适用。例如：Mysql 官方明确建议主键越短越好，36 个字符长度的 UUID 不符合要求。</li>
<li><strong>信息不安全</strong> - 基于 MAC 地址生成 UUID 的算法可能会造成 MAC 地址泄露，这个漏洞曾被用于寻找梅丽莎病毒的制作者位置。</li>
<li><strong>无序性</strong> - 不能生成递增有序的数字。这对于一些特定场景不利。例如：如果作为数据库主键，在 InnoDB 引擎下，UUID 的无序性可能会引起数据位置频繁变动，严重影响性能。</li>
</ul>
<h3 id="23-适用场景"><a class="markdownIt-Anchor" href="#23-适用场景"></a> 2.3. 适用场景</h3>
<p>UUID 的适用场景可以为不需要担心过多的空间占用，以及不需要生成有递增趋势的数字。在 Log4j 里 <code>UuidPatternConverter</code> 中加入了 UUID 来标识每一条日志。</p>
<h2 id="3-数据库自增键"><a class="markdownIt-Anchor" href="#3-数据库自增键"></a> 3. 数据库自增键</h2>
<p>提到自增键，最先想到的肯定是直接使用数据库自增键。<em>各数据库对于该需求也提供了相应的支持，比如 MySQL 的自增键，Oracle 的自增序列等</em>。</p>
<h3 id="31-优点"><a class="markdownIt-Anchor" href="#31-优点"></a> 3.1. 优点</h3>
<ul>
<li>非常简单，利用现有数据库的功能实现，成本小，有 DBA 专业维护</li>
<li>有序递增</li>
<li>方便排序和分页</li>
</ul>
<h3 id="32-缺点"><a class="markdownIt-Anchor" href="#32-缺点"></a> 3.2. 缺点</h3>
<ul>
<li>强依赖数据库，当数据库异常时整个系统不可用。配置主从复制可以尽可能的增加可用性，但是数据一致性在特殊情况下难以保证。主从切换时的不一致可能会导致重复发号。</li>
<li>生成 ID 性能瓶颈限制在单台 MySQL 的读写性能。</li>
<li>简单递增容易被其他人分析利用
<ul>
<li>比如根据用户 ID 来分析注册人数，猜测出服务的一个大概状况。</li>
</ul>
</li>
</ul>
<h3 id="33-适用场景"><a class="markdownIt-Anchor" href="#33-适用场景"></a> 3.3. 适用场景</h3>
<p>数据量不大，并发不高的场景。</p>
<h3 id="34-改进"><a class="markdownIt-Anchor" href="#34-改进"></a> 3.4. 改进</h3>
<p>对于 MySQL 性能问题，可用如下方案解决：在分布式系统中我们可以多部署几台机器，每台机器设置不同的初始值，且步长和机器数相等。比如有两台机器。设置步长 step 为 2，TicketServer1 的初始值为 1（1，3，5，7，9，11…）、TicketServer2 的初始值为 2（2，4，6，8，10…）。这是 Flickr 团队在 2010 年撰文介绍的一种主键生成策略（<a href="http://code.flickr.net/2010/02/08/ticket-servers-distributed-unique-primary-keys-on-the-cheap/" target="_blank" rel="noopener">Ticket Servers: Distributed Unique Primary Keys on the Cheap </a>）。如下所示，为了实现上述方案分别设置两台机器对应的参数，TicketServer1 从 1 开始发号，TicketServer2 从 2 开始发号，两台机器每次发号之后都递增 2。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">TicketServer1:</span><br><span class="line">auto-<span class="keyword">increment</span>-<span class="keyword">increment</span> = <span class="number">2</span></span><br><span class="line">auto-<span class="keyword">increment</span>-offset = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">TicketServer2:</span><br><span class="line">auto-<span class="keyword">increment</span>-<span class="keyword">increment</span> = <span class="number">2</span></span><br><span class="line">auto-<span class="keyword">increment</span>-offset = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/6d2c9ec8.png" alt="image" /></p>
<p>这种架构存在以下缺点：</p>
<ul>
<li>系统水平扩展比较困难，比如定义好了步长和机器台数之后，如果要添加机器该怎么做？假设现在只有一台机器发号是 1,2,3,4,5（步长是 1），这个时候需要扩容机器一台。可以这样做：把第二台机器的初始值设置得比第一台超过很多，比如 14（假设在扩容时间之内第一台不可能发到 14），同时设置步长为 2，那么这台机器下发的号码都是 14 以后的偶数。然后摘掉第一台，把 ID 值保留为奇数，比如 7，然后修改第一台的步长为 2。让它符合我们定义的号段标准，对于这个例子来说就是让第一台以后只能产生奇数。扩容方案看起来复杂吗？貌似还好，现在想象一下如果我们线上有 100 台机器，这个时候要扩容该怎么做？简直是噩梦。所以系统水平扩展方案复杂难以实现。</li>
<li>ID 没有了单调递增的特性，只能趋势递增，这个缺点对于一般业务需求不是很重要，可以容忍。</li>
<li>数据库压力还是很大，每次获取 ID 都得读写一次数据库，只能靠堆机器来提高性能。</li>
</ul>
<h2 id="4-利用-redis-生成键"><a class="markdownIt-Anchor" href="#4-利用-redis-生成键"></a> 4. 利用 Redis 生成键</h2>
<p>Redis 中有两个命令 <code>Incr</code>，<code>IncrBy</code>。</p>
<p>因为 Redis 是单线程的，所以能保证原子性。</p>
<h3 id="41-优点"><a class="markdownIt-Anchor" href="#41-优点"></a> 4.1. 优点</h3>
<ul>
<li>性能比数据库好</li>
<li>能满足有序递增</li>
</ul>
<h3 id="42-缺点"><a class="markdownIt-Anchor" href="#42-缺点"></a> 4.2. 缺点</h3>
<ul>
<li>由于 Redis 是内存数据库，即使支持持久化（AOF 和 RDB），但是依然可能丢失数据，造成 ID 重复。</li>
<li>依赖于 Redis 生成键，如果 Redis 服务不稳定，会影响 ID 生成。</li>
</ul>
<h3 id="43-适用场景"><a class="markdownIt-Anchor" href="#43-适用场景"></a> 4.3. 适用场景</h3>
<p>Redis 性能比数据库好，但是有可能会出现 ID 重复和不稳定。如果可以接受，那么就可以使用这种方案。</p>
<h2 id="5-雪花算法snowflake"><a class="markdownIt-Anchor" href="#5-雪花算法snowflake"></a> 5. 雪花算法（Snowflake）</h2>
<p>雪花算法（Snowflake）是由 Twitter 公布的分布式主键生成算法，<strong>它会生成一个 <code>64 bit</code> 的整数</strong>，可以保证不同进程主键的不重复性，以及相同进程主键的有序性。</p>
<p>在同一个进程中，它首先是通过时间位保证不重复，如果时间相同则是通过序列位保证。 同时由于时间位是单调递增的，且各个服务器如果大体做了时间同步，那么生成的主键在分布式环境可以认为是总体有序的，这就保证了对索引字段的插入的高效性。</p>
<h3 id="51-基本原理"><a class="markdownIt-Anchor" href="#51-基本原理"></a> 5.1. 基本原理</h3>
<h4 id="键的组成"><a class="markdownIt-Anchor" href="#键的组成"></a> 键的组成</h4>
<p>使用<strong>雪花算法生成的主键，二进制表示形式包含 4 部分</strong>，从高位到低位分表为：1bit 符号位、41bit 时间戳位、10bit 工作进程位以及 12bit 序列号位。</p>
<ul>
<li><strong>符号位(1bit)</strong></li>
</ul>
<p>预留的符号位，恒为零。</p>
<ul>
<li><strong>时间戳位(41bit)</strong></li>
</ul>
<p>41 位的时间戳可以容纳的毫秒数是 2 的 41 次幂，一年所使用的毫秒数是：<code>365 * 24 * 60 * 60 * 1000</code>。通过计算可知：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Math.pow(<span class="number">2</span>, <span class="number">41</span>) / (<span class="number">365</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000L</span>);</span><br></pre></td></tr></table></figure>
<p>结果约等于 69.73 年。ShardingSphere 的雪花算法的时间纪元从 2016 年 11 月 1 日零点开始，可以使用到 2086 年，相信能满足绝大部分系统的要求。</p>
<ul>
<li><strong>工作进程位(10bit)</strong></li>
</ul>
<p>该标志在 Java 进程内是唯一的，如果是分布式应用部署应保证每个工作进程的 id 是不同的。该值默认为 0，可通过属性设置。</p>
<ul>
<li><strong>序列号位(12bit)</strong></li>
</ul>
<p>该序列是用来在同一个毫秒内生成不同的 ID。如果在这个毫秒内生成的数量超过 4096(2 的 12 次幂)，那么生成器会等待到下个毫秒继续生成。</p>
<p>雪花算法主键的详细结构见下图：</p>
<p><img src="https://shardingsphere.apache.org/document/current/img/sharding/snowflake_cn_v2.png" alt="雪花算法" /></p>
<h4 id="时钟回拨"><a class="markdownIt-Anchor" href="#时钟回拨"></a> 时钟回拨</h4>
<p>服务器时钟回拨会导致产生重复序列，因此默认分布式主键生成器提供了一个最大容忍的时钟回拨毫秒数。 如果时钟回拨的时间超过最大容忍的毫秒数阈值，则程序报错；如果在可容忍的范围内，默认分布式主键生成器会等待时钟同步到最后一次主键生成的时间后再继续工作。 最大容忍的时钟回拨毫秒数的默认值为 0，可通过属性设置。</p>
<h4 id="灵活定制"><a class="markdownIt-Anchor" href="#灵活定制"></a> 灵活定制</h4>
<p>上面只是一个将 <code>64bit</code> 划分的标准，当然也不一定这么做，可以根据不同业务的具体场景来划分，比如下面给出一个业务场景：</p>
<ul>
<li>服务目前 QPS10 万，预计几年之内会发展到百万。</li>
<li>当前机器三地部署，上海，北京，深圳都有。</li>
<li>当前机器 10 台左右，预计未来会增加至百台。</li>
</ul>
<p>这个时候我们根据上面的场景可以再次合理的划分 62bit，QPS 几年之内会发展到百万，那么每毫秒就是千级的请求，目前 10 台机器那么每台机器承担百级的请求，为了保证扩展，后面的循环位可以限制到 1024，也就是 2^10，那么循环位 10 位就足够了。</p>
<p>机器三地部署我们可以用 3bit 总共 8 来表示机房位置，当前的机器 10 台，为了保证扩展到百台那么可以用 7bit 128 来表示，时间位依然是 41bit，那么还剩下 64-10-3-7-41-1 = 2bit，还剩下 2bit 可以用来进行扩展。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/29/16624909d2007c22?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="" /></p>
<h3 id="52-优点"><a class="markdownIt-Anchor" href="#52-优点"></a> 5.2. 优点</h3>
<ul>
<li>生成的 ID 都是趋势递增的。</li>
<li>不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成 ID 的性能也是非常高的。</li>
<li>可以根据自身业务特性分配 bit 位，非常灵活。</li>
</ul>
<h3 id="53-缺点"><a class="markdownIt-Anchor" href="#53-缺点"></a> 5.3. 缺点</h3>
<ul>
<li>强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。</li>
</ul>
<h3 id="54-适用场景"><a class="markdownIt-Anchor" href="#54-适用场景"></a> 5.4. 适用场景</h3>
<p>当我们需要无序不能被猜测的 ID，并且需要一定高性能，且需要 long 型，那么就可以使用我们雪花算法。比如常见的订单 ID，用雪花算法别人就无法猜测你每天的订单量是多少。</p>
<h3 id="55-防止时钟回拨"><a class="markdownIt-Anchor" href="#55-防止时钟回拨"></a> 5.5. 防止时钟回拨</h3>
<p>雪花算法是强依赖于时间的，而如果机器时间发生回拨，有可能会生成重复的 ID。</p>
<p>我们可以针对算法做一些优化，来防止时钟回拨生成重复 ID。</p>
<p>用当前时间和上一次的时间进行判断，如果当前时间小于上一次的时间那么肯定是发生了回拨。普通的算法会直接抛出异常，这里我们可以对其进行优化，一般分为两个情况:</p>
<ul>
<li>如果时间回拨时间较短，比如配置 <code>5ms</code> 以内，那么可以直接等待一定的时间，让机器的时间追上来。</li>
<li>如果时间的回拨时间较长，我们不能接受这么长的阻塞等待，那么又有两个策略:
<ul>
<li>直接拒绝，抛出异常。打日志，通知 RD 时钟回滚。</li>
<li>利用扩展位。上面我们讨论过，不同业务场景位数可能用不到那么多比特位，那么我们可以把扩展位数利用起来。比如：当这个时间回拨比较长的时候，我们可以不需要等待，直接在扩展位加 1。两位的扩展位允许我们有三次大的时钟回拨，一般来说就够了，如果其超过三次我们还是选择抛出异常，打日志。</li>
</ul>
</li>
</ul>
<h2 id="6-leaf"><a class="markdownIt-Anchor" href="#6-leaf"></a> 6. Leaf</h2>
<blockquote>
<p>美团提供了一种分布式 ID 解决方案 Leaf，其本质可以视为数据库分段+服务缓存 ID。</p>
<p>详情可以参考 <a href="https://tech.meituan.com/2017/04/21/mt-leaf.html" target="_blank" rel="noopener">Leaf——美团点评分布式 ID 生成系统</a></p>
</blockquote>
<h3 id="61-基本原理"><a class="markdownIt-Anchor" href="#61-基本原理"></a> 6.1. 基本原理</h3>
<p>使用数据库生成 ID，但是做了如下改进：</p>
<p>原方案每次获取 ID 都得读写一次数据库，造成数据库压力大。改为利用 proxy server 批量获取，每次获取一个 segment(step 决定大小)号段的值。用完之后再去数据库获取新的号段，可以大大的减轻数据库的压力。 - 各个业务不同的发号需求用 biz_tag 字段来区分，每个 biz-tag 的 ID 获取相互隔离，互不影响。如果以后有性能需求需要对数据库扩容，不需要上述描述的复杂的扩容操作，只需要对 biz_tag 分库分表就行。</p>
<p>数据库表设计如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">+<span class="comment">-------------+--------------+------+-----+-------------------+-----------------------------+</span></span><br><span class="line">| Field       | Type         | Null | Key | Default           | Extra                       |</span><br><span class="line">+<span class="comment">-------------+--------------+------+-----+-------------------+-----------------------------+</span></span><br><span class="line">| biz_tag     | varchar(128) | NO   | PRI |                   |                             |</span><br><span class="line">| max_id      | bigint(20)   | NO   |     | 1                 |                             |</span><br><span class="line">| step        | int(11)      | NO   |     | NULL              |                             |</span><br><span class="line">| desc        | varchar(256) | YES  |     | NULL              |                             |</span><br><span class="line">| update_time | timestamp    | NO   |     | CURRENT_TIMESTAMP | on <span class="keyword">update</span> <span class="keyword">CURRENT_TIMESTAMP</span> |</span><br><span class="line">+<span class="comment">-------------+--------------+------+-----+-------------------+-----------------------------+</span></span><br></pre></td></tr></table></figure>
<p>重要字段说明：</p>
<ul>
<li><code>biz_tag</code> 用来区分业务</li>
<li><code>max_id</code> 表示该 <code>biz_tag</code> 目前所被分配的 ID 号段的最大值</li>
<li><code>step</code> 表示每次分配的号段长度。原来获取 ID 每次都需要写数据库，现在只需要把 <code>step</code> 设置得足够大，比如 1000。那么只有当 1000 个号被消耗完了之后才会去重新读写一次数据库。读写数据库的频率从 1 减小到了 1/step。</li>
</ul>
<p>大致架构如下图所示：</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/5e4ff128.png" alt="image" /></p>
<p>test_tag 在第一台 Leaf 机器上是 <code>1~1000</code> 的号段，当这个号段用完时，会去加载另一个长度为 step=1000 的号段，假设另外两台号段都没有更新，这个时候第一台机器新加载的号段就应该是 <code>3001~4000</code>。同时数据库对应的 biz_tag 这条数据的 max_id 会从 3000 被更新成 4000，更新号段的 SQL 语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Begin</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">table</span> <span class="keyword">SET</span> max_id=max_id+step <span class="keyword">WHERE</span> biz_tag=xxx</span><br><span class="line"><span class="keyword">SELECT</span> tag, max_id, step <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> biz_tag=xxx</span><br><span class="line"><span class="keyword">Commit</span></span><br></pre></td></tr></table></figure>
<h3 id="62-优点"><a class="markdownIt-Anchor" href="#62-优点"></a> 6.2. 优点</h3>
<ul>
<li>比数据库自增键性能高</li>
<li>能保证键趋势递增。</li>
<li>如果数据库宕机，由于 proxServer 有缓存，依然可以坚持一段时间。</li>
</ul>
<h3 id="63-缺点"><a class="markdownIt-Anchor" href="#63-缺点"></a> 6.3. 缺点</h3>
<ul>
<li>和主键递增一样，容易被人猜测。</li>
<li>数据库宕机后，虽然能支撑一段时间，但是仍然会造成系统不可用。</li>
</ul>
<h3 id="64-适用场景"><a class="markdownIt-Anchor" href="#64-适用场景"></a> 6.4. 适用场景</h3>
<p>需要趋势递增，并且 ID 大小可控制的，可以使用这套方案。</p>
<p>当然这个方案也可以通过一些手段避免被人猜测，把 ID 变成是无序的，比如把我们生成的数据是一个递增的 long 型，把这个 Long 分成几个部分，比如可以分成几组三位数，几组四位数，然后在建立一个映射表，将我们的数据变成无序。</p>
<h2 id="7-参考资料"><a class="markdownIt-Anchor" href="#7-参考资料"></a> 7. 参考资料</h2>
<ul>
<li><a href="https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md" target="_blank" rel="noopener">百度分布式 ID</a></li>
<li><a href="https://juejin.im/post/5bb0217ef265da0ac2567b42" target="_blank" rel="noopener">如果再有人问你分布式 ID，这篇文章丢给他</a></li>
<li><a href="https://segmentfault.com/a/1190000011282426" target="_blank" rel="noopener">理解分布式 id 生成算法 SnowFlake</a></li>
<li><a href="https://tech.meituan.com/2017/04/21/mt-leaf.html" target="_blank" rel="noopener">Leaf——美团点评分布式 ID 生成系统</a></li>
<li><a href="https://www.ietf.org/rfc/rfc4122.txt" target="_blank" rel="noopener">UUID 规范</a></li>
<li><a href="https://shardingsphere.apache.org/document/current/cn/features/sharding/other-features/key-generator/" target="_blank" rel="noopener">ShardingSphere 分布式主键</a></li>
</ul>
]]></content>
      <categories>
        <category>设计</category>
        <category>系统原理</category>
      </categories>
      <tags>
        <tag>设计</tag>
        <tag>系统原理</tag>
        <tag>分布式 ID</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列基本原理</title>
    <url>/blog/design/theory/mq-theory/</url>
    <content><![CDATA[<h1 id="消息队列基本原理"><a class="markdownIt-Anchor" href="#消息队列基本原理"></a> 消息队列基本原理</h1>
<blockquote>
<p>消息队列（Message Queue，简称 MQ）技术是分布式应用间交换信息的一种技术。</p>
<p>消息队列主要解决应用耦合，异步消息，流量削锋等问题，实现高性能，高可用，可伸缩和最终一致性架构。是大型分布式系统不可缺少的中间件。</p>
<p>注意：<em>为了简便，下文中除了文章标题，一律使用 MQ 简称</em>。</p>
</blockquote>
<h2 id="1-为什么要使用-mq"><a class="markdownIt-Anchor" href="#1-为什么要使用-mq"></a> 1. 为什么要使用 MQ</h2>
<p>MQ 比较核心的优点有 3 个：<strong>解耦</strong>、<strong>异步</strong>、<strong>削峰</strong>。</p>
<h3 id="11-解耦"><a class="markdownIt-Anchor" href="#11-解耦"></a> 1.1. 解耦</h3>
<p>不同系统如果要建立通信，传统的做法是：调用接口。</p>
<p>如果需要和新的系统建立通信或删除已建立的通信，都需要修改代码，这种方案显然耦合度很高。</p>
<p><img src="http://dunwu.test.upcdn.net/cs/design/theory/mq/mq_1.png" alt="" /></p>
<p>如果使用 MQ，系统间的通信只需要通过发布/订阅（Pub/Sub）模型即可，彼此没有直接联系，也就不需要相互感知，从而达到 <strong>解耦</strong>。</p>
<p><img src="http://dunwu.test.upcdn.net/cs/design/theory/mq/mq_2.png" alt="" /></p>
<h3 id="12-异步"><a class="markdownIt-Anchor" href="#12-异步"></a> 1.2. 异步</h3>
<p>假设这样一个场景，用户向系统 A 发起请求，系统 A 处理计算只需要 10 ms，然后通知系统 BCD 写库，系统 BCD 写库耗时分别为：100ms、200ms、300ms。最终总耗时为： 10+100ms+200ms+300ms=610ms。此外，加上请求和响应的网络传输时间，从用户角度看，可能要等待将近 1s 才能得到结果。</p>
<p><img src="http://dunwu.test.upcdn.net/cs/design/theory/mq/mq_3.png" alt="" /></p>
<p>如果使用 MQ，系统 A 接到请求后，耗时 10ms 处理计算，然后向系统 BCD 连续发送消息，假设耗时 5ms。那么 这一过程的总耗时为 3ms + 5ms = 8ms，这相比于 610 ms，大大缩短了响应时间。至于系统 BCD 的写库操作，只要自行消费 MQ 后处理即可，用户无需关注。</p>
<p><img src="http://dunwu.test.upcdn.net/cs/design/theory/mq/mq_4.png" alt="" /></p>
<h3 id="13-削峰"><a class="markdownIt-Anchor" href="#13-削峰"></a> 1.3. 削峰</h3>
<p>假设某个系统读写数据库的稳定性能为每秒处理 1000 条数据。平常情况下，远远达不到这么大的处理量。假设，因为因为做活动，系统的瞬时请求量剧增，达到每秒 10000 个并发请求，数据库根本承受不了，可能直接就把数据库给整崩溃了，这样系统服务就不可用了。</p>
<p><img src="http://dunwu.test.upcdn.net/cs/design/theory/mq/mq_5.png" alt="" /></p>
<p>如果使用 MQ，每秒写入 10000 条请求，但是系统 A 每秒只从 MQ 中消费 1000 条请求，然后写入数据库。这样，就不会超过数据库的承受能力，而是把请求积压在 MQ 中。只要高峰期一过，系统 A 就会很快把积压的消息给处理掉。</p>
<p><img src="http://dunwu.test.upcdn.net/cs/design/theory/mq/mq_6.png" alt="" /></p>
<h2 id="2-mq-引入的问题"><a class="markdownIt-Anchor" href="#2-mq-引入的问题"></a> 2. MQ 引入的问题</h2>
<p>凡事有利有弊，使用 MQ 给系统带来很多好处，也会付出一定的代价。</p>
<p>它引入了以下问题：</p>
<ul>
<li><strong>系统可用性降低</strong> - 引入了 MQ 后，通信需要基于 MQ 完成，如果 MQ 宕机，则服务不可用。因此，MQ 要保证是高可用的，详情参考：<a href="#MQ-%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8">MQ 的高可用</a></li>
<li><strong>系统复杂度提高</strong> - 使用 MQ，需要关注一些新的问题：
<ul>
<li>如何保证消息没有重复消费？</li>
<li>如何处理消息丢失的问题？</li>
<li>如何保证消息传递的顺序性？</li>
<li>如何处理大量消息积压的问题？</li>
</ul>
</li>
<li><strong>一致性问题</strong> - 假设系统 A 处理完直接返回成功的结果给用户，用户认为请求成功。但如果此时，系统 BCD 中只要有任意一个写库失败，那么数据就不一致了。这种情况如何处理？</li>
</ul>
<h3 id="21-重复消费"><a class="markdownIt-Anchor" href="#21-重复消费"></a> 2.1. 重复消费</h3>
<p><strong>如何保证消息不被重复消费</strong> 和 <strong>如何保证消息消费的幂等性</strong> 是同一个问题。</p>
<p>必须先明确产生重复消费的原因，才能对症下药。</p>
<h4 id="211-重复消费问题原因"><a class="markdownIt-Anchor" href="#211-重复消费问题原因"></a> 2.1.1. 重复消费问题原因</h4>
<p>重复消费问题通常不是 MQ 来处理，而是由开发来处理的。</p>
<p>以 Kafka 举例：Kafka 每个 Partition 都是一个有序的、不可变的记录序列，不断追加到结构化的提交日志中。Partition 中的记录每个分配一个连续的 id 号，称为偏移量（Offset），用于唯一标识 Partition 内的每条记录。</p>
<p><img src="http://kafka.apachecn.org/10/images/log_consumer.png" alt="" /></p>
<p>Kafka 的客户端和 Broker 都会保存 Offset。客户端消费消息后，每隔一段时间，就把已消费的 Offset 提交给 Kafka Broker，表示已消费。</p>
<p>在这个过程中，如果客户端应用消费消息后，因为宕机、重启等情况而没有提交已消费的 Offset 。当系统恢复后，会继续消费消息，由于 Offset 未提交，就会出现重复消费的问题。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3101171-75abe308f9cf21f8.png" alt="" /></p>
<h4 id="212-重复消费解决方案"><a class="markdownIt-Anchor" href="#212-重复消费解决方案"></a> 2.1.2. 重复消费解决方案</h4>
<p>应对重复消费问题，就要通过幂等性来解决。</p>
<p>这个问题可以从业务层面来解决。</p>
<p>MQ 重复消费不可怕，可怕的是没有应对机制，可以借鉴的思路有：</p>
<ul>
<li>如果是写库，可以先根据主键查询，判断数据是否已存在，存在则更新，不存在则插入；</li>
<li>如果是写 Redis，set 操作，由于天然具有幂等性，大可放心；</li>
<li>如果是根据消息做较复杂的逻辑处理，可以在消息中加入全局唯一 ID，例如：订单 ID 等。在客户端存储中（Mysql、Redis 等）保存已消费消息的 ID。一旦接受到新消息，先判断消息中的 ID 是否在已消费消息 ID 表中存在，存在则不再处理，不存在则处理。</li>
</ul>
<h3 id="22-消息丢失"><a class="markdownIt-Anchor" href="#22-消息丢失"></a> 2.2. 消息丢失</h3>
<p><strong>如何处理消息丢失的问题</strong> 和 <strong>如何保证消息不被重复消费</strong> 是同一个问题。关注点有按个：</p>
<ul>
<li>Kafka 丢失数据</li>
<li>消费方丢失数据</li>
<li>生产方丢失数据</li>
</ul>
<h4 id="221-消费方丢失数据"><a class="markdownIt-Anchor" href="#221-消费方丢失数据"></a> 2.2.1. 消费方丢失数据</h4>
<p>唯一可能导致消费方丢失数据的情况，就是：消费方设置了<strong>自动提交 Offset</strong>。设置了自动提交 Offset，接受到消息后就会自动提交 Offset 给 Kafka ，Kafka 就认为消息已被消费。如果此时，消费方尚未来得及处理消息就挂了，那么消息就丢了。</p>
<p>解决方法就是消费方关闭自动提交 Offset，处理完消息后手动提交 Offset。但这种情况下可能会出现重复消费的情形，需要自行保证幂等性。</p>
<h4 id="222-kafka-丢失数据"><a class="markdownIt-Anchor" href="#222-kafka-丢失数据"></a> 2.2.2. Kafka 丢失数据</h4>
<p>当 Kafka 某个 Broker 宕机，需要重新选举 Partition 的 Leader。若此时其他的 Follower 尚未同步 Leader 的数据，那么新选某个 Follower 为 Leader 后，就丢失了部分数据。</p>
<p>为此，一般要求至少设置 4 个参数：</p>
<ul>
<li>给 Topic 设置 <code>replication.factor</code> 参数 - 这个值必须大于 1，要求每个 Partition 必须有至少 2 个副本。</li>
<li>在 Kafka 服务端设置 <code>min.insync.replicas</code> 参数 - 这个值必须大于 1，这是要求一个 Leader 需要和至少一个 Follower 保持通信，这样才能确保 Leader 挂了还有替补。</li>
<li>在 Producer 端设置 <code>acks=all</code> - 这意味着：要求每条数据，必须是<strong>写入所有 replica 之后，才能认为是写成功了</strong>。</li>
<li>在 Producer 端设置 <code>retries=MAX</code>（很大很大很大的一个值，无限次重试的意思） - 这意味着<strong>要求一旦写入失败，就无限重试</strong>，卡在这里了。</li>
</ul>
<h4 id="223-生产方丢失数据"><a class="markdownIt-Anchor" href="#223-生产方丢失数据"></a> 2.2.3. 生产方丢失数据</h4>
<p>如果按照上述的思路设置了 <code>acks=all</code>，生产方一定不会丢数据。</p>
<p>要求是，你的 Leader 接收到消息，所有的 Follower 都同步到了消息之后，才认为本生产消息成功了。如果未满足这个条件，生产者会自动不断的重试，重试无限次。</p>
<h3 id="23-消息的顺序性"><a class="markdownIt-Anchor" href="#23-消息的顺序性"></a> 2.3. 消息的顺序性</h3>
<blockquote>
<p>以 Kafka 为例</p>
</blockquote>
<p>要保证 MQ 的顺序性，势必要付出一定的代价，所以实施方案前，要先明确业务场景是不是有必要保证消息的顺序性。只有那些明确对消息处理顺序有要求的业务场景才值得去保证消息顺序性。</p>
<p>方案一</p>
<p>一个 Topic，一个 Partition，一个 Consumer，内部单线程消费，单线程吞吐量太低，一般不会用这个。</p>
<p>方案二</p>
<ul>
<li>写入数据到 Partition 时指定一个唯一的 Key，例如订单 ID。由发送方保证相同 Key 的消息只能发送到同一个 Partition 并且这个 Partition 中的数据一定是顺序的。</li>
<li>基于上一点，消费方从 Kafka Partition 中消费消息时，此刻一定是顺序的。但如果消费方式以并发方式消费消息，顺序就可能会被打乱。为此，还有做到以下几点：
<ul>
<li>消费方维护 N 个缓存队列，具有相同 key 的数据都写入同一个队列中；</li>
<li>创建 N 个线程，每个线程只负责从指定的一个队列中取数据。</li>
</ul>
</li>
</ul>
<p><img src="http://dunwu.test.upcdn.net/cs/design/theory/mq/mq_7.png" alt="" /></p>
<h3 id="24-消息积压"><a class="markdownIt-Anchor" href="#24-消息积压"></a> 2.4. 消息积压</h3>
<p>假设一个 MQ 消费者可以一秒处理 1000 条消息，三个 MQ 消费者可以一秒处理 3000 条消息，那么一分钟的处理量是 18 万条。如果 MQ 中积压了几百万到上千万的数据，即使消费者恢复了，也需要大概很长的时间才能恢复过来。</p>
<p>对于产线环境来说，漫长的等待是不可接受的，所以面临这种窘境时，只能临时紧急扩容以应对了，具体操作步骤和思路如下：</p>
<ul>
<li>先修复 Consumer 的问题，确保其恢复消费速度，然后将现有 Consumer 都停掉。</li>
<li>新建一个 Topic，Partition 是原来的 10 倍，临时建立好原先 10 倍的 Queue 数量。</li>
<li>然后写一个临时的分发数据的 Consumer 程序，这个程序部署上去消费积压的数据，<strong>消费之后不做耗时的处理</strong>，直接均匀轮询写入临时建立好的 10 倍数量的 Queue。</li>
<li>接着临时征用 10 倍的机器来部署 Consumer ，每一批 Consumer 消费一个临时 Queue 的数据。这种做法相当于是临时将 Queue 资源和 Consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。</li>
<li>等快速消费完积压数据之后，<strong>得恢复原先部署的架构</strong>，<strong>重新</strong>用原先的 consumer 机器来消费消息。</li>
</ul>
<h2 id="3-mq-的高可用"><a class="markdownIt-Anchor" href="#3-mq-的高可用"></a> 3. MQ 的高可用</h2>
<p>不同 MQ 实现高可用的原理各不相同。因为 Kafka 比较具有代表性，所以这里以 Kafka 为例。</p>
<h3 id="31-kafka-的高可用"><a class="markdownIt-Anchor" href="#31-kafka-的高可用"></a> 3.1. Kafka 的高可用</h3>
<h4 id="311-kafka-的核心概念"><a class="markdownIt-Anchor" href="#311-kafka-的核心概念"></a> 3.1.1. Kafka 的核心概念</h4>
<p>了解 Kafka，必须先了解 Kafka 的核心概念：</p>
<ul>
<li>
<p><strong>Broker</strong> - Kafka 集群包含一个或多个节点，这种节点被称为 Broker。</p>
</li>
<li>
<p><strong>Topic</strong> - 每条发布到 Kafka 集群的消息都有一个类别，这个类别被称为 Topic。（不同 Topic 的消息是物理隔离的；同一个 Topic 的消息保存在一个或多个 Broker 上，但用户只需指定消息的 Topic 即可生产或消费数据而不必关心数据存于何处）。对于每一个 Topic， Kafka 集群都会维持一个分区日志。</p>
</li>
<li>
<p><strong>Partition</strong> - 了提高 Kafka 的吞吐率，每个 Topic 包含一个或多个 Partition，每个 Partition 在物理上对应一个文件夹，该文件夹下存储这个 Partition 的所有消息和索引文件。</p>
<ul>
<li>Kafka 日志的分区（Partition）分布在 Kafka 集群的节点上。每个节点在处理数据和请求时，共享这些分区。每一个分区都会在已配置的节点上进行备份，确保容错性。</li>
</ul>
</li>
</ul>
<p><img src="http://dunwu.test.upcdn.net/cs/java/javaweb/distributed/mq/kafka/kafka-cluster-roles.png" alt="" /></p>
<h4 id="312-kafka-的副本机制"><a class="markdownIt-Anchor" href="#312-kafka-的副本机制"></a> 3.1.2. Kafka 的副本机制</h4>
<p>Kafka 是如何实现高可用的呢？</p>
<p>Kafka 在 0.8 以前的版本中，如果一个 Broker 宕机了，其上面的 Partition 都不能用了，这自然不是高可用的。</p>
<p>为了实现高可用，Kafka 引入了复制功能。</p>
<p>简单来说，就是副本机制（ Replicate ）。</p>
<p>每个 Partition 都有一个 Broker 作为 Leader，零个或者多个 Broker 作为 Follower。每个 Broker 都会成为某些分区的 Leader 和某些分区的 Follower，因此集群的负载是平衡的。</p>
<ul>
<li><strong>Leader 处理一切对 Partition （分区）的读写请求</strong>；</li>
<li><strong>而 Follower 只需被动的同步 Leader 上的数据</strong>。</li>
</ul>
<p>同一个 Topic 的不同 Partition 会分布在多个 Broker 上，而且一个 Partition 还会在其他的 Broker 上面进行备份，Producer 在发布消息到某个 Partition 时，先找到该 Partition 的 Leader，然后向这个 Leader 推送消息；每个 Follower 都从 Leader 拉取消息，拉取消息成功之后，向 Leader 发送一个 ACK 确认。</p>
<p><img src="http://dunwu.test.upcdn.net/cs/java/javaweb/distributed/mq/kafka/kafka-replication.png" alt="" /></p>
<blockquote>
<p>FAQ</p>
<p>问：为什么让 Leader 处理一切对对 Partition （分区）的读写请求？</p>
<p>答：因为如果允许所有 Broker 都可以处理读写请求，就可能产生数据一致性问题。</p>
</blockquote>
<h4 id="313-kafka-选举-leader"><a class="markdownIt-Anchor" href="#313-kafka-选举-leader"></a> 3.1.3. Kafka 选举 Leader</h4>
<p>由上文可知，Partition 在多个 Broker 上存在副本。</p>
<p>如果某个 Follower 宕机，啥事儿没有，正常工作。</p>
<p>如果 Leader 宕机了，会从 Follower 中<strong>重新选举</strong>一个新的 Leader。</p>
<h2 id="4-mq-的通信模式"><a class="markdownIt-Anchor" href="#4-mq-的通信模式"></a> 4. MQ 的通信模式</h2>
<p>MQ 可驻留在内存或磁盘上，队列存储消息直到它们被应用程序读取。通过 MQ，应用程序可独立地执行，它们不需要知道彼此的位置，不需要等待接收程序接收此消息。在分布式计算环境中，为了集成分布式应用，开发者需要对异构网络环境下的分布式应用提供有效的通信手段。为了管理需要共享的信息，对应用提供公共的信息交换机制是重要的。</p>
<ul>
<li><strong>点对点</strong> - 点对点方式是最为传统和常见的通讯方式，它支持一对一、一对多、多对多、多对一等多种配置方式，支持树状、网状等多种拓扑结构。</li>
<li><strong>多点广播</strong> - MQ 适用于不同类型的应用。其中重要的，也是正在发展中的是&quot;多点广播&quot;应用，即能够将消息发送到多个目标站点 (Destination List)。可以使用一条 MQ 指令将单一消息发送到多个目标站点，并确保为每一站点可靠地提供信息。MQ 不仅提供了多点广播的功能，而且还拥有智能消息分发功能，在将一条消息发送到同一系统上的多个用户时，MQ 将消息的一个复制版本和该系统上接收者的名单发送到目标 MQ 系统。目标 MQ 系统在本地复制这些消息，并将它们发送到名单上的队列，从而尽可能减少网络的传输量。</li>
<li><strong>发布/订阅 (Publish/Subscribe)</strong> - 发布/订阅模式使消息的分发可以突破目的队列地理位置的限制，使消息按照特定的主题甚至内容进行分发，用户或应用程序可以根据主题或内容接收到所需要的消息。发布/订阅模式使得发送者和接收者之间的耦合关系变得更为松散，发送者不必关心接收者的目的地址，而接收者也不必关心消息的发送地址，而只是根据消息的主题进行消息的收发。</li>
<li><strong>集群 (Cluster)</strong> - 为了简化点对点通讯模式中的系统配置，MQ 提供 Cluster(集群) 的解决方案。集群类似于一个域 (Domain)，集群内部的队列管理器之间通讯时，不需要两两之间建立消息通道，而是采用集群 (Cluster) 通道与其它成员通讯，从而大大简化了系统配置。此外，集群中的队列管理器之间能够自动进行负载均衡，当某一队列管理器出现故障时，其它队列管理器可以接管它的工作，从而大大提高系统的高可靠性。</li>
</ul>
<h2 id="5-常用-mq-对比"><a class="markdownIt-Anchor" href="#5-常用-mq-对比"></a> 5. 常用 MQ 对比</h2>
<table>
<thead>
<tr>
<th>特性</th>
<th>ActiveMQ</th>
<th>RabbitMQ</th>
<th>RocketMQ</th>
<th>Kafka</th>
</tr>
</thead>
<tbody>
<tr>
<td>单机吞吐量</td>
<td>万级，比 RocketMQ、Kafka 低一个数量级</td>
<td>同 ActiveMQ</td>
<td>10 万级，支撑高吞吐</td>
<td>10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td>
</tr>
<tr>
<td>topic 数量对吞吐量的影响</td>
<td></td>
<td></td>
<td>topic 可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic</td>
<td>topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源</td>
</tr>
<tr>
<td>时效性</td>
<td>ms 级</td>
<td>微秒级，这是 RabbitMQ 的一大特点，延迟最低</td>
<td>ms 级</td>
<td>延迟在 ms 级以内</td>
</tr>
<tr>
<td>可用性</td>
<td>高，基于主从架构实现高可用</td>
<td>同 ActiveMQ</td>
<td>非常高，分布式架构</td>
<td>非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td>
</tr>
<tr>
<td>消息可靠性</td>
<td>有较低的概率丢失数据</td>
<td>基本不丢</td>
<td>经过参数优化配置，可以做到 0 丢失</td>
<td>同 RocketMQ</td>
</tr>
<tr>
<td>功能支持</td>
<td>MQ 领域的功能极其完备</td>
<td>基于 erlang 开发，并发能力很强，性能极好，延时很低</td>
<td>MQ 功能较为完善，还是分布式的，扩展性好</td>
<td>功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用</td>
</tr>
</tbody>
</table>
<p>综上，各种对比之后，有如下建议：</p>
<ul>
<li>一般的业务系统要引入 MQ，最早大家都用 ActiveMQ，但是现在确实大家用的不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃，所以大家还是算了吧，我个人不推荐用这个了；</li>
<li>后来大家开始用 RabbitMQ，但是确实 erlang 语言阻止了大量的 Java 工程师去深入研究和掌控它，对公司而言，几乎处于不可控的状态，但是确实人家是开源的，比较稳定的支持，活跃度也高；</li>
<li>不过现在确实越来越多的公司会去用 RocketMQ，确实很不错，毕竟是阿里出品，但社区可能有突然黄掉的风险（目前 RocketMQ 已捐给 <a href="https://github.com/apache/rocketmq" target="_blank" rel="noopener">Apache</a>，但 GitHub 上的活跃度其实不算高）对自己公司技术实力有绝对自信的，推荐用 RocketMQ，否则回去老老实实用 RabbitMQ 吧，人家有活跃的开源社区，绝对不会黄。</li>
<li>所以<strong>中小型公司</strong>，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是不错的选择；<strong>大型公司</strong>，基础架构研发实力较强，用 RocketMQ 是很好的选择。</li>
<li>如果是<strong>大数据领域</strong>的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</li>
</ul>
<h2 id="6-jms"><a class="markdownIt-Anchor" href="#6-jms"></a> 6. JMS</h2>
<p>谈 MQ 就不得不提一下 JMS 。</p>
<p><strong>JMS（JAVA Message Service，java 消息服务）API 是一个消息服务的标准/规范，允许应用程序组件基于 JavaEE 平台创建、发送、接收和读取消息</strong>。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。</p>
<p>在 EJB 架构中，有消息 bean 可以无缝的与 JM 消息服务集成。在 J2EE 架构模式中，有消息服务者模式，用于实现消息与应用直接的解耦。</p>
<h3 id="61-消息模型"><a class="markdownIt-Anchor" href="#61-消息模型"></a> 6.1. 消息模型</h3>
<p>在 JMS 标准中，有两种消息模型：</p>
<ul>
<li>P2P(Point to Point)</li>
<li>Pub/Sub(Publish/Subscribe)</li>
</ul>
<h4 id="611-p2p-模式"><a class="markdownIt-Anchor" href="#611-p2p-模式"></a> 6.1.1. P2P 模式</h4>
<div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-2adc66e2367cd2c2.png"/></div>
P2P 模式包含三个角色：MQ（Queue），发送者(Sender)，接收者(Receiver)。每个消息都被发送到一个特定的队列，接收者从队列中获取消息。队列保留着消息，直到他们被消费或超时。
<p>P2P 的特点</p>
<ul>
<li>每个消息只有一个消费者（Consumer）(即一旦被消费，消息就不再在 MQ 中)</li>
<li>发送者和接收者之间在时间上没有依赖性，也就是说当发送者发送了消息之后，不管接收者有没有正在运行，它不会影响到消息被发送到队列</li>
<li>接收者在成功接收消息之后需向队列应答成功</li>
</ul>
<p>如果希望发送的每个消息都会被成功处理的话，那么需要 P2P 模式。</p>
<h4 id="612-pubsub-模式"><a class="markdownIt-Anchor" href="#612-pubsub-模式"></a> 6.1.2. Pub/sub 模式</h4>
<div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-12afe9581da889ea.png"/></div>
包含三个角色主题（Topic），发布者（Publisher），订阅者（Subscriber） 。多个发布者将消息发送到 Topic,系统将这些消息传递给多个订阅者。
<p>Pub/Sub 的特点</p>
<ul>
<li>每个消息可以有多个消费者</li>
<li>发布者和订阅者之间有时间上的依赖性。针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息。</li>
<li>为了消费消息，订阅者必须保持运行的状态。</li>
</ul>
<p>为了缓和这样严格的时间相关性，JMS 允许订阅者创建一个可持久化的订阅。这样，即使订阅者没有被激活（运行），它也能接收到发布者的消息。</p>
<p>如果希望发送的消息可以不被做任何处理、或者只被一个消息者处理、或者可以被多个消费者处理的话，那么可以采用 Pub/Sub 模型。</p>
<h3 id="62-消息消费"><a class="markdownIt-Anchor" href="#62-消息消费"></a> 6.2. 消息消费</h3>
<p>在 JMS 中，消息的产生和消费都是异步的。对于消费来说，JMS 的消息者可以通过两种方式来消费消息。</p>
<ul>
<li><strong>同步</strong> - 订阅者或接收者通过 <code>receive</code> 方法来接收消息，<code>receive</code> 方法在接收到消息之前（或超时之前）将一直阻塞；</li>
<li><strong>异步</strong> - 订阅者或接收者可以注册为一个消息监听器。当消息到达之后，系统自动调用监听器的 <code>onMessage</code> 方法。</li>
</ul>
<p><code>JNDI</code> - Java 命名和目录接口,是一种标准的 Java 命名系统接口。可以在网络上查找和访问服务。通过指定一个资源名称，该名称对应于数据库或命名服务中的一个记录，同时返回资源连接建立所必须的信息。</p>
<p>JNDI 在 JMS 中起到查找和访问发送目标或消息来源的作用。</p>
<h3 id="63-jms-编程模型"><a class="markdownIt-Anchor" href="#63-jms-编程模型"></a> 6.3. JMS 编程模型</h3>
<h4 id="631-connectionfactory"><a class="markdownIt-Anchor" href="#631-connectionfactory"></a> 6.3.1. ConnectionFactory</h4>
<p>创建 Connection 对象的工厂，针对两种不同的 jms 消息模型，分别有 QueueConnectionFactory 和 TopicConnectionFactory 两种。可以通过 JNDI 来查找 ConnectionFactory 对象。</p>
<h4 id="632-destination"><a class="markdownIt-Anchor" href="#632-destination"></a> 6.3.2. Destination</h4>
<p>Destination 的意思是消息生产者的消息发送目标或者说消息消费者的消息来源。对于消息生产者来说，它的 Destination 是某个队列（Queue）或某个主题（Topic）;对于消息消费者来说，它的 Destination 也是某个队列或主题（即消息来源）。</p>
<p>所以，Destination 实际上就是两种类型的对象：Queue、Topic。可以通过 JNDI 来查找 Destination。</p>
<h4 id="633-3-connection"><a class="markdownIt-Anchor" href="#633-3-connection"></a> 6.3.3. (3) Connection</h4>
<p>Connection 表示在客户端和 JMS 系统之间建立的链接（对 TCP/IP socket 的包装）。Connection 可以产生一个或多个 Session。跟 ConnectionFactory 一样，Connection 也有两种类型：QueueConnection 和 TopicConnection。</p>
<h4 id="634-4-session"><a class="markdownIt-Anchor" href="#634-4-session"></a> 6.3.4. (4) Session</h4>
<p>Session 是操作消息的接口。可以通过 session 创建生产者、消费者、消息等。Session 提供了事务的功能。当需要使用 session 发送/接收多个消息时，可以将这些发送/接收动作放到一个事务中。同样，也分 QueueSession 和 TopicSession。</p>
<h4 id="635-消息的生产者"><a class="markdownIt-Anchor" href="#635-消息的生产者"></a> 6.3.5. 消息的生产者</h4>
<p>消息生产者由 Session 创建，并用于将消息发送到 Destination。同样，消息生产者分两种类型：QueueSender 和 TopicPublisher。可以调用消息生产者的方法（send 或 publish 方法）发送消息。</p>
<h4 id="636-消息消费者"><a class="markdownIt-Anchor" href="#636-消息消费者"></a> 6.3.6. 消息消费者</h4>
<p>消息消费者由 Session 创建，用于接收被发送到 Destination 的消息。两种类型：QueueReceiver 和 TopicSubscriber。可分别通过 session 的 createReceiver(Queue)或 createSubscriber(Topic)来创建。当然，也可以 session 的 creatDurableSubscriber 方法来创建持久化的订阅者。</p>
<h4 id="637-messagelistener"><a class="markdownIt-Anchor" href="#637-messagelistener"></a> 6.3.7. MessageListener</h4>
<p>消息监听器。如果注册了消息监听器，一旦消息到达，将自动调用监听器的 onMessage 方法。EJB 中的 MDB（Message-Driven Bean）就是一种 MessageListener。</p>
<p>深入学习 JMS 对掌握 JAVA 架构，EJB 架构有很好的帮助，消息中间件也是大型分布式系统必须的组件。本次分享主要做全局性介绍，具体的深入需要大家学习，实践，总结，领会。</p>
<h2 id="7-参考资料"><a class="markdownIt-Anchor" href="#7-参考资料"></a> 7. 参考资料</h2>
<ul>
<li><a href="https://www.cnblogs.com/itfly8/p/5155983.html" target="_blank" rel="noopener">大型网站架构系列：分布式 MQ（一）</a></li>
<li><a href="https://www.cnblogs.com/itfly8/p/5156155.html" target="_blank" rel="noopener">大型网站架构系列：MQ（二）</a></li>
<li><a href="https://www.jianshu.com/p/453c6e7ff81c" target="_blank" rel="noopener">分布式开放 MQ(RocketMQ)的原理与实践</a></li>
<li><a href="https://juejin.im/entry/5a0abfb5f265da43062a4a91" target="_blank" rel="noopener">阿里 RocketMQ 优势对比</a></li>
<li><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/mq-interview.md" target="_blank" rel="noopener">advanced-java 之 MQ</a></li>
</ul>
]]></content>
      <categories>
        <category>设计</category>
        <category>系统原理</category>
      </categories>
      <tags>
        <tag>设计</tag>
        <tag>系统原理</tag>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存基本原理</title>
    <url>/blog/design/theory/cache-theory/</url>
    <content><![CDATA[<h1 id="缓存基本原理"><a class="markdownIt-Anchor" href="#缓存基本原理"></a> 缓存基本原理</h1>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#1-%E7%BC%93%E5%AD%98%E6%A6%82%E8%BF%B0">1. 缓存概述</a>
<ul>
<li><a href="#11-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98">1.1. 什么是缓存</a></li>
<li><a href="#12-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%95%E5%85%A5%E7%BC%93%E5%AD%98">1.2. 为什么引入缓存</a></li>
<li><a href="#13-%E7%BC%93%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86">1.3. 缓存的基本原理</a></li>
<li><a href="#14-%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95">1.4. 缓存淘汰算法</a></li>
<li><a href="#15-%E7%BC%93%E5%AD%98%E7%9A%84%E5%88%86%E7%B1%BB">1.5. 缓存的分类</a></li>
<li><a href="#16-%E7%BC%93%E5%AD%98%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84">1.6. 缓存整体架构</a></li>
</ul>
</li>
<li><a href="#2-cdn-%E7%BC%93%E5%AD%98">2. CDN 缓存</a>
<ul>
<li><a href="#21-cdn-%E5%8E%9F%E7%90%86">2.1. CDN 原理</a></li>
<li><a href="#22-cdn-%E7%89%B9%E7%82%B9">2.2. CDN 特点</a></li>
</ul>
</li>
<li><a href="#3-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98">3. 反向代理缓存</a>
<ul>
<li><a href="#31-%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86">3.1. 缓存原理</a></li>
<li><a href="#32-%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98%E6%AF%94%E8%BE%83">3.2. 代理缓存比较</a></li>
</ul>
</li>
<li><a href="#4-%E8%BF%9B%E7%A8%8B%E5%86%85%E7%BC%93%E5%AD%98">4. 进程内缓存</a>
<ul>
<li><a href="#41-concurrenthashmap">4.1. ConcurrentHashMap</a></li>
<li><a href="#42-lruhashmap">4.2. LRUHashMap</a></li>
<li><a href="#43-guava-cache">4.3. Guava Cache</a></li>
<li><a href="#44-caffeine">4.4. Caffeine</a></li>
<li><a href="#45-%E9%80%89%E6%8B%A9%E8%BF%9B%E7%A8%8B%E5%86%85%E7%BC%93%E5%AD%98">4.5. 选择进程内缓存</a></li>
</ul>
</li>
<li><a href="#5-%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98">5. 分布式缓存</a>
<ul>
<li><a href="#51-memcache">5.1. Memcache</a></li>
<li><a href="#52-redis">5.2. Redis</a></li>
<li><a href="#53-%E9%80%89%E6%8B%A9%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98">5.3. 选择分布式缓存</a></li>
</ul>
</li>
<li><a href="#6-%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98">6. 多级缓存</a>
<ul>
<li><a href="#61-%E4%BD%BF%E7%94%A8%E8%BF%9B%E7%A8%8B%E5%86%85%E7%BC%93%E5%AD%98">6.1. 使用进程内缓存</a></li>
<li><a href="#62-%E4%BD%BF%E7%94%A8%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98">6.2. 使用分布式缓存</a></li>
<li><a href="#63-%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98">6.3. 使用多级缓存</a></li>
</ul>
</li>
<li><a href="#7-%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98">7. 缓存问题</a>
<ul>
<li><a href="#71-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9">7.1. 缓存雪崩</a></li>
<li><a href="#72-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F">7.2. 缓存穿透</a></li>
<li><a href="#73-%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF">7.3. 缓存击穿</a></li>
<li><a href="#74-%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0">7.4. 缓存更新</a></li>
<li><a href="#75-%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD">7.5. 缓存预热</a></li>
<li><a href="#76-%E7%BC%93%E5%AD%98%E9%99%8D%E7%BA%A7">7.6. 缓存降级</a></li>
</ul>
</li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="1-缓存概述"><a class="markdownIt-Anchor" href="#1-缓存概述"></a> 1. 缓存概述</h2>
<h3 id="11-什么是缓存"><a class="markdownIt-Anchor" href="#11-什么是缓存"></a> 1.1. 什么是缓存</h3>
<p><strong>缓存就是数据交换的缓冲区</strong>。</p>
<p>缓存是用于存储数据的硬件或软件的组成部分，以使得后续更快访问相应的数据。缓存中的数据可能是提前计算好的结果、数据的副本等。典型的应用场景：有 cpu cache, 磁盘 cache 等。本文中提及到缓存主要是指互联网应用中所使用的缓存组件。</p>
<h3 id="12-为什么引入缓存"><a class="markdownIt-Anchor" href="#12-为什么引入缓存"></a> 1.2. 为什么引入缓存</h3>
<p>传统的后端业务场景中，访问量以及对响应时间的要求均不高，通常只使用数据库即可满足要求。这种架构简单，便于快速部署，很多网站发展初期均考虑使用这种架构。但是随着访问量的上升，以及对响应时间的要求提升，一个数据库服务已无法再满足要求。这时候通常会考虑数据库拆分(sharding)、读写分离、甚至硬件升级(SSD)等以满足新的业务需求。但是这种方式仍然会面临很多问题，主要体现在：</p>
<ul>
<li>性能提升有限，很难达到数量级上的提升，尤其在互联网业务场景下，随着网站的发展，访问量经常会面临十倍、百倍的上涨。</li>
<li>成本高昂，为了承载 N 倍的访问量，通常需要 N 倍的机器，这个代价难以接受。</li>
</ul>
<p>在数据层引入缓存，有以下几个好处：</p>
<ul>
<li>提升数据读取速度。</li>
<li>提升系统扩展能力，通过扩展缓存，提升系统承载能力。</li>
<li>降低存储成本，Cache+DB 的方式可以承担原有需要多台 DB 才能承担的请求量，节省机器成本。</li>
</ul>
<p>根据业务场景，通常缓存有以下几种使用方式：</p>
<ul>
<li>懒汉式(读时触发)：写入 DB 后, 然后把相关的数据也写入 Cache。</li>
<li>饥饿式(写时触发)：先查询 DB 里的数据, 然后把相关的数据写入 Cache。</li>
<li>定期刷新：适合周期性的跑数据的任务，或者列表型的数据，而且不要求绝对实时性。</li>
</ul>
<h3 id="13-缓存的基本原理"><a class="markdownIt-Anchor" href="#13-缓存的基本原理"></a> 1.3. 缓存的基本原理</h3>
<ol>
<li>将数据写入/读取速度更快的存储（设备）；</li>
<li>将数据缓存到离应用最近的位置；</li>
<li>将数据缓存到离用户最近的位置。</li>
</ol>
<h3 id="14-缓存淘汰算法"><a class="markdownIt-Anchor" href="#14-缓存淘汰算法"></a> 1.4. 缓存淘汰算法</h3>
<p>常见的缓存淘汰算法有以下几种：</p>
<ul>
<li><strong>FIFO</strong> - 先进先出，在这种淘汰算法中，先进入缓存的会先被淘汰。这种可谓是最简单的了，但是会导致我们命中率很低。试想一下我们如果有个访问频率很高的数据是所有数据第一个访问的，而那些不是很高的是后面再访问的，那这样就会把我们的首个数据但是他的访问频率很高给挤出。</li>
<li><strong>LRU</strong> - 最近最少使用算法。在这种算法中避免了上面的问题，每次访问数据都会将其放在我们的队尾，如果需要淘汰数据，就只需要淘汰队首即可。但是这个依然有个问题，如果有个数据在 1 个小时的前 59 分钟访问了 1 万次(可见这是个热点数据),再后一分钟没有访问这个数据，但是有其他的数据访问，就导致了我们这个热点数据被淘汰。</li>
<li><strong>LFU</strong> - 最近最少频率使用。在这种算法中又对上面进行了优化，利用额外的空间记录每个数据的使用频率，然后选出频率最低进行淘汰。这样就避免了 LRU 不能处理时间段的问题。</li>
</ul>
<p>这三种缓存淘汰算法，实现复杂度一个比一个高，同样的命中率也是一个比一个好。而我们一般来说选择的方案居中即可，即实现成本不是太高，而命中率也还行的 LRU。</p>
<h3 id="15-缓存的分类"><a class="markdownIt-Anchor" href="#15-缓存的分类"></a> 1.5. 缓存的分类</h3>
<p>在分布式系统中，缓存的应用非常广泛，从部署角度有以下几个方面的缓存应用。</p>
<ul>
<li><strong>CDN 缓存</strong> - 存放 HTML、CSS、JS 等静态资源。</li>
<li><strong>反向代理缓存</strong> - 动静分离，只缓存用户请求的静态资源。</li>
<li><strong>进程内缓存</strong> - 缓存应用字典等常用数据。</li>
<li><strong>分布式缓存</strong> - 缓存数据库中的热点数据。</li>
</ul>
<h3 id="16-缓存整体架构"><a class="markdownIt-Anchor" href="#16-缓存整体架构"></a> 1.6. 缓存整体架构</h3>
<p>通常，网站的缓存整体架构如下图所示：</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/java/javaweb/technology/cache/缓存整体架构.png!zp" /></div>
请求过程：
<ol>
<li>浏览器向客户端发起请求，如果 CDN 有缓存则直接返回；</li>
<li>如果 CDN 无缓存，则访问反向代理服务器；</li>
<li>如果反向代理服务器有缓存则直接返回；</li>
<li>如果反向代理服务器无缓存或动态请求，则访问应用服务器；</li>
<li>应用服务器访问进程内缓存；如果有缓存，则返回代理服务器，并缓存数据；（动态请求不缓存）</li>
<li>如果进程内缓存无数据，则读取分布式缓存；并返回应用服务器；应用服务器将数据缓存到本地缓存（部分）；</li>
<li>如果分布式缓存无数据，则应用程序读取数据库数据，并放入分布式缓存；</li>
</ol>
<h2 id="2-cdn-缓存"><a class="markdownIt-Anchor" href="#2-cdn-缓存"></a> 2. CDN 缓存</h2>
<blockquote>
<p><strong>CDN 将数据缓存到离用户物理距离最近的服务器，使得用户可以就近获取请求内容。CDN 一般缓存静态资源文件（页面，脚本，图片，视频，文件等）</strong>。</p>
<p>国内网络异常复杂，跨运营商的网络访问会很慢。为了解决跨运营商或各地用户访问问题，可以在重要的城市，部署 CDN 应用。使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。</p>
</blockquote>
<div align="center"><img src="http://dunwu.test.upcdn.net/snap/1559138689425.png!zp"/></div>
### 2.1. CDN 原理
<p>CDN 的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。</p>
<p>（1）未部署 CDN 应用前的网络路径：</p>
<ul>
<li>请求：本机网络（局域网）=&gt; 运营商网络 =&gt; 应用服务器机房</li>
<li>响应：应用服务器机房 =&gt; 运营商网络 =&gt; 本机网络（局域网）</li>
</ul>
<p>在不考虑复杂网络的情况下，从请求到响应需要经过 3 个节点，6 个步骤完成一次用户访问操作。</p>
<p>（2）部署 CDN 应用后网络路径：</p>
<ul>
<li>请求：本机网络（局域网） =&gt; 运营商网络</li>
<li>响应：运营商网络 =&gt; 本机网络（局域网）</li>
</ul>
<p>在不考虑复杂网络的情况下，从请求到响应需要经过 2 个节点，2 个步骤完成一次用户访问操作。</p>
<p>与不部署 CDN 服务相比，减少了 1 个节点，4 个步骤的访问。极大的提高的系统的响应速度。</p>
<h3 id="22-cdn-特点"><a class="markdownIt-Anchor" href="#22-cdn-特点"></a> 2.2. CDN 特点</h3>
<ul>
<li><strong>优点</strong>
<ul>
<li><strong>本地 Cache 加速</strong> - 提升访问速度，尤其含有大量图片和静态页面站点；</li>
<li><strong>镜像服务</strong> - 消除了不同运营商之间互联的瓶颈造成的影响，实现了跨运营商的网络加速，保证不同网络中的用户都能得到良好的访问质量；</li>
<li><strong>远程加速</strong> - 远程访问用户根据 DNS 负载均衡技术智能自动选择 Cache 服务器，选择最快的 Cache 服务器，加快远程访问的速度；</li>
<li><strong>带宽优化</strong> - 自动生成服务器的远程 Mirror（镜像）cache 服务器，远程用户访问时从 cache 服务器上读取数据，减少远程访问的带宽、分担网络流量、减轻原站点 WEB 服务器负载等功能。</li>
<li><strong>集群抗攻击</strong> - 广泛分布的 CDN 节点加上节点之间的智能冗余机制，可以有效地预防黑客入侵以及降低各种 D.D.o.S 攻击对网站的影响，同时保证较好的服务质量。</li>
</ul>
</li>
<li><strong>缺点</strong>
<ul>
<li><strong>不适宜缓存动态资源</strong>
<ul>
<li>解决方案：主要缓存静态资源，动态资源建立多级缓存或准实时同步；</li>
</ul>
</li>
<li><strong>存在数据的一致性问题</strong>
<ul>
<li>解决方案（主要是在性能和数据一致性二者间寻找一个平衡）
<ul>
<li>设置缓存失效时间（1 个小时，过期后同步数据）。</li>
<li>针对资源设置版本号。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-反向代理缓存"><a class="markdownIt-Anchor" href="#3-反向代理缓存"></a> 3. 反向代理缓存</h2>
<blockquote>
<p><strong>反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</strong></p>
</blockquote>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/web/nginx/reverse-proxy.png!zp"/></div>
### 3.1. 缓存原理
<p>反向代理位于应用服务器同一网络，处理所有对 WEB 服务器的请求。</p>
<p>反向代理缓存的原理：</p>
<ul>
<li>如果用户请求的页面在代理服务器上有缓存的话，代理服务器直接将缓存内容发送给用户。</li>
<li>如果没有缓存则先向 WEB 服务器发出请求，取回数据，本地缓存后再发送给用户。</li>
</ul>
<p>这种方式通过降低向 WEB 服务器的请求数，从而降低了 WEB 服务器的负载。</p>
<p><strong>反向代理缓存一般针对的是静态资源，而将动态资源请求转发到应用服务器处理</strong>。常用的缓存应用服务器有 Varnish，Ngnix，Squid。</p>
<h3 id="32-代理缓存比较"><a class="markdownIt-Anchor" href="#32-代理缓存比较"></a> 3.2. 代理缓存比较</h3>
<p>常用的代理缓存有 Varnish，Squid，Ngnix，简单比较如下：</p>
<ul>
<li>Varnish 和 Squid 是专业的 cache 服务，Ngnix 需要第三方模块支持；</li>
<li>Varnish 采用内存型缓存，避免了频繁在内存、磁盘中交换文件，性能比 Squid 高；</li>
<li>Varnish 由于是内存 cache，所以对小文件如 css、js、小图片的支持很棒，后端的持久化缓存可以采用的是 Squid 或 ATS；</li>
<li>Squid 功能全而大，适合于各种静态的文件缓存，一般会在前端挂一个 HAProxy 或 Ngnix 做负载均衡跑多个实例；</li>
<li>Nginx 采用第三方模块 ncache 做的缓冲，性能基本达到 Varnish，一般作为反向代理使用，可以实现简单的缓存。</li>
</ul>
<h2 id="4-进程内缓存"><a class="markdownIt-Anchor" href="#4-进程内缓存"></a> 4. 进程内缓存</h2>
<blockquote>
<p>进程内缓存是指应用内部的缓存，标准的分布式系统，一般有多级缓存构成。本地缓存是离应用最近的缓存，一般可以将数据缓存到硬盘或内存。</p>
</blockquote>
<ul>
<li><code>硬盘缓存</code> - 将数据缓存到硬盘到，读取时从硬盘读取。原理是直接读取本机文件，减少了网络传输消耗，比通过网络读取数据库速度更快。可以应用在对速度要求不是很高，但需要大量缓存存储的场景。</li>
<li><code>内存缓存</code> - 直接将数据存储到本机内存中，通过程序直接维护缓存对象，是访问速度最快的方式。</li>
</ul>
<p>常见的本地缓存实现方案：HashMap、Guava Cache、Caffeine、Ehcache。</p>
<h3 id="41-concurrenthashmap"><a class="markdownIt-Anchor" href="#41-concurrenthashmap"></a> 4.1. ConcurrentHashMap</h3>
<p>最简单的进程内缓存可以通过 JDK 自带的 <code>HashMap</code> 或 <code>ConcurrentHashMap</code> 实现。</p>
<p>适用场景：不需要淘汰的缓存数据。</p>
<p>缺点：无法进行缓存淘汰，内存会无限制的增长。</p>
<h3 id="42-lruhashmap"><a class="markdownIt-Anchor" href="#42-lruhashmap"></a> 4.2. LRUHashMap</h3>
<p>可以通过继承 <code>LinkedHashMap</code> 来实现一个简单的 <code>LRUHashMap</code>。重写 <code>removeEldestEntry</code> 方法，即可完成一个简单的最近最少使用算法。</p>
<ul>
<li>缺点：
<ul>
<li>锁竞争严重，性能比较低。</li>
<li>不支持过期时间</li>
<li>不支持自动刷新</li>
</ul>
</li>
</ul>
<h3 id="43-guava-cache"><a class="markdownIt-Anchor" href="#43-guava-cache"></a> 4.3. Guava Cache</h3>
<p>解决了 <code>LRUHashMap</code> 中的几个缺点。</p>
<p>Guava Cache 采用了类似 <code>ConcurrentHashMap</code> 的思想，分段加锁，减少锁竞争。</p>
<p>Guava Cache 对于过期的 Entry 并没有马上过期(也就是并没有后台线程一直在扫)，而是通过进行读写操作的时候进行过期处理，这样做的好处是避免后台线程扫描的时候进行全局加锁。</p>
<p>直接通过查询，判断其是否满足刷新条件，进行刷新。</p>
<h3 id="44-caffeine"><a class="markdownIt-Anchor" href="#44-caffeine"></a> 4.4. Caffeine</h3>
<p>Caffeine 实现了 W-TinyLFU(LFU+LRU 算法的变种)，其命中率和读写吞吐量大大优于 Guava Cache。</p>
<p>其实现原理较复杂，可以参考<a href="https://juejin.im/post/5b7593496fb9a009b62904fa#comment" target="_blank" rel="noopener">你应该知道的缓存进化史</a>。</p>
<h3 id="45-选择进程内缓存"><a class="markdownIt-Anchor" href="#45-选择进程内缓存"></a> 4.5. 选择进程内缓存</h3>
<table>
<thead>
<tr>
<th>比较项</th>
<th>ConcurrentHashMap</th>
<th>LRUMap</th>
<th>Ehcache</th>
<th>Guava Cache</th>
<th>Caffeine</th>
</tr>
</thead>
<tbody>
<tr>
<td>读写性能</td>
<td>很好，分段锁</td>
<td>一般，全局加锁</td>
<td>好</td>
<td>好，需要做淘汰操作</td>
<td>很好</td>
</tr>
<tr>
<td>淘汰算法</td>
<td>无</td>
<td>LRU，一般</td>
<td>支持多种淘汰算法,LRU,LFU,FIFO</td>
<td>LRU，一般</td>
<td>W-TinyLFU, 很好</td>
</tr>
<tr>
<td>功能丰富程度</td>
<td>功能比较简单</td>
<td>功能比较单一</td>
<td>功能很丰富</td>
<td>功能很丰富，支持刷新和虚引用等</td>
<td>功能和 Guava Cache 类似</td>
</tr>
<tr>
<td>工具大小</td>
<td>jdk 自带类，很小</td>
<td>基于 LinkedHashMap，较小</td>
<td>很大，最新版本 1.4MB</td>
<td>是 Guava 工具类中的一个小部分，较小</td>
<td>一般，最新版本 644KB</td>
</tr>
<tr>
<td>是否持久化</td>
<td>否</td>
<td>否</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>是否支持集群</td>
<td>否</td>
<td>否</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
</tbody>
</table>
<ul>
<li><strong><code>ConcurrentHashMap</code></strong> - 比较适合缓存比较固定不变的元素，且缓存的数量较小的。虽然从上面表格中比起来有点逊色，但是其由于是 JDK 自带的类，在各种框架中依然有大量的使用，比如我们可以用来缓存我们反射的 Method，Field 等等；也可以缓存一些链接，防止其重复建立。在 Caffeine 中也是使用的 <code>ConcurrentHashMap</code> 来存储元素。</li>
<li><strong><code>LRUMap</code></strong> - 如果不想引入第三方包，又想使用淘汰算法淘汰数据，可以使用这个。</li>
<li><strong><code>Ehcache</code></strong> - 由于其 jar 包很大，较重量级。对于需要持久化和集群的一些功能的，可以选择 Ehcache。笔者没怎么使用过这个缓存，如果要选择的话，可以选择分布式缓存来替代 Ehcache。</li>
<li><strong><code>Guava Cache</code></strong> - Guava 这个 jar 包在很多 Java 应用程序中都有大量的引入，所以很多时候其实是直接用就好了，并且其本身是轻量级的而且功能较为丰富，在不了解 Caffeine 的情况下可以选择 Guava Cache。</li>
<li><strong><code>Caffeine</code></strong> - 其在命中率，读写性能上都比 Guava Cache 好很多，并且其 API 和 Guava cache 基本一致，甚至会多一点。在真实环境中使用 Caffeine，取得过不错的效果。</li>
</ul>
<p>总结一下：如果不需要淘汰算法则选择 <code>ConcurrentHashMap</code>，如果需要淘汰算法和一些丰富的 API，推荐选择 Caffeine。</p>
<h2 id="5-分布式缓存"><a class="markdownIt-Anchor" href="#5-分布式缓存"></a> 5. 分布式缓存</h2>
<blockquote>
<p><strong>分布式缓存解决了进程内缓存最大的问题：如果应用是分布式系统，节点之间无法共享彼此的进程内缓存</strong>。</p>
<p>分布式缓存的应用场景：</p>
<ul>
<li>缓存经过复杂计算得到的数据</li>
<li>缓存系统中频繁访问的热点数据，减轻数据库压力</li>
</ul>
</blockquote>
<p>不同分布式缓存的实现原理往往有比较大的差异。本文主要针对 Memcached 和 Redis 进行说明。</p>
<h3 id="51-memcache"><a class="markdownIt-Anchor" href="#51-memcache"></a> 5.1. Memcache</h3>
<blockquote>
<p><a href="https://memcached.org/" target="_blank" rel="noopener">Memcache</a> 是一个高性能，分布式内存对象缓存系统，通过在内存里维护一个统一的巨大的 hash 表，它能够用来存储各种格式的数据，包括图像、视频、文件以及数据库检索的结果等。</p>
<p>简单的说就是：将数据缓存到内存中，然后从内存中读取，从而大大提高读取速度。</p>
</blockquote>
<h4 id="memcache-特性"><a class="markdownIt-Anchor" href="#memcache-特性"></a> Memcache 特性</h4>
<ul>
<li><strong>使用物理内存作为缓存区，可独立运行在服务器上</strong>。每个进程最大 2G，如果想缓存更多的数据，可以开辟更多的 Memcache 进程（不同端口）或者使用分布式 Memcache 进行缓存，将数据缓存到不同的物理机或者虚拟机上。</li>
<li><strong>使用 key-value 的方式来存储数据</strong>。这是一种单索引的结构化数据组织形式，可使数据项查询时间复杂度为 O(1)。</li>
<li><strong>协议简单，基于文本行的协议</strong>。直接通过 telnet 在 Memcached 服务器上可进行存取数据操作，简单，方便多种缓存参考此协议；</li>
<li><strong>基于 libevent 高性能通信</strong>。Libevent 是一套利用 C 开发的程序库，它将 BSD 系统的 kqueue,Linux 系统的 epoll 等事件处理功能封装成一个接口，与传统的 select 相比，提高了性能。</li>
<li><strong>分布式能力取决于 Memcache 客户端，服务器之间互不通信</strong>。各个 Memcached 服务器之间互不通信，各自独立存取数据，不共享任何信息。服务器并不具有分布式功能，分布式部署取决于 Memcached 客户端。</li>
<li><strong>采用 LRU 缓存淘汰策略</strong>。在 Memcached 内存储数据项时，可以指定它在缓存的失效时间，默认为永久。当 Memcached 服务器用完分配的内时，失效的数据被首先替换，然后也是最近未使用的数据。在 LRU 中，Memcached 使用的是一种 Lazy Expiration 策略，自己不会监控存入的 key/vlue 对是否过期，而是在获取 key 值时查看记录的时间戳，检查 key/value 对空间是否过期，这样可减轻服务器的负载。</li>
<li><strong>内置了一套高效的内存管理算法</strong>。这套内存管理效率很高，而且不会造成内存碎片，但是它最大的缺点就是会导致空间浪费。当内存满后，通过 LRU 算法自动删除不使用的缓存。</li>
<li><strong>不支持持久化</strong>。Memcached 没有考虑数据的容灾问题，重启服务，所有数据会丢失。</li>
</ul>
<h4 id="memcache-工作原理"><a class="markdownIt-Anchor" href="#memcache-工作原理"></a> Memcache 工作原理</h4>
<p>（1）内存管理</p>
<p>Memcached 利用 <strong>slab allocation</strong> 机制来分配和管理内存，它按照预先规定的大小，将分配的内存分割成特定长度的内存块，再把尺寸相同的内存块分成组，数据在存放时，根据键值 大小去匹配 slab 大小，找就近的 slab 存放，所以存在空间浪费现象。</p>
<p>这套内存管理效率很高，而且不会造成内存碎片，但是它最大的缺点就是会导致空间浪费。</p>
<p>（2）缓存淘汰策略</p>
<p>Memcached 的缓存淘汰策略是 <strong>LRU</strong> + 到期失效策略。</p>
<p>当你在 Memcached 内存储数据项时，你有可能会指定它在缓存的失效时间，默认为永久。当 Memcached 服务器用完分配的内时，失效的数据被首先替换，然后是最近未使用的数据。</p>
<p>在 LRU 中，Memcached 使用的是一种 Lazy Expiration 策略：<strong>Memcached 不会监控存入的 key/vlue 对是否过期</strong>，而是在获取 key 值时查看记录的时间戳，<strong>检查 key/value 对空间是否过期</strong>，这样可减轻服务器的负载。</p>
<p>（3）分区</p>
<p>Memcached 服务器之间彼此不通信，它的分布式能力是依赖客户端来实现。</p>
<p>具体来说，就是在客户端实现一种算法，根据 key 来计算出数据应该向哪个服务器节点读/写。</p>
<p>而这种选取集群节点的算法常见的有三种：</p>
<ul>
<li><strong>哈希取余算法</strong> - 使用公式：<code>hash（key）% N</code> 计算出 <strong>哈希值</strong> 来决定数据映射到哪一个节点。</li>
<li><strong>一致性哈希算法</strong> - 可以很好的解决 <strong>稳定性问题</strong>，可以将所有的 <strong>存储节点</strong> 排列在 <strong>首尾相接</strong> 的 <code>Hash</code> 环上，每个 <code>key</code> 在计算 <code>Hash</code> 后会 <strong>顺时针</strong> 找到 <strong>临接</strong> 的 <strong>存储节点</strong> 存放。而当有节点 <strong>加入</strong> 或 <strong>退出</strong> 时，仅影响该节点在 <code>Hash</code> 环上 <strong>顺时针相邻</strong> 的 <strong>后续节点</strong>。</li>
<li><strong>虚拟 Hash 槽算法</strong> - 使用 <strong>分散度良好</strong> 的 <strong>哈希函数</strong> 把所有数据 <strong>映射</strong> 到一个 <strong>固定范围</strong> 的 <strong>整数集合</strong> 中，整数定义为 <strong>槽</strong>（<code>slot</code>），这个范围一般 <strong>远远大于</strong> 节点数。<strong>槽</strong> 是集群内 <strong>数据管理</strong> 和 <strong>迁移</strong> 的 <strong>基本单位</strong>。采用 <strong>大范围槽</strong> 的主要目的是为了方便 <strong>数据拆分</strong> 和 <strong>集群扩展</strong>。每个节点会负责 <strong>一定数量的槽</strong>。</li>
</ul>
<h3 id="52-redis"><a class="markdownIt-Anchor" href="#52-redis"></a> 5.2. Redis</h3>
<blockquote>
<p>Redis 是一个开源（BSD 许可）的，基于内存的，多数据结构存储系统。可以用作数据库、缓存和消息中间件。</p>
<p>Redis 还可以使用客户端分片来扩展写性能。内置了 复制（replication），LUA 脚本（Lua scripting），LRU 驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis 哨兵（Sentinel）和自动分区（Cluster）提供高可用性（high availability）。</p>
</blockquote>
<h4 id="redis-特性"><a class="markdownIt-Anchor" href="#redis-特性"></a> Redis 特性</h4>
<ul>
<li>
<p>支持多种数据类型 - string、hash、list、set、sorted set。</p>
</li>
<li>
<p>支持多种数据淘汰策略</p>
<ul>
<li><strong>volatile-lru</strong> - 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</li>
<li><strong>volatile-ttl</strong> - 从已设置过期时间的数据集中挑选将要过期的数据淘汰</li>
<li><strong>volatile-random</strong> - 从已设置过期时间的数据集中任意选择数据淘汰</li>
<li><strong>allkeys-lru</strong> - 从所有数据集中挑选最近最少使用的数据淘汰</li>
<li><strong>allkeys-random</strong> - 从所有数据集中任意选择数据进行淘汰</li>
<li><strong>noeviction</strong> - 禁止驱逐数据</li>
</ul>
</li>
<li>
<p>提供两种持久化方式 - RDB 和 AOF</p>
</li>
<li>
<p>通过 Redis cluster 提供集群模式。</p>
</li>
</ul>
<h4 id="redis-原理"><a class="markdownIt-Anchor" href="#redis-原理"></a> Redis 原理</h4>
<ul>
<li>缓存淘汰
<ul>
<li>Redis 有两种数据淘汰实现
<ul>
<li>消极方式 - 访问 Redis key 时，如果发现它已经失效，则删除它</li>
<li>积极方式 - 周期性从设置了失效时间的 key 中，根据淘汰策略，选择一部分失效的 key 进行删除。</li>
</ul>
</li>
</ul>
</li>
<li>分区
<ul>
<li>Redis Cluster 集群包含 16384 个虚拟 Hash 槽，它通过一个高效的算法来计算 key 属于哪个 Hash 槽。</li>
<li>Redis Cluster 支持请求分发 - 节点在接到一个命令请求时，会先检测这个命令请求要处理的键所在的槽是否由自己负责，如果不是的话，节点将向客户端返回一个 MOVED 错误，MOVED 错误携带的信息可以指引客户端将请求重定向至正在负责相关槽的节点。</li>
</ul>
</li>
<li>主从复制
<ul>
<li>Redis 2.8 后支持异步复制。它有两种模式：
<ul>
<li><code>完整重同步（full resychronization）</code> - 用于初次复制。执行步骤与 <code>SYNC</code> 命令基本一致。</li>
<li><code>部分重同步（partial resychronization）</code> - 用于断线后重复制。如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只需接收并执行这些写命令，即可将主从服务器的数据库状态保持一致。</li>
</ul>
</li>
<li>集群中每个节点都会定期向集群中的其他节点发送 PING 消息，以此来检测对方是否在线。</li>
<li>如果一个主节点被认为下线，则在其从节点中，根据 Raft 算法，选举出一个节点，升级为主节点。</li>
</ul>
</li>
<li>数据一致性
<ul>
<li>Redis 不保证强一致性，因为这会使得集群性能大大降低。</li>
<li>Redis 是通过异步复制来实现最终一致性。</li>
</ul>
</li>
</ul>
<h3 id="53-选择分布式缓存"><a class="markdownIt-Anchor" href="#53-选择分布式缓存"></a> 5.3. 选择分布式缓存</h3>
<p>不同的分布式缓存功能特性和实现原理方面有很大的差异，因此他们所适应的场景也有所不同。</p>
<p>这里选取三个比较出名的分布式缓存（MemCache，Redis，Tair）来作为比较：</p>
<table>
<thead>
<tr>
<th>比较项</th>
<th>MemCache</th>
<th>Redis</th>
<th>Tair</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据结构</td>
<td>只支持简单的 Key-Value 结构</td>
<td>String,Hash, List, Set, Sorted Set</td>
<td>String,HashMap, List，Set</td>
</tr>
<tr>
<td>持久化</td>
<td>不支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>容量大小</td>
<td>数据纯内存，数据存储不宜过多</td>
<td>数据全内存，资源成本考量不宜超过 100GB</td>
<td>可以配置全内存或内存+磁盘引擎，数据容量可无限扩充</td>
</tr>
<tr>
<td>读写性能</td>
<td>很高</td>
<td>很高(RT0.5ms 左右)</td>
<td>String 类型比较高(RT1ms 左右)，复杂类型比较慢(RT5ms 左右)</td>
</tr>
<tr>
<td>过期策略</td>
<td>过期后，不删除缓存</td>
<td>有六种策略来处理过期数据</td>
<td>支持</td>
</tr>
</tbody>
</table>
<ul>
<li><code>MemCache</code> - 这一块接触得比较少，不做过多的推荐。其吞吐量较大，但是支持的数据结构较少，并且不支持持久化。</li>
<li><code>Redis</code> - 支持丰富的数据结构，读写性能很高，但是数据全内存，必须要考虑资源成本，支持持久化。</li>
<li><code>Tair</code> - 支持丰富的数据结构，读写性能较高，部分类型比较慢，理论上容量可以无限扩充。</li>
</ul>
<p>总结：如果服务对延迟比较敏感，Map/Set 数据也比较多的话，比较适合 Redis。如果服务需要放入缓存量的数据很大，对延迟又不是特别敏感的话，那就可以选择 Tair。</p>
<h2 id="6-多级缓存"><a class="markdownIt-Anchor" href="#6-多级缓存"></a> 6. 多级缓存</h2>
<h3 id="61-使用进程内缓存"><a class="markdownIt-Anchor" href="#61-使用进程内缓存"></a> 6.1. 使用进程内缓存</h3>
<p>如果应用服务不是分布式系统，那么进程内缓存当然是缓存的首选方案。</p>
<p>对于进程内缓存，其本来受限于内存的大小的限制，以及进程缓存更新后其他缓存无法得知，所以一般来说进程缓存适用于:</p>
<ol>
<li>数据量不是很大且更新频率较低的数据。</li>
<li>如果更新频繁的数据，也想使用进程内缓存，那么可以将其过期时间设置为较短的时间，或者设置较短的自动刷新时间。</li>
</ol>
<p>这种方案存在以下问题：</p>
<ul>
<li>如果应用服务是分布式系统，应用节点之间无法共享缓存，存在数据不一致问题。</li>
<li>由于进程内缓存受限于内存大小的限制，所以缓存不能无限扩展。</li>
</ul>
<h3 id="62-使用分布式缓存"><a class="markdownIt-Anchor" href="#62-使用分布式缓存"></a> 6.2. 使用分布式缓存</h3>
<p>如果应用服务是分布式系统，那么最简单的缓存方案就是直接使用分布式缓存。</p>
<p>其应用场景如图所示：</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/java/javaweb/technology/cache/多级缓存1.png!zp" width="600px"/></div>
Redis 用来存储热点数据，如果缓存不命中，则去查询数据库，并更新缓存。
<p>这种方案存在以下问题：</p>
<ol>
<li>缓存服务如果挂了，这时应用只能访问数据库，容易造成缓存雪崩。</li>
<li>访问分布式缓存服务会有一定的 I/O 以及序列化反序列化的开销，虽然性能很高，但是其终究没有在内存中查询快。</li>
</ol>
<h3 id="63-使用多级缓存"><a class="markdownIt-Anchor" href="#63-使用多级缓存"></a> 6.3. 使用多级缓存</h3>
<p>单纯使用进程内缓存和分布式缓存都存在各自的不足。如果需要更高的性能以及更好的可用性，我们可以将缓存设计为多级结构。将最热的数据使用进程内缓存存储在内存中，进一步提升访问速度。</p>
<p>这个设计思路在计算机系统中也存在，比如 CPU 使用 L1、L2、L3 多级缓存，用来减少对内存的直接访问，从而加快访问速度。</p>
<p>一般来说，多级缓存架构使用二级缓存已可以满足大部分业务需求，过多的分级会增加系统的复杂度以及维护的成本。因此，多级缓存不是分级越多越好，需要根据实际情况进行权衡。</p>
<p>一个典型的二级缓存架构，可以使用进程内缓存（如： Caffeine/Google Guava/Ehcache/HashMap）作为一级缓存；使用分布式缓存（如：Redis/Memcached）作为二级缓存。</p>
<h4 id="多级缓存查询"><a class="markdownIt-Anchor" href="#多级缓存查询"></a> 多级缓存查询</h4>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/java/javaweb/technology/cache/多级缓存2.png!zp" width="600" /></div>
多级缓存查询流程如下：
<ol>
<li>首先，查询 L1 缓存，如果缓存命中，直接返回结果；如果没有命中，执行下一步。</li>
<li>接下来，查询 L2 缓存，如果缓存命中，直接返回结果并回填 L1 缓存；如果没有命中，执行下一步。</li>
<li>最后，查询数据库，返回结果并依次回填 L2 缓存、L1 缓存。</li>
</ol>
<h4 id="多级缓存更新"><a class="markdownIt-Anchor" href="#多级缓存更新"></a> 多级缓存更新</h4>
<p>对于 L1 缓存，如果有数据更新，只能删除并更新所在机器上的缓存，其他机器只能通过超时机制来刷新缓存。超时设定可以有两种策略:</p>
<ul>
<li>设置成写入后多少时间后过期</li>
<li>设置成写入后多少时间刷新</li>
</ul>
<p>对于 L1 缓存，如果有数据更新，其他机器立马可见。但是，也必须要设置超时时间，其时间应该比 L1 缓存的有效时间长。</p>
<p>为了解决进程内缓存不一致的问题，设计可以进一步优化:</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/java/javaweb/technology/cache/多级缓存3.png!zp" /></div>
通过消息队列的发布、订阅机制，可以通知其他应用节点对进程内缓存进行更新。使用这种方案，即使消息队列服务挂了或不可靠，由于先执行了数据库更新，但进程内缓存过期，刷新缓存时，也能保证数据的最终一致性。
<h2 id="7-缓存问题"><a class="markdownIt-Anchor" href="#7-缓存问题"></a> 7. 缓存问题</h2>
<h3 id="71-缓存雪崩"><a class="markdownIt-Anchor" href="#71-缓存雪崩"></a> 7.1. 缓存雪崩</h3>
<blockquote>
<p><strong>缓存雪崩是指缓存不可用或者大量缓存由于超时时间相同在同一时间段失效，大量请求直接访问数据库，数据库压力过大导致系统雪崩</strong>。</p>
</blockquote>
<p>解决方案：</p>
<ul>
<li>增加缓存系统可用性。通过监控关注缓存的健康程度，根据业务量适当的扩容缓存。</li>
<li>采用多级缓存。不同级别缓存设置的超时时间不同，即使某个级别缓存都过期，也有其他级别缓存兜底。</li>
<li>缓存的过期时间可以取个随机值。比如以前是设置 10 分钟的超时时间，那每个 Key 都可以随机 8-13 分钟过期，尽量让不同 Key 的过期时间不同。</li>
<li>对数据库进行过载保护或应用层限流。</li>
</ul>
<h3 id="72-缓存穿透"><a class="markdownIt-Anchor" href="#72-缓存穿透"></a> 7.2. 缓存穿透</h3>
<blockquote>
<p><strong>缓存穿透是指：查询的数据在数据库中不存在，那么缓存中自然也不存在。所以，应用在缓存中查不到，则会去查询数据库。当这样的请求多了后，数据库的压力就会增大。</strong></p>
</blockquote>
<p>解决缓存穿透，一般有两种方法：</p>
<ul>
<li><strong>对于返回为 NULL 的依然缓存，对于抛出异常的返回不进行缓存</strong>。</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/java/javaweb/technology/cache/缓存穿透1.png!zp" width="350px"/></div>
采用这种手段的会增加我们缓存的维护成本，需要在插入缓存的时候删除这个空缓存，当然我们可以通过设置较短的超时时间来解决这个问题。
<ul>
<li><strong>过滤不可能存在的数据</strong></li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/java/javaweb/technology/cache/缓存穿透2.png!zp" width="350px"/></div>
**制定一些规则过滤一些不可能存在的数据**。小数据用 BitMap，大数据可以用布隆过滤器，比如你的订单 ID 明显是在一个范围 1-1000，如果不是 1-1000 之内的数据那其实可以直接给过滤掉。
<h3 id="73-缓存击穿"><a class="markdownIt-Anchor" href="#73-缓存击穿"></a> 7.3. 缓存击穿</h3>
<p>对于某些 key 设置了过期时间，但是其是热点数据，如果某个 key 失效，可能大量的请求打过来，缓存未命中，然后去数据库访问，此时数据库访问量会急剧增加。</p>
<p>为了避免这个问题，我们可以采取下面的两个手段:</p>
<ul>
<li><strong>分布式锁</strong> - 锁住热点数据的 key，避免大量线程同时访问同一个 key。</li>
<li><strong>异步加载</strong> - 可以对部分数据采取到期自动刷新的策略，而不是到期自动淘汰。淘汰其实也是为了数据的时效性，所以采用自动刷新也可以。</li>
</ul>
<h3 id="74-缓存更新"><a class="markdownIt-Anchor" href="#74-缓存更新"></a> 7.4. 缓存更新</h3>
<p>一般来说缓存的更新有两种情况:</p>
<ul>
<li>先删除缓存，再更新数据库。</li>
<li>先更新数据库，再删除缓存。</li>
</ul>
<blockquote>
<p><strong>为什么是删除缓存，而不是更新缓存呢？</strong></p>
<p>你可以想想当有多个并发的请求更新数据，你并不能保证更新数据库的顺序和更新缓存的顺序一致，那就会出现数据库中和缓存中数据不一致的情况。所以一般来说考虑删除缓存。</p>
</blockquote>
<ul>
<li><strong>先删除缓存，再更新数据库</strong></li>
</ul>
<p>对于一个更新操作简单来说，就是先去各级缓存进行删除，然后更新数据库。</p>
<p>这个操作有一个比较大的问题，在对缓存删除完之后，有一个读请求，这个时候由于缓存被删除所以直接会读库，读操作的数据是老的并且会被加载进入缓存当中，后续读请求全部访问的老数据。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/java/javaweb/technology/cache/缓存更新.png!zp" width="400px"/></div>
对缓存的操作不论成功失败都不能阻塞我们对数据库的操作，那么很多时候删除缓存可以用异步的操作，但是先删除缓存不能很好的适用于这个场景。
<p>先删除缓存也有一个好处是，如果对数据库操作失败了，那么由于先删除的缓存，最多只是造成 Cache Miss。</p>
<ul>
<li><strong>先更新数据库，再删除缓存</strong></li>
</ul>
<blockquote>
<p>注：更推荐使用这种策略</p>
</blockquote>
<p>如果我们使用更新数据库，再删除缓存就能避免上面的问题。</p>
<p>但是同样的引入了新的问题：假设执行更新操作时，又接收到查询请求，此时就会返回缓存中的老数据。更麻烦的是，如果数据库更新操作执行失败，则缓存中可能永远是脏数据。</p>
<ul>
<li>应该选择哪种更新测录</li>
</ul>
<p>通过上面的内容，我们知道，两种更新策略都存在并发问题。</p>
<p>但是建议选择先更新数据库，再删除缓存，因为其并发问题出现的概率可能非常低，因为这个条件需要发生在读缓存时缓存失效，而且并发着有一个写操作。而实际上数据库的写操作会比读操作慢得多，而且还要锁表，而读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存，所有的这些条件都具备的概率基本并不大。</p>
<p>如果需要数据库和缓存保证强一致性，则可以通过 2PC 或 Paxos 协议来实现。但是 2PC 太慢，而 Paxos 太复杂，所以如果不是非常重要的数据，不建议使用强一致性方案。</p>
<h3 id="75-缓存预热"><a class="markdownIt-Anchor" href="#75-缓存预热"></a> 7.5. 缓存预热</h3>
<p>缓存预热是指系统启动后，将常用的数据直接缓存。这样就可以避免用户请求的时候，先查询数据库，然后再更新缓存的问题。</p>
<p>解决方案：</p>
<ul>
<li>直接写个缓存刷新页面，上线时手工操作下。</li>
<li>数据量不大，可以在项目启动的时候自动进行加载。</li>
<li>定时刷新缓存。</li>
</ul>
<h3 id="76-缓存降级"><a class="markdownIt-Anchor" href="#76-缓存降级"></a> 7.6. 缓存降级</h3>
<p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</p>
<p>降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。</p>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li>《大型网站技术架构》</li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fjuejin.im%2Fpost%2F5b7593496fb9a009b62904fa">你应该知道的缓存进化史</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fjuejin.im%2Fpost%2F5b849878e51d4538c77a974a">如何优雅的设计和使用缓存？</a></li>
<li><a href="https://www.jianshu.com/p/73ce0ef820f9" target="_blank" rel="noopener">理解分布式系统中的缓存架构(上)</a></li>
</ul>
]]></content>
      <categories>
        <category>设计</category>
        <category>系统原理</category>
      </categories>
      <tags>
        <tag>设计</tag>
        <tag>系统原理</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式事务基本原理</title>
    <url>/blog/design/theory/distributed-transaction-theory/</url>
    <content><![CDATA[<h1 id="分布式事务基本原理"><a class="markdownIt-Anchor" href="#分布式事务基本原理"></a> 分布式事务基本原理</h1>
<blockquote>
<p><strong>分布式事务指的是事务操作跨越多个节点，并且要求满足事务的 ACID 特性。</strong></p>
</blockquote>
<p>分布式事务的实现主要有以下 5 种方案：</p>
<ul>
<li>XA 方案</li>
<li>TCC 方案</li>
<li>本地消息表</li>
<li>可靠消息最终一致性方案</li>
<li>最大努力通知方案</li>
</ul>
<h2 id="1-两阶段提交"><a class="markdownIt-Anchor" href="#1-两阶段提交"></a> 1. 两阶段提交</h2>
<blockquote>
<p>两阶段提交（Two-phase Commit，2PC）通过引入协调者（Coordinator）来调度参与者的行为，并最终决定这些参与者是否要真正执行事务。</p>
<p>参考实现：<a href="https://github.com/changmingxie/tcc-transaction" target="_blank" rel="noopener">https://github.com/changmingxie/tcc-transaction</a></p>
</blockquote>
<h3 id="11-运行过程"><a class="markdownIt-Anchor" href="#11-运行过程"></a> 1.1. 运行过程</h3>
<h4 id="111-准备阶段"><a class="markdownIt-Anchor" href="#111-准备阶段"></a> 1.1.1. 准备阶段</h4>
<p>协调者询问参与者事务是否执行成功，参与者发回事务执行结果。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/分布式事务两阶段提交-01.jpg!zp" />
</div>
<h4 id="112-提交阶段"><a class="markdownIt-Anchor" href="#112-提交阶段"></a> 1.1.2. 提交阶段</h4>
<p>如果事务在每个参与者上都执行成功，事务协调者发送通知让参与者提交事务；否则，协调者发送通知让参与者回滚事务。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/分布式事务两阶段提交-02.jpg!zp" />
</div>
<p>需要注意的是，在准备阶段，参与者执行了事务，但是还未提交。只有在提交阶段接收到协调者发来的通知后，才进行提交或者回滚。</p>
<h3 id="12-问题"><a class="markdownIt-Anchor" href="#12-问题"></a> 1.2. 问题</h3>
<ul>
<li><strong>同步阻塞</strong> - 所有事务参与者在等待其它参与者响应的时候都处于同步阻塞状态，无法进行其它操作。</li>
<li><strong>单点问题</strong> - 协调者在 2PC 中起到非常大的作用，发生故障将会造成很大影响，特别是在阶段二发生故障，所有参与者会一直等待状态，无法完成其它操作。</li>
<li><strong>数据不一致</strong> - 在阶段二，如果协调者只发送了部分 Commit 消息，此时网络发生异常，那么只有部分参与者接收到 Commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。</li>
<li><strong>太过保守</strong> - 任意一个节点失败就会导致整个事务失败，没有完善的容错机制。</li>
</ul>
<h3 id="13-优缺点"><a class="markdownIt-Anchor" href="#13-优缺点"></a> 1.3. 优缺点</h3>
<ul>
<li>优点：尽量保证了数据的强一致，适合对数据强一致要求很高的关键领域。（其实也不能 100%保证强一致</li>
<li>缺点：实现复杂，牺牲了可用性，对性能影响较大，不适合高并发高性能场景。</li>
</ul>
<h2 id="2-补偿事务"><a class="markdownIt-Anchor" href="#2-补偿事务"></a> 2. 补偿事务</h2>
<blockquote>
<p>补偿事务（TCC），全称是：<code>Try</code>、<code>Confirm</code>、<code>Cancel</code>。</p>
<p>其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。它分为三个阶段：</p>
<p>TCC 的。</p>
<ul>
<li>Try 阶段：这个阶段说的是对各个服务的资源做检测以及对资源进行<strong>锁定或者预留</strong>。</li>
<li>Confirm 阶段：这个阶段说的是在各个服务中<strong>执行实际的操作</strong>。</li>
<li>Cancel 阶段：如果任何一个服务的业务方法执行出错，那么这里就需要<strong>进行补偿</strong>，就是执行已经执行成功的业务逻辑的回滚操作。（把那些执行成功的回滚）</li>
</ul>
</blockquote>
<p>举个例子，假设 Bob 要向 Smith 转账，思路大概是：</p>
<ol>
<li>首先在 Try 阶段，要先调用远程接口把 Smith 和 Bob 的钱给冻结起来。</li>
<li>在 Confirm 阶段，执行远程调用的转账的操作，转账成功进行解冻。</li>
<li>如果第 2 步执行成功，那么转账成功，如果第二步执行失败，则调用远程冻结接口对应的解冻方法 (Cancel)。</li>
</ol>
<p>优缺点：</p>
<ul>
<li>优点：跟 2PC 比起来，实现以及流程相对简单了一些，但数据的一致性比 2PC 也要差一些。</li>
<li>缺点：缺点还是比较明显的，在 2,3 步中都有可能失败。TCC 属于应用层的一种补偿方式，所以需要程序员在实现的时候多写很多补偿的代码，在一些场景中，一些业务流程可能用 TCC 不太好定义及处理。</li>
</ul>
<p>这种方案几乎很少人使用，因为<strong>事务回滚</strong>实际上是<strong>严重依赖于自己写代码来回滚和补偿</strong>了，会造成补偿代码巨大。</p>
<p>但是，也有特殊的使用场景：一般来说跟<strong>钱</strong>相关的，跟钱打交道的，<strong>支付</strong>、<strong>交易</strong>相关的场景，会用 TCC，严格保证分布式事务要么全部成功，要么全部自动回滚，严格保证资金的正确性，保证在资金上不会出现问题。</p>
<p>而且最好是你的各个业务执行的时间都比较短。</p>
<p>但是说实话，一般尽量别这么搞，自己手写回滚逻辑，或者是补偿逻辑，实在太恶心了，那个业务代码是很难维护的。</p>
<h2 id="3-本地消息表异步确保"><a class="markdownIt-Anchor" href="#3-本地消息表异步确保"></a> 3. 本地消息表（异步确保）</h2>
<blockquote>
<p>本地消息表与业务数据表处于同一个数据库中，这样就能利用本地事务来保证在对这两个表的操作满足事务特性。</p>
<ol>
<li>在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送一个消息，本地事务能保证这个消息一定会被写入本地消息表中。</li>
<li>之后将本地消息表中的消息转发到 Kafka 等消息队列（MQ）中，如果转发成功则将消息从本地消息表中删除，否则继续重新转发。</li>
<li>在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作。</li>
</ol>
</blockquote>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/分布式事务本地消息.jpg!zp" />
</div>
<p>这种方案遵循 BASE 理论，采用的是最终一致性。</p>
<p>本地消息表利用了本地事务来实现分布式事务，并且使用了消息队列来保证最终一致性。</p>
<h3 id="31-优缺点"><a class="markdownIt-Anchor" href="#31-优缺点"></a> 3.1. 优缺点</h3>
<ul>
<li>优点：一种非常经典的实现，避免了分布式事务，实现了最终一致性。</li>
<li>缺点：消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。</li>
</ul>
<h2 id="4-mq-事务消息"><a class="markdownIt-Anchor" href="#4-mq-事务消息"></a> 4. MQ 事务消息</h2>
<p>有一些第三方的 MQ 是支持事务消息的，比如 RocketMQ，他们支持事务消息的方式也是类似于采用的二阶段提交。但是市面上一些主流的 MQ 都是不支持事务消息的，比如 RabbitMQ 和 Kafka 都不支持。</p>
<p>以阿里的 RocketMQ 中间件为例，其思路大致为：</p>
<ol>
<li>Prepared 消息，会拿到消息的地址。</li>
<li>执行本地事务。</li>
<li>通过第一阶段拿到的地址去访问消息，并修改状态。</li>
</ol>
<p>也就是说在业务方法内要想消息队列提交两次请求，一次发送消息和一次确认消息。如果确认消息发送失败了 RocketMQ 会定期扫描消息集群中的事务消息，这时候发现了 Prepared 消息，它会向消息发送者确认，所以生产方需要实现一个 check 接口，RocketMQ 会根据发送端设置的策略来决定是回滚还是继续发送确认消息。这样就保证了消息发送与本地事务同时成功或同时失败。</p>
<h3 id="41-优缺点"><a class="markdownIt-Anchor" href="#41-优缺点"></a> 4.1. 优缺点</h3>
<ul>
<li>优点：实现了最终一致性，不需要依赖本地数据库事务。</li>
<li>缺点：实现难度大，主流 MQ 不支持。</li>
</ul>
<h3 id="42-两阶段提交方案xa-方案"><a class="markdownIt-Anchor" href="#42-两阶段提交方案xa-方案"></a> 4.2. 两阶段提交方案/XA 方案</h3>
<p>所谓的 XA 方案，即：两阶段提交，有一个<strong>事务管理器</strong>的概念，负责协调多个数据库（资源管理器）的事务，事务管理器先问问各个数据库你准备好了吗？如果每个数据库都回复 ok，那么就正式提交事务，在各个数据库上执行操作；如果任何其中一个数据库回答不 ok，那么就回滚事务。</p>
<p>这种分布式事务方案，比较适合单块应用里，跨多个库的分布式事务，而且因为严重依赖于数据库层面来搞定复杂的事务，效率很低，绝对不适合高并发的场景。如果要玩儿，那么基于 <code>Spring + JTA</code> 就可以搞定，自己随便搜个 demo 看看就知道了。</p>
<p>这个方案，我们很少用，一般来说<strong>某个系统内部如果出现跨多个库</strong>的这么一个操作，是<strong>不合规</strong>的。我可以给大家介绍一下， 现在微服务，一个大的系统分成几十个甚至几百个服务。一般来说，我们的规定和规范，是要求<strong>每个服务只能操作自己对应的一个数据库</strong>。</p>
<p>如果你要操作别的服务对应的库，不允许直连别的服务的库，违反微服务架构的规范，你随便交叉胡乱访问，几百个服务的话，全体乱套，这样的一套服务是没法管理的，没法治理的，可能会出现数据被别人改错，自己的库被别人写挂等情况。</p>
<p>如果你要操作别人的服务的库，你必须是通过<strong>调用别的服务的接口</strong>来实现，绝对不允许交叉访问别人的数据库。</p>
<div align="center"><img src="https://github.com/doocs/advanced-java/blob/master/images/distributed-transaction-XA.png"/></div>
<h3 id="43-本地消息表"><a class="markdownIt-Anchor" href="#43-本地消息表"></a> 4.3. 本地消息表</h3>
<p>本地消息表其实是国外的 ebay 搞出来的这么一套思想。</p>
<p>这个大概意思是这样的：</p>
<ol>
<li>A 系统在自己本地一个事务里操作同时，插入一条数据到消息表；</li>
<li>接着 A 系统将这个消息发送到 MQ 中去；</li>
<li>B 系统接收到消息之后，在一个事务里，往自己本地消息表里插入一条数据，同时执行其他的业务操作，如果这个消息已经被处理过了，那么此时这个事务会回滚，这样<strong>保证不会重复处理消息</strong>；</li>
<li>B 系统执行成功之后，就会更新自己本地消息表的状态以及 A 系统消息表的状态；</li>
<li>如果 B 系统处理失败了，那么就不会更新消息表状态，那么此时 A 系统会定时扫描自己的消息表，如果有未处理的消息，会再次发送到 MQ 中去，让 B 再次处理；</li>
<li>这个方案保证了最终一致性，哪怕 B 事务失败了，但是 A 会不断重发消息，直到 B 那边成功为止。</li>
</ol>
<p>这个方案说实话最大的问题就在于<strong>严重依赖于数据库的消息表来管理事务</strong>啥的，如果是高并发场景咋办呢？咋扩展呢？所以一般确实很少用。</p>
<div align="center"><img src="https://github.com/doocs/advanced-java/blob/master/images/distributed-transaction-local-message-table.png"/></div>
<h3 id="44-可靠消息最终一致性方案"><a class="markdownIt-Anchor" href="#44-可靠消息最终一致性方案"></a> 4.4. 可靠消息最终一致性方案</h3>
<p>这个的意思，就是干脆不要用本地的消息表了，直接基于 MQ 来实现事务。比如阿里的 RocketMQ 就支持消息事务。</p>
<p>大概的意思就是：</p>
<ol>
<li>A 系统先发送一个 prepared 消息到 mq，如果这个 prepared 消息发送失败那么就直接取消操作别执行了；</li>
<li>如果这个消息发送成功过了，那么接着执行本地事务，如果成功就告诉 mq 发送确认消息，如果失败就告诉 mq 回滚消息；</li>
<li>如果发送了确认消息，那么此时 B 系统会接收到确认消息，然后执行本地的事务；</li>
<li>mq 会自动<strong>定时轮询</strong>所有 prepared 消息回调你的接口，问你，这个消息是不是本地事务处理失败了，所有没发送确认的消息，是继续重试还是回滚？一般来说这里你就可以查下数据库看之前本地事务是否执行，如果回滚了，那么这里也回滚吧。这个就是避免可能本地事务执行成功了，而确认消息却发送失败了。</li>
<li>这个方案里，要是系统 B 的事务失败了咋办？重试咯，自动不断重试直到成功，如果实在是不行，要么就是针对重要的资金类业务进行回滚，比如 B 系统本地回滚后，想办法通知系统 A 也回滚；或者是发送报警由人工来手工回滚和补偿。</li>
<li>这个还是比较合适的，目前国内互联网公司大都是这么玩儿的，要不你举用 RocketMQ 支持的，要不你就自己基于类似 ActiveMQ？RabbitMQ？自己封装一套类似的逻辑出来，总之思路就是这样子的。</li>
</ol>
<div align="center"><img src="https://github.com/doocs/advanced-java/blob/master/images/distributed-transaction-reliable-message.png"/></div>
<h3 id="45-最大努力通知方案"><a class="markdownIt-Anchor" href="#45-最大努力通知方案"></a> 4.5. 最大努力通知方案</h3>
<p>这个方案的大致意思就是：</p>
<ol>
<li>系统 A 本地事务执行完之后，发送个消息到 MQ；</li>
<li>这里会有个专门消费 MQ 的<strong>最大努力通知服务</strong>，这个服务会消费 MQ 然后写入数据库中记录下来，或者是放入个内存队列也可以，接着调用系统 B 的接口；</li>
<li>要是系统 B 执行成功就 ok 了；要是系统 B 执行失败了，那么最大努力通知服务就定时尝试重新调用系统 B，反复 N 次，最后还是不行就放弃。</li>
</ol>
<h3 id="46-你们公司是如何处理分布式事务的"><a class="markdownIt-Anchor" href="#46-你们公司是如何处理分布式事务的"></a> 4.6. 你们公司是如何处理分布式事务的？</h3>
<p>如果你真的被问到，可以这么说，我们某某特别严格的场景，用的是 TCC 来保证强一致性；然后其他的一些场景基于阿里的 RocketMQ 来实现分布式事务。</p>
<p>你找一个严格资金要求绝对不能错的场景，你可以说你是用的 TCC 方案；如果是一般的分布式事务场景，订单插入之后要调用库存服务更新库存，库存数据没有资金那么的敏感，可以用可靠消息最终一致性方案。</p>
<p>友情提示一下，RocketMQ 3.2.6 之前的版本，是可以按照上面的思路来的，但是之后接口做了一些改变，我这里不再赘述了。</p>
<p>当然如果你愿意，你可以参考可靠消息最终一致性方案来自己实现一套分布式事务，比如基于 RocketMQ 来玩儿。</p>
<h2 id="5-参考资料"><a class="markdownIt-Anchor" href="#5-参考资料"></a> 5. 参考资料</h2>
<ul>
<li><a href="https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html" target="_blank" rel="noopener">聊聊分布式事务，再说说解决方案</a></li>
</ul>
]]></content>
      <categories>
        <category>设计</category>
        <category>系统原理</category>
      </categories>
      <tags>
        <tag>设计</tag>
        <tag>系统原理</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式锁基本原理</title>
    <url>/blog/design/theory/distributed-lock-theory/</url>
    <content><![CDATA[<h1 id="分布式锁基本原理"><a class="markdownIt-Anchor" href="#分布式锁基本原理"></a> 分布式锁基本原理</h1>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#1-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%80%9D%E8%B7%AF">1. 分布式锁思路</a></li>
<li><a href="#2-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">2. 数据库分布式锁</a>
<ul>
<li><a href="#21-%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0">2.1. 具体实现</a></li>
<li><a href="#22-%E9%97%AE%E9%A2%98">2.2. 问题</a></li>
<li><a href="#23-%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95">2.3. 解决办法</a></li>
<li><a href="#24-%E5%B0%8F%E7%BB%93">2.4. 小结</a></li>
</ul>
</li>
<li><a href="#3-redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">3. Redis 分布式锁</a>
<ul>
<li><a href="#31-%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF">3.1. 实现思路</a></li>
<li><a href="#32-%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0">3.2. 具体实现</a></li>
<li><a href="#33-%E5%B0%8F%E7%BB%93">3.3. 小结</a></li>
<li><a href="#34-redlock-%E7%AE%97%E6%B3%95">3.4. RedLock 算法</a></li>
</ul>
</li>
<li><a href="#4-zookeeper-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">4. ZooKeeper 分布式锁</a>
<ul>
<li><a href="#41-%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF">4.1. 实现思路</a></li>
<li><a href="#42-%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0">4.2. 具体实现</a></li>
<li><a href="#43-%E5%B0%8F%E7%BB%93">4.3. 小结</a></li>
</ul>
</li>
<li><a href="#5-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94">5. 分布式锁方案对比</a></li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- /TOC -->
<p>Java 原生 API 虽然有并发锁，但并没有提供分布式锁的能力，所以针对分布式场景中的锁需要解决的方案。</p>
<p>分布式锁的解决方案大致有以下几种：</p>
<ul>
<li>基于数据库实现</li>
<li>基于缓存（redis，memcached 等）实现</li>
<li>基于 Zookeeper 实现 ✅</li>
</ul>
<blockquote>
<p>注：推荐基于 ZooKeeper 实现分布式锁，具体原因看完本文即可明了。</p>
</blockquote>
<h2 id="1-分布式锁思路"><a class="markdownIt-Anchor" href="#1-分布式锁思路"></a> 1. 分布式锁思路</h2>
<p>分布式锁的总体思路大同小异，仅在实现细节上有所不同。</p>
<p>分布式锁的主要思路如下：</p>
<ul>
<li><strong>互斥</strong> - 创建锁必须是唯一的，表现形式为向数据存储服务器或容器插入一个唯一的 key，一旦有一个线程插入这个 key，其他线程就不能再插入了。</li>
<li><strong>避免永远不释放锁</strong> - 数据库分布式锁和缓存分布式锁（Redis）的思路都是引入超时机制，即成功申请锁后，超过一定时间，锁失效（删除 key），原因在于它们无法感知申请锁的客户端节点状态。而 ZooKeeper 由于其 znode 以目录、文件形式组织，天然就存在物理空间隔离，只要 znode 存在，即表示客户端节点还在工作，所以不存在这种问题。</li>
<li><strong>容错</strong>（只要大部分 redis 节点创建了这把锁就可以）</li>
</ul>
<h2 id="2-数据库分布式锁"><a class="markdownIt-Anchor" href="#2-数据库分布式锁"></a> 2. 数据库分布式锁</h2>
<h3 id="21-具体实现"><a class="markdownIt-Anchor" href="#21-具体实现"></a> 2.1. 具体实现</h3>
<p>（1）创建表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`methodLock`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">  <span class="string">`method_name`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'锁定的方法名'</span>,</span><br><span class="line">  <span class="string">`desc`</span> <span class="built_in">varchar</span>(<span class="number">1024</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'备注信息'</span>,</span><br><span class="line">  <span class="string">`update_time`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'保存数据时间，自动生成'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`uidx_method_name`</span> (<span class="string">`method_name `</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'锁定中的方法'</span>;</span><br></pre></td></tr></table></figure>
<p>（2）获取锁</p>
<p>想要锁住某个方法时，执行以下 SQL：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> methodLock(method_name,<span class="keyword">desc</span>) <span class="keyword">values</span> (‘method_name’,‘<span class="keyword">desc</span>’)</span><br></pre></td></tr></table></figure>
<p>因为我们对 <code>method_name</code> 做了唯一性约束，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，可以执行方法体内容。</p>
<p>成功插入则获取锁。</p>
<p>（3）释放锁</p>
<p>当方法执行完毕之后，想要释放锁的话，需要执行以下 Sql:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> methodLock <span class="keyword">where</span> method_name =<span class="string">'method_name'</span></span><br></pre></td></tr></table></figure>
<h3 id="22-问题"><a class="markdownIt-Anchor" href="#22-问题"></a> 2.2. 问题</h3>
<ul>
<li>这把锁强依赖数据库的可用性。如果数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。</li>
<li>这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。</li>
<li>这把锁只能是非阻塞的，因为数据的 insert 操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。</li>
<li>这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。</li>
</ul>
<h3 id="23-解决办法"><a class="markdownIt-Anchor" href="#23-解决办法"></a> 2.3. 解决办法</h3>
<ul>
<li>单点问题可以用多数据库实例，同时塞 N 个表，N/2+1 个成功就任务锁定成功</li>
<li>写一个定时任务，隔一段时间清除一次过期的数据。</li>
<li>写一个 while 循环，不断的重试插入，直到成功。</li>
<li>在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。</li>
</ul>
<h3 id="24-小结"><a class="markdownIt-Anchor" href="#24-小结"></a> 2.4. 小结</h3>
<ul>
<li>优点: 直接借助数据库，容易理解。</li>
<li>缺点: 会有各种各样的问题，在解决问题的过程中会使整个方案变得越来越复杂。操作数据库需要一定的开销，性能问题需要考虑。</li>
</ul>
<h2 id="3-redis-分布式锁"><a class="markdownIt-Anchor" href="#3-redis-分布式锁"></a> 3. Redis 分布式锁</h2>
<p>相比于用数据库来实现分布式锁，基于缓存实现的分布式锁的性能会更好一些。目前有很多成熟的分布式产品，包括 Redis、memcache、Tair 等。这里以 Redis 举例。</p>
<h3 id="31-实现思路"><a class="markdownIt-Anchor" href="#31-实现思路"></a> 3.1. 实现思路</h3>
<p>这个分布式锁有 3 个重要的考量点：</p>
<ol>
<li>互斥（只能有一个客户端获取锁）</li>
<li>不能死锁</li>
<li>容错（只要大部分 redis 节点创建了这把锁就可以）</li>
</ol>
<p>对应的 Redis 指令如下：</p>
<ul>
<li><code>setnx</code> - <code>setnx key val</code>：当且仅当 key 不存在时，set 一个 key 为 val 的字符串，返回 1；若 key 存在，则什么都不做，返回 0。</li>
<li><code>expire</code> - <code>expire key timeout</code>：为 key 设置一个超时时间，单位为 second，超过这个时间锁会自动释放，避免死锁。</li>
<li><code>delete</code> - <code>delete key</code>：删除 key</li>
</ul>
<h3 id="32-具体实现"><a class="markdownIt-Anchor" href="#32-具体实现"></a> 3.2. 具体实现</h3>
<p>（1）申请锁</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> resource_name <span class="comment">my_random_value NX PX 30000</span></span><br></pre></td></tr></table></figure>
<p>执行这个命令就 ok。</p>
<ul>
<li><code>NX</code>：表示只有 <code>key</code> 不存在的时候才会设置成功。（如果此时 redis 中存在这个 key，那么设置失败，返回 <code>nil</code>）</li>
<li><code>PX 30000</code>：意思是 30s 后锁自动释放。别人创建的时候如果发现已经有了就不能加锁了。</li>
</ul>
<p>（2）释放锁</p>
<p>释放锁就是删除 key ，但是一般可以用 <code>lua</code> 脚本删除，判断 value 一样才删除：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">-- 删除锁的时候，找到 key 对应的 value，跟自己传过去的 value 做比较，如果是一样的才删除。</span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">"get"</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] then</span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">"del"</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h3 id="33-小结"><a class="markdownIt-Anchor" href="#33-小结"></a> 3.3. 小结</h3>
<p>为啥要用 <code>random_value</code> 随机值呢？因为如果某个客户端获取到了锁，但是阻塞了很长时间才执行完，比如说超过了 30s，此时可能已经自动释放锁了，此时可能别的客户端已经获取到了这个锁，要是你这个时候直接删除 key 的话会有问题，所以得用随机值加上面的 <code>lua</code> 脚本来释放锁。</p>
<p>但是这样是肯定不行的。因为如果是普通的 redis 单实例，那就是单点故障。或者是 redis 普通主从，那 redis 主从异步复制，如果主节点挂了（key 就没有了），key 还没同步到从节点，此时从节点切换为主节点，别人就可以 set key，从而拿到锁。</p>
<h3 id="34-redlock-算法"><a class="markdownIt-Anchor" href="#34-redlock-算法"></a> 3.4. RedLock 算法</h3>
<p>这个场景是假设有一个 redis cluster，有 5 个 redis master 实例。然后执行如下步骤获取一把锁：</p>
<ol>
<li>获取当前时间戳，单位是毫秒；</li>
<li>跟上面类似，轮流尝试在每个 master 节点上创建锁，过期时间较短，一般就几十毫秒；</li>
<li>尝试在<strong>大多数节点</strong>上建立一个锁，比如 5 个节点就要求是 3 个节点 <code>n / 2 + 1</code>；</li>
<li>客户端计算建立好锁的时间，如果建立锁的时间小于超时时间，就算建立成功了；</li>
<li>要是锁建立失败了，那么就依次之前建立过的锁删除；</li>
<li>只要别人建立了一把分布式锁，你就得<strong>不断轮询去尝试获取锁</strong>。</li>
</ol>
<p><a href="https://redis.io/" target="_blank" rel="noopener">Redis 官方</a>给出了以上两种基于 Redis 实现分布式锁的方法，详细说明可以查看：<a href="https://redis.io/topics/distlock" target="_blank" rel="noopener">https://redis.io/topics/distlock</a> 。</p>
<h2 id="4-zookeeper-分布式锁"><a class="markdownIt-Anchor" href="#4-zookeeper-分布式锁"></a> 4. ZooKeeper 分布式锁</h2>
<h3 id="41-实现思路"><a class="markdownIt-Anchor" href="#41-实现思路"></a> 4.1. 实现思路</h3>
<p>这也是 ZooKeeper 客户端 curator 的分布式锁实现。</p>
<ol>
<li>创建一个目录 mylock；</li>
<li>线程 A 想获取锁就在 mylock 目录下创建临时顺序节点；</li>
<li>获取 mylock 目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；</li>
<li>线程 B 获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；</li>
<li>线程 A 处理完，删除自己的节点，线程 B 监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。</li>
</ol>
<h3 id="42-具体实现"><a class="markdownIt-Anchor" href="#42-具体实现"></a> 4.2. 具体实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ZooKeeperSession</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> bingo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018/11/29</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZooKeeperSession</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch connectedSemaphore = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zookeeper;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZooKeeperSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.zookeeper = <span class="keyword">new</span> ZooKeeper(<span class="string">"192.168.31.187:2181,192.168.31.19:2181,192.168.31.227:2181"</span>, <span class="number">50000</span>, <span class="keyword">new</span> ZooKeeperWatcher());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                connectedSemaphore.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"ZooKeeper session established......"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取分布式锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> productId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">acquireDistributedLock</span><span class="params">(Long productId)</span> </span>&#123;</span><br><span class="line">        String path = <span class="string">"/product-lock-"</span> + productId;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zookeeper.create(path, <span class="string">""</span>.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 相当于是给node注册一个监听器，去看看这个监听器是否存在</span></span><br><span class="line">                    Stat stat = zk.exists(path, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (stat != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">this</span>.latch.await(waitTime, TimeUnit.MILLISECONDS);</span><br><span class="line">                        <span class="keyword">this</span>.latch = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    zookeeper.create(path, <span class="string">""</span>.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ee) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放掉一个分布式锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> productId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseDistributedLock</span><span class="params">(Long productId)</span> </span>&#123;</span><br><span class="line">        String path = <span class="string">"/product-lock-"</span> + productId;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zookeeper.delete(path, -<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">"release the lock for product[id="</span> + productId + <span class="string">"]......"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 建立zk session的watcher</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> bingo</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 2018/11/29</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ZooKeeperWatcher</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Receive watched event: "</span> + event.getState());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (KeeperState.SyncConnected == event.getState()) &#123;</span><br><span class="line">                connectedSemaphore.countDown();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.latch != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 封装单例的静态内部类</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> bingo</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 2018/11/29</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> ZooKeeperSession instance;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> ZooKeeperSession();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ZooKeeperSession <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取单例</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ZooKeeperSession <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Singleton.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化单例的便捷方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以采用另一种方式，创建临时顺序节点：</p>
<p>如果有一把锁，被多个人给竞争，此时多个人会排队，第一个拿到锁的人会执行，然后释放锁；后面的每个人都会去监听<strong>排在自己前面</strong>的那个人创建的 node 上，一旦某个人释放了锁，排在自己后面的人就会被 zookeeper 给通知，一旦被通知了之后，就 ok 了，自己就获取到了锁，就可以执行代码了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZooKeeperDistributedLock</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zk;</span><br><span class="line">    <span class="keyword">private</span> String locksRoot = <span class="string">"/locks"</span>;</span><br><span class="line">    <span class="keyword">private</span> String productId;</span><br><span class="line">    <span class="keyword">private</span> String waitNode;</span><br><span class="line">    <span class="keyword">private</span> String lockNode;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch connectedLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sessionTimeout = <span class="number">30000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZooKeeperDistributedLock</span><span class="params">(String productId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.productId = productId;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String address = <span class="string">"192.168.31.187:2181,192.168.31.19:2181,192.168.31.227:2181"</span>;</span><br><span class="line">            zk = <span class="keyword">new</span> ZooKeeper(address, sessionTimeout, <span class="keyword">this</span>);</span><br><span class="line">            connectedLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LockException(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LockException(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LockException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event.getState() == KeeperState.SyncConnected) &#123;</span><br><span class="line">            connectedLatch.countDown();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.latch != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.latch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireDistributedLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                waitForLock(waitNode, sessionTimeout);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LockException(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LockException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"> 		    <span class="comment">// 传入进去的locksRoot + “/” + productId</span></span><br><span class="line">		    <span class="comment">// 假设productId代表了一个商品id，比如说1</span></span><br><span class="line">		    <span class="comment">// locksRoot = locks</span></span><br><span class="line">		    <span class="comment">// /locks/10000000000，/locks/10000000001，/locks/10000000002</span></span><br><span class="line">            lockNode = zk.create(locksRoot + <span class="string">"/"</span> + productId, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 看看刚创建的节点是不是最小的节点</span></span><br><span class="line">	 	    <span class="comment">// locks：10000000000，10000000001，10000000002</span></span><br><span class="line">            List&lt;String&gt; locks = zk.getChildren(locksRoot, <span class="keyword">false</span>);</span><br><span class="line">            Collections.sort(locks);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(lockNode.equals(locksRoot+<span class="string">"/"</span>+ locks.get(<span class="number">0</span>)))&#123;</span><br><span class="line">                <span class="comment">//如果是最小的节点,则表示取得锁</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果不是最小的节点，找到比自己小1的节点</span></span><br><span class="line">	  <span class="keyword">int</span> previousLockIndex = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; locks.size(); i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(lockNode.equals(locksRoot + “/” + locks.get(i))) &#123;</span><br><span class="line">	         	    previousLockIndex = i - <span class="number">1</span>;</span><br><span class="line">		    <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	   &#125;</span><br><span class="line"></span><br><span class="line">	   <span class="keyword">this</span>.waitNode = locks.get(previousLockIndex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LockException(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LockException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">waitForLock</span><span class="params">(String waitNode, <span class="keyword">long</span> waitTime)</span> <span class="keyword">throws</span> InterruptedException, KeeperException </span>&#123;</span><br><span class="line">        Stat stat = zk.exists(locksRoot + <span class="string">"/"</span> + waitNode, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (stat != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">this</span>.latch.await(waitTime, TimeUnit.MILLISECONDS);</span><br><span class="line">            <span class="keyword">this</span>.latch = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 删除/locks/10000000000节点</span></span><br><span class="line">            <span class="comment">// 删除/locks/10000000001节点</span></span><br><span class="line">            System.out.println(<span class="string">"unlock "</span> + lockNode);</span><br><span class="line">            zk.delete(lockNode, -<span class="number">1</span>);</span><br><span class="line">            lockNode = <span class="keyword">null</span>;</span><br><span class="line">            zk.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LockException</span><span class="params">(String e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LockException</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="43-小结"><a class="markdownIt-Anchor" href="#43-小结"></a> 4.3. 小结</h3>
<p>ZooKeeper 版本的分布式锁问题相对比较来说少。</p>
<ul>
<li>锁的占用时间限制：redis 就有占用时间限制，而 ZooKeeper 则没有，最主要的原因是 redis 目前没有办法知道已经获取锁的客户端的状态，是已经挂了呢还是正在执行耗时较长的业务逻辑。而 ZooKeeper 通过临时节点就能清晰知道，如果临时节点存在说明还在执行业务逻辑，如果临时节点不存在说明已经执行完毕释放锁或者是挂了。由此看来 redis 如果能像 ZooKeeper 一样添加一些与客户端绑定的临时键，也是一大好事。</li>
<li>是否单点故障：redis 本身有很多中玩法，如客户端一致性 hash，服务器端 sentinel 方案或者 cluster 方案，很难做到一种分布式锁方式能应对所有这些方案。而 ZooKeeper 只有一种玩法，多台机器的节点数据是一致的，没有 redis 的那么多的麻烦因素要考虑。</li>
</ul>
<p>总体上来说 ZooKeeper 实现分布式锁更加的简单，可靠性更高。但 ZooKeeper 因为需要频繁的创建和删除节点，性能上不如 Redis 方式。</p>
<h2 id="5-分布式锁方案对比"><a class="markdownIt-Anchor" href="#5-分布式锁方案对比"></a> 5. 分布式锁方案对比</h2>
<ul>
<li>
<p>数据库分布式锁，问题比较多，解决起来比较麻烦，不推荐</p>
</li>
<li>
<p>redis 分布式锁，其实<strong>需要自己不断去尝试获取锁</strong>，比较消耗性能。</p>
</li>
<li>
<p>zk 分布式锁，获取不到锁，注册个监听器即可，不需要不断主动尝试获取锁，性能开销较小。</p>
</li>
</ul>
<p>另外一点就是，如果是 redis 获取锁的那个客户端出现 bug 挂了，那么只能等待超时时间之后才能释放锁；而 zk 的话，因为创建的是临时 znode，只要客户端挂了，znode 就没了，此时就自动释放锁。</p>
<p>总体上来说，ZooKeeper 实现分布式锁更加的简单，可靠性更高。</p>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><a href="https://juejin.im/post/5a20cd8bf265da43163cdd9a" target="_blank" rel="noopener">分布式锁实现汇总</a></li>
</ul>
]]></content>
      <categories>
        <category>设计</category>
        <category>系统原理</category>
      </categories>
      <tags>
        <tag>设计</tag>
        <tag>系统原理</tag>
        <tag>分布式锁</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式会话基本原理</title>
    <url>/blog/design/theory/distributed-session-theory/</url>
    <content><![CDATA[<h1 id="分布式会话基本原理"><a class="markdownIt-Anchor" href="#分布式会话基本原理"></a> 分布式会话基本原理</h1>
<blockquote>
<p>由于 Http 是一种无状态的协议，服务器单单从网络连接上无从知道客户身份。</p>
<p>会话跟踪是 Web 程序中常用的技术，用来跟踪用户的整个会话。常用会话跟踪技术是 Cookie 与 Session。</p>
</blockquote>
<h2 id="1-简介"><a class="markdownIt-Anchor" href="#1-简介"></a> 1. 简介</h2>
<h3 id="11-什么是-cookie"><a class="markdownIt-Anchor" href="#11-什么是-cookie"></a> 1.1. 什么是 Cookie</h3>
<p>Cookie 实际上是存储在用户浏览器上的文本信息，并保留了各种跟踪的信息。</p>
<p>Cookie 工作步骤：</p>
<ol>
<li>客户端请求服务器，如果服务器需要记录该用户的状态，就是用 response 向客户端浏览器颁发一个 Cookie。</li>
<li>客户端浏览器会把 Cookie 保存下来。</li>
<li>当浏览器再请求该网站时，浏览器把该请求的网址连同 Cookie 一同提交给服务器。服务器检查该 Cookie，以此来辨认用户状态。</li>
</ol>
<p>Cookie 主要用于以下三个方面：</p>
<ul>
<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>
</ul>
<p><strong><em>注：Cookie 功能需要浏览器的支持，如果浏览器不支持 Cookie 或者 Cookie 禁用了，Cookie 功能就会失效。</em></strong></p>
<h3 id="12-什么是-session"><a class="markdownIt-Anchor" href="#12-什么是-session"></a> 1.2. 什么是 Session</h3>
<p>Session 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。</p>
<h3 id="13-cookie-和-session-的区别"><a class="markdownIt-Anchor" href="#13-cookie-和-session-的区别"></a> 1.3. Cookie 和 Session 的区别</h3>
<ul>
<li><strong>作用范围不同</strong>，Cookie 保存在客户端（浏览器），Session 保存在服务器端。</li>
<li><strong>存取方式的不同</strong>，Cookie 只能保存 ASCII，Session 可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。</li>
<li><strong>有效期不同</strong>，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。</li>
<li><strong>隐私策略不同</strong>，Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。</li>
<li><strong>存储大小不同</strong>， 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie。</li>
</ul>
<h3 id="14-为什么需要-cookie-和-session他们有什么关联"><a class="markdownIt-Anchor" href="#14-为什么需要-cookie-和-session他们有什么关联"></a> 1.4. 为什么需要 Cookie 和 Session，他们有什么关联？</h3>
<p>说起来为什么需要 Cookie ，这就需要从浏览器开始说起，我们都知道浏览器是没有状态的(HTTP 协议无状态)，这意味着浏览器并不知道是张三还是李四在和服务端打交道。这个时候就需要有一个机制来告诉服务端，本次操作用户是否登录，是哪个用户在执行的操作，那这套机制的实现就需要 Cookie 和 Session 的配合。</p>
<p>那么 Cookie 和 Session 是如何配合的呢？我画了一张图大家可以先了解下。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/5/13/16aafb5d90f398e2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" /></p>
<p>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建创建对应的 Session ，请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器，浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名。</p>
<p>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。</p>
<p>根据以上流程可知，SessionID 是连接 Cookie 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。</p>
<h3 id="15-如果浏览器禁用-cookie-怎么办"><a class="markdownIt-Anchor" href="#15-如果浏览器禁用-cookie-怎么办"></a> 1.5. 如果浏览器禁用 Cookie 怎么办</h3>
<p>既然服务端是根据 Cookie 中的信息判断用户是否登录，那么如果浏览器中禁止了 Cookie，如何保障整个机制的正常运转。</p>
<p>第一种方案，每次请求中都携带一个 SessionID 的参数，也可以 Post 的方式提交，也可以在请求的地址后面拼接 <code>xxx?SessionID=123456...</code>。</p>
<p>第二种方案，Token 机制。Token 机制多用于 App 客户端和服务器交互的模式，也可以用于 Web 端做用户状态管理。</p>
<p>Token 的意思是“令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。Token 机制和 Cookie 和 Session 的使用机制比较类似。</p>
<p>当用户第一次登录后，服务器根据提交的用户信息生成一个 Token，响应时将 Token 返回给客户端，以后客户端只需带上这个 Token 前来请求数据即可，无需再次登录验证。</p>
<h2 id="2-分布式-session"><a class="markdownIt-Anchor" href="#2-分布式-session"></a> 2. 分布式 Session</h2>
<p>在分布式场景下，一个用户的 Session 如果只存储在一个服务器上，那么当负载均衡器把用户的下一个请求转发到另一个服务器上，该服务器没有用户的 Session，就可能导致用户需要重新进行登录等操作。</p>
<p>分布式 Session 的几种实现策略：</p>
<ol>
<li>粘性 session</li>
<li>应用服务器间的 session 复制共享</li>
<li>基于缓存的 session 共享 ✅</li>
</ol>
<blockquote>
<p>推荐：基于缓存的 session 共享</p>
</blockquote>
<h3 id="21-粘性-session"><a class="markdownIt-Anchor" href="#21-粘性-session"></a> 2.1. 粘性 Session</h3>
<blockquote>
<p>粘性 Session（Sticky Sessions）<strong>需要配置负载均衡器，使得一个用户的所有请求都路由到一个服务器节点上</strong>，这样就可以把用户的 Session 存放在该服务器节点中。</p>
<p>缺点：<strong>当服务器节点宕机时，将丢失该服务器节点上的所有 Session</strong>。</p>
</blockquote>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/MultiNode-StickySessions.jpg!zp" />
</div>
<h3 id="22-session-复制共享"><a class="markdownIt-Anchor" href="#22-session-复制共享"></a> 2.2. Session 复制共享</h3>
<blockquote>
<p>Session 复制共享（Session Replication）<strong>在服务器节点之间进行 Session 同步操作</strong>，这样的话用户可以访问任何一个服务器节点。</p>
<p>缺点：<strong>占用过多内存</strong>；<strong>同步过程占用网络带宽以及服务器处理器时间</strong>。</p>
</blockquote>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/MultiNode-SessionReplication.jpg!zp" />
</div>
<h3 id="23-基于缓存的-session-共享"><a class="markdownIt-Anchor" href="#23-基于缓存的-session-共享"></a> 2.3. 基于缓存的 session 共享</h3>
<blockquote>
<p><strong>使用一个单独的存储服务器存储 Session 数据</strong>，可以存在 MySQL 数据库上，也可以存在 Redis 或者 Memcached 这种内存型数据库。</p>
<p>缺点：需要去实现存取 Session 的代码。</p>
</blockquote>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/MultiNode-SpringSession.jpg!zp" />
</div>
<h2 id="3-具体实现"><a class="markdownIt-Anchor" href="#3-具体实现"></a> 3. 具体实现</h2>
<h3 id="31-jwt-token"><a class="markdownIt-Anchor" href="#31-jwt-token"></a> 3.1. JWT Token</h3>
<p>使用 JWT Token 储存用户身份，然后再从数据库或者 cache 中获取其他的信息。这样无论请求分配到哪个服务器都无所谓。</p>
<h3 id="32-tomcat-redis"><a class="markdownIt-Anchor" href="#32-tomcat-redis"></a> 3.2. tomcat + redis</h3>
<p>这个其实还挺方便的，就是使用 session 的代码，跟以前一样，还是基于 tomcat 原生的 session 支持即可，然后就是用一个叫做 <code>Tomcat RedisSessionManager</code> 的东西，让所有我们部署的 tomcat 都将 session 数据存储到 redis 即可。</p>
<p>在 tomcat 的配置文件中配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"com.orangefunction.tomcat.redissessions.RedisSessionHandlerValve"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Manager</span> <span class="attr">className</span>=<span class="string">"com.orangefunction.tomcat.redissessions.RedisSessionManager"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">host</span>=<span class="string">"&#123;redis.host&#125;"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">port</span>=<span class="string">"&#123;redis.port&#125;"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">database</span>=<span class="string">"&#123;redis.dbnum&#125;"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">maxInactiveInterval</span>=<span class="string">"60"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后指定 redis 的 host 和 port 就 ok 了。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"com.orangefunction.tomcat.redissessions.RedisSessionHandlerValve"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Manager</span> <span class="attr">className</span>=<span class="string">"com.orangefunction.tomcat.redissessions.RedisSessionManager"</span></span></span><br><span class="line"><span class="tag">	 <span class="attr">sentinelMaster</span>=<span class="string">"mymaster"</span></span></span><br><span class="line"><span class="tag">	 <span class="attr">sentinels</span>=<span class="string">"&lt;sentinel1-ip&gt;:26379,&lt;sentinel2-ip&gt;:26379,&lt;sentinel3-ip&gt;:26379"</span></span></span><br><span class="line"><span class="tag">	 <span class="attr">maxInactiveInterval</span>=<span class="string">"60"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>还可以用上面这种方式基于 redis 哨兵支持的 redis 高可用集群来保存 session 数据，都是 ok 的。</p>
<h3 id="33-spring-session-redis"><a class="markdownIt-Anchor" href="#33-spring-session-redis"></a> 3.3. spring session + redis</h3>
<p>上面那种 tomcat + redis 的方式好用，但是会<strong>严重依赖于 web 容器</strong>，不好将代码移植到其他 web 容器上去，尤其是你要是换了技术栈咋整？比如换成了 spring cloud 或者是 spring boot 之类的呢？</p>
<p>所以现在比较好的还是基于 Java 一站式解决方案，也就是 spring。人家 spring 基本上承包了大部分我们需要使用的框架，spirng cloud 做微服务，spring boot 做脚手架，所以用 <a href="https://github.com/spring-projects/spring-session" target="_blank" rel="noopener">sping session</a> 是一个很好的选择。</p>
<p>在 pom.xml 中配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 spring 配置文件中配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"redisHttpSessionConfiguration"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">class</span>=<span class="string">"org.springframework.session.data.redis.config.annotation.web.http.RedisHttpSessionConfiguration"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxInactiveIntervalInSeconds"</span> <span class="attr">value</span>=<span class="string">"600"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jedisPoolConfig"</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.JedisPoolConfig"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxTotal"</span> <span class="attr">value</span>=<span class="string">"100"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxIdle"</span> <span class="attr">value</span>=<span class="string">"10"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jedisConnectionFactory"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"org.springframework.data.redis.connection.jedis.JedisConnectionFactory"</span> <span class="attr">destroy-method</span>=<span class="string">"destroy"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hostName"</span> <span class="attr">value</span>=<span class="string">"$&#123;redis_hostname&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"port"</span> <span class="attr">value</span>=<span class="string">"$&#123;redis_port&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;redis_pwd&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"timeout"</span> <span class="attr">value</span>=<span class="string">"3000"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"usePool"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"poolConfig"</span> <span class="attr">ref</span>=<span class="string">"jedisPoolConfig"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 web.xml 中配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>springSessionRepositoryFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>springSessionRepositoryFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/putIntoSession"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">putIntoSession</span><span class="params">(HttpServletRequest request, String username)</span> </span>&#123;</span><br><span class="line">        request.getSession().setAttribute(<span class="string">"name"</span>,  <span class="string">"leo"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"ok"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/getFromSession"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFromSession</span><span class="params">(HttpServletRequest request, Model model)</span></span>&#123;</span><br><span class="line">        String name = request.getSession().getAttribute(<span class="string">"name"</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码就是 ok 的，给 sping session 配置基于 redis 来存储 session 数据，然后配置了一个 spring session 的过滤器，这样的话，session 相关操作都会交给 spring session 来管了。接着在代码中，就用原生的 session 操作，就是直接基于 spring sesion 从 redis 中获取数据了。</p>
<p>实现分布式的会话有很多种方式，我说的只不过是比较常见的几种方式，tomcat + redis 早期比较常用，但是会重耦合到 tomcat 中；近些年，通过 spring session 来实现。</p>
<h2 id="4-参考资料"><a class="markdownIt-Anchor" href="#4-参考资料"></a> 4. 参考资料</h2>
<ul>
<li><a href="https://github.com/L316476844/distributed-session" target="_blank" rel="noopener">集群/分布式环境 Session 的几种策略</a></li>
<li><a href="https://juejin.im/post/5cd9037ee51d456e5c5babca" target="_blank" rel="noopener">你真的了解 Cookie 和 Session 吗</a></li>
<li><a href="https://juejin.im/post/5aede266f265da0ba266e0ef" target="_blank" rel="noopener">聊一聊 session 和 cookie</a></li>
</ul>
]]></content>
      <categories>
        <category>设计</category>
        <category>系统原理</category>
      </categories>
      <tags>
        <tag>设计</tag>
        <tag>系统原理</tag>
        <tag>session</tag>
      </tags>
  </entry>
  <entry>
    <title>网络通信知识点面经</title>
    <url>/blog/communication/network-interview/</url>
    <content><![CDATA[<h1 id="网络通信知识点面经"><a class="markdownIt-Anchor" href="#网络通信知识点面经"></a> 网络通信知识点面经</h1>
<!-- TOC depthFrom:2 depthTo:4 -->
<ul>
<li><a href="#1-%E7%BB%BC%E5%90%88">1. 综合</a>
<ul>
<li><a href="#11-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A6%82%E4%BD%95%E5%88%86%E5%B1%82">1.1. 计算机网络如何分层？</a></li>
</ul>
</li>
<li><a href="#2-http">2. HTTP</a></li>
<li><a href="#3-dns">3. DNS</a></li>
<li><a href="#4-tcpudp">4. TCP/UDP</a>
<ul>
<li><a href="#41-%E4%BB%80%E4%B9%88%E6%98%AF-tcp">4.1. 什么是 TCP？</a></li>
<li><a href="#42-tcp-%E7%9A%84%E7%89%B9%E6%80%A7%E6%98%AF%E4%BB%80%E4%B9%88">4.2. TCP 的特性是什么？</a></li>
<li><a href="#43-tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B">4.3. TCP 三次握手</a></li>
<li><a href="#44-tcp-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B">4.4. TCP 四次挥手</a></li>
<li><a href="#45-tcp-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">4.5. TCP 滑动窗口</a></li>
<li><a href="#46-tcp-%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6">4.6. TCP 重传机制</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h2 id="1-综合"><a class="markdownIt-Anchor" href="#1-综合"></a> 1. 综合</h2>
<h3 id="11-计算机网络如何分层"><a class="markdownIt-Anchor" href="#11-计算机网络如何分层"></a> 1.1. 计算机网络如何分层？</h3>
<blockquote>
<p>❓ 问题：计算机网络如何分层？各层的作用是什么？各层的主要协议、设备分别是什么？</p>
<p>这是学习计算机网络知识宏观层面必须要了解的核心点。知道了这些，对于网络的体系结构就基本上了解了。</p>
</blockquote>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/overview/network-layers.png!zp"/></div>
<p>计算机网络分层一般有三种划分体系：OSI 分层；五层协议分层；TCP/IP 协议分层。</p>
<ul>
<li>OSI 的七层体系结构概念清楚，理论完整，但是比较复杂且不实用，所以并不流行。</li>
<li>五层协议分层是一种折中方案，在现实中更为流行。</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/overview/网络分层架构图.png!zp"/></div>
<p><strong>物理层</strong></p>
<blockquote>
<p>物理层（Physical Layer）只接收和发送一串比特(bit)流，不考虑信息的意义和信息结构。</p>
<p>扩展阅读：<a href="network-physical.md">计算机网络之物理层</a></p>
</blockquote>
<ul>
<li>关键词：调制、解调、数字信号、模拟信号、通信媒介、信道复用</li>
<li>数据单元：比特流。</li>
<li>典型设备：光纤、同轴电缆、双绞线、中继器和集线器。</li>
</ul>
<p><strong>数据链路层</strong></p>
<blockquote>
<p>网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，数据链路层（Data Link Layer）就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。</p>
<p>扩展阅读：<a href="network-data-link.md">计算机网络之数据链路层</a></p>
</blockquote>
<ul>
<li>关键词：点对点信道、广播信道、<code>PPP</code>、<code>CSMA/CD</code>、局域网、以太网、<code>MAC</code>、适配器、集线器、网桥、交换机</li>
<li>主要协议：<code>PPP</code>、<code>CSMA/CD</code> 等。</li>
<li>数据单元：帧（frame）。</li>
<li>典型设备：二层交换机、网桥、网卡。</li>
</ul>
<p><strong>网络层</strong></p>
<blockquote>
<p>网络层（network layer）为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。</p>
<p>扩展阅读：<a href="network-network.md">计算机网络之网络层</a></p>
</blockquote>
<ul>
<li>关键词：<code>IP</code>、<code>ICMP</code>、<code>ARP</code>、路由</li>
<li>主要协议：<code>IP</code>。</li>
<li>数据单元：IP 数据报（packet）。</li>
<li>典型设备：网关、路由器。</li>
</ul>
<p><strong>传输层</strong></p>
<blockquote>
<p>传输层（transport layer）为两台主机中进程间的通信提供通用的数据传输服务。</p>
<p>扩展阅读：<a href="network-network.md">计算机网络之网络层</a></p>
</blockquote>
<ul>
<li>关键词：<code>UDP</code>、<code>TCP</code>、滑动窗口、拥塞控制、三次握手</li>
<li>主要协议：<code>TCP</code>、<code>UDP</code>。</li>
<li>数据单元：报文段（segment）或用户数据报。</li>
</ul>
<p><sub>~**会话层**~</sub></p>
<blockquote>
<p>~~会话层（Session Layer）不参与具体的传输，它提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制。~~</p>
</blockquote>
<p><sub>~**表示层**~</sub></p>
<blockquote>
<p>~~表示层（Presentation Layer）是为在应用过程之间传送的信息提供表示方法的服务，它关心的只是发出信息的语法与语义。表示层要完成某些特定的功能，主要有不同数据编码格式的转换，提供数据压缩、解压缩服务，对数据进行加密、解密。~~</p>
</blockquote>
<p><strong>应用层</strong></p>
<blockquote>
<p>应用层（application layer）通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程间通信和交互的规则。</p>
<p>扩展阅读：<a href="network-application.md">计算机网络之应用层</a></p>
</blockquote>
<ul>
<li>关键词：<code>HTTP</code>、<code>DNS</code>、<code>FTP</code>、<code>TELNET</code>、<code>DHCP</code></li>
<li>主要协议：<code>HTTP</code>、<code>DNS</code>、<code>SMTP</code>、<code>Telnet</code>、<code>FTP</code>、<code>SNMP</code> 等。</li>
<li>数据单元：报文（message）。</li>
</ul>
<h2 id="2-http"><a class="markdownIt-Anchor" href="#2-http"></a> 2. HTTP</h2>
<blockquote>
<p>扩展阅读：<a href="http.md">超文本传输协议 HTTP</a></p>
</blockquote>
<h2 id="3-dns"><a class="markdownIt-Anchor" href="#3-dns"></a> 3. DNS</h2>
<blockquote>
<p>扩展阅读：<a href="dns.md">域名系统 DNS</a></p>
</blockquote>
<h2 id="4-tcpudp"><a class="markdownIt-Anchor" href="#4-tcpudp"></a> 4. TCP/UDP</h2>
<blockquote>
<p>扩展阅读：<a href="tcp.md">传输控制协议 TCP</a>，<a href="udp.md">用户数据报协议 UDP</a></p>
</blockquote>
<h3 id="41-什么是-tcp"><a class="markdownIt-Anchor" href="#41-什么是-tcp"></a> 4.1. 什么是 TCP？</h3>
<p><strong>TCP（Transmission Control Protocol），即传输控制协议，它是一种<code>面向连接的</code>、<code>可靠的</code>、<code>基于字节流的</code>传输层通信协议</strong>。</p>
<h3 id="42-tcp-的特性是什么"><a class="markdownIt-Anchor" href="#42-tcp-的特性是什么"></a> 4.2. TCP 的特性是什么？</h3>
<ul>
<li><code>面向连接的</code> - 面向连接是指 TCP 需要通过三次握手、四次挥手原则建立和断开双向连接。</li>
<li><code>可靠的</code> - 可靠是指 TCP 传输的数据包保证以原始顺序到达目的地，且数据包不被损坏。为了实现这点，TCP 通过以下技术来保证：
<ul>
<li>数据包的序列号和校验码</li>
<li>确认包和自动重传
<ul>
<li>如果发送者没有收到正确的响应，它将重新发送数据包。如果多次超时，连接就会断开。</li>
<li>TCP 实行流量控制和拥塞控制。这些确保措施会导致延迟，而且通常导致传输效率比 UDP 低。</li>
</ul>
</li>
</ul>
</li>
<li><code>基于字节流的</code>
<ul>
<li>虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序看成是一连串的无结构的字节流。TCP 有一个缓冲，当应用程序传送的数据块太长，TCP 就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP 也可以等待积累有足够多的字节后再构成报文段发送出去。</li>
<li>在 TCP 建立连接前两次握手的 SYN 报文中选项字段的 MSS 值，通信双方商定通信的最大报文长度。如果应用层交付下来的数据过大，就会对数据分段，然后发送；否则通过滑动窗口来控制通信双发的数据。</li>
</ul>
</li>
</ul>
<h3 id="43-tcp-三次握手"><a class="markdownIt-Anchor" href="#43-tcp-三次握手"></a> 4.3. TCP 三次握手</h3>
<blockquote>
<p>❓ 问题：三次握手有什么用？什么是三次握手？为什么需要三次握手？</p>
</blockquote>
<p>（1）三次握手有什么用？</p>
<ul>
<li>三次握手负责建立 TCP 双向连接。</li>
</ul>
<p>（2）什么是三次握手？</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/transport/三次握手.gif!zp"/></div>
<p>如上图所示，三次握手流程如下：</p>
<ol>
<li>第一次握手 - 客户端向服务端发送带有 SYN 标志的数据包。</li>
<li>第二次握手 - 服务端向客户端发送带有 SYN/ACK 标志的数据包。</li>
<li>第三次握手 - 客户端向服务端发送带有带有 ACK 标志的数据包。</li>
</ol>
<p>至此，TCP 三次握手完成，客户端与服务端已建立双向连接。</p>
<blockquote>
<p>💡 说明：SYN 为 synchronize 的缩写，ACK 为 acknowledgment 的缩写。</p>
</blockquote>
<p>（3）为什么需要三次握手？</p>
<p>为了便于说明，假设客户端为 A, 服务端为 B。</p>
<ol>
<li>第一次握手，A 向 B 发同步消息。B 收到消息后，B 认为：A 发消息没问题；B 收消息没问题。</li>
<li>第二次握手，B 向 A 发同步消息和确认消息。A 收到消息后，A 认为：A 发消息、收消息都没问题；B 发消息、收消息都没问题。<strong>但是，此时 B 不确定自己发消息是否没问题</strong>，所以就需要第三次握手。</li>
<li>第三次握手，A 向 B 发确认消息。B 收到消息后。B 认为：B 发消息没问题。</li>
</ol>
<h3 id="44-tcp-四次挥手"><a class="markdownIt-Anchor" href="#44-tcp-四次挥手"></a> 4.4. TCP 四次挥手</h3>
<blockquote>
<p>❓ 问题：四次挥手有什么用？什么是四次挥手？为什么建立连接是三次握手，关闭连接确是四次挥手呢？</p>
</blockquote>
<p>（1）四次挥手有什么用？</p>
<ul>
<li>四次挥手负责断开 TCP 连接。</li>
</ul>
<p>（2）什么是四次挥手？</p>
<p>如上图所示，四次挥手流程如下：</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/transport/四次挥手.gif!zp"/></div>
<ol>
<li>第一次挥手 - 客户端向服务端发送一个 FIN 包，用来关闭客户端到服务端的数据传送。</li>
<li>第二次挥手 - 服务端收到这个 FIN 包，向客户端发送一个 ACK 包，确认序号为收到的序号加 1。和 SYN 一样，一个 FIN 将占用一个序号。</li>
<li>第三次挥手 - 服务端关闭与客户端的连接，向客户端发送一个 FIN 包。</li>
<li>第四次挥手 - 客户端向服务端发送 ACK 包，并将确认序号设置为收到序号加 1。</li>
</ol>
<p>（3）为什么建立连接是三次握手，关闭连接确是四次挥手呢？</p>
<ul>
<li>建立连接的时候， 服务器在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。</li>
<li>而关闭连接时，服务器收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接，因此，己方 ACK 和 FIN 一般都会分开发送，从而导致多了一次。</li>
</ul>
<h3 id="45-tcp-滑动窗口"><a class="markdownIt-Anchor" href="#45-tcp-滑动窗口"></a> 4.5. TCP 滑动窗口</h3>
<blockquote>
<p>❓ 问题：什么是滑动窗口？滑动窗口原理是什么？</p>
</blockquote>
<p>什么是滑动窗口？</p>
<p><strong>滑动窗口是 TCP 的一种控制网络流量的技术。</strong></p>
<p><strong>TCP 必需要解决的可靠传输以及包乱序（reordering）的问题</strong>，所以，TCP 必需要知道网络实际的数据处理带宽或是数据处理速度，这样才不会引起网络拥塞，导致丢包。</p>
<p>TCP 头里有一个字段叫 Window，又叫 Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。<strong>于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来</strong>。</p>
<p>滑动窗口原理是什么？</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/snap/1559265819762.png!zp"/></div>
<ol>
<li>已发送已确认 - 数据流中最早的字节已经发送并得到确认。这些数据是站在发送端的角度来看的。上图中的 31 个字节已经发送并确认。</li>
<li>已发送但尚未确认 - 已发送但尚未得到确认的字节。发送方在确认之前，不认为这些数据已经被处理。上图中的 32 ~ 45 字节为第 2 类。</li>
<li>未发送而接收方已 Ready - 设备尚未将数据发出 ，但接收方根据最近一次关于发送方一次要发送多少字节确认自己有足够空间。发送方会立即尝试发送。上图中的 46 ~ 51 字节为第 3 类。</li>
<li>未发送而接收方 Not Ready - 由于接收方 not ready，还不允许将这部分数据发出。上图中的 52 以后的字节为第 4 类。</li>
</ol>
<div align="center"><img src="http://dunwu.test.upcdn.net/snap/1559265927658.png!zp"/></div>
<p>这张图片相对于上一张图片，滑动窗口偏移了 5 个字节，意味着有 5 个已发送的字节得到了确认。</p>
<h3 id="46-tcp-重传机制"><a class="markdownIt-Anchor" href="#46-tcp-重传机制"></a> 4.6. TCP 重传机制</h3>
<blockquote>
<p>❓ 问题：为什么需要重传机制？TCP 有哪些重传机制，原理是什么？</p>
</blockquote>
<p>TCP 要保证所有的数据包都可以到达，所以，必需要有重传机制。</p>
<p>TCP 重传机制主要有两种：</p>
<ul>
<li>超时重传机制</li>
<li>快速重传机制</li>
</ul>
<p>（1）超时重传机制</p>
<p>超时重传机制是指：发送数据包在一定的时间周期内没有收到相应的 ACK，等待一定的时间，超时之后就认为这个数据包丢失，就会重新发送。这个等待时间被称为 RTO(Retransmission TimeOut)，即重传超时时间。</p>
<p>没有确认的数据包不会从窗口中移走，定时器在重传时间到期内，每个片段的位置不变。</p>
<p>这种机制的重点是 RTO 的设置：</p>
<ul>
<li>RTO 设长了，重发就慢，丢了老半天才重发，没有效率，性能差；</li>
<li>RTO 设短了，会导致可能并没有丢就重发。于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发</li>
</ul>
<p>（2）快速重传机制</p>
<p>快速重传机制，实现了另外的一种丢包评定标准，即如果连续收到 3 次重复 ACK，发送方就认为这个 seq 的包丢失了，立刻进行重传。</p>
<p>当接收方收到乱序片段时，需要重复发送 ACK。</p>
]]></content>
      <categories>
        <category>通信</category>
      </categories>
      <tags>
        <tag>通信</tag>
        <tag>网络</tag>
        <tag>application</tag>
      </tags>
  </entry>
  <entry>
    <title>网络协议之 TCP</title>
    <url>/blog/communication/tcp/</url>
    <content><![CDATA[<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<h3 id="什么是-tcp"><a class="markdownIt-Anchor" href="#什么是-tcp"></a> 什么是 TCP</h3>
<p><strong>TCP（Transmission Control Protocol），即传输控制协议，它是一种<code>面向连接的</code>、<code>可靠的</code>、<code>基于字节流的</code>传输层通信协议</strong>。TCP 由 RFC 793 定义。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/snap/1559263786555.png!zp"/></div>
<h3 id="tcp-的特性"><a class="markdownIt-Anchor" href="#tcp-的特性"></a> TCP 的特性</h3>
<ul>
<li><code>面向连接的</code> - 面向连接是指 TCP 需要通过三次握手、四次挥手原则建立和断开双向连接。</li>
<li><code>可靠的</code> - 可靠是指 TCP 传输的数据包保证以原始顺序到达目的地，且数据包不被损坏。为了实现这点，TCP 通过以下技术来保证：
<ul>
<li>数据包的序列号和校验码</li>
<li>确认包和自动重传
<ul>
<li>如果发送者没有收到正确的响应，它将重新发送数据包。如果多次超时，连接就会断开。</li>
<li>TCP 实行流量控制和拥塞控制。这些确保措施会导致延迟，而且通常导致传输效率比 UDP 低。</li>
</ul>
</li>
</ul>
</li>
<li><code>基于字节流的</code>
<ul>
<li>虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序看成是一连串的无结构的字节流。TCP 有一个缓冲，当应用程序传送的数据块太长，TCP 就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP 也可以等待积累有足够多的字节后再构成报文段发送出去。</li>
<li>在 TCP 建立连接前两次握手的 SYN 报文中选项字段的 MSS 值，通信双方商定通信的最大报文长度。如果应用层交付下来的数据过大，就会对数据分段，然后发送；否则通过滑动窗口来控制通信双发的数据。</li>
</ul>
</li>
</ul>
<h3 id="tcp-的适用场景"><a class="markdownIt-Anchor" href="#tcp-的适用场景"></a> TCP 的适用场景</h3>
<p>基于以上特性，为了确保高吞吐量，Web 服务器可以保持大量的 TCP 连接，从而导致高内存使用。但要注意的是，在 Web 服务器线程间拥有大量开放连接可能开销巨大，消耗资源过多，这时可以考虑在适用情况下切换到 UDP。</p>
<p>TCP 对于需要高可靠性但时间紧迫的应用程序很有用。比如包括 Web 服务器，数据库信息，SMTP，FTP 和 SSH。</p>
<p>以下情况使用 TCP 代替 UDP：</p>
<ul>
<li>你需要数据完好无损。</li>
<li>你想对网络吞吐量自动进行最佳评估。</li>
</ul>
<h3 id="tcp-报文"><a class="markdownIt-Anchor" href="#tcp-报文"></a> TCP 报文</h3>
<div align="center"><img src="http://dunwu.test.upcdn.net/snap/1559264511812.png!zp"/></div>
<p>报文字段不一一阐述，重点关注以下几点：</p>
<ul>
<li>TCP 的包是没有 IP 地址的，那是 IP 层上的事。但是有源端口和目标端口。</li>
<li>一个 TCP 连接需要四个元组来表示是同一个连接（src_ip, src_port, dst_ip, dst_port）准确说是五元组，还有一个是协议。但因为这里只是说 TCP 协议，所以，这里我只说四元组。</li>
<li>注意上图中的四个非常重要的东西：
<ul>
<li><strong>Sequence Number</strong>是包的序号，<strong>用来解决网络包乱序（reordering）问题。</strong></li>
<li><strong>Acknowledgement Number</strong>就是 ACK——用于确认收到，<strong>用来解决不丢包的问题</strong>。</li>
<li><strong>Window 又叫 Advertised-Window</strong>，也就是著名的滑动窗口（Sliding Window），<strong>用于解决流控的</strong>。</li>
<li><strong>TCP Flag</strong>，也就是包的类型，<strong>主要是用于操控 TCP 的状态机的</strong>。</li>
</ul>
</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/snap/1559264593860.png!zp"/></div>
<h2 id="tcp-通信流程"><a class="markdownIt-Anchor" href="#tcp-通信流程"></a> TCP 通信流程</h2>
<div align="center"><img src="http://dunwu.test.upcdn.net/snap/1559264679371.png!zp"/></div>
<p>TCP 完整的通信分为三块：</p>
<ol>
<li>三次握手建立连接</li>
<li>数据传输</li>
<li>四次挥手端口连接</li>
</ol>
<h3 id="三次握手"><a class="markdownIt-Anchor" href="#三次握手"></a> 三次握手</h3>
<p>（1）三次握手有什么用？</p>
<ul>
<li>三次握手负责建立 TCP 双向连接。</li>
</ul>
<p>（2）什么是三次握手？</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/transport/三次握手.gif!zp"/></div>
<p>如上图所示，三次握手流程如下：</p>
<ol>
<li>第一次握手 - 客户端向服务端发送带有 SYN 标志的数据包。</li>
<li>第二次握手 - 服务端向客户端发送带有 SYN/ACK 标志的数据包。</li>
<li>第三次握手 - 客户端向服务端发送带有带有 ACK 标志的数据包。</li>
</ol>
<p>至此，TCP 三次握手完成，客户端与服务端已建立双向连接。</p>
<blockquote>
<p>💡 说明：SYN 为 synchronize 的缩写，ACK 为 acknowledgment 的缩写。</p>
</blockquote>
<p>（3）为什么需要三次握手？</p>
<p>为了便于说明，假设客户端为 A, 服务端为 B。</p>
<ol>
<li>第一次握手，A 向 B 发同步消息。B 收到消息后，B 认为：A 发消息没问题；B 收消息没问题。</li>
<li>第二次握手，B 向 A 发同步消息和确认消息。A 收到消息后，A 认为：A 发消息、收消息都没问题；B 发消息、收消息都没问题。<strong>但是，此时 B 不确定自己发消息是否没问题</strong>，所以就需要第三次握手。</li>
<li>第三次握手，A 向 B 发确认消息。B 收到消息后。B 认为：B 发消息没问题。</li>
</ol>
<h3 id="四次挥手"><a class="markdownIt-Anchor" href="#四次挥手"></a> 四次挥手</h3>
<p>（1）四次挥手有什么用？</p>
<ul>
<li>四次挥手负责断开 TCP 连接。</li>
</ul>
<p>（2）什么是四次挥手？</p>
<p>如上图所示，四次挥手流程如下：</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/transport/四次挥手.gif!zp"/></div>
<ol>
<li>第一次挥手 - 客户端向服务端发送一个 FIN 包，用来关闭客户端到服务端的数据传送。</li>
<li>第二次挥手 - 服务端收到这个 FIN 包，向客户端发送一个 ACK 包，确认序号为收到的序号加 1。和 SYN 一样，一个 FIN 将占用一个序号。</li>
<li>第三次挥手 - 服务端关闭与客户端的连接，向客户端发送一个 FIN 包。</li>
<li>第四次挥手 - 客户端向服务端发送 ACK 包，并将确认序号设置为收到序号加 1。</li>
</ol>
<p>（3）为什么建立连接是三次握手，关闭连接确是四次挥手呢？</p>
<ul>
<li>建立连接的时候， 服务器在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。</li>
<li>而关闭连接时，服务器收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接，因此，己方 ACK 和 FIN 一般都会分开发送，从而导致多了一次。</li>
</ul>
<h2 id="滑动窗口"><a class="markdownIt-Anchor" href="#滑动窗口"></a> 滑动窗口</h2>
<p>什么是滑动窗口？</p>
<p><strong>滑动窗口是 TCP 的一种控制网络流量的技术。</strong></p>
<p><strong>TCP 必需要解决的可靠传输以及包乱序（reordering）的问题</strong>，所以，TCP 必需要知道网络实际的数据处理带宽或是数据处理速度，这样才不会引起网络拥塞，导致丢包。</p>
<p>TCP 头里有一个字段叫 Window，又叫 Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。<strong>于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来</strong>。</p>
<p>滑动窗口原理是什么？</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/snap/1559265819762.png!zp"/></div>
<ol>
<li>已发送已确认 - 数据流中最早的字节已经发送并得到确认。这些数据是站在发送端的角度来看的。上图中的 31 个字节已经发送并确认。</li>
<li>已发送但尚未确认 - 已发送但尚未得到确认的字节。发送方在确认之前，不认为这些数据已经被处理。上图中的 32 ~ 45 字节为第 2 类。</li>
<li>未发送而接收方已 Ready - 设备尚未将数据发出 ，但接收方根据最近一次关于发送方一次要发送多少字节确认自己有足够空间。发送方会立即尝试发送。上图中的 46 ~ 51 字节为第 3 类。</li>
<li>未发送而接收方 Not Ready - 由于接收方 not ready，还不允许将这部分数据发出。上图中的 52 以后的字节为第 4 类。</li>
</ol>
<div align="center"><img src="http://dunwu.test.upcdn.net/snap/1559265927658.png!zp"/></div>
<p>这张图片相对于上一张图片，滑动窗口偏移了 5 个字节，意味着有 5 个已发送的字节得到了确认。</p>
<h2 id="tcp-重传机制"><a class="markdownIt-Anchor" href="#tcp-重传机制"></a> TCP 重传机制</h2>
<p>TCP 要保证所有的数据包都可以到达，所以，必需要有重传机制。</p>
<p>TCP 重传机制主要有两种：</p>
<ul>
<li>超时重传机制</li>
<li>快速重传机制</li>
</ul>
<h3 id="超时重传机制"><a class="markdownIt-Anchor" href="#超时重传机制"></a> 超时重传机制</h3>
<p>超时重传机制是指：发送数据包在一定的时间周期内没有收到相应的 ACK，等待一定的时间，超时之后就认为这个数据包丢失，就会重新发送。这个等待时间被称为 RTO(Retransmission TimeOut)，即重传超时时间。</p>
<p>没有确认的数据包不会从窗口中移走，定时器在重传时间到期内，每个片段的位置不变。</p>
<p>这种机制的重点是 RTO 的设置：</p>
<ul>
<li>RTO 设长了，重发就慢，丢了老半天才重发，没有效率，性能差；</li>
<li>RTO 设短了，会导致可能并没有丢就重发。于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发</li>
</ul>
<h3 id="快速重传机制"><a class="markdownIt-Anchor" href="#快速重传机制"></a> 快速重传机制</h3>
<p>快速重传机制，实现了另外的一种丢包评定标准，即如果连续收到 3 次重复 ACK，发送方就认为这个 seq 的包丢失了，立刻进行重传。</p>
<p>当接收方收到乱序片段时，需要重复发送 ACK。</p>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><a href="https://coolshell.cn/articles/11564.html" target="_blank" rel="noopener">TCP 的那些事儿（上）</a></li>
<li><a href="https://coolshell.cn/articles/11609.html" target="_blank" rel="noopener">TCP 的那些事儿（下）</a></li>
<li><a href="https://juejin.im/post/5a7835a46fb9a063606eb801" target="_blank" rel="noopener">图解 TCP 三次握手与四次分手</a></li>
<li><a href="https://blog.csdn.net/qzcsu/article/details/72861891" target="_blank" rel="noopener">TCP 的三次握手与四次挥手（详解+动图）</a></li>
<li><a href="https://blog.csdn.net/sinat_36629696/article/details/80740678" target="_blank" rel="noopener">TCP 详解</a></li>
</ul>
]]></content>
      <categories>
        <category>通信</category>
      </categories>
      <tags>
        <tag>通信</tag>
        <tag>网络</tag>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title>网络协议之 UDP</title>
    <url>/blog/communication/udp/</url>
    <content><![CDATA[<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<div align="center"><img src="http://dunwu.test.upcdn.net/snap/1559263939493.png!zp"/></div>
<p>UDP 是无连接的。数据报（类似于数据包）只在数据报级别有保证。数据报可能会无序的到达目的地，也有可能会遗失。UDP 不支持拥塞控制。虽然不如 TCP 那样有保证，但 UDP 通常效率更高。</p>
<p>UDP 可以通过广播将数据报发送至子网内的所有设备。这对 <a href="https://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol" target="_blank" rel="noopener">DHCP</a> 很有用，因为子网内的设备还没有分配 IP 地址，而 IP 对于 TCP 是必须的。</p>
<p>UDP 可靠性更低但适合用在网络电话、视频聊天，流媒体和实时多人游戏上。</p>
<p>以下情况使用 UDP 代替 TCP：</p>
<ul>
<li>你需要低延迟</li>
<li>相对于数据丢失更糟的是数据延迟</li>
<li>你想实现自己的错误校正方法</li>
</ul>
<h3 id="udp-特点"><a class="markdownIt-Anchor" href="#udp-特点"></a> UDP 特点</h3>
<ol>
<li><strong>无连接的</strong>，即发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延。</li>
<li><strong>不保证可靠交付</strong>，因此主机不需要为此复杂的连接状态表</li>
<li><strong>面向报文的</strong>，意思是 UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界，在添加首部后向下交给 IP 层。</li>
<li><strong>没有阻塞控制</strong>，因此网络出现的拥塞不会使发送方的发送速率降低。</li>
<li><strong>支持一对一、一对多、多对一和多对多的交互通信</strong>，也即是提供广播和多播的功能。</li>
<li><strong>首部开销小</strong>，首部只有 8 个字节，分为四部分。</li>
</ol>
<h3 id="udp-应用场景"><a class="markdownIt-Anchor" href="#udp-应用场景"></a> UDP 应用场景</h3>
<ol>
<li>名字转换（DNS）</li>
<li>文件传送（TFTP）</li>
<li>路由选择协议（RIP）</li>
<li>IP 地址配置（BOOTP，DHTP）</li>
<li>网络管理（SNMP）</li>
<li>远程文件服务（NFS）</li>
<li>IP 电话</li>
<li>流式多媒体通信</li>
</ol>
<h2 id="udp-报文"><a class="markdownIt-Anchor" href="#udp-报文"></a> UDP 报文</h2>
<p>UDP 数据报分为数据字段和首部字段。<br />
首部字段只有 8 个字节，由四个字段组成，每个字段的长度是 2 个字节。</p>
<p><strong>首部各字段意义</strong>：</p>
<ol>
<li><strong>源端口</strong>：源端口号，在需要对方回信时选用，不需要时可全 0.</li>
<li><strong>目的端口</strong>：目的端口号，在终点交付报文时必须要使用到。</li>
<li><strong>长度</strong>：UDP 用户数据报的长度，在只有首部的情况，其最小值是 8 。</li>
<li><strong>检验和</strong>：检测 UDP 用户数据报在传输中是否有错，有错就丢弃。</li>
</ol>
]]></content>
      <categories>
        <category>通信</category>
      </categories>
      <tags>
        <tag>通信</tag>
        <tag>网络</tag>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title>网络协议之 Websocket</title>
    <url>/blog/communication/websocket/</url>
    <content><![CDATA[<h1 id="socket-和-websocket"><a class="markdownIt-Anchor" href="#socket-和-websocket"></a> Socket 和 WebSocket</h1>
<h2 id="socket"><a class="markdownIt-Anchor" href="#socket"></a> Socket</h2>
<p>Socket 作为一种抽象层，应用程序通过它来发送和接收数据，使用 Socket 可以将应用程序与处于同一网络中的其他应用程序进行通信交互。简而言之，Socket 提供了应用程序内部与外界通信的端口以及为通信双方提供了数据传输的通道。</p>
<h3 id="socket-用法"><a class="markdownIt-Anchor" href="#socket-用法"></a> Socket 用法</h3>
<p>很多编程语言都支持 Socket。这里以 Java 的 Socket 用法为例。</p>
<p>在 Java 的 SDK 中，socket 的共有两个接口：用于监听客户连接的 <code>ServerSocket</code> 和用于通信的 <code>Socket</code>。使用 socket 的步骤如下：</p>
<ul>
<li>创建 <code>ServerSocket</code> 并监听客户连接</li>
<li>使用 <code>Socket</code> 连接服务端</li>
<li>通过 <code>Socket</code> 获取输入输出流进行通信</li>
</ul>
<h3 id="socket-长连接"><a class="markdownIt-Anchor" href="#socket-长连接"></a> Socket 长连接</h3>
<p>Socket 长连接，指的是在客户和服务端之间保持一个 socket 连接长时间不断开。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">socket.set<span class="constructor">KeepAlive(<span class="params">true</span>)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="websocket"><a class="markdownIt-Anchor" href="#websocket"></a> WebSocket</h2>
<h3 id="websocket-简介"><a class="markdownIt-Anchor" href="#websocket-简介"></a> WebSocket 简介</h3>
<h4 id="websocket-是什么"><a class="markdownIt-Anchor" href="#websocket-是什么"></a> WebSocket 是什么</h4>
<p><a href="http://websocket.org/" target="_blank" rel="noopener">WebSocket</a> 是一种网络通信协议。<a href="https://tools.ietf.org/html/rfc6455" target="_blank" rel="noopener">RFC6455</a> 定义了它的通信标准。</p>
<p>WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。</p>
<h4 id="为什么需要-websocket"><a class="markdownIt-Anchor" href="#为什么需要-websocket"></a> 为什么需要 WebSocket</h4>
<p>了解计算机网络协议的人，应该都知道：HTTP 协议是一种无状态的、无连接的、单向的应用层协议。它采用了请求/响应模型。通信请求只能由客户端发起，服务端对请求做出应答处理。</p>
<p>这种通信模型有一个弊端：HTTP 协议无法实现服务器主动向客户端发起消息。</p>
<p>这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。大多数 Web 应用程序将通过频繁的异步 JavaScript 和 XML（AJAX）请求实现长轮询。轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/java/spring/web/ajax-long-polling.png!zp"/></div>
因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的。WebSocket 连接允许客户端和服务器之间进行全双工通信，以便任一方都可以通过建立的连接将数据推送到另一端。WebSocket 只需要建立一次连接，就可以一直保持连接状态。这相比于轮询方式的不停建立连接显然效率要大大提高。
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/java/spring/web/websockets-flow.png!zp"/></div>
#### WebSocket 如何工作
<p>Web 浏览器和服务器都必须实现 WebSockets 协议来建立和维护连接。由于 WebSockets 连接长期存在，与典型的 HTTP 连接不同，对服务器有重要的影响。</p>
<p>基于多线程或多进程的服务器无法适用于 WebSockets，因为它旨在打开连接，尽可能快地处理请求，然后关闭连接。任何实际的 WebSockets 服务器端实现都需要一个异步服务器。</p>
<h3 id="websocket-使用"><a class="markdownIt-Anchor" href="#websocket-使用"></a> WebSocket 使用</h3>
<h4 id="websocket-客户端"><a class="markdownIt-Anchor" href="#websocket-客户端"></a> WebSocket 客户端</h4>
<p>在客户端，没有必要为 WebSockets 使用 JavaScript 库。实现 WebSockets 的 Web 浏览器将通过 WebSockets 对象公开所有必需的客户端功能（主要指支持 Html5 的浏览器）。</p>
<p>以下 API 用于创建 WebSocket 对象。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">var Socket = <span class="keyword">new</span> <span class="constructor">WebSocket(<span class="params">url</span>, [<span class="params">protocol</span>] )</span>;</span><br></pre></td></tr></table></figure>
<p>以上代码中的第一个参数 url, 指定连接的 URL。第二个参数 protocol 是可选的，指定了可接受的子协议。</p>
<h5 id="websocket-属性"><a class="markdownIt-Anchor" href="#websocket-属性"></a> WebSocket 属性</h5>
<p>以下是 WebSocket 对象的属性。假定我们使用了以上代码创建了 Socket 对象：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Socket.readyState</td>
<td>只读属性 <strong>readyState</strong> 表示连接状态，可以是以下值：0 - 表示连接尚未建立。1 - 表示连接已建立，可以进行通信。2 - 表示连接正在进行关闭。3 - 表示连接已经关闭或者连接不能打开。</td>
</tr>
<tr>
<td>Socket.bufferedAmount</td>
<td>只读属性 <strong>bufferedAmount</strong> 已被 send() 放入正在队列中等待传输，但是还没有发出的 UTF-8 文本字节数。</td>
</tr>
</tbody>
</table>
<h5 id="websocket-事件"><a class="markdownIt-Anchor" href="#websocket-事件"></a> WebSocket 事件</h5>
<p>以下是 WebSocket 对象的相关事件。假定我们使用了以上代码创建了 Socket 对象：</p>
<table>
<thead>
<tr>
<th>事件</th>
<th>事件处理程序</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>open</td>
<td>Socket.onopen</td>
<td>连接建立时触发</td>
</tr>
<tr>
<td>message</td>
<td>Socket.onmessage</td>
<td>客户端接收服务端数据时触发</td>
</tr>
<tr>
<td>error</td>
<td>Socket.onerror</td>
<td>通信发生错误时触发</td>
</tr>
<tr>
<td>close</td>
<td>Socket.onclose</td>
<td>连接关闭时触发</td>
</tr>
</tbody>
</table>
<h5 id="websocket-方法"><a class="markdownIt-Anchor" href="#websocket-方法"></a> WebSocket 方法</h5>
<p>以下是 WebSocket 对象的相关方法。假定我们使用了以上代码创建了 Socket 对象：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Socket.send()</td>
<td>使用连接发送数据</td>
</tr>
<tr>
<td>Socket.close()</td>
<td>关闭连接</td>
</tr>
</tbody>
</table>
<p>WebSocket 客户端代码示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化一个 WebSocket 对象</span></span><br><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:9998/echo'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立 web socket 连接成功触发事件</span></span><br><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 使用 send() 方法发送数据</span></span><br><span class="line">	ws.send(<span class="string">'发送数据'</span>)</span><br><span class="line">	alert(<span class="string">'数据发送中...'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收服务端数据时触发事件</span></span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> received_msg = evt.data</span><br><span class="line">	alert(<span class="string">'数据已接收...'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 断开 web socket 连接成功触发事件</span></span><br><span class="line">ws.onclose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	alert(<span class="string">'连接已关闭...'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="websocket-服务端"><a class="markdownIt-Anchor" href="#websocket-服务端"></a> WebSocket 服务端</h4>
<p>WebSocket 在服务端的实现非常丰富。Node.js、Java、C++、Python 等多种语言都有自己的解决方案。</p>
<p>以下，介绍我在学习 WebSocket 过程中接触过的 WebSocket 服务端解决方案。</p>
<h5 id="nodejs"><a class="markdownIt-Anchor" href="#nodejs"></a> Node.js</h5>
<p>常用的 Node 实现有以下三种。</p>
<ul>
<li><a href="https://github.com/uWebSockets/uWebSockets" target="_blank" rel="noopener">µWebSockets</a></li>
<li><a href="http://socket.io/" target="_blank" rel="noopener">Socket.IO</a></li>
<li><a href="https://github.com/theturtle32/WebSocket-Node" target="_blank" rel="noopener">WebSocket-Node</a></li>
</ul>
<h5 id="java"><a class="markdownIt-Anchor" href="#java"></a> Java</h5>
<p>Java 的 web 一般都依托于 servlet 容器。</p>
<p>我使用过的 servlet 容器有：Tomcat、Jetty、Resin。其中 Tomcat7、Jetty7 及以上版本均开始支持 WebSocket（推荐较新的版本，因为随着版本的更迭，对 WebSocket 的支持可能有变更）。</p>
<p>此外，Spring 框架对 WebSocket 也提供了支持。</p>
<p>虽然，以上应用对于 WebSocket 都有各自的实现。但是，它们都遵循<a href="https://tools.ietf.org/html/rfc6455" target="_blank" rel="noopener">RFC6455</a> 的通信标准，并且 Java API 统一遵循 <a href="http://www.jcp.org/en/jsr/detail?id=356" target="_blank" rel="noopener">JSR 356 - JavaTM API for WebSocket </a> 规范。所以，在实际编码中，API 差异不大。</p>
<h5 id="spring"><a class="markdownIt-Anchor" href="#spring"></a> Spring</h5>
<p>Spring 对于 WebSocket 的支持基于下面的 jar 包：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 Spring 实现 WebSocket 服务器大概分为以下几步：</p>
<p><strong>创建 WebSocket 处理器</strong></p>
<p>扩展 <code>TextWebSocketHandler</code> 或 <code>BinaryWebSocketHandler</code> ，你可以覆写指定的方法。Spring 在收到 WebSocket 事件时，会自动调用事件对应的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.socket.WebSocketHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.WebSocketSession;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.TextMessage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">TextWebSocketHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleTextMessage</span><span class="params">(WebSocketSession session, TextMessage message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>WebSocketHandler</code> 源码如下，这意味着你的处理器大概可以处理哪些 WebSocket 事件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WebSocketHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 建立连接后触发的回调</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">afterConnectionEstablished</span><span class="params">(WebSocketSession session)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 收到消息时触发的回调</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(WebSocketSession session, WebSocketMessage&lt;?&gt; message)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 传输消息出错时触发的回调</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">handleTransportError</span><span class="params">(WebSocketSession session, Throwable exception)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 断开连接后触发的回调</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">afterConnectionClosed</span><span class="params">(WebSocketSession session, CloseStatus closeStatus)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 是否处理分片消息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">supportsPartialMessages</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>配置 WebSocket</strong></p>
<p>配置有两种方式：注解和 xml 。其作用就是将 WebSocket 处理器添加到注册中心。</p>
<ol>
<li>实现 <code>WebSocketConfigurer</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.EnableWebSocket;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.WebSocketConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocket</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title">WebSocketConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerWebSocketHandlers</span><span class="params">(WebSocketHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addHandler(myHandler(), <span class="string">"/myHandler"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebSocketHandler <span class="title">myHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>xml 方式</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:websocket</span>=<span class="string">"http://www.springframework.org/schema/websocket"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/websocket</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/websocket/spring-websocket.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">websocket:handlers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">websocket:mapping</span> <span class="attr">path</span>=<span class="string">"/myHandler"</span> <span class="attr">handler</span>=<span class="string">"myHandler"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">websocket:handlers</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myHandler"</span> <span class="attr">class</span>=<span class="string">"org.springframework.samples.MyHandler"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>更多配置细节可以参考：<a href="https://docs.spring.io/spring/docs/4.3.12.RELEASE/spring-framework-reference/htmlsingle/#websocket" target="_blank" rel="noopener">Spring WebSocket 文档</a></p>
</blockquote>
<p>javax.websocket</p>
<p>如果不想使用 Spring 框架的 WebSocket API，你也可以选择基本的 javax.websocket。</p>
<p>首先，需要引入 API jar 包。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- To write basic javax.websocket against --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.websocket<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.websocket-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果使用嵌入式 jetty，你还需要引入它的实现包：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- To run javax.websocket in embedded server --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty.websocket<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax-websocket-server-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jetty-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- To run javax.websocket client --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty.websocket<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax-websocket-client-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jetty-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>@ServerEndpoint</strong></p>
<p>这个注解用来标记一个类是 WebSocket 的处理器。</p>
<p>然后，你可以在这个类中使用下面的注解来表明所修饰的方法是触发事件的回调</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 收到消息触发事件</span></span><br><span class="line"><span class="meta">@OnMessage</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String message, Session session)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开连接触发事件</span></span><br><span class="line"><span class="meta">@OnOpen</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpen</span><span class="params">(Session session, EndpointConfig config, @PathParam(<span class="string">"id"</span>)</span> String id) </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭连接触发事件</span></span><br><span class="line"><span class="meta">@OnClose</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">(Session session, CloseReason closeReason)</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传输消息错误触发事件</span></span><br><span class="line"><span class="meta">@OnError</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable error)</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ServerEndpointConfig.Configurator</strong></p>
<p>编写完处理器，你需要扩展 ServerEndpointConfig.Configurator 类完成配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketServerConfigurator</span> <span class="keyword">extends</span> <span class="title">ServerEndpointConfig</span>.<span class="title">Configurator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modifyHandshake</span><span class="params">(ServerEndpointConfig sec, HandshakeRequest request, HandshakeResponse response)</span> </span>&#123;</span><br><span class="line">        HttpSession httpSession = (HttpSession) request.getHttpSession();</span><br><span class="line">        sec.getUserProperties().put(HttpSession<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>(), <span class="title">httpSession</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就没有然后了，就是这么简单。</p>
<h4 id="websocket-代理"><a class="markdownIt-Anchor" href="#websocket-代理"></a> WebSocket 代理</h4>
<p>如果把 WebSocket 的通信看成是电话连接，Nginx 的角色则像是电话接线员，负责将发起电话连接的电话转接到指定的客服。</p>
<p>Nginx 从 <a href="http://nginx.com/blog/websocket-nginx/" target="_blank" rel="noopener">1.3 版</a>开始正式支持 WebSocket 代理。如果你的 web 应用使用了代理服务器 Nginx，那么你还需要为 Nginx 做一些配置，使得它开启 WebSocket 代理功能。</p>
<p>以下为参考配置：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">  <span class="comment"># this section is specific to the WebSockets proxying</span></span><br><span class="line">  <span class="attribute">location</span> /socket.io &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://app_server_wsgiapp/socket.io;</span><br><span class="line">    <span class="attribute">proxy_redirect</span> <span class="literal">off</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> Connection <span class="string">"upgrade"</span>;</span><br><span class="line">    <span class="attribute">proxy_read_timeout</span> <span class="number">600</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>更多配置细节可以参考：<a href="http://nginx.org/en/docs/http/websocket.html" target="_blank" rel="noopener">Nginx 官方的 websocket 文档</a></p>
</blockquote>
<h4 id="websocket-应用示例"><a class="markdownIt-Anchor" href="#websocket-应用示例"></a> WebSocket 应用示例</h4>
<p>如果需要完整示例代码，可以参考我的 Github 代码：</p>
<ul>
<li><a href="https://github.com/dunwu/spring-notes/tree/master/codes/web/websocket" target="_blank" rel="noopener">Spring 对 WebSocket 支持的示例</a></li>
<li><a href="https://github.com/dunwu/javaee-notes/tree/master/codes/websocket" target="_blank" rel="noopener">嵌入式 Jetty 服务器的 WebSocket 示例</a></li>
</ul>
<p>spring-websocket 和 jetty 9.3 版本似乎存在兼容性问题，Tomcat 则木有问题。</p>
<p>我尝试了好几次，没有找到解决方案，只好使用 Jetty 官方的嵌入式示例在 Jetty 中使用 WebSocket 。</p>
<h2 id="faq"><a class="markdownIt-Anchor" href="#faq"></a> FAQ</h2>
<h3 id="http-vs-socket"><a class="markdownIt-Anchor" href="#http-vs-socket"></a> Http vs. Socket</h3>
<p>Http 通信与 Socket 通信方式有何差异？</p>
<ul>
<li>Http
<ul>
<li>基于请求/响应模式，采取一问一答方式（客户端请求，服务端才会响应）</li>
</ul>
</li>
<li>Socket
<ul>
<li>客户端和服务端建立双向连接。连接成功后，任意一方都可主动发送消息。</li>
<li>数据丢失率低，使用简单，易于移植。</li>
</ul>
</li>
</ul>
<h3 id="http-和-websocket-有什么关系"><a class="markdownIt-Anchor" href="#http-和-websocket-有什么关系"></a> HTTP 和 WebSocket 有什么关系？</h3>
<p>Websocket 其实是一个新协议，跟 HTTP 协议基本没有关系，只是为了兼容现有浏览器的握手规范而已，也就是说它是 HTTP 协议上的一种补充。</p>
<h3 id="html-和-http-有什么关系"><a class="markdownIt-Anchor" href="#html-和-http-有什么关系"></a> Html 和 HTTP 有什么关系？</h3>
<p>Html 是超文本标记语言，是一种用于创建网页的标准标记语言。它是一种技术标准。Html5 是它的最新版本。</p>
<p>Http 是一种网络通信协议。其本身和 Html 没有直接关系。</p>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><a href="https://www.zhihu.com/question/20215561" target="_blank" rel="noopener">知乎高票答案——WebSocket 是什么原理</a> - 对 WebSocket 原理的阐述简单易懂。</li>
<li><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" rel="noopener">WebSocket 教程</a> - 阮一峰大神的科普一如既往的浅显易懂。</li>
<li><a href="https://www.fullstackpython.com/websockets.html" target="_blank" rel="noopener">WebSockets</a> - by <em>fullstackpython</em></li>
<li><a href="http://nginx.org/en/docs/http/websocket.html" target="_blank" rel="noopener">Nginx 官方的 websocket 文档</a></li>
<li><a href="https://docs.spring.io/spring/docs/4.3.12.RELEASE/spring-framework-reference/htmlsingle/#websocket" target="_blank" rel="noopener">Spring WebSocket 文档</a></li>
<li><a href="http://tomcat.apache.org/tomcat-7.0-doc/web-socket-howto.html" target="_blank" rel="noopener">Tomcat7 WebSocket 文档</a></li>
<li><a href="https://www.eclipse.org/jetty/documentation/9.4.7.v20170914/websocket-intro.html" target="_blank" rel="noopener">Jetty WebSocket 文档</a></li>
<li><a href="https://juejin.im/post/57f885370bd1d00058b37d74" target="_blank" rel="noopener">Socket，你需要知道的事儿</a></li>
<li><a href="https://juejin.im/post/5b3649d751882552f052703b" target="_blank" rel="noopener">手把手教你写 Socket 长连接</a></li>
</ul>
]]></content>
      <categories>
        <category>通信</category>
      </categories>
      <tags>
        <tag>通信</tag>
        <tag>网络</tag>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title>网络通信之 CDN</title>
    <url>/blog/communication/cdn/</url>
    <content><![CDATA[<div align="center"><img src="http://dunwu.test.upcdn.net/snap/1559138689425.png!zp"/></div>
<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<h3 id="cdn-是什么"><a class="markdownIt-Anchor" href="#cdn-是什么"></a> CDN 是什么</h3>
<p>CDN(<strong>Content Delivery Network</strong>)，即<strong>内容分发网络</strong>。</p>
<p>CDN 是一个全球性的代理服务器分布式网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。它从靠近用户的位置提供内容。通常，HTML/CSS/JS，图片和视频等静态内容由 CDN 提供。CDN 的 DNS 解析会告知客户端连接哪台服务器。CDN 的关键技术主要有内容存储和分发技术。</p>
<h3 id="cdn-的优缺点"><a class="markdownIt-Anchor" href="#cdn-的优缺点"></a> CDN 的优缺点</h3>
<ul>
<li>优点
<ul>
<li><strong>访问加速</strong> - 由于 CDN 就近服务，大大降低了网络传播时延，所以自然提高了访问速度。</li>
<li><strong>降低负载</strong> - 如果 CDN 已经能获取数据，那么就不必请求源站，这自然降低了源站（服务器）的负载。</li>
</ul>
</li>
<li>缺点
<ul>
<li>CDN 成本可能因流量而异，可能在权衡之后你将不会使用 CDN。</li>
<li>如果在 TTL 过期之前更新内容，CDN 缓存内容可能会过时。</li>
<li>CDN 需要更改静态内容的 URL 地址以指向 CDN。</li>
</ul>
</li>
</ul>
<h2 id="cdn-原理"><a class="markdownIt-Anchor" href="#cdn-原理"></a> CDN 原理</h2>
<p>CDN 的基本原理是：</p>
<ul>
<li>广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中；</li>
<li>在用户访问网站时，实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息来选择最佳缓存服务器；</li>
<li>然后，将用户的请求重新导向最佳的缓存服务器上，由缓存服务器直接响应用户请求。</li>
</ul>
<p>CDN 网络架构主要由两大部分，分为<strong>中心</strong>和<strong>边缘</strong>两部分：</p>
<ul>
<li>中心指 CDN 网管中心和 DNS 重定向解析中心，负责全局负载均衡，设备系统安装在管理中心机房；</li>
<li>边缘主要指异地节点，CDN 分发的载体，主要由 Cache 和负载均衡器等组成。</li>
</ul>
<p>CDN 是一个策略性部署的整体系统，包括<strong>分布式存储</strong>、<strong>负载均衡</strong>、<strong>内容管理</strong>和<strong>网络请求的重定向</strong>４个要件。</p>
<h3 id="分布式存储"><a class="markdownIt-Anchor" href="#分布式存储"></a> 分布式存储</h3>
<p>CDN 网络将存储资源分布到各个地理位置、各个网段。存储系统作为 CDN 系统密不可分的一部分，将 CDN 分发的文件和数据库表记录内容存储起来，提供持续服务。存储系统采用三级存储架构，包括核心存储、CDN 服务节点分布式缓存和终端本地缓存。任意一个点的存储崩溃或失效，并不影响系统服务的可用性。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/snap/1559140068433.png!zp"/></div>
<p>如 CDN 系统在 5 大运营商（中国电信、中国网通、中国铁通、中国移动、中国联通）以及 2 大专有网络（中国教育和科研计算机网、中国科技网）都布有 CDN 节点。<strong>这样就消除了不同运营商之间互联的瓶颈造成的影响，实现了跨运营商的网络加速，保证不同网络中的用户都能得到良好的访问质量。</strong></p>
<h3 id="内容管理"><a class="markdownIt-Anchor" href="#内容管理"></a> 内容管理</h3>
<p>内容管理和全局的网络流量管理(Traffic Management)是 CDN 的核心所在。<strong>通过用户就近性和服务器负载的判断，CDN 确保内容以一种极为高效的方式为用户的请求提供服务</strong>。总的来说，内容服务基于<strong>缓存服务器</strong>，也称作<strong>代理缓存(Surrogate)</strong>，它位于网络的边缘，距用户仅有&quot;一跳&quot;(Single Hop)之遥。同时，代理缓存是内容提供商源服务器（通常位于 CDN 服务提供商的数据中心）的一个透明镜像。这样的架构使得 CDN 服务提供商能够代表他们客户，即内容供应商，向最终用户提供尽可能好的体验，而这些用户是不能容忍请求响应时间有任何延迟的。据统计，采用 CDN 技术，能处理整个网站页面的 70%～ 95％的内容访问量，减轻服务器的压力，提升了网站的性能和可扩展性。</p>
<h3 id="负载均衡"><a class="markdownIt-Anchor" href="#负载均衡"></a> 负载均衡</h3>
<p>CDN 负载均衡系统实现 CDN 的<strong>内容路由功能</strong>。它的作用是将用户的请求导向整个 CDN 网络中的最佳节点。最佳节点的选定可以根据多种策略，例如<strong>距离最近</strong>、<strong>节点负载最轻</strong>等。负载均衡系统是整个 CDN 的核心，负载均衡的准确性和效率直接决定了整个 CDN 的效率和性能。通常负载均衡可以分为两个层次：<strong>全局负载均衡（GSLB）<strong>和</strong>本地负载均衡（SLB）</strong>。</p>
<h3 id="网络请求的重定向"><a class="markdownIt-Anchor" href="#网络请求的重定向"></a> 网络请求的重定向</h3>
<p>当用户访问了使用 CDN 服务的资源时，DNS 域名服务器通过 CNAME 方式将最终域名请求重定向到 CDN 系统中的智能 DNS 负载均衡系统。<strong>智能 DNS 负载均衡系统通过一组预先定义好的策略（如内容类型、地理区域、网络负载状况等），将当时能够最快响应用户的节点地址提供给用户，使用户可以得到快速的服务</strong>。</p>
<p>同时，它还与分布在不同地点的所有 CDN 节点保持通信，搜集各节点的健康状态，确保不将用户的请求分配到任何一个已经不可用的节点上。</p>
<blockquote>
<p>参考：</p>
<ul>
<li><a href="https://www.cnblogs.com/skynet/archive/2012/12/18/2824141.html" target="_blank" rel="noopener">CDN-内容推送网络</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/39028766" target="_blank" rel="noopener">闲话 CDN</a></li>
</ul>
</blockquote>
<h2 id="cdn-访问流程"><a class="markdownIt-Anchor" href="#cdn-访问流程"></a> CDN 访问流程</h2>
<div align="center"><img src="http://dunwu.test.upcdn.net/snap/1559126750010.png!zp"/></div>
<ol>
<li>用户在浏览器中访问域名，域名解析的请求被发往网站的 DNS 域名解析服务器；</li>
<li>由于网站的 DNS 域名解析服务器对此域名的解析设置了 CNAME，请求被指向 CDN 网络中的智能 DNS 负载均衡系统；</li>
<li>智能 DNS 负载均衡系统对域名进行智能解析，将响应速度最快的节点 IP 返回给用户；浏览器在得到速度最快节点的 IP 地址以后，向 CDN 节点发出访问请求；</li>
<li>由于是第一次访问，CDN 节点将回到源站取用户请求的数据并发给用户；</li>
<li>当有其他用户再次访问同样内容时，CDN 将直接将数据返回给客户，完成请求/服务过程。</li>
</ol>
<p>同时，它还与分布在不同地点的所有 CDN 节点保持通信，搜集各节点的健康状态，确保不将用户的请求分配到任何一个已经不可用的节点上。</p>
<blockquote>
<p>参考：</p>
<ul>
<li><a href="https://www.cnblogs.com/skynet/archive/2012/12/18/2824141.html" target="_blank" rel="noopener">CDN-内容推送网络</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/39028766" target="_blank" rel="noopener">闲话 CDN</a></li>
</ul>
</blockquote>
<h2 id="推送和拉取"><a class="markdownIt-Anchor" href="#推送和拉取"></a> 推送和拉取</h2>
<p>CDN 服务有推送和拉取两种方式：</p>
<h3 id="cdn-推送"><a class="markdownIt-Anchor" href="#cdn-推送"></a> CDN 推送</h3>
<p>当你服务器上内容发生变动时，推送 CDN 接受新内容。直接推送给 CDN 并重写 URL 地址以指向你的内容的 CDN 地址。你可以配置内容到期时间及何时更新。内容只有在更改或新增是才推送，流量最小化，但储存最大化。</p>
<p>优点在于节省源站带宽，提前将要分发的内容放到 CDN 节点上了，当某个流量高峰来临时，不会把你的源站带宽占满（源站还要留点带宽提供动态 HTML 啊）。</p>
<p>缺点是需要针对 CDN 做接口开发，在被分发内容生成时主动上传给 CDN。</p>
<h3 id="cdn-拉取"><a class="markdownIt-Anchor" href="#cdn-拉取"></a> CDN 拉取</h3>
<p>CDN 拉取是当第一个用户请求该资源时，从服务器上拉取资源。你将内容留在自己的服务器上并重写 URL 指向 CDN 地址。直到内容被缓存在 CDN 上为止，这样请求只会更慢，</p>
<p><a href="https://en.wikipedia.org/wiki/Time_to_live" target="_blank" rel="noopener">存活时间（TTL）</a>决定缓存多久时间。CDN 拉取方式最小化 CDN 上的储存空间，但如果过期文件并在实际更改之前被拉取，则会导致冗余的流量。</p>
<p>高流量站点使用 CDN 拉取效果不错，因为只有最近请求的内容保存在 CDN 中，流量才能更平衡地分散。</p>
<p>优点在于实现简单。</p>
<blockquote>
<p>参考：<a href="https://segmentfault.com/q/1010000000119794" target="_blank" rel="noopener">推送式与拉取式 CDN 服务的优劣问题</a></p>
</blockquote>
<h2 id="资源"><a class="markdownIt-Anchor" href="#资源"></a> 资源</h2>
<ul>
<li>文章
<ul>
<li><a href="https://en.wikipedia.org/wiki/Content_delivery_network" target="_blank" rel="noopener">Wikipedia - CDN</a></li>
<li><a href="https://www.cnblogs.com/skynet/archive/2012/12/18/2824141.html" target="_blank" rel="noopener">CDN-内容推送网络</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/39028766" target="_blank" rel="noopener">闲话 CDN</a></li>
<li><a href="https://www.cnblogs.com/losbyday/p/5843960.html" target="_blank" rel="noopener">CDN 技术详解</a></li>
<li><a href="https://segmentfault.com/q/1010000000119794" target="_blank" rel="noopener">推送式与拉取式 CDN 服务的优劣问题</a></li>
</ul>
</li>
<li>CDN 资源
<ul>
<li><a href="https://staticfile.org/" target="_blank" rel="noopener">https://staticfile.org/</a></li>
<li><a href="https://unpkg.com/" target="_blank" rel="noopener">https://unpkg.com/</a></li>
<li><a href="https://cdnjs.com/" target="_blank" rel="noopener">https://cdnjs.com/</a></li>
<li><a href="https://github.com/ossrs/srs" target="_blank" rel="noopener">https://github.com/ossrs/srs</a></li>
<li><a href="https://github.com/jsdelivr/jsdelivr" target="_blank" rel="noopener">https://github.com/jsdelivr/jsdelivr</a></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>通信</category>
      </categories>
      <tags>
        <tag>通信</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 常用技巧总结</title>
    <url>/blog/os/windows/</url>
    <content><![CDATA[<h1 id="windows-常用技巧总结"><a class="markdownIt-Anchor" href="#windows-常用技巧总结"></a> Windows 常用技巧总结</h1>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#%E8%BD%AF%E4%BB%B6">软件</a>
<ul>
<li><a href="#%E8%A7%86%E9%A2%91%E9%9F%B3%E9%A2%91">视频音频</a></li>
<li><a href="#%E5%8E%8B%E7%BC%A9">压缩</a></li>
<li><a href="#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86">文件管理</a></li>
<li><a href="#%E5%BC%80%E5%8F%91">开发</a></li>
<li><a href="#%E7%BC%96%E8%BE%91%E5%99%A8">编辑器</a></li>
<li><a href="#%E6%96%87%E6%A1%A3">文档</a></li>
<li><a href="#%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87">效率提升</a></li>
<li><a href="#%E5%8A%9E%E5%85%AC">办公</a></li>
<li><a href="#%E4%B8%AA%E6%80%A7%E5%8C%96">个性化</a></li>
</ul>
</li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="软件"><a class="markdownIt-Anchor" href="#软件"></a> 软件</h2>
<blockquote>
<p>扩展阅读：</p>
<ul>
<li><a href="https://github.com/Awesome-Windows/Awesome/blob/master/README-cn.md" target="_blank" rel="noopener">Awesome Windows</a></li>
<li><a href="https://github.com/stackia/best-windows-apps" target="_blank" rel="noopener">best-windows-apps</a></li>
</ul>
</blockquote>
<h3 id="视频音频"><a class="markdownIt-Anchor" href="#视频音频"></a> 视频音频</h3>
<ul>
<li><a href="http://getmusicbee.com/" target="_blank" rel="noopener">Musicbee</a> - 类似 iTunes，但比 iTunes 更好用。</li>
<li><a href="http://www.screentogif.com/" target="_blank" rel="noopener">ScreenToGif</a> - 它允许你录制屏幕的一部分区域并保存为 gif 或视频。</li>
<li><a href="http://potplayer.daum.net/" target="_blank" rel="noopener">PotPlayer</a> - 多媒体播放器，具有广泛的编解码器集合，它还为用户提供大量配置选项。</li>
<li><a href="http://www.splayer.org/" target="_blank" rel="noopener">射手影音播放器</a> - 来自射手网，小巧开源，首创自动匹配字幕功能。</li>
</ul>
<h3 id="压缩"><a class="markdownIt-Anchor" href="#压缩"></a> 压缩</h3>
<ul>
<li><a href="http://www.7-zip.org/" target="_blank" rel="noopener">7-Zip</a> - 用于处理压缩包的开源 Windows 实用程序。完美支持 7z，ZIP，GZIP，BZIP2 和 TAR 的全部特性，其他格式也可解压缩。</li>
<li><a href="http://www.rarlab.com/" target="_blank" rel="noopener">WinRAR</a> - 强大的归档管理器。 它可以备份您的数据并减小电子邮件附件的大小，解压缩 RAR，ZIP 和其他文件。</li>
</ul>
<h3 id="文件管理"><a class="markdownIt-Anchor" href="#文件管理"></a> 文件管理</h3>
<ul>
<li><a href="http://en.ejie.me/" target="_blank" rel="noopener">Clover</a> - 为资源管理器加上多标签功能。</li>
<li><a href="http://www.ghisler.com/" target="_blank" rel="noopener">Total Commander</a> - 老牌、功能异常强大的文件管理增强软件。</li>
<li><a href="http://www.softwareok.com/?seite=Freeware/Q-Dir" target="_blank" rel="noopener">Q-Dir</a> - 轻量级的文件管理器，各种布局视图切换灵活，默认四个小窗口组成一个大窗口，操作快捷。软件虽小，粉丝忠诚。</li>
<li><a href="https://github.com/Wox-launcher/Wox" target="_blank" rel="noopener">WoX</a> - 新一代文件定位工具，堪称 Windows 上的 Alfred。</li>
<li><a href="http://www.voidtools.com/" target="_blank" rel="noopener">Everything</a> - 最快的文件/文件夹搜索工具， 通过名称搜索。</li>
<li><a href="http://www.listary.com/" target="_blank" rel="noopener">Listary</a> - 非常优秀的 Windows 文件浏览和搜索增强工具。</li>
<li>Beyond Compare - 好用又万能的文件对比工具。</li>
<li><a href="https://www.piriform.com/ccleaner/download" target="_blank" rel="noopener">CCleaner</a> - 如果你有系统洁癖，那一定要选择一款干净、良心、老牌的清洁软件。</li>
<li><a href="https://chocolatey.org/" target="_blank" rel="noopener">chocolatey</a> - 包管理器</li>
<li><a href="https://ninite.com/" target="_blank" rel="noopener">Ninite</a> - 最简单，最快速的更新或安装软件的方式。</li>
<li><a href="http://www.piriform.com/RECUVA" target="_blank" rel="noopener">Recuva</a> - 来自 piriform 梨子公司产品，免费的数据恢复工具。</li>
<li><a href="http://www.launchy.net/" target="_blank" rel="noopener">Launchy</a>：自由的跨平台工具，帮助你忘记开始菜单、桌面图标甚至文件管理器。</li>
</ul>
<h3 id="开发"><a class="markdownIt-Anchor" href="#开发"></a> 开发</h3>
<ul>
<li><a href="http://www.telerik.com/fiddler" target="_blank" rel="noopener">Fiddler</a> - web 调试代理工具。</li>
<li><a href="https://www.getpostman.com/postman" target="_blank" rel="noopener">Postman</a> - 适合 API 开发的完整工具链，最常用的 REST 客户端。</li>
<li><a href="https://www.sourcetreeapp.com/" target="_blank" rel="noopener">SourceTree</a> - 一个免费的 Git &amp; Mercurial 客户端。</li>
<li><a href="https://tortoisesvn.net/" target="_blank" rel="noopener">TortoiseSVN</a> - Subversion(SVN)的图形客户端</li>
<li><a href="https://www.wireshark.org/" target="_blank" rel="noopener">Wireshark</a> - 一个网络协议分析工具。</li>
<li>Switchhosts</li>
<li><a href="https://github.com/cmderdev/cmder" target="_blank" rel="noopener">Cmder</a> - 控制台模拟器包。扩展阅读：<a href="https://www.jeffjade.com/2016/01/13/2016-01-13-windows-software-cmder/" target="_blank" rel="noopener">Win 下必备神器之 Cmder</a></li>
<li><a href="http://babun.github.io/" target="_blank" rel="noopener">Babun</a> - 基于 Cygwin，用于替代 Windows shell。</li>
</ul>
<h3 id="编辑器"><a class="markdownIt-Anchor" href="#编辑器"></a> 编辑器</h3>
<ul>
<li><a href="http://www.jetbrains.com/" target="_blank" rel="noopener">JetBrain IDE 系列</a> - 真香！</li>
<li><a href="https://code.visualstudio.com/" target="_blank" rel="noopener">Visual Studio Code</a> - 用于构建和调试现代 Web 和云应用程序。</li>
<li><a href="https://eclipse.org/downloads/" target="_blank" rel="noopener">Eclipse</a> - 一款功能强大的 IDE。</li>
<li><a href="https://www.visualstudio.com/vs/" target="_blank" rel="noopener">Visual Studio</a> - 微软官方的 IDE，通过插件可支持大量编程语言。</li>
<li><a href="https://netbeans.org/" target="_blank" rel="noopener">NetBeans IDE</a> - 免费开源的 IDE。</li>
<li><a href="https://www.typora.io/" target="_blank" rel="noopener">Typora</a> - 个人觉得最好用的 Markdown 编辑器。</li>
<li><a href="https://www.zybuluo.com/cmd/" target="_blank" rel="noopener">Cmd Markdown</a> - 跨平台优秀 Markdown 编辑器，本文即用其所写。</li>
<li><a href="https://notepad-plus-plus.org/" target="_blank" rel="noopener">Notepad++</a> - 一款支持多种编程语言的源码编辑器。</li>
<li><a href="http://www.flos-freeware.ch/notepad2.html" target="_blank" rel="noopener">Notepad2</a> - 用于替代默认文本编辑器的轻量快速的编辑器，拥有众多有用的功能。</li>
<li><a href="http://www.sublimetext.com/3" target="_blank" rel="noopener">Sublime Text 3</a> - 高级文本编辑器。</li>
<li><a href="https://atom.io/" target="_blank" rel="noopener">Atom</a> - 面向 21 世纪的极客文本编辑器。</li>
</ul>
<h3 id="文档"><a class="markdownIt-Anchor" href="#文档"></a> 文档</h3>
<ul>
<li><a href="http://www.office.com/" target="_blank" rel="noopener">Microsoft Office</a> - 微软办公软件。</li>
<li><a href="https://www.wps.com/office-free" target="_blank" rel="noopener">WPS Office</a> - 金山免费办公软件。</li>
<li><a href="http://calibre-ebook.com/" target="_blank" rel="noopener">Calibre</a> - 用于电子书管理和转换的强大软件。</li>
<li><a href="http://www.foxitsoftware.cn/products/reader/" target="_blank" rel="noopener">福昕阅读器</a> - 在全球拥有大量用户，最优秀的国产软件之一。Ribbon 界面，支持手写签名、插入印章等。</li>
</ul>
<h3 id="效率提升"><a class="markdownIt-Anchor" href="#效率提升"></a> 效率提升</h3>
<p><strong>【笔记】</strong></p>
<ul>
<li><a href="http://www.xmind.net/" target="_blank" rel="noopener">XMind</a> - 优秀的思维导图。</li>
<li><a href="https://www.onenote.com/" target="_blank" rel="noopener">OneNote</a> - Windows 下综合评价非常高的笔记应用。</li>
<li><a href="http://www.yinxiang.com/" target="_blank" rel="noopener">印象笔记</a> - 老牌跨平台笔记工具，国际版 Evernote。一家立志于做百年公司的企业，安全、可靠。</li>
<li><a href="http://www.wiz.cn/index.html" target="_blank" rel="noopener">为知笔记</a> - 越来越好的笔记应用，记录、查阅一切有价值的信息，同样跨平台支持。</li>
<li><a href="http://note.youdao.com/" target="_blank" rel="noopener">有道云笔记</a> - 网易旗下笔记工具，同样跨主流平台支持，文字、手写、录音、拍照多种记录方式，支持任意附件格式。</li>
<li><a href="https://getsharex.com/" target="_blank" rel="noopener">ShareX</a> - 你要的所有与截图、录屏相关的功能，这里都有了。</li>
</ul>
<p>【快捷键】</p>
<ul>
<li><a href="https://autohotkey.com/" target="_blank" rel="noopener">AutoHotkey</a> - Windows 平台的终极自动化脚本语言。</li>
</ul>
<blockquote>
<p>技巧：</p>
<ul>
<li><a href="https://www.jeffjade.com/2016/03/11/2016-03-11-autohotkey/" target="_blank" rel="noopener">https://www.jeffjade.com/2016/03/11/2016-03-11-autohotkey/</a></li>
<li><a href="https://www.autohotkey.com/boards/viewtopic.php?f=29&amp;t=4296" target="_blank" rel="noopener">https://www.autohotkey.com/boards/viewtopic.php?f=29&amp;t=4296</a></li>
</ul>
</blockquote>
<h3 id="办公"><a class="markdownIt-Anchor" href="#办公"></a> 办公</h3>
<ul>
<li><a href="http://cidian.youdao.com/index.html" target="_blank" rel="noopener">有道词典</a> - 最好用的免费全能翻译软件。</li>
<li><a href="http://office.microsoft.com/zh-cn/outlook/" target="_blank" rel="noopener">Outlook</a> - 大名鼎鼎的 Microsoft Office 组件之一，除了电子邮件，还包含了日历、任务管理、联系人、记事本等功能。</li>
<li><a href="http://www.gmail.com/" target="_blank" rel="noopener">Gmail</a> - 功能上可以称为业界标杆，用户数量世界第一，或许你真的找不到比它更好的邮件系统。</li>
<li><a href="https://www.google.com/intl/zh-CN/chrome/browser/" target="_blank" rel="noopener">Chrome</a> - 最好的浏览器。</li>
<li><a href="http://www.teamviewer.com/Zhcn/index.aspx" target="_blank" rel="noopener">Teamviewer</a> - 专业、功能强大的远程控制软件。使用简单，对个人用户免费。</li>
</ul>
<h3 id="个性化"><a class="markdownIt-Anchor" href="#个性化"></a> 个性化</h3>
<ul>
<li><a href="https://github.com/TranslucentTB/TranslucentTB" target="_blank" rel="noopener">TranslucentTB</a> - 透明化你的 Windows 任务栏。</li>
<li><a href="http://qttabbar.wikidot.com/" target="_blank" rel="noopener">QTTabBar</a> - 通过多标签和额外的文件夹视图扩展资源管理器的功能。</li>
<li><a href="https://www.stardock.com/products/fences/" target="_blank" rel="noopener">Fences</a> - 管理桌面快捷方式。</li>
</ul>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><a href="https://github.com/Awesome-Windows/Awesome/blob/master/README-cn.md" target="_blank" rel="noopener">https://github.com/Awesome-Windows/Awesome/blob/master/README-cn.md</a></li>
<li><a href="https://love.appinn.com/" target="_blank" rel="noopener">https://love.appinn.com/</a></li>
<li><a href="https://github.com/stackia/best-windows-apps" target="_blank" rel="noopener">https://github.com/stackia/best-windows-apps</a></li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac 常用技巧总结</title>
    <url>/blog/os/mac/</url>
    <content><![CDATA[<h2 id="基本操作"><a class="markdownIt-Anchor" href="#基本操作"></a> 基本操作</h2>
<h3 id="软件管理"><a class="markdownIt-Anchor" href="#软件管理"></a> 软件管理</h3>
<p>dmg 格式：双击安装包，然后拖到 applications 文件夹下即可。</p>
<h3 id="浏览器"><a class="markdownIt-Anchor" href="#浏览器"></a> 浏览器</h3>
<h4 id="更改默认搜索引擎"><a class="markdownIt-Anchor" href="#更改默认搜索引擎"></a> 更改默认搜索引擎</h4>
<p>选择「偏好设置–&gt;搜索–&gt;搜索引擎–&gt;Google」。</p>
<h4 id="导入-chrome-浏览器的书签"><a class="markdownIt-Anchor" href="#导入-chrome-浏览器的书签"></a> 导入 chrome 浏览器的书签</h4>
<p>选择「文件–&gt;导入自–&gt; Google Chrome」，然后选择要导入的项目。</p>
<h4 id="快捷键"><a class="markdownIt-Anchor" href="#快捷键"></a> 快捷键</h4>
<p>Command + R 刷新</p>
<h4 id="上方显示书签栏收藏栏"><a class="markdownIt-Anchor" href="#上方显示书签栏收藏栏"></a> 上方显示书签栏／收藏栏</h4>
<p>选择「显示–&gt; 显示个人收藏栏」。</p>
<h4 id="关闭软件的右上角通知"><a class="markdownIt-Anchor" href="#关闭软件的右上角通知"></a> 关闭软件的右上角通知</h4>
<p>在 Mac 系统中有对通知的设置，打开系统偏好设置 — 通知 找到 QQ，然后将 QQ 提示样式设置成无即可。</p>
<h4 id="复制文件文件夹路径"><a class="markdownIt-Anchor" href="#复制文件文件夹路径"></a> 复制文件/文件夹路径</h4>
<ul>
<li>OS X 10.11 系统，选中文件夹，「cmd +Option +c」 复制文件夹路径，cmd+v 粘贴。<br />
之前的系统，利用 Administrator 创建一个到右键菜单，然后到设置里面设置快捷键。具体操作请百度。</li>
</ul>
<h4 id="打开来自身份不明的开发者的应用程序"><a class="markdownIt-Anchor" href="#打开来自身份不明的开发者的应用程序"></a> 打开来自身份不明的开发者的应用程序</h4>
<p>在应用程序文件夹，按住 control 键的同时打开应用程序。</p>
<h4 id="复制文件路径"><a class="markdownIt-Anchor" href="#复制文件路径"></a> 复制文件路径</h4>
<ul>
<li>
<p>选择文件／文件夹按 Command+C 复制，在终端中 Command+V 粘贴即可。</p>
</li>
<li>
<p>如果只是想在 Finder 中看到文件的路径, 并方便切换层级, Finder 内置了「显示路径栏」的功能, 并配置了快捷键(Option+Cmd+P). 如下图所示：</p>
</li>
</ul>
<p>20161124-184148.png</p>
<p>参考链接：</p>
<ul>
<li>[<a href="https://www.zhihu.com/question/22883229" target="_blank" rel="noopener">https://www.zhihu.com/question/22883229</a>]</li>
</ul>
<h3 id="隐藏和取消隐藏-mac-app-store-中的已购项目"><a class="markdownIt-Anchor" href="#隐藏和取消隐藏-mac-app-store-中的已购项目"></a> 隐藏和取消隐藏 Mac App Store 中的已购项目</h3>
<h3 id="mac-同时登陆两个-qq"><a class="markdownIt-Anchor" href="#mac-同时登陆两个-qq"></a> Mac 同时登陆两个 QQ</h3>
<p>在已经打开的 QQ 中，按住「command + N」即可。</p>
<h2 id="系统便好设置"><a class="markdownIt-Anchor" href="#系统便好设置"></a> 系统便好设置</h2>
<h3 id="语音播报"><a class="markdownIt-Anchor" href="#语音播报"></a> 语音播报</h3>
<p>打开「系统便好设置–&gt;辅助功能–&gt;语音」，即可设置不同国家的语言。</p>
<p>勾选上图中的红框部分，可以设置全局快捷键。这样的话，在任何一个软件当中，按下「 option+esc」时，就会朗读选中的文本。</p>
<h3 id="调整字体大小"><a class="markdownIt-Anchor" href="#调整字体大小"></a> 调整字体大小</h3>
<p>Mac 调整字体大小：「系统偏好设置 -&gt; 显示器 -&gt; 缩放」。如下图：</p>
<h3 id="如何分别设置-mac-的鼠标和触控板的滚动方向"><a class="markdownIt-Anchor" href="#如何分别设置-mac-的鼠标和触控板的滚动方向"></a> 如何分别设置 Mac 的鼠标和触控板的滚动方向</h3>
<p>很多人习惯鼠标使用相反的滚动方向，而触控板类似 iPad 那样的自然滚动，问如何设置，当时我的回答是不知道，因为目前 OS X 的系统设置里，鼠标和触控板的设置是统一<br />
的。今天发现了一个免费的软件 Scroll Reverser，可以实现鼠标和触控板的分别设置。下载地址：<a href="https://pilotmoon.com/scrollreverser/" target="_blank" rel="noopener">https://pilotmoon.com/scrollreverser/</a><br />
启动后程序显示在顶部菜单栏，设置简单明了，有需要的用户体验一下吧。</p>
<h3 id="touch-bar-自定义"><a class="markdownIt-Anchor" href="#touch-bar-自定义"></a> Touch Bar 自定义</h3>
<p>打开「系统偏好设置-键盘」，下面有个自定义控制条。</p>
<h3 id="色温调节夜间模式"><a class="markdownIt-Anchor" href="#色温调节夜间模式"></a> 色温调节：夜间模式</h3>
<p>iOS9.3 的最明显变化，莫过于苹果在发布会上特意提到的 Night Shift 夜间护眼模式。</p>
<h3 id="icloud-邮箱"><a class="markdownIt-Anchor" href="#icloud-邮箱"></a> iCloud 邮箱</h3>
<p>如果您用于设置 iCloud 的 Apple ID 不以“@icloud.com”、“@me.com”或“@mac.com”结尾，您必须先设置一个“@icloud.com”电子邮件地址，然后才能使用 iCloud“邮件”。</p>
<p>如果您拥有以“@mac.com”或“@me.com”结尾的电子邮件地址，则您已经拥有了名称相同但以“@icloud.com”结尾的等效地址。如果您使用的电子邮件别名以“@mac.com”或“@me.com”结尾，您也将拥有以“@icloud.com”结尾的等效地址。</p>
<p><strong>操作如下：</strong></p>
<ul>
<li>
<p>在 iOS 设备上，前往“设置”&gt;“iCloud”，开启“邮件”，然后按照屏幕上的说明操作。</p>
</li>
<li>
<p>在 Mac 上，选取 Apple 菜单 &gt;“系统偏好设置”，点按“iCloud”，再选择“邮件”，然后按照屏幕上的说明操作。</p>
</li>
</ul>
<p>PS：创建 iCloud 电子邮件地址后，您无法对其进行更改。</p>
<p>设置 @icloud.com 电子邮件地址后即可用其登录 iCloud。您也可以用创建 iCloud 帐户时所用的 Apple ID 登录。</p>
<p>您可以从以下任意地址发送 iCloud 电子邮件：</p>
<p>您的 iCloud 电子邮件地址（您的帐号名称@icloud.com）</p>
<p>别名</p>
<p>参考链接：</p>
<p><strong>直接注册以@icloud.com 结尾的 Apple ID：</strong></p>
<p>参考链接：</p>
<h2 id="podcast"><a class="markdownIt-Anchor" href="#podcast"></a> PodCast</h2>
<p>PodCast 中文翻译为播客，是一种特殊的音频 or 视频节目。PodCast 这个单词是由 iPod+Broadcast 这两个单词组成的。</p>
<p>PodCast 可以在 iTunes 中收听。</p>
<h2 id="others"><a class="markdownIt-Anchor" href="#others"></a> others</h2>
<h3 id="词典"><a class="markdownIt-Anchor" href="#词典"></a> 词典</h3>
<p>系统有一个自带应用「词典」，可以进行单词的查询。</p>
<h3 id="如何解决-mac-软件dmgakpapp出现程序已损坏的提示"><a class="markdownIt-Anchor" href="#如何解决-mac-软件dmgakpapp出现程序已损坏的提示"></a> 如何解决 MAC 软件（dmg，akp，app）出现程序已损坏的提示</h3>
<p>「xxx.app 已损坏,打不开.你应该将它移到废纸篓」，并非你安装的软件已损坏，而是 Mac 系统的安全设置问题，因为这些应用都是破解或者汉化的,那么解决方法就是临时改变 Mac 系统安全设置。</p>
<p>出现这个问题的解决方法：修改系统配置：系统偏好设置… -&gt; 安全性与隐私。修改为任何来源。</p>
<p>如果没有这个选项的话（macOS Sierra 10.12）,打开终端，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo spctl --master-disable</span><br></pre></td></tr></table></figure>
<p>即可。</p>
<p>参考链接：</p>
<ul>
<li>
<p><a href="http://www.jianshu.com/p/379b49b88df9" target="_blank" rel="noopener">Max OS-[xxx.app 已损坏,打不开.你应该将它移到废纸篓]</a></p>
</li>
<li>
<p><a href="http://www.yunrui.co/25693.html" target="_blank" rel="noopener">如何解决 MAC 软件（dmg，akp，app）出现程序已损坏的提示</a></p>
</li>
</ul>
<p>备注：这个链接里的各种资源都很不错啊。</p>
<h4 id="终端"><a class="markdownIt-Anchor" href="#终端"></a> 终端</h4>
<h4 id="在-finder-的当前目录打开终端"><a class="markdownIt-Anchor" href="#在-finder-的当前目录打开终端"></a> 在 Finder 的当前目录打开终端</h4>
<p>在 Finder 打开 terminal 终端这个功能其实是有的，但是系统默认没有打开。我们可以通过如下方法将其打开：</p>
<p>进入系统偏好设置-&gt;键盘-&gt;快捷键-&gt;服务。</p>
<p>在右边新建位于文件夹位置的终端窗口上打勾。</p>
<p>如此设置后，在 Finder 中右击某文件，在出现的菜单中找到服务，然后点击新建位于文件夹位置的终端窗口即可！</p>
<h2 id="mac-常用快捷键"><a class="markdownIt-Anchor" href="#mac-常用快捷键"></a> Mac 常用快捷键</h2>
<h3 id="finder"><a class="markdownIt-Anchor" href="#finder"></a> Finder</h3>
<table>
<thead>
<tr>
<th style="text-align:left">快捷键</th>
<th style="text-align:left">作用</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Shift + Command + G</td>
<td style="text-align:left">前往指定路径的文件夹</td>
<td style="text-align:left">包括隐藏文件夹</td>
</tr>
<tr>
<td style="text-align:left">Shift + Command + .</td>
<td style="text-align:left">显示隐藏文件、文件夹</td>
<td style="text-align:left">再按一次，恢复隐藏</td>
</tr>
<tr>
<td style="text-align:left">Command + ↑</td>
<td style="text-align:left">返回上一层</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">Command + ↓</td>
<td style="text-align:left">进入当前文件夹</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<h3 id="编辑"><a class="markdownIt-Anchor" href="#编辑"></a> 编辑</h3>
<p><strong>删除文字</strong>：</p>
<table>
<thead>
<tr>
<th style="text-align:left">快捷键</th>
<th style="text-align:left">作用</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">delete</td>
<td style="text-align:left">删除光标的前一个字符</td>
<td style="text-align:left">相当于 Windows 键盘上的退格键</td>
</tr>
<tr>
<td style="text-align:left">fn + delete</td>
<td style="text-align:left">删除光标的后一个字符</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">option + delete</td>
<td style="text-align:left">删除光标之前的一个单词</td>
<td style="text-align:left">英文有效</td>
</tr>
<tr>
<td style="text-align:left"><strong>command + delete</strong></td>
<td style="text-align:left">删除光标之前的整行内容</td>
<td style="text-align:left">【荐】</td>
</tr>
<tr>
<td style="text-align:left">command + delete</td>
<td style="text-align:left">在 finder 中删掉该文件</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">shift + command + delete</td>
<td style="text-align:left">清空回收站</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p><strong>剪切文件</strong>：</p>
<p>首先选中文件，按 Command+C 复制文件；然后按「Command ＋ Option ＋ V」剪切文件。</p>
<p>备注：Command+X 只能剪切文字文本，不要混淆了。</p>
<h2 id="mac-用户必须知道的-15-组快捷键"><a class="markdownIt-Anchor" href="#mac-用户必须知道的-15-组快捷键"></a> Mac 用户必须知道的 15 组快捷键</h2>
<blockquote>
<p>参考链接：<a href="http://v.youku.com/v_show/id_XNDE4MzM0NDgw.html" target="_blank" rel="noopener">《轻松玩 Mac》第 6 期：Mac 用户必须知道的 15 组快捷键</a></p>
</blockquote>
<h3 id="space键快速预览"><a class="markdownIt-Anchor" href="#space键快速预览"></a> 「space」键：快速预览</h3>
<p>选中文件后， 不需要启动任何应用程序，使用「space」空格键可进行快速预览，再次按下「space」空格键取消预览。</p>
<p>可以预览 mp3、视频、pdf 等文件。</p>
<p>我们还可以<strong>选中多张图片</strong>， 然后按「space」键，就可以同时对比预览多张图片。这一点，很赞。</p>
<h3 id="改名"><a class="markdownIt-Anchor" href="#改名"></a> 改名</h3>
<p>选中文件/文件夹后，按 enter 键，就可以改名了。</p>
<h3 id="command-i键查看文件属性"><a class="markdownIt-Anchor" href="#command-i键查看文件属性"></a> 「command + I」键：查看文件属性</h3>
<ul>
<li>
<p>选中文件后，按「command + I」键，可以查看文件的各种属性。</p>
</li>
<li>
<p>选中<strong>文件夹</strong>后，按「command + I」键，可以查看文件夹的大小。【荐】</p>
</li>
</ul>
<h3 id="切换输入法"><a class="markdownIt-Anchor" href="#切换输入法"></a> 切换输入法</h3>
<p>「control + space」</p>
<h3 id="打开-spotlight-搜索框"><a class="markdownIt-Anchor" href="#打开-spotlight-搜索框"></a> 打开 spotlight 搜索框</h3>
<p>spotlight 是系统自带的软件，搜索功能不是很强大。我们一般都会用第三方的 Alfred 软件。</p>
<h3 id="编辑相关"><a class="markdownIt-Anchor" href="#编辑相关"></a> 编辑相关</h3>
<p>Cmd+C、Cmd+V、Cmd+X、Cmd+A、Cmd+Z。</p>
<h3 id="翻页和光标"><a class="markdownIt-Anchor" href="#翻页和光标"></a> 翻页和光标</h3>
<ul>
<li>
<p>「control + ↑」：将光标定位到文章的最开头（翻页到文档的最上方）</p>
</li>
<li>
<p>「control + ↓」：将光标定位到文章的最末尾（翻页到文档的最下方）</p>
</li>
<li>
<p>「control + ←」：将光标定位到当前行的最左侧</p>
</li>
<li>
<p>「control + →」：将光标定位到当前行的最右侧</p>
</li>
</ul>
<h3 id="command-shift-y将文字快速保存到便笺"><a class="markdownIt-Anchor" href="#command-shift-y将文字快速保存到便笺"></a> 「command + shift + Y」：将文字快速保存到便笺</h3>
<p>选中你想要的内容（例如文字、链接等），然后按下 command + shift + Y」，那么你选中的内容就会快速保存到系统自带的「便笺」软件中。</p>
<p>如果你想临时性的保存一段内容，这个操作很实用。</p>
<h3 id="程序相关"><a class="markdownIt-Anchor" href="#程序相关"></a> 程序相关</h3>
<ul>
<li>
<p>「command + Q」：快速退出程序</p>
</li>
<li>
<p>「command + tab」：切换程序</p>
</li>
<li>
<p>「command + H」：隐藏当前应用程序。这是一个有趣的快捷键。</p>
</li>
<li>
<p>「command + ，」：打开当前应用程序的「偏好设置」。</p>
</li>
</ul>
<h3 id="窗口相关"><a class="markdownIt-Anchor" href="#窗口相关"></a> 窗口相关</h3>
<ul>
<li>
<p>「command + N」：新建一个当前应用程序的窗口</p>
</li>
<li>
<p>「command + `」：在当前应用程序的不同窗口之间切换【很实用】</p>
</li>
</ul>
<p>我们知道，「command + tab」是在不同的软件之间切换。但你不知道的是，「command + `」是在同一个软件的不同窗口之间切换。</p>
<ul>
<li>
<p>「command + M」：将当前窗口最小化</p>
</li>
<li>
<p>「command + W」：关闭当前窗口</p>
</li>
</ul>
<h3 id="浏览器相关"><a class="markdownIt-Anchor" href="#浏览器相关"></a> 浏览器相关</h3>
<ul>
<li>
<p>「command + T」：浏览器中，新建一个标签</p>
</li>
<li>
<p>「command + W」：关闭当前标签</p>
</li>
</ul>
<ul>
<li>「command + R」：强制刷新。</li>
</ul>
<ul>
<li>「command + L」：定位到地址栏。【重要】</li>
</ul>
<h3 id="截图相关"><a class="markdownIt-Anchor" href="#截图相关"></a> 截图相关</h3>
<ul>
<li>「command + shift + 3」：截全屏（对整个屏幕截图）。</li>
</ul>
<h3 id="声音相关"><a class="markdownIt-Anchor" href="#声音相关"></a> 声音相关</h3>
<p>选中文字后，按住「ctrl + esc」键，会将文字进行朗读。（我发现，在触控条版的 mac 上，并没有生效）</p>
<h3 id="dock-栏相关"><a class="markdownIt-Anchor" href="#dock-栏相关"></a> Dock 栏相关</h3>
<ul>
<li>「option + command + D」：隐藏 dock 栏</li>
</ul>
<h3 id="强制推出"><a class="markdownIt-Anchor" href="#强制推出"></a> 强制推出</h3>
<blockquote>
<p>强制退出的快捷键非常重要</p>
</blockquote>
<ul>
<li>「option + command + esc」：打开强制退出的窗口</li>
</ul>
<h3 id="option-相关"><a class="markdownIt-Anchor" href="#option-相关"></a> option 相关</h3>
<blockquote>
<p>强烈推荐</p>
</blockquote>
<ul>
<li>
<p>「option + command + H」：隐藏除当前应用程序之外的其他应用程序</p>
</li>
<li>
<p>在文本中，按住「option」键，配合鼠标的选中，可以进行块状文字选取。</p>
</li>
<li>
<p>「option + command + W」：快速关闭当前应用程序的所有窗口。【很实用】</p>
</li>
</ul>
<p>比如说，你一次性打开了很多文件的详情，然后就可以通过此快捷键，将这些窗口一次性关闭。</p>
<ul>
<li>「option + command + I」：查看多个文件的总的属性。</li>
</ul>
<ul>
<li>
<p>打开 launchpad，按住「option」键，可以快速卸载应用程序。</p>
</li>
<li>
<p>在 dock 栏，右键点击软件图标，同时按住「option」键，就可以<strong>强制退出</strong>该软件。【重要】</p>
</li>
</ul>
<ul>
<li>在 Safari 浏览器中，按住「option + command + Q」退出 Safari。等下次进入 Safari 的时候，上次退出时的网址会自动被打开。【实用】</li>
</ul>
<h3 id="推荐一个软件cheatsheet"><a class="markdownIt-Anchor" href="#推荐一个软件cheatsheet"></a> 推荐一个软件：CheatSheet</h3>
<p>打开 CheatSheet 后，长按 command 键，会弹出当前应用程序的所有快捷键。我们还可以对这些快捷键进行保存。</p>
<h2 id="学习资源"><a class="markdownIt-Anchor" href="#学习资源"></a> 📚 学习资源</h2>
<ul>
<li><a href="https://github.com/jaywcjlove/awesome-mac" target="_blank" rel="noopener">Awesome Mac</a></li>
<li><a href="https://github.com/herrbischoff/awesome-macos-command-line" target="_blank" rel="noopener">awesome-macos-command-line</a></li>
</ul>
<h2 id="传送门"><a class="markdownIt-Anchor" href="#传送门"></a> 🚪 传送门</h2>
<p>| <a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">回首頁</a> |</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>系统原理</title>
    <url>/blog/design/theory/README/</url>
    <content><![CDATA[<h1 id="系统原理"><a class="markdownIt-Anchor" href="#系统原理"></a> 系统原理</h1>
<blockquote>
<p>系统原理旨在总结大型系统中常用的核心技术，这也架构设计的基石。</p>
</blockquote>
<h2 id="内容"><a class="markdownIt-Anchor" href="#内容"></a> 内容</h2>
<ul>
<li><a href="system-theory-interview.md">系统原理面试题</a></li>
<li><a href="distributed-base-theory.md">分布式基本原理</a></li>
<li><a href="load-balance-theory.md">负载均衡基本原理</a></li>
<li><a href="cache-theory.md">缓存基本原理</a></li>
<li><a href="mq-theory.md">消息队列基本原理</a></li>
<li><a href="distributed-lock-theory.md">分布式锁基本原理</a></li>
<li><a href="distributed-session-theory.md">分布式会话基本原理</a></li>
<li><a href="distributed-storage-theory.md">分布式存储基本原理</a></li>
<li><a href="distributed-id-theory.md">分布式 ID 基本原理</a></li>
<li><a href="distributed-transaction-theory.md">分布式事务基本原理</a></li>
<li><a href="sharding-theory.md">分库分表基本原理</a></li>
</ul>
<h2 id="学习资料"><a class="markdownIt-Anchor" href="#学习资料"></a> 学习资料</h2>
<ul>
<li>
<p><strong>书籍</strong></p>
<ul>
<li><a href="https://item.jd.com/11322972.html" target="_blank" rel="noopener">大型网站技术架构：核心原理与案例分析</a> - 浅显易懂的将解大型网站架构演进之路；简介了大型系统所面临的挑战以及核心技术点。</li>
<li><a href="https://item.jd.com/11449803.html" target="_blank" rel="noopener">大型网站系统与 Java 中间件实践</a></li>
<li><a href="https://item.jd.com/12153914.html" target="_blank" rel="noopener">亿级流量网站架构核心技术：跟开涛学搭建高可用高并发系统</a></li>
<li><a href="https://item.jd.com/12176278.html" target="_blank" rel="noopener">企业 IT 架构转型之道：阿里巴巴中台战略思想与架构实战</a> - 阐述阿里巴巴中台系统发展，更多的是讲解应用场景和能力，没有讲解技术细节。</li>
<li><a href="https://item.jd.com/12238227.html" target="_blank" rel="noopener">逆流而上：阿里巴巴技术成长之路</a> - 主要以运维的视角阐述系统运维中遇到的困难，定位思路以及解决方法。</li>
</ul>
</li>
<li>
<p><strong>教程</strong></p>
<ul>
<li><a href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md" target="_blank" rel="noopener">system-design-primer</a></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>设计</category>
        <category>系统原理</category>
      </categories>
      <tags>
        <tag>设计</tag>
        <tag>系统原理</tag>
      </tags>
  </entry>
  <entry>
    <title>架构设计</title>
    <url>/blog/design/architecture/README/</url>
    <content><![CDATA[<h1 id="架构设计"><a class="markdownIt-Anchor" href="#架构设计"></a> 架构设计</h1>
<h2 id="内容"><a class="markdownIt-Anchor" href="#内容"></a> 内容</h2>
<ul>
<li><a href="system-architecture-interview.md">系统架构面试题</a></li>
<li><a href="system-architecture-overview.md">系统架构概述</a></li>
<li><a href="high-performance-architecture.md">高性能架构</a></li>
<li><a href="high-availability-architecture.md">高可用架构</a></li>
<li><a href="scalable-architecture.md">伸缩性架构</a></li>
<li><a href="extensible-architecture.md">扩展性架构</a></li>
<li><a href="security-architecture.md">系统安全性架构</a></li>
<li><a href="system-core-technologies.md">大型系统核心技术</a></li>
</ul>
<h2 id="学习资料"><a class="markdownIt-Anchor" href="#学习资料"></a> 学习资料</h2>
<ul>
<li><strong>书籍</strong>
<ul>
<li><a href="https://item.jd.com/11322972.html" target="_blank" rel="noopener">大型网站技术架构：核心原理与案例分析</a> - 浅显易懂的将解大型网站架构演进之路；简介了大型系统所面临的挑战以及核心技术点。</li>
<li><a href="https://item.jd.com/11449803.html" target="_blank" rel="noopener">大型网站系统与 Java 中间件实践</a></li>
<li><a href="https://item.jd.com/12153914.html" target="_blank" rel="noopener">亿级流量网站架构核心技术：跟开涛学搭建高可用高并发系统</a></li>
<li><a href="https://item.jd.com/12176278.html" target="_blank" rel="noopener">企业 IT 架构转型之道：阿里巴巴中台战略思想与架构实战</a> - 阐述阿里巴巴中台系统发展，更多的是讲解应用场景和能力，没有讲解技术细节。</li>
<li><a href="https://item.jd.com/12238227.html" target="_blank" rel="noopener">逆流而上：阿里巴巴技术成长之路</a> - 主要以运维的视角阐述系统运维中遇到的困难，定位思路以及解决方法。</li>
</ul>
</li>
<li><strong>教程</strong>
<ul>
<li><a href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md" target="_blank" rel="noopener">system-design-primer</a></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>设计</category>
        <category>架构</category>
      </categories>
      <tags>
        <tag>设计</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>合理对文档进行归类</title>
    <url>/blog/efficiency/style/dir-style/</url>
    <content><![CDATA[<blockquote>
<p>作为程序员，想必每个人都会有大量的资料、数据。按照条理清晰的目录结构去分类化存储，十分有助于管理文件。</p>
</blockquote>
<h2 id="目录结构"><a class="markdownIt-Anchor" href="#目录结构"></a> 目录结构</h2>
<p>以下是我个人整理的目录结构：</p>
<figure class="highlight capnproto"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── Codes           <span class="comment">#代码目录</span></span><br><span class="line">│   ├── Other       <span class="comment">#第三方代码目录</span></span><br><span class="line">│   ├── My          <span class="comment">#个人代码目录</span></span><br><span class="line">│   └── Work        <span class="comment">#工作代码目录</span></span><br><span class="line">├── <span class="built_in">Data</span>            <span class="comment">#数据目录</span></span><br><span class="line">├── Downloads       <span class="comment">#下载文件目录</span></span><br><span class="line">├── Docs            <span class="comment">#文档目录</span></span><br><span class="line">│   ├── Books       <span class="comment">#电子书目录</span></span><br><span class="line">│   ├── My          <span class="comment">#个人文档目录</span></span><br><span class="line">│   └── Work        <span class="comment">#工作文档目录</span></span><br><span class="line">├── Movies          <span class="comment">#视频目录</span></span><br><span class="line">├── Music           <span class="comment">#音乐目录</span></span><br><span class="line">├── Pictures        <span class="comment">#图片目录</span></span><br><span class="line">├── Public          <span class="comment">#共享目录</span></span><br><span class="line">├── Temp            <span class="comment">#临时文件目录</span></span><br><span class="line">└── Tools           <span class="comment">#工具软件目录</span></span><br><span class="line">    └── Packages    <span class="comment">#安装包目录</span></span><br></pre></td></tr></table></figure>
<p>注：如果您使用的操作系统是 Mac 这种可以为目录或文件添加 tag 的操作系统，那么您可以根据自己的喜好更细致化的管理。</p>
<h2 id="2-文件管理软件"><a class="markdownIt-Anchor" href="#2-文件管理软件"></a> 2. 文件管理软件</h2>
<blockquote>
<p>选用便利的文件管理软件，可以让你的文件管理如虎添翼。这里推荐几款经典的文件管理工具。</p>
</blockquote>
<h3 id="21-clover"><a class="markdownIt-Anchor" href="#21-clover"></a> 2.1. Clover</h3>
<blockquote>
<p><a href="http://cn.ejie.me/" target="_blank" rel="noopener">Clover</a> 是 Windows Explorer 资源管理器的一个扩展，为其增加类似谷歌 Chrome 浏览器的多标签页功能。</p>
</blockquote>
<div align="center">
<img src="http://cn.ejie.me/images/clover.jpg" width="640" />
</div>
<h3 id="22-everything"><a class="markdownIt-Anchor" href="#22-everything"></a> 2.2. Everything</h3>
<blockquote>
<p><a href="http://www.voidtools.com/" target="_blank" rel="noopener">Everything</a> 可以立即在 windows 系统中找到制定名称的文件和文件夹。</p>
</blockquote>
<div align="center">
<img src="http://www.voidtools.com/sssmall2.gif" width="640" />
</div>
<h3 id="23-wox"><a class="markdownIt-Anchor" href="#23-wox"></a> 2.3. Wox</h3>
<blockquote>
<p><a href="https://github.com/Wox-launcher/Wox" target="_blank" rel="noopener">Wox</a> 是一款简单易用的 Windows 启动器。可以把它视为 windows 版的 Alfred。</p>
</blockquote>
<div align="center">
<img src="https://camo.githubusercontent.com/9db33546d3a905a9ad915e0948d3ba3f47f57b64/687474703a2f2f692e696d6775722e636f6d2f4474784e424a692e676966" width="640" />
</div>
<h3 id="24-q-dir"><a class="markdownIt-Anchor" href="#24-q-dir"></a> 2.4. Q-dir</h3>
<blockquote>
<p><a href="http://www.softpedia.com/get/File-managers/Q-Dir.shtml" target="_blank" rel="noopener">Q-dir</a> 是轻量的文件管理器,特点鲜明,各种布局视图切换灵活,默认四个小窗口组成一个大窗口,操作快捷。</p>
</blockquote>
<div align="center">
<img src="http://i1-win.softpedia-static.com/screenshots/q-dir_1.png" width="640" />
</div>
]]></content>
      <categories>
        <category>效率提升</category>
        <category>规范</category>
      </categories>
      <tags>
        <tag>效率提升</tag>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title>合理编排技术文档</title>
    <url>/blog/efficiency/style/doc-style/</url>
    <content><![CDATA[<blockquote>
<p>文档采用 Markdown 语法书写。</p>
<p>📚 「参考」Markdown 语法可以参考：</p>
<ul>
<li><a href="https://github.com/guodongxiaren/README" target="_blank" rel="noopener">https://github.com/guodongxiaren/README</a></li>
<li><a href="https://github.com/tchapi/markdown-cheatsheet" target="_blank" rel="noopener">https://github.com/tchapi/markdown-cheatsheet</a></li>
</ul>
</blockquote>
<h2 id="1-标题"><a class="markdownIt-Anchor" href="#1-标题"></a> 1. 标题</h2>
<h3 id="11-标题层级"><a class="markdownIt-Anchor" href="#11-标题层级"></a> 1.1. 标题层级</h3>
<p>标题分为四级。</p>
<ol>
<li>一级标题：文章的标题</li>
<li>二级标题：文章内容的大标题</li>
<li>三级标题：二级标题下一级的标题</li>
<li>四级标题：三级标题下一级的标题</li>
</ol>
<h3 id="12-标题原则"><a class="markdownIt-Anchor" href="#12-标题原则"></a> 1.2. 标题原则</h3>
<ul>
<li>一篇文章中应该尽力避免同名标题。</li>
<li>一级标题下，不能直接出现三级标题。</li>
<li>标题要避免孤立编号（即同级标题只有一个）。</li>
<li>下级标题不重复上一级标题的内容。</li>
<li>谨慎使用四级标题，尽量避免出现，保持层级的简单和防止出现过于复杂的章节。如果三级标题下有并列性的内容，建议只使用项目列表（Item list）。</li>
</ul>
<h2 id="2-文本"><a class="markdownIt-Anchor" href="#2-文本"></a> 2. 文本</h2>
<h3 id="21-字间距"><a class="markdownIt-Anchor" href="#21-字间距"></a> 2.1. 字间距</h3>
<p>全角中文字符与半角英文字符之间，应有一个半角空格。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">反例：本文介绍如何快速启动Windows系统。</span><br><span class="line"></span><br><span class="line">正例：本文介绍如何快速启动 Windows 系统。</span><br></pre></td></tr></table></figure>
<p>全角中文字符与半角阿拉伯数字之间，有没有半角空格都可，但必须保证风格统一，不能两种风格混杂。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">正例：<span class="number">2011</span>年<span class="number">5</span>月<span class="number">15</span>日，我订购了<span class="number">5</span>台笔记本电脑与<span class="number">10</span>台平板电脑。</span><br><span class="line"></span><br><span class="line">正例：<span class="number">2011</span> 年 <span class="number">5</span> 月 <span class="number">15</span> 日，我订购了 <span class="number">5</span> 台笔记本电脑与 <span class="number">10</span> 台平板电脑。</span><br></pre></td></tr></table></figure>
<p>半角的百分号，视同阿拉伯数字。</p>
<p>英文单位若不翻译，单位前的阿拉伯数字与单位间不留空格。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">反例：一部容量为 <span class="number">16</span> GB 的智能手机</span><br><span class="line"></span><br><span class="line">正例：一部容量为 <span class="number">16</span>GB 的智能手机</span><br></pre></td></tr></table></figure>
<p>半角英文字符和半角阿拉伯数字，与全角标点符号之间不留空格。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">反例：他的电脑是 MacBook Air 。</span><br><span class="line"></span><br><span class="line">正例：他的电脑是 MacBook Air。</span><br></pre></td></tr></table></figure>
<h3 id="22-句子"><a class="markdownIt-Anchor" href="#22-句子"></a> 2.2. 句子</h3>
<ul>
<li>避免使用长句。一个句子建议不超过 100 字或者正文的 3 行。</li>
<li>尽量使用简单句和并列句，避免使用复合句。</li>
</ul>
<h3 id="23-写作风格"><a class="markdownIt-Anchor" href="#23-写作风格"></a> 2.3. 写作风格</h3>
<p>尽量不使用被动语态，改为使用主动语态。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">反例：假如此软件尚未被安装，</span><br><span class="line"></span><br><span class="line">正例：假如尚未安装这个软件，</span><br></pre></td></tr></table></figure>
<p>不使用非正式的语言风格。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">反例：Lady Gaga 的演唱会真是酷毙了，从没看过这么给力的表演！！！</span><br><span class="line"></span><br><span class="line">正例：无法参加本次活动，我深感遗憾。</span><br></pre></td></tr></table></figure>
<p>用对“的”、“地”、“得”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">她露出了开心的笑容。</span><br><span class="line">（形容词＋的＋名词）</span><br><span class="line"></span><br><span class="line">她开心地笑了。</span><br><span class="line">（副词＋地＋动词）</span><br><span class="line"></span><br><span class="line">她笑得很开心。</span><br><span class="line">（动词＋得＋副词）</span><br></pre></td></tr></table></figure>
<p>使用代词时（比如“其”、“该”、“此”、“这”等词），必须明确指代的内容，保证只有一个含义。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">反例：从管理系统可以监视中继系统和受其直接控制的分配系统。</span><br><span class="line"></span><br><span class="line">正例：从管理系统可以监视两个系统：中继系统和受中继系统直接控制的分配系统。</span><br></pre></td></tr></table></figure>
<p>名词前不要使用过多的形容词。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">反例：此设备的使用必须在接受过本公司举办的正式的设备培训的技师的指导下进行。</span><br><span class="line"></span><br><span class="line">正例：此设备必须在技师的指导下使用，且指导技师必须接受过由本公司举办的正式设备培训。</span><br></pre></td></tr></table></figure>
<p>单个句子的长度尽量保持在 20 个字以内；20 ～ 29 个字的句子，可以接受；30 ～ 39 个字的句子，语义必须明确，才能接受；多于 40 个字的句子，在任何情况下都不能接受。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">反例：本产品适用于从由一台服务器进行动作控制的单一节点结构到由多台服务器进行动作控制的并行处理程序结构等多种体系结构。</span><br><span class="line"></span><br><span class="line">正例：本产品适用于多种体系结构。无论是由一台服务器（单一节点结构），还是由多台服务器（并行处理结构）进行动作控制，均可以使用本产品。</span><br></pre></td></tr></table></figure>
<p>同样一个意思，尽量使用肯定句表达，不使用否定句表达。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">反例：请确认没有接通装置的电源。</span><br><span class="line"></span><br><span class="line">正例：请确认装置的电源已关闭。</span><br></pre></td></tr></table></figure>
<p>避免使用双重否定句。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">反例：没有删除权限的用户，不能删除此文件。</span><br><span class="line"></span><br><span class="line">正例：用户必须拥有删除权限，才能删除此文件。</span><br></pre></td></tr></table></figure>
<h3 id="24-英文处理"><a class="markdownIt-Anchor" href="#24-英文处理"></a> 2.4. 英文处理</h3>
<p>英文原文如果使用了复数形式，翻译成中文时，应该将其还原为单数形式。</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">英文：⋯information stored <span class="keyword">in</span> random <span class="keyword">access</span> memory (RAMs)⋯</span><br><span class="line"></span><br><span class="line">中文：……存储在随机存取存储器（RAM）里的信息……</span><br></pre></td></tr></table></figure>
<p>外文缩写可以使用半角圆点(<code>.</code>)表示缩写。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">U</span><span class="selector-class">.S</span><span class="selector-class">.A</span>.</span><br><span class="line"><span class="selector-tag">Apple</span>, <span class="selector-tag">Inc</span>.</span><br></pre></td></tr></table></figure>
<p>表示中文时，英文省略号（<code>⋯</code>）应改为中文省略号（<code>……</code>）。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">英文：<span class="number">5</span> minutes later⋯</span><br><span class="line"></span><br><span class="line">中文：<span class="number">5</span> 分钟过去了⋯⋯</span><br></pre></td></tr></table></figure>
<p>英文书名或电影名改用中文表达时，双引号应改为书名号。</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">英文：<span class="keyword">He</span> published <span class="keyword">an</span> article entitled <span class="string">"The Future of the Aviation"</span>.</span><br><span class="line"></span><br><span class="line">中文：他发表了一篇名为《航空业的未来》的文章。</span><br></pre></td></tr></table></figure>
<p>第一次出现英文词汇时，在括号中给出中文标注。此后再次出现时，直接使用英文缩写即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IOC（International Olympic Committee，国际奥林匹克委员会）。这样定义后，便可以直接使用“IOC”了。</span><br></pre></td></tr></table></figure>
<p>专有名词中每个词第一个字母均应大写，非专有名词则不需要大写。</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">“American Association <span class="keyword">of</span> Physicists <span class="keyword">in</span> Medicine”（美国医学物理学家协会）是专有名词，需要大写。</span><br><span class="line"></span><br><span class="line">“online <span class="keyword">transaction</span> processing”（在线事务处理）不是专有名词，不应大写。</span><br></pre></td></tr></table></figure>
<h2 id="3-段落"><a class="markdownIt-Anchor" href="#3-段落"></a> 3. 段落</h2>
<h3 id="31-段落原则"><a class="markdownIt-Anchor" href="#31-段落原则"></a> 3.1. 段落原则</h3>
<ul>
<li>一个段落只能有一个主题，或一个中心句子。</li>
<li>段落的中心句子放在段首，对全段内容进行概述。后面陈述的句子为核心句服务。</li>
<li>一个段落的长度不能超过七行，最佳段落长度小于等于四行。</li>
<li>段落的句子语气要使用陈述和肯定语气，避免使用感叹语气。</li>
<li>段落之间使用一个空行隔开。</li>
<li>段落开头不要留出空白字符。</li>
</ul>
<h3 id="32-引用"><a class="markdownIt-Anchor" href="#32-引用"></a> 3.2. 引用</h3>
<p>引用第三方内容时，应注明出处。</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">One <span class="keyword">man</span>’s constant <span class="keyword">is</span> another <span class="keyword">man</span>’s variable. — Alan Perlis</span><br></pre></td></tr></table></figure>
<p>如果是全篇转载，请在全文开头显著位置注明作者和出处，并链接至原文。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">本文转载自 WikiQuote</span><br></pre></td></tr></table></figure>
<p>使用外部图片时，必须在图片下方或文末标明来源。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">本文部分图片来自 Wikipedia</span><br></pre></td></tr></table></figure>
<h3 id="33-强调"><a class="markdownIt-Anchor" href="#33-强调"></a> 3.3. 强调</h3>
<p>一些特殊的强调内容可以按照如下方式书写：</p>
<blockquote>
<p>🔔 『注意』</p>
</blockquote>
<blockquote>
<p>💡 『提示』</p>
</blockquote>
<blockquote>
<p>📚 『参考』</p>
</blockquote>
<h2 id="4-数值"><a class="markdownIt-Anchor" href="#4-数值"></a> 4. 数值</h2>
<h3 id="41-半角数字"><a class="markdownIt-Anchor" href="#41-半角数字"></a> 4.1. 半角数字</h3>
<p>数字一律使用半角形式，不得使用全角形式。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">反例： 这件商品的价格是１０００元。</span><br><span class="line"></span><br><span class="line">正例： 这件商品的价格是 <span class="number">1000</span> 元。</span><br></pre></td></tr></table></figure>
<h3 id="42-千分号"><a class="markdownIt-Anchor" href="#42-千分号"></a> 4.2. 千分号</h3>
<p>数值为千位以上，应添加千分号（半角逗号）。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">XXX 公司的实收资本为 RMB1,<span class="number">258</span>,<span class="number">000</span>。</span><br></pre></td></tr></table></figure>
<p>对于 4 ～ 6 位的数值，千分号是选用的，比如<code>1000</code>和<code>1,000</code>都可以接受。对于 7 位及以上的数值，千分号是必须的。</p>
<p>多位小数要从小数点后从左向右添加千分号，比如<code>4.234,345</code>。</p>
<h3 id="43-货币"><a class="markdownIt-Anchor" href="#43-货币"></a> 4.3. 货币</h3>
<p>货币应为阿拉伯数字，并在数字前写出货币符号，或在数字后写出货币中文名称。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$<span class="number">1</span>,<span class="number">000</span></span><br><span class="line"><span class="number">1</span>,<span class="number">000</span> 美元</span><br></pre></td></tr></table></figure>
<h3 id="44-数值范围"><a class="markdownIt-Anchor" href="#44-数值范围"></a> 4.4. 数值范围</h3>
<p>表示数值范围时，用<code>～</code>连接。参见《标点符号》一节的“连接号”部分。</p>
<p>带有单位或百分号时，两个数字都要加上单位或百分号，不能只加后面一个。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">反例：<span class="number">132</span>～<span class="number">234</span>kg</span><br><span class="line">正例：<span class="number">132</span>kg～<span class="number">234</span>kg</span><br><span class="line"></span><br><span class="line">反例：<span class="number">67</span>～<span class="number">89</span>%</span><br><span class="line">正例：<span class="number">67</span>%～<span class="number">89</span>%</span><br></pre></td></tr></table></figure>
<h3 id="45-变化程度的表示法"><a class="markdownIt-Anchor" href="#45-变化程度的表示法"></a> 4.5. 变化程度的表示法</h3>
<p>数字的增加要使用“增加了”、“增加到”。“了”表示增量，“到”表示定量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">增加到过去的两倍</span><br><span class="line">（过去为一，现在为二）</span><br><span class="line"></span><br><span class="line">增加了两倍</span><br><span class="line">（过去为一，现在为三）</span><br></pre></td></tr></table></figure>
<p>数字的减少要使用“降低了”、“降低到”。“了”表示增量，“到”表示定量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">降低到百分之八十</span><br><span class="line">（定额是一百，现在是八十）</span><br><span class="line"></span><br><span class="line">降低了百分之八十</span><br><span class="line">（原来是一百，现在是二十）</span><br></pre></td></tr></table></figure>
<p>不能用“降低 N 倍”或“减少 N 倍”的表示法，要用“降低百分之几”或“减少百分之几”。因为减少（或降低）一倍表示数值原来为一百，现在等于零。</p>
<h2 id="5-符号"><a class="markdownIt-Anchor" href="#5-符号"></a> 5. 符号</h2>
<h3 id="51-符号原则"><a class="markdownIt-Anchor" href="#51-符号原则"></a> 5.1. 符号原则</h3>
<ul>
<li>中文语句的标点符号，均应该采取全角符号，这样可以保证视觉的一致。</li>
<li>如果整句为英文，则该句使用英文/半角标点。</li>
<li>句号、问号、叹号、逗号、顿号、分号和冒号不得出现在一行之首。</li>
</ul>
<h3 id="52-句号"><a class="markdownIt-Anchor" href="#52-句号"></a> 5.2. 句号</h3>
<p>中文语句中的结尾处应该用全角句号（<code>。</code>）。</p>
<p>句子末尾用括号加注时，句号应在括号之外。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">反例：关于文件的输出，请参照第 <span class="number">1.3</span> 节（见第 <span class="number">26</span> 页。）</span><br><span class="line"></span><br><span class="line">正例：关于文件的输出，请参照第 <span class="number">1.3</span> 节（见第 <span class="number">26</span> 页）。</span><br></pre></td></tr></table></figure>
<h3 id="53-逗号"><a class="markdownIt-Anchor" href="#53-逗号"></a> 5.3. 逗号</h3>
<p>逗号<code>，</code>表示句子内部的一般性停顿。</p>
<p>注意避免“一逗到底”，即整个段落除了结尾，全部停顿都使用逗号。</p>
<h3 id="54-顿号"><a class="markdownIt-Anchor" href="#54-顿号"></a> 5.4. 顿号</h3>
<p>句子内部的并列词，应该用全角顿号(<code>、</code>) 分隔，而不用逗号，即使并列词是英语也是如此。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">反例：我最欣赏的科技公司有 Google, Facebook, 腾讯, 阿里和百度等。</span><br><span class="line"></span><br><span class="line">正例：我最欣赏的科技公司有 Google、Facebook、腾讯、阿里和百度等。</span><br></pre></td></tr></table></figure>
<p>英文句子中，并列词语之间使用半角逗号（<code>,</code>）分隔。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">例句：Microsoft Office includes Word, Excel, PowerPoint, Outlook <span class="keyword">and </span>other components.</span><br></pre></td></tr></table></figure>
<h3 id="55-分号"><a class="markdownIt-Anchor" href="#55-分号"></a> 5.5. 分号</h3>
<p>分号<code>；</code>表示复句内部并列分句之间的停顿。</p>
<h3 id="56-引号"><a class="markdownIt-Anchor" href="#56-引号"></a> 5.6. 引号</h3>
<p>引用时，应该使用全角双引号（<code>“ ”</code>），注意前后双引号不同。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：许多人都认为客户服务的核心是“友好”和“专业”。</span><br></pre></td></tr></table></figure>
<p>引号里面还要用引号时，外面一层用双引号，里面一层用单引号（<code>‘ ’</code>），注意前后单引号不同。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：鲍勃解释道：“我要放音乐，可萨利说，‘不行！’。”</span><br></pre></td></tr></table></figure>
<h3 id="57-圆括号"><a class="markdownIt-Anchor" href="#57-圆括号"></a> 5.7. 圆括号</h3>
<p>补充说明时，使用全角圆括号<code>（）</code>，括号前后不加空格。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：请确认所有的连接（电缆和接插件）均安装牢固。</span><br></pre></td></tr></table></figure>
<h3 id="58-冒号"><a class="markdownIt-Anchor" href="#58-冒号"></a> 5.8. 冒号</h3>
<p>全角冒号（<code>：</code>）常用在需要解释的词语后边，引出解释和说明。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：请确认以下几项内容：时间、地点、活动名称，以及来宾数量。</span><br></pre></td></tr></table></figure>
<p>表示时间时，应使用半角冒号（<code>:</code>）。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">例句：早上 <span class="number">8</span>:<span class="number">00</span></span><br></pre></td></tr></table></figure>
<h3 id="59-省略号"><a class="markdownIt-Anchor" href="#59-省略号"></a> 5.9. 省略号</h3>
<p>省略号<code>……</code>表示语句未完、或者语气的不连续。它占两个汉字空间、包含六个省略点，不要使用<code>。。。</code>或<code>...</code>等非标准形式。</p>
<p>省略号不应与“等”这个词一起使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">反例：我们为会餐准备了香蕉、苹果、梨…等各色水果。</span><br><span class="line"></span><br><span class="line">正例：我们为会餐准备了各色水果，有香蕉、苹果、梨……</span><br><span class="line"></span><br><span class="line">正例：我们为会餐准备了香蕉、苹果、梨等各色水果。</span><br></pre></td></tr></table></figure>
<h3 id="510-感叹号"><a class="markdownIt-Anchor" href="#510-感叹号"></a> 5.10. 感叹号</h3>
<p>应该使用平静的语气叙述，尽量避免使用感叹号<code>！</code>。</p>
<p>不得多个感叹号连用，比如<code>！！</code>和<code>!!!</code>。</p>
<h3 id="511-破折号"><a class="markdownIt-Anchor" href="#511-破折号"></a> 5.11. 破折号</h3>
<p>破折号<code>————</code>一般用于做进一步解释。破折号应占两个汉字的位置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：直觉————尽管它并不总是可靠的————告诉我，这事可能出了些问题。</span><br></pre></td></tr></table></figure>
<h3 id="512-连接号"><a class="markdownIt-Anchor" href="#512-连接号"></a> 5.12. 连接号</h3>
<p>连接号用于连接两个类似的词。</p>
<p>以下场合应该使用直线连接号（<code>-</code>），占一个半角字符的位置。</p>
<ul>
<li>两个名词的复合</li>
<li>图表编号</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">例句：氧化-还原反应</span><br><span class="line"></span><br><span class="line">例句：图 <span class="number">1</span><span class="number">-1</span></span><br></pre></td></tr></table></figure>
<p>以下场合应该使用波浪连接号（<code>～</code>），占一个全角字符的位置。</p>
<ul>
<li>数值范围（例如日期、时间或数字）</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">例句：<span class="number">2009</span> 年～<span class="number">2011</span> 年</span><br></pre></td></tr></table></figure>
<p>注意，波浪连接号前后两个值都应该加上单位。</p>
<p>波浪连接号也可以用汉字“至”代替。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">例句：周围温度：<span class="number">-20</span>°C 至 <span class="number">-10</span>°C</span><br></pre></td></tr></table></figure>
<h2 id="6-结构"><a class="markdownIt-Anchor" href="#6-结构"></a> 6. 结构</h2>
<h3 id="61-目录结构"><a class="markdownIt-Anchor" href="#61-目录结构"></a> 6.1. 目录结构</h3>
<p>技术手册目录结构是一部完整的书，建议采用下面的结构。</p>
<ul>
<li><strong>简介</strong>（Introduction） - [必选][目录|文件] 提供对产品和文档本身的总体的、扼要的说明</li>
<li><strong>入门篇</strong>（Quickstart） - [可选][文件] 如何最快速地使用产品</li>
<li><strong>基础篇</strong>（Basics） - [必选][目录] 又称”使用篇“，提供初级的使用教程
<ul>
<li><strong>环境准备</strong>（Prerequisite） - [可选][文件] 软件使用需要满足的前置条件</li>
<li><strong>安装</strong>（Installation） - [可选][文件] 软件的安装方法</li>
<li><strong>配置</strong>（Configuration） - [可选][目录|文件] 软件的配置</li>
<li><strong>特性</strong>（Feature） - [必选][目录|文件] 软件的功能特性</li>
</ul>
</li>
<li><strong>进阶篇</strong>（Advanced） - [可选][目录] 又称”开发篇“，提供中高级的开发教程
<ul>
<li><strong>原理</strong>（Principle） - [可选][目录|文件] 软件的原理</li>
<li><strong>设计</strong>（Design） - [可选][目录|文件] 软件的设计，如：架构、设计思想等</li>
</ul>
</li>
<li><strong>实战篇</strong>（Action） - [可选][目录] 提供一些具有实战意义的示例说明</li>
<li><strong>API</strong>（API） - [可选][目录|文件] 软件 API 的逐一介绍</li>
<li><strong>常见问题</strong>（FAQ） - [可选][目录|文件] 常见问题解答</li>
<li><strong>附录</strong>（Appendix） - [可选][目录] 不属于教程本身、但对阅读教程有帮助的内容
<ul>
<li><strong>命令</strong>（Command） - [可选][目录] 命令</li>
<li><strong>资源</strong>（Resource） - [必选][文件] 资源</li>
<li><strong>术语</strong>（Glossary） - [可选][文件] 名词解释</li>
<li><strong>技巧</strong>（Recipe） - [可选][文件] 最佳实践</li>
<li><strong>版本</strong>（Changelog） - [可选][文件] 版本说明</li>
<li><strong>反馈</strong>（Feedback） - [可选][文件] 反馈方式</li>
</ul>
</li>
</ul>
<p>下面是两个真实范例，可参考。</p>
<ul>
<li><a href="http://redux.js.org/index.html" target="_blank" rel="noopener">Redux 手册</a></li>
<li><a href="http://flight-manual.atom.io/" target="_blank" rel="noopener">Atom 手册</a></li>
</ul>
<h3 id="62-文件名"><a class="markdownIt-Anchor" href="#62-文件名"></a> 6.2. 文件名</h3>
<p>文档的文件名不得含有空格。</p>
<p>文件名必须使用半角字符，不得使用全角字符。这也意味着，中文不能用于文件名。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">反例： 名词解释<span class="selector-class">.md</span></span><br><span class="line"></span><br><span class="line">正例： <span class="selector-tag">glossary</span><span class="selector-class">.md</span></span><br></pre></td></tr></table></figure>
<p>文件名建议只使用小写字母，不使用大写字母。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">反例：<span class="selector-tag">TroubleShooting</span><span class="selector-class">.md</span></span><br><span class="line"></span><br><span class="line">正例：<span class="selector-tag">troubleshooting</span><span class="selector-class">.md</span></span><br></pre></td></tr></table></figure>
<p>为了醒目，某些说明文件的文件名，可以使用大写字母，比如<code>README</code>、<code>LICENSE</code>。</p>
<p>文件名包含多个单词时，单词之间建议使用半角的连词线（<code>-</code>）分隔。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">反例：<span class="selector-tag">advanced_usage</span><span class="selector-class">.md</span></span><br><span class="line"></span><br><span class="line">正例：<span class="selector-tag">advanced-usage</span><span class="selector-class">.md</span></span><br></pre></td></tr></table></figure>
<h2 id="7-emoji"><a class="markdownIt-Anchor" href="#7-emoji"></a> 7. Emoji</h2>
<p>在 markdown 文档中，普遍会使用 emoji，帮助理解内容。但是，如果滥用 emoji，可能会适得其反。</p>
<p>这里，将一些比较约定俗成的 emoji 表情使用场景列举一下：</p>
<ul>
<li>💡 提示 - [推荐]</li>
<li>🔔 注意、警告 - [推荐]</li>
<li>⭕ 正确 - [推荐]</li>
<li>❌ 错误 - [推荐]</li>
<li>❓ 问题 - [推荐]</li>
<li>⛔ 禁止 - [推荐]</li>
<li>🚧 未完待续、有待补充 - [推荐]</li>
<li>📚 参考、参考资料 - [可选]</li>
<li>⌨ 源码 - [可选]</li>
</ul>
<h2 id="8-参考"><a class="markdownIt-Anchor" href="#8-参考"></a> 8. 参考</h2>
<ul>
<li><a href="http://wenku.baidu.com/view/23cc1a6527d3240c8447efbf.html" target="_blank" rel="noopener">产品手册中文写作规范</a>, by 华为</li>
<li><a href="http://docs.daocloud.io/write-docs/format" target="_blank" rel="noopener">写作规范和格式规范</a>, by DaoCloud</li>
<li><a href="http://www.hitachi-tc.co.jp/company/thesis/thesis.pdf" target="_blank" rel="noopener">技术写作技巧在日汉翻译中的应用</a>, by 刘方</li>
<li><a href="https://www.lengoo.de/documents/styleguides/lengoo_styleguide_ZH.pdf" target="_blank" rel="noopener">简体中文规范指南</a>, by lengoo</li>
<li><a href="https://open.leancloud.cn/copywriting-style-guide.html" target="_blank" rel="noopener">文档风格指南</a>, by LeanCloud</li>
<li><a href="https://docs.google.com/document/d/1R8lMCPf6zCD5KEA8ekZ5knK77iw9J-vJ6vEopPemqZM/edit" target="_blank" rel="noopener">豌豆荚文案风格指南</a>, by 豌豆荚</li>
<li><a href="https://github.com/sparanoid/chinese-copywriting-guidelines" target="_blank" rel="noopener">中文文案排版指北</a>, by sparanoid</li>
<li><a href="http://w3c.github.io/clreq/" target="_blank" rel="noopener">中文排版需求</a>, by W3C</li>
<li><a href="http://www.ruanyifeng.com/blog/2017/02/filename-should-be-lowercase.html" target="_blank" rel="noopener">为什么文件名要小写？</a>, by 阮一峰</li>
</ul>
]]></content>
      <categories>
        <category>效率提升</category>
        <category>规范</category>
      </categories>
      <tags>
        <tag>效率提升</tag>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title>军事</title>
    <url>/blog/minds/%E4%BA%BA%E6%96%87/%E5%86%9B%E4%BA%8B/README/</url>
    <content><![CDATA[<h1 id="军事"><a class="markdownIt-Anchor" href="#军事"></a> 军事</h1>
<blockquote>
<p>军事是与战争、军队、军人等有关事务的总称。</p>
</blockquote>
<h2 id="关键词"><a class="markdownIt-Anchor" href="#关键词"></a> 关键词</h2>
<p>战争、战役、战斗、战士、战略、战术、武器、兵种、进攻、防御、指挥、兵法、军衔</p>
]]></content>
  </entry>
  <entry>
    <title>计算机网络之传输层</title>
    <url>/blog/communication/network-transport/</url>
    <content><![CDATA[<blockquote>
<p>网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。</p>
</blockquote>
<h2 id="udp-和-tcp-的特点"><a class="markdownIt-Anchor" href="#udp-和-tcp-的特点"></a> UDP 和 TCP 的特点</h2>
<ul>
<li>
<p>用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。</p>
</li>
<li>
<p>传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。</p>
</li>
</ul>
<h2 id="udp-首部格式"><a class="markdownIt-Anchor" href="#udp-首部格式"></a> UDP 首部格式</h2>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/transport/1551092392065.png!zp"/></div>
<p>首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。</p>
<h2 id="tcp-首部格式"><a class="markdownIt-Anchor" href="#tcp-首部格式"></a> TCP 首部格式</h2>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/transport/1551092419042.png!zp"/></div>
<ul>
<li>
<p><strong>序号</strong> ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</p>
</li>
<li>
<p><strong>确认号</strong> ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</p>
</li>
<li>
<p><strong>数据偏移</strong> ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</p>
</li>
<li>
<p><strong>确认 ACK</strong> ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</p>
</li>
<li>
<p><strong>同步 SYN</strong> ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。</p>
</li>
<li>
<p><strong>终止 FIN</strong> ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</p>
</li>
<li>
<p><strong>窗口</strong> ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</p>
</li>
</ul>
<h2 id="tcp-的三次握手"><a class="markdownIt-Anchor" href="#tcp-的三次握手"></a> TCP 的三次握手</h2>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/transport/1551092794258.png!zp"/></div>
<p>假设 A 为客户端，B 为服务器端。</p>
<ul>
<li>
<p>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</p>
</li>
<li>
<p>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。</p>
</li>
<li>
<p>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</p>
</li>
<li>
<p>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</p>
</li>
<li>
<p>B 收到 A 的确认后，连接建立。</p>
</li>
</ul>
<p><strong>三次握手的原因</strong></p>
<p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p>
<p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p>
<h2 id="tcp-的四次挥手"><a class="markdownIt-Anchor" href="#tcp-的四次挥手"></a> TCP 的四次挥手</h2>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/transport/1551092825974.png!zp"/></div>
<p>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。</p>
<ul>
<li>
<p>A 发送连接释放报文，FIN=1。</p>
</li>
<li>
<p>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</p>
</li>
<li>
<p>当 B 不再需要连接时，发送连接释放报文，FIN=1。</p>
</li>
<li>
<p>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。</p>
</li>
<li>
<p>B 收到 A 的确认后释放连接。</p>
</li>
</ul>
<p><strong>四次挥手的原因</strong></p>
<p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p>
<p><strong>TIME_WAIT</strong></p>
<p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p>
<ul>
<li>
<p>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</p>
</li>
<li>
<p>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</p>
</li>
</ul>
<h2 id="tcp-可靠传输"><a class="markdownIt-Anchor" href="#tcp-可靠传输"></a> TCP 可靠传输</h2>
<p>TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。</p>
<p>一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下：</p>
<div align="center"><img src="https://latex.codecogs.com/gif.latex?RTTs=(1-a)*(RTTs)+a*RTT"/></div> <br>
<p>其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响。</p>
<p>超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下：</p>
<div align="center"><img src="https://latex.codecogs.com/gif.latex?RTO=RTTs+4*RTT_d"/></div> <br>
<p>其中 RTT<sub>d</sub> 为偏差的加权平均值。</p>
<h2 id="tcp-滑动窗口"><a class="markdownIt-Anchor" href="#tcp-滑动窗口"></a> TCP 滑动窗口</h2>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/transport/1551092841802.png!zp"/></div>
<p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。</p>
<p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p>
<p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p>
<h2 id="tcp-流量控制"><a class="markdownIt-Anchor" href="#tcp-流量控制"></a> TCP 流量控制</h2>
<p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。</p>
<p>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>
<h2 id="tcp-拥塞控制"><a class="markdownIt-Anchor" href="#tcp-拥塞控制"></a> TCP 拥塞控制</h2>
<p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/transport/1551092981695.png!zp"/></div>
<p>TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。</p>
<p>发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。</p>
<p>为了便于讨论，做如下假设：</p>
<ul>
<li>接收方有足够大的接收缓存，因此不会发生流量控制；</li>
<li>虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/transport/1551093119265.png!zp"/></div>
<h3 id="1-慢开始与拥塞避免"><a class="markdownIt-Anchor" href="#1-慢开始与拥塞避免"></a> 1. 慢开始与拥塞避免</h3>
<p>发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …</p>
<p>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</p>
<p>如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。</p>
<h3 id="2-快重传与快恢复"><a class="markdownIt-Anchor" href="#2-快重传与快恢复"></a> 2. 快重传与快恢复</h3>
<p>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M<sub>1</sub> 和 M<sub>2</sub>，此时收到 M<sub>4</sub>，应当发送对 M<sub>2</sub> 的确认。</p>
<p>在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M<sub>2</sub>，则 M<sub>3</sub> 丢失，立即重传 M<sub>3</sub>。</p>
<p>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。</p>
<p>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/transport/1551093167163.png!zp"/></div>
]]></content>
      <categories>
        <category>通信</category>
      </categories>
      <tags>
        <tag>通信</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>HBase</title>
    <url>/blog/bigdata/hbase/README/</url>
    <content><![CDATA[<h1 id="hbase"><a class="markdownIt-Anchor" href="#hbase"></a> HBase</h1>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li>
<li><a href="#%E5%9F%BA%E7%A1%80">基础</a></li>
<li><a href="#%E5%8E%9F%E7%90%86">原理</a>
<ul>
<li><a href="#%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B">数据模型</a></li>
<li><a href="#hbase-%E6%9E%B6%E6%9E%84">HBase 架构</a></li>
</ul>
</li>
<li><a href="#hbase-%E5%92%8C-rdbms">HBase 和 RDBMS</a></li>
<li><a href="#api">API</a></li>
<li><a href="#%E9%99%84%E5%BD%95">附录</a>
<ul>
<li><a href="#%E5%91%BD%E4%BB%A4%E8%A1%8C">命令行</a></li>
</ul>
</li>
<li><a href="#%E6%9B%B4%E5%A4%9A%E5%86%85%E5%AE%B9">更多内容</a>
<ul>
<li><a href="#%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB">扩展阅读</a></li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<p>HBase 是建立在 HDFS 基础上的面向列的分布式数据库。</p>
<ul>
<li>HBase 参考了谷歌的 BigTable 建模，实现的编程语言为 Java。</li>
<li>它是 Hadoop 项目的子项目，运行于 HDFS 文件系统之上。</li>
</ul>
<p>HBase 适用场景：实时地随机访问超大数据集。</p>
<p>在 <a href="https://zh.wikipedia.org/wiki/CAP%E5%AE%9A%E7%90%86" target="_blank" rel="noopener">CAP 理论</a>中，HBase 属于 CP 类型的系统。</p>
<h2 id="基础"><a class="markdownIt-Anchor" href="#基础"></a> 基础</h2>
<p><a href="hbase-ops.md">HBase 维护</a></p>
<h2 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h2>
<h3 id="数据模型"><a class="markdownIt-Anchor" href="#数据模型"></a> 数据模型</h3>
<p>HBase 是一个面向列的数据库，在表中它由行排序。</p>
<p>HBase 表模型结构为：</p>
<ul>
<li>表（table）是行的集合。</li>
<li>行（row）是列族的集合。</li>
<li>列族（column family）是列的集合。</li>
<li>列（row）是键值对的集合。</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/bigdata/hbase/1551164163369.png"/></div>
<p>HBase 表的单元格（cell）由行和列的坐标交叉决定，是有版本的。默认情况下，版本号是自动分配的，为 HBase 插入单元格时的时间戳。单元格的内容是未解释的字节数组。</p>
<p>行的键也是未解释的字节数组，所以理论上，任何数据都可以通过序列化表示成字符串或二进制，从而存为 HBase 的键值。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/bigdata/hbase/1551164224778.png"/></div>
<h3 id="hbase-架构"><a class="markdownIt-Anchor" href="#hbase-架构"></a> HBase 架构</h3>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/bigdata/hbase/1551164744748.png"/></div>
<p>和 HDFS、YARN 一样，HBase 也采用 master / slave 架构：</p>
<ul>
<li>HBase 有一个 master 节点。master 节点负责将区域（region）分配给 region 节点；恢复 region 节点的故障。</li>
<li>HBase 有多个 region 节点。region 节点负责零个或多个区域（region）的管理并相应客户端的读写请求。region 节点还负责区域的划分并通知 master 节点有了新的子区域。</li>
</ul>
<p>HBase 依赖 ZooKeeper 来实现故障恢复。</p>
<h4 id="regin"><a class="markdownIt-Anchor" href="#regin"></a> Regin</h4>
<p>HBase 表按行键范围水平自动划分为区域（region）。每个区域由表中行的子集构成。每个区域由它所属的表、它所含的第一行及最后一行来表示。</p>
<p><strong>区域只不过是表被拆分，并分布在区域服务器。</strong></p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/bigdata/hbase/1551165887616.png"/></div>
<h4 id="master-服务器"><a class="markdownIt-Anchor" href="#master-服务器"></a> Master 服务器</h4>
<p>区域分配、DDL(create、delete)操作由 HBase master 服务器处理。</p>
<ul>
<li>master 服务器负责协调 region 服务器
<ul>
<li>协助区域启动，出现故障恢复或负载均衡情况时，重新分配 region 服务器</li>
<li>监控集群中的所有 region 服务器</li>
</ul>
</li>
<li>支持 DDL 接口（创建、删除、更新表）</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/bigdata/hbase/1551166513572.png"/></div>
<h4 id="regin-服务器"><a class="markdownIt-Anchor" href="#regin-服务器"></a> Regin 服务器</h4>
<p>区域服务器运行在 HDFS 数据节点上，具有以下组件</p>
<ul>
<li>
<p><code>WAL</code> - Write Ahead Log 是 HDFS 上的文件。WAL 存储尚未持久存储到永久存储的新数据，它用于在发生故障时进行恢复。</p>
</li>
<li>
<p><code>BlockCache</code> - 是读缓存。它将频繁读取的数据存储在内存中。至少最近使用的数据在完整时被逐出。</p>
</li>
<li>
<p><code>MemStore</code> - 是写缓存。它存储尚未写入磁盘的新数据。在写入磁盘之前对其进行排序。每个区域每个列族有一个 MemStore。</p>
</li>
<li>
<p><code>Hfiles</code> - 将行存储为磁盘上的排序键值对。</p>
</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/bigdata/hbase/1551166602999.png"/></div>
<h4 id="zookeeper"><a class="markdownIt-Anchor" href="#zookeeper"></a> ZooKeeper</h4>
<p>HBase 使用 ZooKeeper 作为分布式协调服务来维护集群中的服务器状态。Zookeeper 维护哪些服务器是活动的和可用的，并提供服务器故障通知。集群至少应该有 3 个节点。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/bigdata/hbase/1551166447147.png"/></div>
<h2 id="hbase-和-rdbms"><a class="markdownIt-Anchor" href="#hbase-和-rdbms"></a> HBase 和 RDBMS</h2>
<table>
<thead>
<tr>
<th>HBase</th>
<th>RDBMS</th>
</tr>
</thead>
<tbody>
<tr>
<td>HBase 无模式，它不具有固定列模式的概念;仅定义列族。</td>
<td>RDBMS 有它的模式，描述表的整体结构的约束。</td>
</tr>
<tr>
<td>它专门创建为宽表。 HBase 是横向扩展。</td>
<td>这些都是细而专为小表。很难形成规模。</td>
</tr>
<tr>
<td>没有任何事务存在于 HBase。</td>
<td>RDBMS 是事务性的。</td>
</tr>
<tr>
<td>它反规范化的数据。</td>
<td>它具有规范化的数据。</td>
</tr>
<tr>
<td>它用于半结构以及结构化数据是非常好的。</td>
<td>用于结构化数据非常好。</td>
</tr>
</tbody>
</table>
<h2 id="api"><a class="markdownIt-Anchor" href="#api"></a> API</h2>
<p>Java API 归纳总结在这里：<a href="hbase-api-java.md">Hbase Java API</a></p>
<h2 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> 附录</h2>
<h3 id="命令行"><a class="markdownIt-Anchor" href="#命令行"></a> 命令行</h3>
<p>HBase 命令行可以参考这里：<a href="hbase-cli.md">HBase 命令行</a></p>
<h2 id="更多内容"><a class="markdownIt-Anchor" href="#更多内容"></a> 更多内容</h2>
<h3 id="扩展阅读"><a class="markdownIt-Anchor" href="#扩展阅读"></a> 扩展阅读</h3>
<ul>
<li><a href="hbase-cli.md">HBase 命令</a></li>
<li><a href="hbase-ops.md">HBase 配置</a></li>
</ul>
<h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3>
<h4 id="官方"><a class="markdownIt-Anchor" href="#官方"></a> 官方</h4>
<ul>
<li><a href="http://hbase.apache.org/" target="_blank" rel="noopener">HBase 官网</a></li>
<li><a href="https://hbase.apache.org/book.html" target="_blank" rel="noopener">HBase 官方文档</a></li>
<li><a href="http://abloz.com/hbase/book.html" target="_blank" rel="noopener">HBase 官方文档中文版</a></li>
<li><a href="https://hbase.apache.org/apidocs/index.html" target="_blank" rel="noopener">HBase API</a></li>
</ul>
<h4 id="文章"><a class="markdownIt-Anchor" href="#文章"></a> 文章</h4>
<ul>
<li><a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/bigtable-osdi06.pdf" target="_blank" rel="noopener">Bigtable: A Distributed Storage System for Structured Data</a></li>
<li><a href="https://mapr.com/blog/in-depth-look-hbase-architecture/" target="_blank" rel="noopener">https://mapr.com/blog/in-depth-look-hbase-architecture/</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>HBase Java API</title>
    <url>/blog/bigdata/hbase/hbase-api-java/</url>
    <content><![CDATA[<h1 id="hbase-java-api"><a class="markdownIt-Anchor" href="#hbase-java-api"></a> HBase Java API</h1>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#%E6%9B%B4%E5%A4%9A%E5%86%85%E5%AE%B9">更多内容</a>
<ul>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h2 id="更多内容"><a class="markdownIt-Anchor" href="#更多内容"></a> 更多内容</h2>
<blockquote>
<p>📓 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p>
</blockquote>
<h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3>
<p><a href="https://blog.csdn.net/jiyiqinlovexx/article/details/36526433" target="_blank" rel="noopener">https://blog.csdn.net/jiyiqinlovexx/article/details/36526433</a><br />
<a href="https://blog.csdn.net/u010967382/article/details/38046821" target="_blank" rel="noopener">https://blog.csdn.net/u010967382/article/details/38046821</a></p>
]]></content>
  </entry>
  <entry>
    <title>HBase 维护</title>
    <url>/blog/bigdata/hbase/hbase-ops/</url>
    <content><![CDATA[<h1 id="hbase-维护"><a class="markdownIt-Anchor" href="#hbase-维护"></a> HBase 维护</h1>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">配置文件</a></li>
<li><a href="#%E7%8E%AF%E5%A2%83%E8%A6%81%E6%B1%82">环境要求</a></li>
<li><a href="#%E5%BC%95%E7%94%A8%E5%92%8C%E5%BC%95%E7%94%B3">引用和引申</a>
<ul>
<li><a href="#%E5%BC%95%E7%94%B3">引申</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h2 id="配置文件"><a class="markdownIt-Anchor" href="#配置文件"></a> 配置文件</h2>
<ul>
<li><code>backup-masters</code> - 默认情况下不存在。列出主服务器应在其上启动备份主进程的主机，每行一个主机。</li>
<li><code>hadoop-metrics2-hbase.properties</code> - 用于连接 HBase Hadoop 的 Metrics2 框架。</li>
<li><code>hbase-env.cmd</code> and <a href="http://hbase-env.sh" target="_blank" rel="noopener">hbase-env.sh</a> - 用于 Windows 和 Linux / Unix 环境的脚本，用于设置 HBase 的工作环境，包括 Java，Java 选项和其他环境变量的位置。</li>
<li><code>hbase-policy.xml</code> - RPC 服务器用于对客户端请求进行授权决策的默认策略配置文件。仅在启用 HBase 安全性时使用。</li>
<li><code>hbase-site.xml</code> - 主要的 HBase 配置文件。此文件指定覆盖 HBase 默认配置的配置选项。您可以在 docs / hbase-default.xml 中查看（但不要编辑）默认配置文件。您还可以在 HBase Web UI 的 HBase 配置选项卡中查看群集的整个有效配置（默认值和覆盖）。</li>
<li><code>log4j.properties</code> - log4j 日志配置。</li>
<li><code>regionservers</code> - 包含应在 HBase 集群中运行 RegionServer 的主机列表。默认情况下，此文件包含单个条目 localhost。它应包含主机名或 IP 地址列表，每行一个，并且如果群集中的每个节点将在其 localhost 接口上运行 RegionServer，则应仅包含 localhost。</li>
</ul>
<h2 id="环境要求"><a class="markdownIt-Anchor" href="#环境要求"></a> 环境要求</h2>
<ul>
<li>Java
<ul>
<li>HBase 2.0+ 要求 JDK8+</li>
<li>HBase 1.2+ 要求 JDK7+</li>
</ul>
</li>
<li>SSH - 环境要支持 SSH</li>
<li>DNS - 环境中要在 hosts 配置本机 hostname 和本机 IP</li>
<li>NTP - HBase 集群的时间要同步，可以配置统一的 NTP</li>
<li>平台 - 生产环境不推荐部署在 Windows 系统中</li>
<li>Hadoop - 依赖 Hadoop 配套版本</li>
<li>Zookeeper - 依赖 Zookeeper 配套版本</li>
</ul>
<h2 id="运行模式"><a class="markdownIt-Anchor" href="#运行模式"></a> 运行模式</h2>
<h3 id="单点"><a class="markdownIt-Anchor" href="#单点"></a> 单点</h3>
<p>hbase-site.xml 配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.rootdir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://namenode.example.org:8020/hbase<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.cluster.distributed<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="分布式"><a class="markdownIt-Anchor" href="#分布式"></a> 分布式</h3>
<p>hbase-site.xm 配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.rootdir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://namenode.example.org:8020/hbase<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.cluster.distributed<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.quorum<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>node-a.example.com,node-b.example.com,node-c.example.com<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="引用和引申"><a class="markdownIt-Anchor" href="#引用和引申"></a> 引用和引申</h2>
<h3 id="扩展阅读"><a class="markdownIt-Anchor" href="#扩展阅读"></a> 扩展阅读</h3>
<ul>
<li><a href="http://hbase.apache.org/book.html#configuration" target="_blank" rel="noopener">Apache HBase Configuration</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>HBase 命令</title>
    <url>/blog/bigdata/hbase/hbase-cli/</url>
    <content><![CDATA[<h1 id="hbase-命令"><a class="markdownIt-Anchor" href="#hbase-命令"></a> HBase 命令</h1>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#1-%E8%BF%9E%E6%8E%A5-hbase">1. 连接 HBase</a></li>
<li><a href="#2-%E6%9F%A5%E8%AF%A2%E5%B8%AE%E5%8A%A9">2. 查询帮助</a></li>
<li><a href="#3-%E5%88%9B%E5%BB%BA%E8%A1%A8">3. 创建表</a></li>
<li><a href="#4-%E6%9F%A5%E7%9C%8B%E8%A1%A8%E4%BF%A1%E6%81%AF">4. 查看表信息</a></li>
<li><a href="#5-%E6%9F%A5%E7%9C%8B%E8%A1%A8%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF">5. 查看表详细信息</a></li>
<li><a href="#6-%E5%90%91%E8%A1%A8%E4%B8%AD%E5%86%99%E6%95%B0%E6%8D%AE">6. 向表中写数据</a></li>
<li><a href="#7-%E6%89%AB%E6%8F%8F%E8%A1%A8">7. 扫描表</a></li>
<li><a href="#8-%E6%9F%A5%E8%AF%A2-row">8. 查询 row</a></li>
<li><a href="#9-%E7%A6%81%E7%94%A8%E5%90%AF%E7%94%A8%E8%A1%A8">9. 禁用、启用表</a></li>
<li><a href="#10-%E5%88%A0%E9%99%A4%E8%A1%A8">10. 删除表</a></li>
<li><a href="#11-%E5%81%9C%E6%AD%A2-hbase">11. 停止 HBase</a></li>
</ul>
<!-- /TOC -->
<h2 id="1-连接-hbase"><a class="markdownIt-Anchor" href="#1-连接-hbase"></a> 1. 连接 HBase</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./bin/hbase shell</span><br><span class="line">hbase(main):001:0&gt;</span><br></pre></td></tr></table></figure>
<h2 id="2-查询帮助"><a class="markdownIt-Anchor" href="#2-查询帮助"></a> 2. 查询帮助</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">help</span></span><br></pre></td></tr></table></figure>
<h2 id="3-创建表"><a class="markdownIt-Anchor" href="#3-创建表"></a> 3. 创建表</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create <span class="string">'table1'</span>,<span class="string">'columnFamliy1'</span>,<span class="string">'columnFamliy2'</span></span><br></pre></td></tr></table></figure>
<p>说明：</p>
<p>创建一张名为 table1 的 HBase 表，columnFamliy1、columnFamliy2 是 table1 表的列族。</p>
<h2 id="4-查看表信息"><a class="markdownIt-Anchor" href="#4-查看表信息"></a> 4. 查看表信息</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">list <span class="string">'table1'</span></span><br></pre></td></tr></table></figure>
<h2 id="5-查看表详细信息"><a class="markdownIt-Anchor" href="#5-查看表详细信息"></a> 5. 查看表详细信息</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">describe <span class="string">'table1'</span></span><br></pre></td></tr></table></figure>
<h2 id="6-向表中写数据"><a class="markdownIt-Anchor" href="#6-向表中写数据"></a> 6. 向表中写数据</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">put <span class="string">'table1'</span>, <span class="string">'row1'</span>, <span class="string">'columnFamliy1:a'</span>, <span class="string">'valueA'</span></span><br><span class="line">put <span class="string">'table1'</span>, <span class="string">'row1'</span>, <span class="string">'columnFamliy1:b'</span>, <span class="string">'valueB'</span></span><br><span class="line">put <span class="string">'table1'</span>, <span class="string">'row1'</span>, <span class="string">'columnFamliy1:c'</span>, <span class="string">'valueC'</span></span><br><span class="line"></span><br><span class="line">put <span class="string">'table1'</span>, <span class="string">'row2'</span>, <span class="string">'columnFamliy1:a'</span>, <span class="string">'valueA'</span></span><br><span class="line">put <span class="string">'table1'</span>, <span class="string">'row2'</span>, <span class="string">'columnFamliy1:b'</span>, <span class="string">'valueB'</span></span><br><span class="line">put <span class="string">'table1'</span>, <span class="string">'row2'</span>, <span class="string">'columnFamliy1:c'</span>, <span class="string">'valueC'</span></span><br><span class="line"></span><br><span class="line">put <span class="string">'table1'</span>, <span class="string">'row1'</span>, <span class="string">'columnFamliy2:a'</span>, <span class="string">'valueA'</span></span><br><span class="line">put <span class="string">'table1'</span>, <span class="string">'row1'</span>, <span class="string">'columnFamliy2:b'</span>, <span class="string">'valueB'</span></span><br><span class="line">put <span class="string">'table1'</span>, <span class="string">'row1'</span>, <span class="string">'columnFamliy2:c'</span>, <span class="string">'valueC'</span></span><br></pre></td></tr></table></figure>
<h2 id="7-扫描表"><a class="markdownIt-Anchor" href="#7-扫描表"></a> 7. 扫描表</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hbase&gt; scan <span class="string">'hbase:meta'</span></span><br><span class="line">hbase&gt; scan <span class="string">'hbase:meta'</span>, &#123;COLUMNS =&gt; <span class="string">'info:regioninfo'</span>&#125;</span><br><span class="line">hbase&gt; scan <span class="string">'ns1:</span></span><br><span class="line"><span class="string">hbase&gt; scan '</span>t1<span class="string">', &#123;COLUMNS =&gt; ['</span>c1<span class="string">', '</span>c2<span class="string">'], LIMIT =&gt; 10, STARTROW =&gt; '</span>xyz<span class="string">'&#125;</span></span><br><span class="line"><span class="string">hbase&gt; scan '</span>t1<span class="string">', &#123;COLUMNS =&gt; '</span>c1<span class="string">', TIMERANGE =&gt; [1303668804, 1303668904]&#125;</span></span><br><span class="line"><span class="string">hbase&gt; scan '</span>t1<span class="string">', &#123;REVERSED =&gt; true&#125;</span></span><br><span class="line"><span class="string">hbase&gt; scan '</span>t1<span class="string">', &#123;ALL_METRICS =&gt; true&#125;</span></span><br><span class="line"><span class="string">hbase&gt; scan '</span>t1<span class="string">', &#123;METRICS =&gt; ['</span>RPC_RETRIES<span class="string">', '</span>ROWS_FILTERED<span class="string">']&#125;</span></span><br><span class="line"><span class="string">hbase&gt; scan '</span>t1<span class="string">', &#123;ROWPREFIXFILTER =&gt; '</span>row2<span class="string">', FILTER =&gt; "</span></span><br><span class="line"><span class="string">  (QualifierFilter (&gt;=, '</span>binary:xyz<span class="string">')) AND (TimestampsFilter ( 123, 456))"&#125;</span></span><br><span class="line"><span class="string">hbase&gt; scan '</span>t1<span class="string">', &#123;FILTER =&gt;</span></span><br><span class="line"><span class="string">  org.apache.hadoop.hbase.filter.ColumnPaginationFilter.new(1, 0)&#125;</span></span><br><span class="line"><span class="string">hbase&gt; scan '</span>t1<span class="string">', &#123;CONSISTENCY =&gt; '</span>TIMELINE<span class="string">'&#125;</span></span><br><span class="line"><span class="string">For setting the Operation Attributes </span></span><br><span class="line"><span class="string">hbase&gt; scan '</span>t1<span class="string">', &#123; COLUMNS =&gt; ['</span>c1<span class="string">', '</span>c2<span class="string">'], ATTRIBUTES =&gt; &#123;'</span>mykey<span class="string">' =&gt; '</span>myvalue<span class="string">'&#125;&#125;</span></span><br><span class="line"><span class="string">hbase&gt; scan '</span>t1<span class="string">', &#123; COLUMNS =&gt; ['</span>c1<span class="string">', '</span>c2<span class="string">'], AUTHORIZATIONS =&gt; ['</span>PRIVATE<span class="string">','</span>SECRET<span class="string">']&#125;</span></span><br><span class="line"><span class="string">For experts, there is an additional option -- CACHE_BLOCKS -- which</span></span><br><span class="line"><span class="string">switches block caching for the scanner on (true) or off (false).  By</span></span><br><span class="line"><span class="string">default it is enabled.  Examples:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">hbase&gt; scan '</span>t1<span class="string">', &#123;COLUMNS =&gt; ['</span>c1<span class="string">', '</span>c2<span class="string">'], CACHE_BLOCKS =&gt; false&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="8-查询-row"><a class="markdownIt-Anchor" href="#8-查询-row"></a> 8. 查询 row</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">get <span class="string">'table1'</span>, <span class="string">'row1'</span></span><br><span class="line">get <span class="string">'table1'</span>, <span class="string">'row1'</span>, <span class="string">'columnFamliy1'</span></span><br><span class="line">get <span class="string">'table1'</span>, <span class="string">'row1'</span>, <span class="string">'columnFamliy1:a'</span></span><br></pre></td></tr></table></figure>
<h2 id="9-禁用-启用表"><a class="markdownIt-Anchor" href="#9-禁用-启用表"></a> 9. 禁用、启用表</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hbase(main):008:0&gt; <span class="built_in">disable</span> <span class="string">'test'</span></span><br><span class="line">0 row(s) <span class="keyword">in</span> 1.1820 seconds</span><br><span class="line"></span><br><span class="line">hbase(main):009:0&gt; <span class="built_in">enable</span> <span class="string">'test'</span></span><br><span class="line">0 row(s) <span class="keyword">in</span> 0.1770 seconds</span><br></pre></td></tr></table></figure>
<h2 id="10-删除表"><a class="markdownIt-Anchor" href="#10-删除表"></a> 10. 删除表</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hbase(main):011:0&gt; drop <span class="string">'test'</span></span><br><span class="line">0 row(s) <span class="keyword">in</span> 0.1370 seconds</span><br></pre></td></tr></table></figure>
<h2 id="11-停止-hbase"><a class="markdownIt-Anchor" href="#11-停止-hbase"></a> 11. 停止 HBase</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./bin/stop-hbase.sh</span><br><span class="line">stopping hbase....................</span><br><span class="line">$</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>HDFS 命令</title>
    <url>/blog/bigdata/hdfs/hdfs-cli/</url>
    <content><![CDATA[<h1 id="hdfs-命令"><a class="markdownIt-Anchor" href="#hdfs-命令"></a> HDFS 命令</h1>
<ul>
<li>列出目录的内容：</li>
</ul>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>hdfs dfs -ls /</span><br></pre></td></tr></table></figure>
<ul>
<li>将文件从本地文件系统加载到HDFS：</li>
</ul>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> hdfs dfs -<span class="keyword">put</span> songs.txt /user/adam</span><br></pre></td></tr></table></figure>
<ul>
<li>从HDFS读取文件内容：</li>
</ul>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">$ hdfs dfs -cat <span class="regexp">/user/</span>adam<span class="regexp">/songs.txt</span></span><br></pre></td></tr></table></figure>
<ul>
<li>更改文件的权限：</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ hdfs dfs -chmod <span class="number">700</span> /user/adam/songs.txt</span><br></pre></td></tr></table></figure>
<ul>
<li>将文件的复制因子设置为4：</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ hdfs dfs -setrep -w <span class="number">4</span> /user/adam/songs.txt</span><br></pre></td></tr></table></figure>
<ul>
<li>检查文件的大小：</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">$ hdfs dfs -du -h /user/adam/songs.txt Create a subdirectory in your <span class="built_in">home</span> directory.</span><br><span class="line">$ hdfs dfs -<span class="built_in">mkdir</span> songs</span><br></pre></td></tr></table></figure>
<p>注意，相对路径总是引用执行命令的用户的主目录。HDFS上没有“当前”目录的概念（换句话说，没有“CD”命令）：</p>
<ul>
<li>
<p>将文件移到新创建的子目录：</p>
<p>$ hdfs dfs -mv songs.txt songs</p>
</li>
<li>
<p>从HDFS中删除一个目录：</p>
<p>$ hdfs dfs -rm -r songs</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>计算机网络之数据链路层</title>
    <url>/blog/communication/network-data-link/</url>
    <content><![CDATA[<blockquote>
<p><strong>数据链路层（Data Link Layer）</strong> - 网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。</p>
<ul>
<li>主要协议：<code>PPP</code>、<code>CSMA/CD</code> 等。</li>
<li>数据单元：帧（frame）。</li>
<li>典型设备：二层交换机、网桥、网卡。</li>
</ul>
</blockquote>
<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<ul>
<li>链路是从一个节点到相邻节点的一段物理线路，数据链路则是在链路的基础上增加了一些必要的硬件（网络适配器）和软件（协议）。</li>
<li>数据链路层三个基本问题：封装成帧、透明传输、差错检测。</li>
<li>数据链路层有两种信道类型：点对点信道（主要使用 <code>PPP</code>）和广播信道（主要使用 <code>CSMA/CD</code>）。</li>
<li>以太网 MAC 层的地址。</li>
<li>适配器、转发器、集线器、网桥、以太网交换机的作用及使用场合。</li>
</ul>
<h2 id="基本问题"><a class="markdownIt-Anchor" href="#基本问题"></a> 基本问题</h2>
<h3 id="封装成帧"><a class="markdownIt-Anchor" href="#封装成帧"></a> 封装成帧</h3>
<p>为网络层传下来的 IP 数据报添加首部和尾部，用于标记帧的开始和结束。</p>
<p>为了提高传输效率，应该让数据部分长度尽可能大于首部和尾部。但是，每种链路层协议都限制了帧的数据部分长度上线——最大传送单元 MTU（Maximum Transfer Unit）</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/data-link/数据链路帧.png!zp"/></div>
<h3 id="透明传输"><a class="markdownIt-Anchor" href="#透明传输"></a> 透明传输</h3>
<p><strong>透明</strong>表示：某一个实际存在的事物看起来好像不存在一样。</p>
<p>帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/data-link/经过字节填充后发送的数据.png!zp"/></div>
<h3 id="差错检测"><a class="markdownIt-Anchor" href="#差错检测"></a> 差错检测</h3>
<p>目前数据链路层广泛使用了<a href="https://zh.wikipedia.org/wiki/%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A3%80%E9%AA%8C" target="_blank" rel="noopener"><strong>循环冗余检验 CRC（Cyclic redundancy check）</strong></a>来检查比特差错。</p>
<h2 id="点对点信道"><a class="markdownIt-Anchor" href="#点对点信道"></a> 点对点信道</h2>
<p>点对点信道使用一对一的点对点通信方式。</p>
<p>对于点对点的链路，点对点协议 PPP（Point-to-Point Protocol）是使用最广泛的数据链路层协议。</p>
<h3 id="ppp-协议"><a class="markdownIt-Anchor" href="#ppp-协议"></a> PPP 协议</h3>
<p>互联网用户通常都要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/data-link/PPP协议.png!zp"/></div>
<p>PPP（点到点协议）是为在同等单元之间传输数据包这样的简单链路设计的链路层协议。这种链路提供全双工操作，并按照顺序传递数据包。设计目的主要是用来通过拨号或专线方式建立点对点连接发送数据，使其成为各种主机、网桥和路由器之间简单连接的一种共通的解决方案。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/data-link/PPP帧.png!zp"/></div>
<p>PPP 的帧格式：</p>
<ul>
<li>F 字段为帧的定界符</li>
<li>A 和 C 字段暂时没有意义</li>
<li>FCS 字段是使用 CRC 的检验序列</li>
<li>信息部分的长度不超过 1500</li>
</ul>
<h2 id="广播信道"><a class="markdownIt-Anchor" href="#广播信道"></a> 广播信道</h2>
<p>广播信道(broadcast channel)是通过广播的方式传输信息的信息通道。</p>
<p>所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。</p>
<p>主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用 CSMA/CD 协议。</p>
<h3 id="csmacd-协议"><a class="markdownIt-Anchor" href="#csmacd-协议"></a> CSMA/CD 协议</h3>
<p>CSMA/CD（Carrier Sense Multiple Access with Collision Detection）即带冲突检测的载波监听多路访问技术(载波监听多点接入/碰撞检测)。</p>
<ul>
<li><strong>多点接入</strong> ：说明这是总线型网络，许多计算机以多点接入的方式连接在一根总线上。</li>
<li><strong>载波监听</strong> ：每个主机都必须不停地监听信道。发送前监听，如果忙则等待，如果空闲则发送。</li>
<li><strong>碰撞检测</strong> ：即边发送边检测。若检测到信道有干扰信号，则表示产生了碰撞，于是就要停止发送数据，计算出退避等待时间，然后使用 CSMA 方法继续尝试发送。计算退避等待时间采用的是<a href="https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%8C%87%E6%95%B0%E9%80%80%E9%81%BF%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">二进制指数退避算法</a>。</li>
</ul>
<h2 id="局域网"><a class="markdownIt-Anchor" href="#局域网"></a> 局域网</h2>
<p>局域网 LAN（Local Area Network）是指在某一区域内由多台计算机互联成的计算机组。</p>
<p>局域网的拓扑结构通常为总线型和环型。</p>
<p>局域网技术主要有：以太网、令牌环网、FDDI 网和无线局域网等。</p>
<h2 id="以太网"><a class="markdownIt-Anchor" href="#以太网"></a> 以太网</h2>
<p>以太网（Ethernet）是一种星型拓扑结构局域网。</p>
<p>以太网是目前应用最广泛的局域网。</p>
<p>以太网使用 CSMA/CD 协议。</p>
<h2 id="mac-地址"><a class="markdownIt-Anchor" href="#mac-地址"></a> MAC 地址</h2>
<p>MAC 地址（Media Access Control Address），也称为以太网地址或物理地址，它是一个用来确认网上设备位置的地址。</p>
<p>MAC 地址长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。</p>
<p>一台主机拥有多少个网络适配器就有多少个 MAC 地址。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/data-link/MAC帧.png!zp"/></div>
<h2 id="设备"><a class="markdownIt-Anchor" href="#设备"></a> 设备</h2>
<h3 id="适配器"><a class="markdownIt-Anchor" href="#适配器"></a> 适配器</h3>
<p>网络适配器一般指网卡。</p>
<p>网卡是工作在链路层的网络组件，是局域网中连接计算机和传输介质的接口，不仅能实现与局域网传输介质之间的物理连接和电信号匹配，还涉及帧的发送与接收、帧的封装与拆封、介质访问控制、数据的编码与解码以及数据缓存的功能等。</p>
<p>网卡和局域网之间的通信是通过电缆或双绞线以串行传输方式进行的。而网卡和计算机之间的通信则是通过计算机主板上的 I/O 总线以并行传输方式进行。</p>
<h3 id="集线器"><a class="markdownIt-Anchor" href="#集线器"></a> 集线器</h3>
<p>集线器（Hub）的主要功能是对接收到的信号进行再生整形放大，以扩大网络的传输距离，同时把所有节点集中在以它为中心的节点上。</p>
<p>使用集线器可以在物理层扩展以太网。</p>
<h3 id="网桥"><a class="markdownIt-Anchor" href="#网桥"></a> 网桥</h3>
<p>网桥（Bridge）是早期的两端口二层网络设备，用来连接不同网段。网桥的两个端口分别有一条独立的交换信道，不是共享一条背板总线，可隔离冲突域。网桥比集线器（Hub）性能更好，集线器上各端口都是共享同一条背板总线的。后来，网桥被具有更多端口、同时也可隔离冲突域的交换机（Switch）所取代。</p>
<h3 id="以太网交换机"><a class="markdownIt-Anchor" href="#以太网交换机"></a> 以太网交换机</h3>
<p>以太网交换机是基于以太网传输数据的交换机，以太网采用共享总线型传输媒体方式的局域网。以太网交换机的结构是每个端口都直接与主机相连，并且一般都工作在全双工方式。交换机能同时连通许多对端口，使每一对相互通信的主机都能像独占通信媒体那样，进行无冲突地传输数据。</p>
<ul>
<li>以太网交换机的每个端口都直接与主机相连，并且一般都工作在全双工方式。</li>
<li>交换机能同时连通许多对的端口，使每一对相互通信的主机都能像独占通信媒体那样，进行无冲突地传输数据。</li>
<li>用户独占传输媒体的带宽，若一个接口到主机的带宽是 10Mbit 每秒，那么有 10 个接口的交换机的总容量是 100Mbit 每秒。这是交换机的最大优点。</li>
</ul>
]]></content>
      <categories>
        <category>通信</category>
      </categories>
      <tags>
        <tag>通信</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络之网络层</title>
    <url>/blog/communication/network-network/</url>
    <content><![CDATA[<blockquote>
<p><strong>网络层（network layer）</strong> - 为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。</p>
<ul>
<li>主要协议：<code>IP</code>、<code>ICMP</code>。</li>
<li>数据单元：IP 数据报（packet）。</li>
<li>典型设备：网关、路由器。</li>
</ul>
</blockquote>
<h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2>
<p>网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。网络层不提供服务质量的承诺，不保证分组交付的时限，所传送的分组可能出错、丢失、重复和失序。进程间通信的可靠性由运输层负责。</p>
<h2 id="ip-协议"><a class="markdownIt-Anchor" href="#ip-协议"></a> IP 协议</h2>
<p>网际协议 IP (Internet Protocol) 定义了三种功能：</p>
<ol>
<li>IP 定义了在 TCP/IP 互联网上数据传送的基本单元和数据格式。</li>
<li>IP 软件完成路由选择功能，选择数据传送的路径。</li>
<li>IP 包含了一组不可靠分组传送的规则，指明了分组处理、差错信息发生以及分组的规则。</li>
</ol>
<h3 id="相关协议"><a class="markdownIt-Anchor" href="#相关协议"></a> 相关协议</h3>
<p>与 IP 协议配套使用的还有三个协议：</p>
<ul>
<li>地址解析协议 ARP（Address Resolution Protocol）</li>
<li>网际控制报文协议 ICMP（Internet Control Message Protocol）</li>
<li>网际组管理协议 IGMP（Internet Group Management Protocol）</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/network/1550912617336.png!zp"/></div>
<h3 id="分类的-ip-地址"><a class="markdownIt-Anchor" href="#分类的-ip-地址"></a> 分类的 IP 地址</h3>
<p>IP 地址的编址方式经历了三个历史阶段：</p>
<ul>
<li>分类</li>
<li>子网划分</li>
<li>无分类</li>
</ul>
<h4 id="1-分类"><a class="markdownIt-Anchor" href="#1-分类"></a> 1. 分类</h4>
<p>由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。</p>
<figure class="highlight bnf"><table><tr><td class="code"><pre><span class="line">IP 地址 ::= &#123;&lt; 网络号 &gt;, &lt; 主机号 &gt;&#125;</span><br></pre></td></tr></table></figure>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/network/1551086738403.png!zp"/></div>
<h4 id="2-子网划分"><a class="markdownIt-Anchor" href="#2-子网划分"></a> 2. 子网划分</h4>
<p>通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。</p>
<figure class="highlight bnf"><table><tr><td class="code"><pre><span class="line">IP 地址 ::= &#123;&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;&#125;</span><br></pre></td></tr></table></figure>
<p>要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。</p>
<p>注意，外部网络看不到子网的存在。</p>
<h4 id="3-无分类"><a class="markdownIt-Anchor" href="#3-无分类"></a> 3. 无分类</h4>
<p>无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。</p>
<figure class="highlight bnf"><table><tr><td class="code"><pre><span class="line">IP 地址 ::= &#123;&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;&#125;</span><br></pre></td></tr></table></figure>
<p>CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。</p>
<p>CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。</p>
<p>一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 <strong>构成超网</strong> 。</p>
<p>在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。</p>
<h3 id="ip-地址与物理地址"><a class="markdownIt-Anchor" href="#ip-地址与物理地址"></a> IP 地址与物理地址</h3>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/network/1551088476626.png!zp"/></div>
<ul>
<li>物理地址是数据链路层和物理层使用的地址。</li>
<li>IP 地址是网络层和以上各层使用的地址，是一种逻辑地址。</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/network/1551088631948.png!zp"/></div>
<h3 id="ip-数据报格式"><a class="markdownIt-Anchor" href="#ip-数据报格式"></a> IP 数据报格式</h3>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/network/1550913213250.png!zp"/></div>
<ul>
<li><strong>版本</strong> - 有 4（IPv4）和 6（IPv6）两个值。</li>
<li><strong>首部长度</strong> - 占 4 位，因此最大十进制数值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为首部固定长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</li>
<li><strong>区分服务</strong> - 用来获得更好的服务，一般情况下不使用。</li>
<li><strong>总长度</strong> - 包括首部长度和数据部分长度。占 16 位，因此数据报的最大长度为 2 <sup>16</sup> - 1 = 65535 字节。</li>
<li><strong>生存时间</strong> - TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</li>
<li><strong>协议</strong> - 指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</li>
<li><strong>首部检验和</strong> - 因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。</li>
<li><strong>标识</strong> - 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</li>
<li><strong>片偏移</strong> - 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/network/1550913364479.png!zp"/></div>
<h2 id="地址解析协议-arp"><a class="markdownIt-Anchor" href="#地址解析协议-arp"></a> 地址解析协议 ARP</h2>
<p>网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/network/1551086787261.png!zp"/></div>
<p>ARP 实现由 IP 地址得到 MAC 地址。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/network/1551086769846.png!zp"/></div>
<p>每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。</p>
<p>如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/network/1551086833117.png!zp"/></div>
<h2 id="网际控制报文协议-icmp"><a class="markdownIt-Anchor" href="#网际控制报文协议-icmp"></a> 网际控制报文协议 ICMP</h2>
<p>ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/network/1551086857345.png!zp"/></div>
<p>ICMP 报文分为差错报告报文和询问报文。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/network/1551086870897.png!zp"/></div>
<h3 id="1-ping"><a class="markdownIt-Anchor" href="#1-ping"></a> 1. Ping</h3>
<p>Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。</p>
<p>Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。</p>
<h3 id="2-traceroute"><a class="markdownIt-Anchor" href="#2-traceroute"></a> 2. Traceroute</h3>
<p>Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。</p>
<p>Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。</p>
<ul>
<li>源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；</li>
<li>源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。</li>
<li>不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。</li>
<li>之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</li>
</ul>
<h2 id="虚拟专用网-vpn"><a class="markdownIt-Anchor" href="#虚拟专用网-vpn"></a> 虚拟专用网 VPN</h2>
<p>由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。</p>
<p>有三个专用地址块：</p>
<ul>
<li>10.0.0.0 ~ 10.255.255.255</li>
<li>172.16.0.0 ~ 172.31.255.255</li>
<li>192.168.0.0 ~ 192.168.255.255</li>
</ul>
<p>VPN 使用公用的互联网作为本机构各专用网之间的通信载体。专用指机构内的主机只与本机构内的其它主机通信；虚拟指好像是，而实际上并不是，它有经过公用的互联网。</p>
<p>下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/network/1551086901339.png!zp"/></div>
<h2 id="网络地址转换-nat"><a class="markdownIt-Anchor" href="#网络地址转换-nat"></a> 网络地址转换 NAT</h2>
<p>专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。</p>
<p>在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。</p>
<h2 id="路由器的结构"><a class="markdownIt-Anchor" href="#路由器的结构"></a> 路由器的结构</h2>
<p>路由器从功能上可以划分为：路由选择和分组转发。</p>
<p>分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/network/1551086930371.png!zp"/></div>
<h2 id="路由器分组转发流程"><a class="markdownIt-Anchor" href="#路由器分组转发流程"></a> 路由器分组转发流程</h2>
<ul>
<li>从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。</li>
<li>若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付；</li>
<li>若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器；</li>
<li>若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；</li>
<li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；</li>
<li>报告转发分组出错。</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/network/1551086952828.png!zp"/></div>
<h2 id="路由选择协议"><a class="markdownIt-Anchor" href="#路由选择协议"></a> 路由选择协议</h2>
<p>路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。</p>
<p>互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。</p>
<p>可以把路由选择协议划分为两大类：</p>
<ul>
<li>自治系统内部的路由选择：RIP 和 OSPF</li>
<li>自治系统间的路由选择：BGP</li>
</ul>
<h3 id="1-内部网关协议-rip"><a class="markdownIt-Anchor" href="#1-内部网关协议-rip"></a> 1. 内部网关协议 RIP</h3>
<p>RIP 是一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。</p>
<p>RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。</p>
<p>距离向量算法：</p>
<ul>
<li>对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1；</li>
<li>对修改后的 RIP 报文中的每一个项目，进行以下步骤：</li>
<li>若原来的路由表中没有目的网络 N，则把该项目添加到路由表中；</li>
<li>否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。</li>
<li>若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。</li>
</ul>
<p>RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。</p>
<h3 id="2-内部网关协议-ospf"><a class="markdownIt-Anchor" href="#2-内部网关协议-ospf"></a> 2. 内部网关协议 OSPF</h3>
<p>开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。</p>
<p>开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。</p>
<p>OSPF 具有以下特点：</p>
<ul>
<li>向本自治系统中的所有路由器发送信息，这种方法是洪泛法。</li>
<li>发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。</li>
<li>只有当链路状态发生变化时，路由器才会发送信息。</li>
</ul>
<p>所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。</p>
<h3 id="3-外部网关协议-bgp"><a class="markdownIt-Anchor" href="#3-外部网关协议-bgp"></a> 3. 外部网关协议 BGP</h3>
<p>BGP（Border Gateway Protocol，边界网关协议）</p>
<p>AS 之间的路由选择很困难，主要是由于：</p>
<ul>
<li>互联网规模很大；</li>
<li>各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量；</li>
<li>AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。</li>
</ul>
<p>BGP 只能寻找一条比较好的路由，而不是最佳路由。</p>
<p>每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/network/1551086977310.png!zp"/></div>
]]></content>
      <categories>
        <category>通信</category>
      </categories>
      <tags>
        <tag>通信</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络之应用层</title>
    <url>/blog/communication/network-application/</url>
    <content><![CDATA[<h2 id="http"><a class="markdownIt-Anchor" href="#http"></a> HTTP</h2>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/application/1551096916007.png!zp"/></div>
<p>超文本传输协议（英语：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP 是万维网的数据通信的基础。</p>
<p>设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。通过 HTTP 或者 HTTPS 协议请求的资源由统一资源标识符（Uniform Resource Identifiers，URI）来标识。</p>
<p>安全套接字层超文本传输协议 HTTPS 为了数据传输的安全，HTTPS 在 HTTP 的基础上加入了 SSL 协议，SSL 依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p>
<blockquote>
<p>👉 扩展阅读：<a href="HTTP.md">HTTP</a></p>
</blockquote>
<h2 id="dns"><a class="markdownIt-Anchor" href="#dns"></a> DNS</h2>
<p>域名服务器 DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/application/1551094759786.png!zp"/></div>
<p>域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/application/1551094954067.png!zp"/></div>
<p>DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传来保证可靠性。在两种情况下会使用 TCP 进行传输：</p>
<ul>
<li>如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。</li>
<li>区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。</li>
</ul>
<blockquote>
<p>👉 扩展阅读：<a href="DNS.md">DNS</a></p>
</blockquote>
<h2 id="ftp"><a class="markdownIt-Anchor" href="#ftp"></a> FTP</h2>
<p>文件传送协议 FTP 使用 TCP 进行连接，它需要两个连接来传送一个文件：</p>
<ul>
<li>控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。</li>
<li>数据连接：用来传送一个文件数据。</li>
</ul>
<p>根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式：</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/application/1551095440002.png!zp"/></div>
<ul>
<li>主动模式：服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。</li>
<li>被动模式：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。</li>
</ul>
<p>主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。</p>
<p>FTPS 是一种对常用的文件传输协议（FTP）添加传输层安全（TLS）和安全套接层（SSL）加密协议支持的扩展协议。</p>
<h2 id="dhcp"><a class="markdownIt-Anchor" href="#dhcp"></a> DHCP</h2>
<p>动态主机配置协议 DHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要去手动配置 IP 地址等信息。</p>
<p>DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。</p>
<p>DHCP 工作过程如下：</p>
<ol>
<li>客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。</li>
<li>DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。</li>
<li>如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。</li>
<li>DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。</li>
</ol>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/application/1551095610521.png!zp"/></div>
<h2 id="telnet"><a class="markdownIt-Anchor" href="#telnet"></a> TELNET</h2>
<p>远程登录协议 TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。</p>
<p>TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。</p>
<h2 id="电子邮件协议"><a class="markdownIt-Anchor" href="#电子邮件协议"></a> 电子邮件协议</h2>
<p>一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。</p>
<p>邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。</p>
<h3 id="1-smtp"><a class="markdownIt-Anchor" href="#1-smtp"></a> 1. SMTP</h3>
<p>SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。</p>
<h3 id="2-pop3"><a class="markdownIt-Anchor" href="#2-pop3"></a> 2. POP3</h3>
<p>POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。</p>
<h3 id="3-imap"><a class="markdownIt-Anchor" href="#3-imap"></a> 3. IMAP</h3>
<p>IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。</p>
<h2 id="常用端口"><a class="markdownIt-Anchor" href="#常用端口"></a> 常用端口</h2>
<table>
<thead>
<tr>
<th style="text-align:center">应用</th>
<th style="text-align:center">应用层协议</th>
<th style="text-align:center">端口号</th>
<th style="text-align:center">传输层协议</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">域名解析</td>
<td style="text-align:center">DNS</td>
<td style="text-align:center">53</td>
<td style="text-align:center">UDP/TCP</td>
<td style="text-align:center">长度超过 512 字节时使用 TCP</td>
</tr>
<tr>
<td style="text-align:center">动态主机配置协议</td>
<td style="text-align:center">DHCP</td>
<td style="text-align:center">67/68</td>
<td style="text-align:center">UDP</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">简单网络管理协议</td>
<td style="text-align:center">SNMP</td>
<td style="text-align:center">161/162</td>
<td style="text-align:center">UDP</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">文件传送协议</td>
<td style="text-align:center">FTP</td>
<td style="text-align:center">20/21</td>
<td style="text-align:center">TCP</td>
<td style="text-align:center">控制连接 21，数据连接 20</td>
</tr>
<tr>
<td style="text-align:center">远程终端协议</td>
<td style="text-align:center">TELNET</td>
<td style="text-align:center">23</td>
<td style="text-align:center">TCP</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">超文本传送协议</td>
<td style="text-align:center">HTTP</td>
<td style="text-align:center">80</td>
<td style="text-align:center">TCP</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">简单邮件传送协议</td>
<td style="text-align:center">SMTP</td>
<td style="text-align:center">25</td>
<td style="text-align:center">TCP</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">邮件读取协议</td>
<td style="text-align:center">POP3</td>
<td style="text-align:center">110</td>
<td style="text-align:center">TCP</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">网际报文存取协议</td>
<td style="text-align:center">IMAP</td>
<td style="text-align:center">143</td>
<td style="text-align:center">TCP</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h2 id="web-页面请求过程"><a class="markdownIt-Anchor" href="#web-页面请求过程"></a> Web 页面请求过程</h2>
<h3 id="1-dhcp-配置主机信息"><a class="markdownIt-Anchor" href="#1-dhcp-配置主机信息"></a> 1. DHCP 配置主机信息</h3>
<ul>
<li>假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。</li>
<li>主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。</li>
<li>该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。</li>
<li>该数据报则被放置在 MAC 帧中，该帧具有目的地址 FF:FF:FF:FF:FF:FF，将广播到与交换机连接的所有设备。</li>
<li>连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。</li>
<li>该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。</li>
<li>主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。</li>
</ul>
<h3 id="2-arp-解析-mac-地址"><a class="markdownIt-Anchor" href="#2-arp-解析-mac-地址"></a> 2. ARP 解析 MAC 地址</h3>
<ul>
<li>主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。</li>
<li>主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。</li>
<li>该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。</li>
<li>该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。</li>
<li>DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。</li>
<li>主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FF:FF:FF:FF:FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。</li>
<li>网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。</li>
</ul>
<h3 id="3-dns-解析域名"><a class="markdownIt-Anchor" href="#3-dns-解析域名"></a> 3. DNS 解析域名</h3>
<ul>
<li>知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。</li>
<li>网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。</li>
<li>因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。</li>
<li>到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。</li>
<li>找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。</li>
</ul>
<h3 id="4-http-请求页面"><a class="markdownIt-Anchor" href="#4-http-请求页面"></a> 4. HTTP 请求页面</h3>
<ul>
<li>有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。</li>
<li>在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。</li>
<li>HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。</li>
<li>连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。</li>
<li>HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。</li>
<li>浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。</li>
</ul>
]]></content>
      <categories>
        <category>通信</category>
      </categories>
      <tags>
        <tag>通信</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>合理规划项目</title>
    <url>/blog/efficiency/style/project-style/</url>
    <content><![CDATA[<blockquote>
<p>软件项目开发规范。</p>
</blockquote>
<h2 id="项目结构"><a class="markdownIt-Anchor" href="#项目结构"></a> 项目结构</h2>
<p>以下为项目根目录下的文件和目录的组织结构：</p>
<h3 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h3>
<p><strong>codes</strong> - 代码目录。<br />
<strong>configurations</strong> - 配置目录。一般存放项目相关的配置文件。如 maven 的 settings.xml，nginx 的 nginx.conf 等。<br />
<strong>demos</strong> - 示例目录。<br />
<strong>docs</strong> - 文档目录。<br />
<strong>libs</strong> - 第三方库文件。<br />
<strong>scripts</strong> - 脚本目录。一般存放用于启动、构建项目的可执行脚本文件。<br />
<strong>packages</strong> - 打包文件目录。Java 项目中可能是 jar、war 等；前端项目中可能是 zip、rar 等；电子书项目中可能是 pdf 等。</p>
<h3 id="文件"><a class="markdownIt-Anchor" href="#文件"></a> 文件</h3>
<p><strong>.gitignore</strong> - git 忽略规则。<br />
<strong>.gitattributes</strong> - git 属性规则。<br />
<strong>.editorconfig</strong> - 编辑器书写规则。<br />
<strong><a href="http://README.md" target="_blank" rel="noopener">README.md</a></strong> - 项目说明文件。<br />
<strong>LICENSE</strong> - 开源协议。如果项目是开源文件，需要添加。</p>
<h2 id="命名规则"><a class="markdownIt-Anchor" href="#命名规则"></a> 命名规则</h2>
<h3 id="目录名"><a class="markdownIt-Anchor" href="#目录名"></a> 目录名</h3>
<p>目录名必须使用半角字符，不得使用全角字符。这也意味着，中文不能用于文件名。</p>
<p>目录名建议只使用小写字母，不使用大写字母。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">不佳： <span class="keyword">Test</span></span><br><span class="line">正确： <span class="keyword">test</span></span><br></pre></td></tr></table></figure>
<p>目录名可以使用数字，但不应该是首字符。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">不佳： <span class="number">1</span>-demo</span><br><span class="line">正确： demo1</span><br></pre></td></tr></table></figure>
<p>目录名包含多个单词时，单词之间建议使用半角的连词线（<code>-</code>）分隔。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">不佳： common_demo</span><br><span class="line">正确： <span class="meta">common</span>-demo</span><br></pre></td></tr></table></figure>
<h3 id="文件名"><a class="markdownIt-Anchor" href="#文件名"></a> 文件名</h3>
<p>文档的文件名不得含有空格。</p>
<p>文件名必须使用半角字符，不得使用全角字符。这也意味着，中文不能用于文件名。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">错误： 名词解释<span class="selector-class">.md</span></span><br><span class="line">正确： <span class="selector-tag">glossary</span><span class="selector-class">.md</span></span><br></pre></td></tr></table></figure>
<p>文件名建议只使用小写字母，不使用大写字母。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">错误：<span class="selector-tag">TroubleShooting</span><span class="selector-class">.md</span></span><br><span class="line">正确：<span class="selector-tag">troubleshooting</span><span class="selector-class">.md</span></span><br></pre></td></tr></table></figure>
<p>为了醒目，某些说明文件的文件名，可以使用大写字母，比如<code>README</code>、<code>LICENSE</code>。</p>
<p>一些约定俗成的习惯可以保持传统写法，如：Java 的文件名一般使用驼峰命名法，且首字母大写；配置文件 <code>applicationContext.xml</code> ；React 中的 JSX 组件文件名一般使用驼峰命名法，且首字母大写等。</p>
<p>文件名包含多个单词时，单词之间建议使用半角的连词线（<code>-</code>）分隔。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">不佳：<span class="selector-tag">advanced_usage</span><span class="selector-class">.md</span></span><br><span class="line">正确：<span class="selector-tag">advanced-usage</span><span class="selector-class">.md</span></span><br></pre></td></tr></table></figure>
<h2 id="java-日志规范"><a class="markdownIt-Anchor" href="#java-日志规范"></a> Java 日志规范</h2>
<blockquote>
<p>这里基于<a href="https://yq.aliyun.com/attachment/download/?id=4942" target="_blank" rel="noopener">阿里巴巴 Java 开发手册</a>日志规约章节，结合自己的开发经验做了一些增删和调整。</p>
</blockquote>
<ol>
<li>【强制】应用中不可直接使用日志系统（Log4j、Logback）中的 API，而应依赖使用日志框架 SLF4J 中的 API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(Abc<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>
<p>【强制】日志文件推荐至少保存 <code>30</code> 天，因为有些异常具备以“周”为频次发生的特点。</p>
</li>
<li>
<p>【强制】应用中的扩展日志（如打点、临时监控、访问日志等）命名方式：<code>appName_logType_logName.log</code>。logType:日志类型，推荐分类有 stats/desc/monitor/visit 等；logName:日志描述。这种命名的好处：通过文件名就可知道日志文件属于什么应用，什么类型，什么目的，也有利于归类查找。</p>
</li>
</ol>
<p><strong>正例</strong>：mppserver 应用中单独监控时区转换异常，如：<code>mppserver_monitor_timeZoneConvert.log</code></p>
<p><strong>说明</strong>：推荐对日志进行分类，如将错误日志和业务日志分开存放，便于开发人员查看，也便于通过日志对系统进行及时监控。</p>
<ol start="4">
<li>【强制】对 <code>trace/debug/info</code> 级别的日志输出，必须使用条件输出形式或者使用占位符的方式。</li>
</ol>
<p>说明：<code>logger.debug(&quot;Processing trade with id: &quot; + id + &quot; and symbol: &quot; + symbol);</code> 如果日志级别是 warn，上述日志不会打印，但是会执行字符串拼接操作，如果 symbol 是对象，会执行 toString()方法，浪费了系统资源，执行了上述操作，最终日志却没有打印。</p>
<p><strong>正例：（条件）</strong></p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line"><span class="selector-tag">logger</span><span class="selector-class">.debug</span>(<span class="string">"Processing trade with id: "</span> + id + <span class="string">" and symbol: "</span> + symbol);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>正例：（占位符）</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">logger</span><span class="selector-class">.debug</span>("<span class="selector-tag">Processing</span> <span class="selector-tag">trade</span> <span class="selector-tag">with</span> <span class="selector-tag">id</span>: &#123;&#125; <span class="selector-tag">and</span> <span class="selector-tag">symbol</span> : &#123;&#125; ", <span class="selector-tag">id</span>, <span class="selector-tag">symbol</span>);</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>【强制】避免重复打印日志，浪费磁盘空间。务必在 <code>log4j.xml</code> 或 <code>logback.xml</code> 中设置 <code>additivity=false</code>。</li>
</ol>
<p><strong>正例</strong>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"com.taobao.dubbo.config"</span> <span class="attr">additivity</span>=<span class="string">"false"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="6">
<li>【强制】异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过关键字 throws 往上抛出。</li>
</ol>
<p><strong>正例</strong>：logger.error(各类参数或者对象 toString + “_” + e.getMessage(), e);</p>
<ol start="9">
<li>【强制】日志格式遵循如下格式：</li>
</ol>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/java/javalib/log/logback/log-pattern.png"/></div>
<p>打印出的日志信息如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">2018<span class="selector-tag">-03-29</span> 15<span class="selector-pseudo">:06</span><span class="selector-pseudo">:57.277</span> <span class="selector-attr">[javalib]</span> <span class="selector-attr">[main]</span> <span class="selector-attr">[TRACE]</span> <span class="selector-tag">i</span><span class="selector-class">.g</span><span class="selector-class">.dunwu</span><span class="selector-class">.javalib</span><span class="selector-class">.log</span><span class="selector-class">.LogbackDemo</span><span class="selector-id">#main</span> <span class="selector-tag">-</span> 这是一条 <span class="selector-tag">trace</span> 日志记录</span><br><span class="line">2018<span class="selector-tag">-03-29</span> 15<span class="selector-pseudo">:06</span><span class="selector-pseudo">:57.282</span> <span class="selector-attr">[javalib]</span> <span class="selector-attr">[main]</span> <span class="selector-attr">[DEBUG]</span> <span class="selector-tag">i</span><span class="selector-class">.g</span><span class="selector-class">.dunwu</span><span class="selector-class">.javalib</span><span class="selector-class">.log</span><span class="selector-class">.LogbackDemo</span><span class="selector-id">#main</span> <span class="selector-tag">-</span> 这是一条 <span class="selector-tag">debug</span> 日志记录</span><br><span class="line">2018<span class="selector-tag">-03-29</span> 15<span class="selector-pseudo">:06</span><span class="selector-pseudo">:57.282</span> <span class="selector-attr">[javalib]</span> <span class="selector-attr">[main]</span> <span class="selector-attr">[INFO]</span> <span class="selector-tag">i</span><span class="selector-class">.g</span><span class="selector-class">.dunwu</span><span class="selector-class">.javalib</span><span class="selector-class">.log</span><span class="selector-class">.LogbackDemo</span><span class="selector-id">#main</span> <span class="selector-tag">-</span> 这是一条 <span class="selector-tag">info</span> 日志记录</span><br><span class="line">2018<span class="selector-tag">-03-29</span> 15<span class="selector-pseudo">:06</span><span class="selector-pseudo">:57.282</span> <span class="selector-attr">[javalib]</span> <span class="selector-attr">[main]</span> <span class="selector-attr">[WARN]</span> <span class="selector-tag">i</span><span class="selector-class">.g</span><span class="selector-class">.dunwu</span><span class="selector-class">.javalib</span><span class="selector-class">.log</span><span class="selector-class">.LogbackDemo</span><span class="selector-id">#main</span> <span class="selector-tag">-</span> 这是一条 <span class="selector-tag">warn</span> 日志记录</span><br><span class="line">2018<span class="selector-tag">-03-29</span> 15<span class="selector-pseudo">:06</span><span class="selector-pseudo">:57.282</span> <span class="selector-attr">[javalib]</span> <span class="selector-attr">[main]</span> <span class="selector-attr">[ERROR]</span> <span class="selector-tag">i</span><span class="selector-class">.g</span><span class="selector-class">.dunwu</span><span class="selector-class">.javalib</span><span class="selector-class">.log</span><span class="selector-class">.LogbackDemo</span><span class="selector-id">#main</span> <span class="selector-tag">-</span> 这是一条 <span class="selector-tag">error</span> 日志记录</span><br></pre></td></tr></table></figure>
<ol start="8">
<li>【参考】slf4j 支持的日志级别，按照级别从低到高，分别为：<code>trace &lt; debug &lt; info &lt; warn &lt; error</code>。</li>
</ol>
<p>建议只使用 <code>debug &lt; info &lt; warn &lt; error</code> 四个级别。</p>
<ul>
<li><code>error</code> 日志级别只记录系统逻辑出错、异常等重要的错误信息。如非必要，请不要在此场景打出 error 级别。</li>
<li><code>warn</code> 日志级别记录用户输入参数错误的情况，避免用户投诉时，无所适从。</li>
<li><code>info</code> 日志级别记录业务逻辑中一些重要步骤信息。</li>
<li><code>debug</code> 日志级别记录一些用于调试的信息。</li>
</ul>
<ol start="10">
<li>【参考】有一些第三方框架或库的日志对于排查问题具有一定的帮助，如 Spring、Dubbo、Mybatis 等。这些框架所使用的日志库未必和本项目一样，为了避免出现日志无法输出的问题，请引入对应的桥接 jar 包。</li>
</ol>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><a href="https://yq.aliyun.com/attachment/download/?id=4942" target="_blank" rel="noopener">阿里巴巴 Java 开发手册</a>日志规约章节</li>
</ul>
]]></content>
      <categories>
        <category>效率提升</category>
        <category>规范</category>
      </categories>
      <tags>
        <tag>效率提升</tag>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络之物理层</title>
    <url>/blog/communication/network-physical/</url>
    <content><![CDATA[<blockquote>
<p><strong>摘要</strong></p>
<p><strong>物理层（Physical Layer）</strong> - 物理层只接收和发送一串比特(bit)流，不考虑信息的意义和信息结构。</p>
<ul>
<li>数据单元：比特流。</li>
<li>典型设备：光纤、同轴电缆、双绞线、中继器和集线器。</li>
</ul>
</blockquote>
<h2 id="通信系统模型"><a class="markdownIt-Anchor" href="#通信系统模型"></a> 通信系统模型</h2>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/physical/数据通信系统的模型.png!zp"/></div>
<p>通信系统模型分为三大部分：源系统（包括信源和发送器）、传输系统、目的系统（包括信宿接收器）。</p>
<p>重要概念：</p>
<ul>
<li><strong>信源</strong> - 也叫源点。产生各类信息的实体。</li>
<li><strong>信道</strong> - 通信的通道，是信号传输的媒介。</li>
<li><strong>信宿</strong> - 传输信息的归宿。</li>
<li><strong>码元</strong> - 在数字通信中常常用时间间隔相同的符号来表示一个二进制数字，这样的时间间隔内的信号称为(二进制）码元。</li>
</ul>
<h2 id="通信方式"><a class="markdownIt-Anchor" href="#通信方式"></a> 通信方式</h2>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/physical/通信方式.jpg!zp"/></div>
<p>有三种通信方式：</p>
<ul>
<li>单工通信：单向传输</li>
<li>半双工通信：双向交替传输</li>
<li>全双工通信：双向同时传输</li>
</ul>
<h2 id="通信信号"><a class="markdownIt-Anchor" href="#通信信号"></a> 通信信号</h2>
<p>通信的目的是传送消息。如语音、文字、图像、视频都是消息。数据时传送消息的实体。信号是数据的电气或电磁的表现。</p>
<p>模拟信号和数字信号</p>
<ul>
<li><strong>模拟信号</strong> - 模拟信号是连续的信号。</li>
<li><strong>数字信号</strong> - 数字信号是离散的信号。</li>
</ul>
<h2 id="调制解调"><a class="markdownIt-Anchor" href="#调制解调"></a> 调制解调</h2>
<p>重要概念：</p>
<ul>
<li><strong>基带信号</strong> - 来自信源的信号叫做基带信号。</li>
<li><strong>调制</strong> - 将各种数字基带信号转换成适于信道传输的数字调制信号(已调信号或频带信号)。简单来说：调制即，数字 -&gt; 模拟。</li>
<li><strong>解调</strong> - 在接收端将收到的数字频带信号还原成数字基带信号。简单来说：解调即，模拟 -&gt; 数字。</li>
</ul>
<blockquote>
<p>📌 提示：我们上网时所用到的调制解调器（俗称“猫”），指的就是转换数字和模拟信号的机器。</p>
</blockquote>
<p>信号要在信道上传输就要经过调制。</p>
<p>调制分为：基带调制和带通调制</p>
<h3 id="基本带通调制方法"><a class="markdownIt-Anchor" href="#基本带通调制方法"></a> 基本带通调制方法</h3>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/physical/基本调制方法.png!zp"/></div>
<p>如果你收听过广播，一定经常听到 AM、FM 这两个关键词，这是什么意思呢？答案如下：</p>
<ul>
<li><strong>调幅（AM）</strong> - 即载波的<strong>振幅</strong>随基带数字信号而变化。</li>
<li><strong>调频（FM）</strong> - 即载波的<strong>频率</strong>随基带数字信号而变化。</li>
<li><strong>调相（PM）</strong> - 即载波的<strong>初始相位</strong>随基带数字信号而变化。</li>
</ul>
<blockquote>
<p>📌 提示：我们收听广播时，为了接收不同广播台的信号，就要调整 AM 或 FM，指的就是这里的调制方法。</p>
</blockquote>
<h2 id="通信媒介"><a class="markdownIt-Anchor" href="#通信媒介"></a> 通信媒介</h2>
<p>通信媒介分为两大类：</p>
<ul>
<li>导引型 - 双绞线、电缆、光纤</li>
<li>非导引型 - 无线、红外线、大气、激光</li>
</ul>
<h2 id="信道复用"><a class="markdownIt-Anchor" href="#信道复用"></a> 信道复用</h2>
<p>信道复用就是将用于传输信道的总带宽划分成若干个子频带（或称子信道），每一个子信道传输一路信号。</p>
<ul>
<li>频分复用</li>
<li>时分复用</li>
<li>波分复用</li>
<li>码分复用</li>
</ul>
]]></content>
      <categories>
        <category>通信</category>
      </categories>
      <tags>
        <tag>通信</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>UML 教程</title>
    <url>/blog/tools/uml/</url>
    <content><![CDATA[<blockquote>
<p>关键词：<code>部署图</code>, <code>组件图</code>, <code>包图</code>, <code>类图</code>, <code>复合结构图</code>, <code>对象图</code>, <code>活动图</code>, <code>状态机图</code>, <code>用例图</code>, <code>通信图</code>, <code>交互概述图</code>, <code>时序图</code>, <code>时间图</code></p>
</blockquote>
<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<h3 id="uml-图类型"><a class="markdownIt-Anchor" href="#uml-图类型"></a> UML 图类型</h3>
<p>UML 图类型如下图所示：</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-diagrams.png"/></div>
<h4 id="结构式建模图"><a class="markdownIt-Anchor" href="#结构式建模图"></a> <a href="UML%E7%BB%93%E6%9E%84%E5%BB%BA%E6%A8%A1%E5%9B%BE.md">结构式建模图</a></h4>
<blockquote>
<p>结构式建模图（Structure diagrams）强调的是系统式的建模。结构图定义了一个模型的静态架构。它们通常被用来对那些构成模型的‘要素’建模，诸如：类，对象，接口和物理组件。另外，它们也被用来对元素间关联和依赖关系进行建模。</p>
</blockquote>
<ul>
<li><a href="#%E7%B1%BB%E5%9B%BE">类图</a></li>
<li><a href="#%E5%AF%B9%E8%B1%A1%E5%9B%BE">对象图</a></li>
<li><a href="#%E5%8C%85%E5%9B%BE">包图</a></li>
<li><a href="#%E7%BB%84%E4%BB%B6%E5%9B%BE">组件图</a></li>
<li><a href="#%E9%83%A8%E7%BD%B2%E5%9B%BE">部署图</a></li>
<li><a href="#%E5%A4%8D%E5%90%88%E7%BB%93%E6%9E%84%E5%9B%BE">复合结构图</a></li>
</ul>
<h4 id="行为式建模图"><a class="markdownIt-Anchor" href="#行为式建模图"></a> <a href="UML%E8%A1%8C%E4%B8%BA%E5%BB%BA%E6%A8%A1%E5%9B%BE.md">行为式建模图</a></h4>
<blockquote>
<p>行为式建模图（Behavior diagrams）强调系统模型中触发的事。行为图用来记录在一个模型内部，随时间的变化，模型执行的交互变化和瞬间的状态；并跟踪系统在真实环境下如何表现，以及观察系统对一个操作或事件的反应，以及它的结果。</p>
</blockquote>
<ul>
<li><a href="#%E6%B4%BB%E5%8A%A8%E5%9B%BE">活动图</a></li>
<li><a href="#%E7%8A%B6%E6%80%81%E5%9B%BE">状态图</a></li>
<li><a href="#%E7%94%A8%E4%BE%8B%E5%9B%BE">用例图</a></li>
<li><a href="#%E9%80%9A%E4%BF%A1%E5%9B%BE">通信图</a></li>
<li><a href="#%E4%BA%A4%E4%BA%92%E6%A6%82%E8%BF%B0%E5%9B%BE">交互概述图</a></li>
<li><a href="#%E6%97%B6%E5%BA%8F%E5%9B%BE">时序图</a></li>
<li><a href="#%E6%97%B6%E9%97%B4%E5%9B%BE">时间图</a></li>
</ul>
<h3 id="uml-概念"><a class="markdownIt-Anchor" href="#uml-概念"></a> UML 概念</h3>
<p>UML 从来源中使用相当多的概念。我们将之定义于统一建模语言术语汇表。下面仅列代表性的概念。</p>
<ul>
<li>对于结构而言 - 执行者，属性，类，元件，接口，对象，包。</li>
<li>对于行为而言 - 活动（UML），事件（UML），消息（UML），方法（UML），操作（UML），状态（UML），用例（UML）。</li>
<li>对于关系而言 - 聚合，关联，组合，相依，广义化（or 继承）。</li>
<li>其他概念
<ul>
<li>构造型—这规范符号应用到的模型</li>
<li>多重性—多重性标记法与资料库建模基数对应，例如：<code>1, 0..1, 1..*</code></li>
</ul>
</li>
</ul>
<h2 id="部署图"><a class="markdownIt-Anchor" href="#部署图"></a> 部署图</h2>
<blockquote>
<p><strong>部署图（Deployment Diagram）用于对系统的物理结构建模</strong>。部署图将显示系统中的软件组件和硬件组件之间的关系以及处理工作的物理分布。</p>
</blockquote>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-deployment-diagram-example.png"/></div>
<h3 id="节点"><a class="markdownIt-Anchor" href="#节点"></a> 节点</h3>
<p>节点既可以是硬件元素，也可以是软件元素。它显示为一个立方体，如下图所示。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-node.gif"/></div>
<h3 id="节点实例"><a class="markdownIt-Anchor" href="#节点实例"></a> 节点实例</h3>
<p>图可以显示节点实例，实例与节点的区分是：实例的名称带下划线，冒号放在它的基本节点类型之前。实例在冒号之前可以有名称，也可以没有名称。下图显示了一个具名的计算机实例。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-node-instance.gif"/></div>
<h3 id="节点构造型"><a class="markdownIt-Anchor" href="#节点构造型"></a> 节点构造型</h3>
<p>为节点提供了许多标准的构造型，分别命名为 «cdrom»， «cd-rom»， «computer»， «disk array»， «pc»， «pc client»， «pc server»， «secure»， «server»， «storage»， «unix server»， «user pc»。 并在节点符号的右上角显示适当的图标。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-node-stereotype.gif"/></div>
<h3 id="工件"><a class="markdownIt-Anchor" href="#工件"></a> 工件</h3>
<p>工件是<a href="http://www.sparxsystems.cn/platforms/software_development.html" target="_blank" rel="noopener">软件开发</a>过程中的产品。包括过程模型（如：用例模型，设计模型等），源文件，执行文件，设计文档，测试报告，构造型，用户手册等等。</p>
<p>工件表示为带有工件名称的矩形，并显示«artifact»关键字和文档符号。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-artifact.gif"/></div>
<h3 id="关联"><a class="markdownIt-Anchor" href="#关联"></a> 关联</h3>
<p>在部署图的上下文联系中，关联代表节点间的联系通道。下图显示了一个网络系统的部署图，描述了网络协议为构造型和关联终端的多重性，</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-network-model.gif"/></div>
<h3 id="作为容器的节点"><a class="markdownIt-Anchor" href="#作为容器的节点"></a> 作为容器的节点</h3>
<p>节点可以包含其他元素，如组件和工件。下图显示了一个嵌入式系统某个部分的部署图。描写了一个被主板节点包含的可执行工件。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-embedded-model.gif"/></div>
<h2 id="组件图"><a class="markdownIt-Anchor" href="#组件图"></a> 组件图</h2>
<blockquote>
<p><strong>组件图（Component Diagram）描绘了组成一个软件系统的模块和嵌入控件</strong>。组件图比类图具有更高层次的抽象－通常运行时一个组件被一个或多个类（或对象）实现。它们象积木那样使得组件能最终构成系统的绝大部分。</p>
</blockquote>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-component-diagram.gif"/></div>
<p>上图演示了一些组件和它们的内部关系。装配连接器（Assembly connectors）“连接”由&quot;Product&quot;和&quot;Customer&quot;的提供接口到由 &quot;Order&quot;指定的需求接口。 一个依赖关系映射了客户相关的帐户信息到“Order”需要的 &quot;Payment&quot;需求接口。</p>
<p>实际上，组件图同包图很相似，它们都有明确的界限，把元素分组到逻辑结构中。他们之间的不同是：组件图提供了语义更丰富的分组机制，在组件图中，所有的模型元素都是私有的，而包图只显示公有的成员。</p>
<h3 id="表现组件"><a class="markdownIt-Anchor" href="#表现组件"></a> 表现组件</h3>
<p>组件可表示为带关键字 «component»的矩形类元；也可用右上角有组件图标的矩形表示。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-representing-components.gif"/></div>
<h3 id="装配连接器"><a class="markdownIt-Anchor" href="#装配连接器"></a> 装配连接器</h3>
<p>装配连接器在组件 “Component1”的需求接口和另一个组件 “Component2”的提供接口之间建立桥梁; 这个桥梁使得一个组件能提供另一个组件所需要的服务。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-required-interfaces.gif"/></div>
<h3 id="带端口组件"><a class="markdownIt-Anchor" href="#带端口组件"></a> 带端口组件</h3>
<p>使用端口的组件图允许在它的环境指定一个服务和行为，同时这个服务和行为也是组件需要的。当端口进行双向操作的时候，它可以指定输入和输出。下图详述了用于在线服务的带端口组件，它有两个提供接口 “order entry”和 “tracking”，也有 “payment” 需求接口。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-component-with-ports.gif"/></div>
<h2 id="包图"><a class="markdownIt-Anchor" href="#包图"></a> 包图</h2>
<blockquote>
<p><strong>包图（Package Diagram）用来表现包和它所包含元素的组织</strong>。当用来代表类元素时，包图提供了命名空间的可视化。包图最常用的用途是用来组织用例图和类图，尽管它不局限于这些 UML 元素。</p>
</blockquote>
<p>下面是一个包图的例子。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-package-diagram.gif"/></div>
<p>包中的元素共享相同的命名空间，因此，一个指定命名空间的元素必须有唯一的名称。</p>
<p>包可以用来代表物理或逻辑关系。选择把类包括在指定的包里，有助于在同一个包里赋予这些类相同继承层次。通常认为把通过复合相关联的类，以及与它们相协作的类放在同一个包里。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-package.gif"/></div>
<p>在 UML2.5 中，包用文件夹来表示，包中的元素共享同一个命名空间，并且必须是可识别的，因此要有唯一的名称或类型。包必须显示包名，在附属方框部分有选择的显示包内的元素。</p>
<ul>
<li><strong>包的合并</strong> - 包之间的合并连接符«merge»定义了源包元素与目标包同名元素之间的泛化关系。源包元素的定义被扩展来包含目标包元素定义。当源包元素与目标包内没有同名元素时，目标包元素的定义不受影响。</li>
<li><strong>包的导入</strong> - 导入连接符 «import»表明目标包的元素，在该例中是一个类 ，在源包中被引用要用非限定修饰名。源包的命名空间获得目标类的接口，目标包的命名空间则不受影响。</li>
<li><strong>嵌套连接符</strong> - 源包和目标包间的嵌套连接符说明目标包完全包含源包。</li>
</ul>
<h2 id="类图"><a class="markdownIt-Anchor" href="#类图"></a> 类图</h2>
<blockquote>
<p><strong>类图（Class Diagram）展示了面向对象系统的构造模块</strong>。描绘了模型或部分模型的静态视图，显示它包含的属性和行为，而不是详细描述操作的功能或完善方法。类图最常用来表达多个类和接口之间的关系。泛化（Generalizations），聚合（aggregations）和关联（associations）分别是类之间继承，复合或应用，及连接的表现。</p>
</blockquote>
<p>下面的图显示了类之间的聚合关系。弱聚合（浅色箭头）表现在类 “Account” 使用 “AddressBook”，但是不必要包含它的一个实例。强聚合（图中的黑色箭头）表示了目标类包含源类，例如，“Contact” 和 &quot;ContactGroup&quot;值被包含在 &quot;AddressBook&quot;中。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-class-diagram.png"/></div>
<h3 id="类classes"><a class="markdownIt-Anchor" href="#类classes"></a> 类（Classes）</h3>
<p>类是定义对象所具有的属性和行为的元素。行为用类能理解的合适消息和适合每条消息的操作来描述。 类中也可能定义约束，标记值，构造型。</p>
<h3 id="类的标柱class-notation"><a class="markdownIt-Anchor" href="#类的标柱class-notation"></a> 类的标柱（Class Notation）</h3>
<p>类用矩形表示。除类的名称外，还可以选择性地显示属性和操作。 分栏分别用来显示类的名称，属性和操作。</p>
<p>在下面图中，类的类名显示在最上面的分栏，它下面的分栏显示详细属性，如：“center” 属性显示初始化的值。最后面的分栏显示操作，如： setWidth，setLength 和 setPosition 以及他们的参数。 属性和操作名前的标注表示了该属性或操作的可见性: 如果使用 &quot;+&quot;号，这个属性或操作是公共的 ; “-” 号则代表这个属性或操作是私有的。 “#“号是这个属性或操作被定义为保护的，” ~” 号代表包的可见性。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-class.gif"/></div>
<h3 id="接口interfaces"><a class="markdownIt-Anchor" href="#接口interfaces"></a> 接口（Interfaces）</h3>
<p>接口是实施者同意满足的行为规范，是一种约定。实现一个接口，类必需支持其要求的行为，使系统按照同样的方式，即公共的接口，处理不相关的元素。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-class-interface.gif"/></div>
<p>接口有相似于类的外形风格，含有指定的操作，如下图所示。如果没有明确的详细操作，也可以画成一个圆环。当画成圆环的时候，到这个环形标柱的实现连接没有目标箭头。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-interface.gif"/></div>
<h3 id="表tables"><a class="markdownIt-Anchor" href="#表tables"></a> 表（Tables）</h3>
<p>表尽管不是基本 UML 的一部分，仍然是“图型”能完成的实例用。在右上角画一个表的小图标来表示。表属性用“图型” «column»表示。 绝大多数表单有一个主键，是由一个或几个字段组成的一个唯一的字码组合加主键操作来访问表格，主键操作“图型”为«PK»。 一些表有一个或多个外键，使用一个或多个字段加一个外键操作，映射到相关表的主键上去，外键操作“图型”为«FK»。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-table.gif"/></div>
<h3 id="关联associations"><a class="markdownIt-Anchor" href="#关联associations"></a> 关联（Associations）</h3>
<p>关联表明两个模型元素之间有关系，通常用在一个类中被实现为一个实例变量。连接符可以包含两端的命名的角色，基数性，方向和约束。关联是元素之间普通的关系。如果多于两个元素，也可以使用菱形的关联关系。当从类图生成代码时，关联末端的对象将变成目标类中实例变量。见下图示例 “playsFor” 将变成&quot;Player&quot;类中的实例变量。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-associations.gif"/></div>
<h3 id="泛化generalizations"><a class="markdownIt-Anchor" href="#泛化generalizations"></a> 泛化（Generalizations）</h3>
<p>泛化被用来说明继承关系。连接从特定类元到一般类元。泛化的含义是源类继承了目标类的特性。下图的图显示了一个父类泛化一个子类， 类“Circle”的一个实例将会有属性 “ x_position”，“ y_position” ， “radius” 和 方法 “display()”。 注意：类 “Shape” 是抽象的，类名显示为斜体。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-generalizations.gif"/></div>
<p>下图显示了与上图相同信息的视图。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-generalizations-02.gif"/></div>
<h3 id="聚合aggregations"><a class="markdownIt-Anchor" href="#聚合aggregations"></a> 聚合（Aggregations）</h3>
<p>聚合通常被用来描述由更小的组件所构成的元素。聚合关系表示为白色菱形箭头指向目标类或父类。</p>
<p>聚合的更强形式 -组合聚合（强聚合） - 显示为黑色菱形箭头，用来组合每次最大化的包含组件。如果一个组合聚合的父类被删除，通常与他相关的所有部分都会被删除，但是，如果一个部件从组合中去掉，将不用删除整个组合。组合是可迁，非对称的关系和递归的。</p>
<p>下面的图示：显示了弱聚合和强聚合的不同。“ address book” 由许多 “contacts” 和 “contact groups”组成。 “contact group” 是一个“contacts”的虚分组; “contact”可以被包含在不止一个 “ contact group”。 如果你删除一个“ address book”，所有的 “contacts” 和 “contact groups” 也将会被删除；如果你删除“ contact group”， 没有 “contacts”会被删除。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-aggregations.gif"/></div>
<h3 id="关联类association-classes"><a class="markdownIt-Anchor" href="#关联类association-classes"></a> 关联类（Association Classes）</h3>
<p>关联类是一个允许关联连接有属性和操作的构造。下面的示例：显示了远不止简单连接两个类的连接，如给“employee”分配项目。“ employee”在项目中所起的作用是一个复杂的实体，既有自身的也有不属于“employee” 或 “project” 类的细节。 例如，“ employee”可以同时为几个项目工作，有不同的职务头衔和对应的安全权限。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-association-classes.gif"/></div>
<h3 id="依赖dependencies"><a class="markdownIt-Anchor" href="#依赖dependencies"></a> 依赖（Dependencies）</h3>
<p>依赖被用来描述模型元素间广泛的依赖关系。通常在设计过程早期显示两个元素之间存在某种关系，因为是初期而不能确定具体是什么关系，在设计过程末期，该继承关系会被归入已有构造型 (构造型 可以是实例化 «instantiate»，跟踪 «trace»，导入 «import»， 和其它的关系)，或被替换成一个更明确类型的连接符。</p>
<h3 id="跟踪traces"><a class="markdownIt-Anchor" href="#跟踪traces"></a> 跟踪（Traces）</h3>
<p>跟踪关系是一种特殊化的依赖关系。连接模型元素或跨模型但是具有相同概念的模型元素集。跟踪被经常用来追踪需求和模型的变化。由于变化是双向的，这种依赖关系的顺序通常被忽略。这种关系的属性可以被指定为单向映射，但跟踪是双向的，非正式的和很少可计算的。</p>
<h3 id="实现realizations"><a class="markdownIt-Anchor" href="#实现realizations"></a> 实现（Realizations）</h3>
<p>是源对象执行或实现目标，实现被用来表达模型的可跟踪性和完整性－业务模型或需求被一个或多个用例实现，用例则被类实现，类被组件实现，等等。这种实现贯穿于系统设计的映射需求和类等，直至抽象建模水平级。从而确保整个系统的一张宏图，它也反映系统的所有微小组成，以及约束和定义它的细节。实现关系用带虚线的实箭头表示。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-realizations.gif"/></div>
<h3 id="嵌套nestings"><a class="markdownIt-Anchor" href="#嵌套nestings"></a> 嵌套（Nestings）</h3>
<p>嵌套连接符用来表示源元素嵌套在目标元素中。下图显示“ inner class”的定义，尽管在 EA 中，更多地按照着他们在项目层次视图中的位置来显示这种关系。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-nestings.gif"/></div>
<h2 id="复合结构图"><a class="markdownIt-Anchor" href="#复合结构图"></a> 复合结构图</h2>
<blockquote>
<p><strong>复合结构图显示类的内部结构，包括它与系统其他部分的交互点。也显示各部分的配置与关系，这些部分一起执行类元的行为。</strong></p>
</blockquote>
<p>类元素已经在类图部分被详细地阐述，这部分用来说明类表现复合元素的方式，如：暴露接口，包含端口和部件。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-composite-structure-diagram.gif"/></div>
<h3 id="部件"><a class="markdownIt-Anchor" href="#部件"></a> 部件</h3>
<p>部件是代表一组（一个或多个）实例的元素，这组实例的拥有者是一类元实例，例如：如果一个图的实例有一组图形元素，则这些图形元素可以被表示为部件，并可以对他们之间的某种关系建模。注意：一个部件可以在它的父类被删除之前从父类中被去掉，这样部件就不会被同时删除了。<br />
部件在类或组件内部显示为不加修饰的方框。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-part.gif"/></div>
<h3 id="端口"><a class="markdownIt-Anchor" href="#端口"></a> 端口</h3>
<p>端口是类型化的元素，代表一个包含类元实例的外部可视的部分。端口定义了类元和它的环境之间的交互。端口显示在包含它的部件，类或组合结构的边缘上。端口指定了类元提供的服务，以及类元要求环境提供的服务。<br />
端口显示为所属类元边界指定的方框。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-port.gif"/></div>
<h3 id="接口"><a class="markdownIt-Anchor" href="#接口"></a> 接口</h3>
<p>接口与类相似，但是有一些限制，所有的接口操作都是公共和抽象的，不提供任何默认的实现。所有的接口属性都必须是常量。然而，当一个类从一个单独的超级类继承而来，它可以实现多个接口。<br />
当一个接口在图中单列出来，它既可以显示为类元素的方框，带 «interface» 关键字和表明它是抽象的斜体名称，也可以显示为圆环。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-interface.gif"/></div>
<p>注意：圆环标注不显示接口操作。当接口显示为类所有的接口，它们会被当作暴露接口引用。暴露接口可以定义为是提供的，还是需求的。提供接口确认包含它的类元提供指定接口元素定义的操作，可通过类和接口间实现的连接来定义。需求接口说明该类元能与其他类元进行通信，这些类元提供了指定接口元素所定义的操作。需求接口可通过在类和接口间建立依赖连接来定义。<br />
提供接口显示为“带棒球体”，依附在类元边缘。需求接口显示为“带棒杯体”，也是依附在类元边缘。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-interface-02.gif"/></div>
<h3 id="委托"><a class="markdownIt-Anchor" href="#委托"></a> 委托</h3>
<p>委托连接器用来定义组件外部端口和接口的内部工作方式。委托连接器表示为带有 «delegate» 关键字的箭头。它连接组件的外部约定，表现为它的端口，到组件部件行为的内部实现。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-delegate.gif"/></div>
<h3 id="协作"><a class="markdownIt-Anchor" href="#协作"></a> 协作</h3>
<p>协作定义了一系列共同协作的角色，它们集体展示一个指定的设计功能。协作图应仅仅显示完成指定任务或功能的角色与属性。隔离主要角色是用来简化结构和澄清行为，也用于重用。一个协作通常实现一个模式。<br />
协作元素显示为椭圆。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-collaboration.gif"/></div>
<h3 id="角色绑定"><a class="markdownIt-Anchor" href="#角色绑定"></a> 角色绑定</h3>
<p>角色绑定连接器是一条从连接协作到所要完成该任务类元的连线。它显示为虚线，并在类元端显示作用名。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-role-binding.gif"/></div>
<h3 id="表现"><a class="markdownIt-Anchor" href="#表现"></a> 表现</h3>
<p>表现连接器用于连接协作到类元来表示此类元中使用了该协作。显示为带关键字 «represents»的虚线箭头。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-represent.gif"/></div>
<p>发生<br />
发生连接器用于连接协作到类元来表示此协作表现了（同原文）该类元；显示为带关键字«occurrence»的虚线箭头。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-occurrence.gif"/></div>
<h2 id="对象图"><a class="markdownIt-Anchor" href="#对象图"></a> 对象图</h2>
<blockquote>
<p><strong>对象图（Object Diagram）可以认为是类图的特殊情形，是类图元素子集，被用来及时强调在某些点，类的实例间的关系</strong>。这对理解类图很有帮助。他们在构造上与类图显示没有不同，但是反映出多样性和作用。</p>
</blockquote>
<h3 id="类和对象元素"><a class="markdownIt-Anchor" href="#类和对象元素"></a> 类和对象元素</h3>
<p>下面的图显示了类元素和对象元素外观上的不同。注意：类元素包括三个部分，分别是名字栏，属性栏和操作栏；对象元素默认为没有分栏。名称显示也有不同：对象名称有下划线，并可能显示该对象实例化所用类元的名称。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-object.gif"/></div>
<h3 id="运行状态"><a class="markdownIt-Anchor" href="#运行状态"></a> 运行状态</h3>
<p>类元元素可以有任意数量的属性和操作。在对象实例中不会被显示出来。但可能定义对象的运行状态，显示特殊实例的属性设置值。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-run-time-state.gif"/></div>
<h3 id="类和对象图示例"><a class="markdownIt-Anchor" href="#类和对象图示例"></a> 类和对象图示例</h3>
<p>下图是一个对象图，其中插入了类定义图。它例示如何用对象图来测试类图中任务多重性的方法。“car” 类对 “wheel” 类有“1 对多” 的多重性，但是如果已经选择用“1 对 4” 来替代，那样就不会在对象图显示“3 个轮子”的汽车。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-object-diagram.gif"/></div>
<h2 id="活动图"><a class="markdownIt-Anchor" href="#活动图"></a> 活动图</h2>
<blockquote>
<p>UML 中，活动图用来展示活动的顺序。<strong>显示了从起始点到终点的工作流，描述了活动图中存在于事件进程的判断路径</strong>。活动图可以用来详细阐述某些活动执行中发生并行处理的情况。活动图对业务建模也比较有用，用来详细描述发生在业务活动中的过程。<br />
一个活动图的示例如下所示。</p>
</blockquote>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-activity-diagram.gif"/></div>
<p>下面描述组成活动图的元素。</p>
<h3 id="活动"><a class="markdownIt-Anchor" href="#活动"></a> 活动</h3>
<p>活动是行为参数化顺序的规范。活动被表示为圆角矩形，内含全部的动作，工作流和其他组成活动的元素。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-activity.gif"/></div>
<h3 id="动作"><a class="markdownIt-Anchor" href="#动作"></a> 动作</h3>
<p>一个动作代表活动中的一个步骤。动作用圆角矩形表示。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-action.gif"/></div>
<h3 id="动作约束"><a class="markdownIt-Anchor" href="#动作约束"></a> 动作约束</h3>
<p>动作可以附带约束，下图显示了一个带前置条件和后置条件的动作。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-conditions.gif"/></div>
<h3 id="控制流"><a class="markdownIt-Anchor" href="#控制流"></a> 控制流</h3>
<p>控制流显示一个动作到下一个动作的流。表示为带箭头实线</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-activity-edge.gif"/></div>
<h3 id="初始节点"><a class="markdownIt-Anchor" href="#初始节点"></a> 初始节点</h3>
<p>一个开始或起始点用大黑圆点表示，如下图。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-activity-initial.gif"/></div>
<h3 id="结束节点"><a class="markdownIt-Anchor" href="#结束节点"></a> 结束节点</h3>
<p>结束节点有两种类型：活动结束节点和流结束节点。活动结束节点表示为中心带黑点的圆环。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-activity-final.gif"/></div>
<p>流结束节点表示为内部为叉号的圆环。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-flow-final.gif"/></div>
<p>这两种不同类型节点的区别为：流结束节点表明单独的控制流的终点。活动结束终点是活动图内所有控制流的结束。</p>
<h3 id="对象和对象流"><a class="markdownIt-Anchor" href="#对象和对象流"></a> 对象和对象流</h3>
<p>对象流是对象和数据转递的通道。对象显示为矩形。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-activity-object.gif"/></div>
<p>对象流显示为带箭头的连接器，表明方向和通过的对象。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-object-flow.gif"/></div>
<p>一个对象流在它的至少一个终端有一个对象。在上图中，可以采用带输入输出引脚的速记标柱表示。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-object-flow-alt.gif"/></div>
<p>数据存储显示为带 «datastore» 关键字的对象。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-data-store.gif"/></div>
<h3 id="判断节点和合并节点"><a class="markdownIt-Anchor" href="#判断节点和合并节点"></a> 判断节点和合并节点</h3>
<p>判断节点和合并节点是相同标注：菱形。它们可以被命名。从判断节点出来的控制流有监护条件，当监护条件满足时，可以对流控制。下图显示了判断节点和合并节点的使用。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-activity-decision-or-merge.gif"/></div>
<h3 id="分叉和结合节点"><a class="markdownIt-Anchor" href="#分叉和结合节点"></a> 分叉和结合节点</h3>
<p>分叉和结合节点有同样的标柱：垂直或水平条（方向取决于工作流从左到右，还是从上到下）。它们说明了控制的并发线程的起始和终点，下图显示他们的使用示例。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-activity-fork-and-join.gif"/></div>
<p>结合节点与合并节点不同之处在于：结合节点同步两个输入量，产生一个单独的输出量。来自结合节点的输出量要接收到所有的输入量后才能执行。合并节点直接将控制流传递通过。如果两个或更多的输入量到达合并节点。则它的输出流指定的动作会被执行两次或更多次。</p>
<h3 id="扩展域"><a class="markdownIt-Anchor" href="#扩展域"></a> 扩展域</h3>
<p>扩展域是会执行多次的结构活动域。输入输出扩展节点表示为一组“3 厢” ，代表多个选择项。关键词 “iterative”， “parallel” 或 &quot;stream&quot;显示在区域的左上角</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-activity-expansion-region.gif"/></div>
<h3 id="异常处理器"><a class="markdownIt-Anchor" href="#异常处理器"></a> 异常处理器</h3>
<p>异常处理器在活动图中可以建模。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-exception-handler.gif"/></div>
<h3 id="可中断活动区"><a class="markdownIt-Anchor" href="#可中断活动区"></a> 可中断活动区</h3>
<p>可中断活动区环绕一组可以中断的动作。在下面非常简单的例子中： 当控制被传递到结束订单 “Close Order” 动作，定单处理&quot;Process Order&quot; 动作会执行直到完成，除非&quot;Cancel Request&quot;取消请求中断被接受，这会将控制传递给&quot;Cancel Order&quot;动作。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-interruptible-activity-region.gif"/></div>
<h3 id="分割"><a class="markdownIt-Anchor" href="#分割"></a> 分割</h3>
<p>一个活动分割显示为垂直或水平泳道。在下图中，分割被用来在活动图中分隔动作，有在 &quot;accounting department&quot;中执行的，有在 &quot;customer&quot;中执行的。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-activity-partitions.gif"/></div>
<h2 id="状态机图"><a class="markdownIt-Anchor" href="#状态机图"></a> 状态机图</h2>
<blockquote>
<p><strong>状态机图（state-machine-diagram）对一个单独对象的行为建模，指明对象在它的整个生命周期里，响应不同事件时，执行相关事件的顺序。</strong></p>
</blockquote>
<p>如下示例， 下列的状态机图显示了门在它的整个生命周期里如何运作。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-state-diagram.gif"/></div>
<p>门可以处于以下的三种状态之一： &quot;Opened&quot;打开状态， &quot;Closed&quot;关闭状态，或者&quot;Locked&quot;锁定状态。 它分别响应事件：“Open”开门， “Close”关门， “Lock”锁门 和 “Unlock”解锁。 注意：不是所有的事件，在所有的状态下都是有效的。如：一个门打开的时候是不可能锁定的，除非你关上门。并且，状态转移可能有附加监护条件：假设门是开的，如果“doorWay-&gt;isEmpty”（门是空的）被满足，那么它只能响应关门事件。状态机图使用的语法和约定将在下面的部分进行讨论。</p>
<h3 id="状态"><a class="markdownIt-Anchor" href="#状态"></a> 状态</h3>
<p>状态被表示为圆角矩形，状态名写在里面。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-state.gif"/></div>
<h3 id="起始和结束状态"><a class="markdownIt-Anchor" href="#起始和结束状态"></a> 起始和结束状态</h3>
<p>初始状态表示为实心黑圆环，可以标注名称。结束状态表示为中心带黑点圆环，也可以被标注名称。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-state-initial-and-final.gif"/></div>
<h3 id="转移"><a class="markdownIt-Anchor" href="#转移"></a> 转移</h3>
<p>一个状态到下一个状态的转移表示为带箭头实线。转移可以有一个“Trigger”触发器，一个“Guard”监护条件和一个“effect”效果。如下所示：</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-state-transition.gif"/></div>
<p>&quot;Trigger&quot;触发器是转移的起因，它可以是某个条件下的一个信号，一个事件，一个变化或一个时间通路。&quot;Guard&quot;监护是一个条件，而且必须为真，以便于让触发器引起转移。效果&quot;Effect&quot;是直接作用到对象上的一个动作，该对象具有做为转移结果的状态机。</p>
<h3 id="状态活动"><a class="markdownIt-Anchor" href="#状态活动"></a> 状态活动</h3>
<p>在上面的状态转移示例中，一个效果与该转移相关联。如果目标状态有多个转移到达，并且每一个转移都有相同的效果与它相关联，那最好将该效果与目标状态相关联，而不与转移相关联。你可以通过为这个状态定义初始动作来实现。下图显示了一个带入口动作和出口动作的状态。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-state-entry-and-exit.gif"/></div>
<p>可以定义发生在事件上的动作或一直发生的动作。每一种类型的动作是可以定义任意数量的。</p>
<h3 id="自转移"><a class="markdownIt-Anchor" href="#自转移"></a> 自转移</h3>
<p>一个状态可能有一个返回到自身的转移，如下图。效果与转移关联是十分有帮助。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-state-self-transition.gif"/></div>
<h3 id="复合状态"><a class="markdownIt-Anchor" href="#复合状态"></a> 复合状态</h3>
<p>一个状态机图可以有子状态机图，如下图所示：</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-state-compound.gif"/></div>
<p>可选择不同方式显示相同信息，如下图所示：</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-state-composite.gif"/></div>
<p>上面版本的标注说明&quot;Check PIN&quot;的子状态机图显示在单独的图中。</p>
<h3 id="入口点"><a class="markdownIt-Anchor" href="#入口点"></a> 入口点</h3>
<p>有时，你不想在正常的初始状态进入子状态机。例如下面的子状态机，它通常从&quot;初始化&quot;状态开始，但是如果因为某些原因，它不必执行初始化，可能靠转移到指定的入口点来从 “Ready” 状态开始。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-state-entry-point.gif"/></div>
<p>下图显示了状态机的上一层。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-state-entry-point-higher.gif"/></div>
<h3 id="出口点"><a class="markdownIt-Anchor" href="#出口点"></a> 出口点</h3>
<p>有与入口点相类似的方式，它可能也指定可选择的出口点。下图给出了主处理状态执行后，所执行状态的去向将取决于该状态转移时所使用的路径。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-state-exit-point.gif"/></div>
<h3 id="选择伪状态"><a class="markdownIt-Anchor" href="#选择伪状态"></a> 选择伪状态</h3>
<p>选择伪状态显示为菱形，有一个转移输入，两个或多个输出。下图显示不管到达哪一个状态，经过选择伪状态后的去向，取决于在伪状态中执行时所选择的消息格式。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-state-choice.gif"/></div>
<h3 id="连接伪状态"><a class="markdownIt-Anchor" href="#连接伪状态"></a> 连接伪状态</h3>
<p>连接伪状态用来将多个状态转移链接在一起。一个单独的连接伪状态可以有一个或多个输入和一个或多个输出，监护可能应用于每一个转移，连接是没有语义的。连接可以把一个输入转移分成多个输出转移来实现一个静态分支。与之对照的是选择伪状态实现一个动态条件分支。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-state-junction.gif"/></div>
<h3 id="终止伪状态"><a class="markdownIt-Anchor" href="#终止伪状态"></a> 终止伪状态</h3>
<p>进入终止伪状态是指状态机生命线已经终止。终止伪状态表示为叉号。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-state-terminate.gif"/></div>
<h3 id="历史状态"><a class="markdownIt-Anchor" href="#历史状态"></a> 历史状态</h3>
<p>历史状态用来当状态机中断时，恢复状态机之前状态。下面例图说明了历史状态的使用。这个例子是关于洗衣机的状态机。</p>
<p>在这个状态机中，当洗衣机运行时，它会按照&quot;Washing&quot; 到 Rinsing&quot;再到&quot;Spinning&quot;来进行。如果电源被切断 ，洗衣机会停止运行并进入&quot;Power Off&quot; 状态。当电源恢复，运行状态在&quot;History State&quot;符号处进入，表示它会从上次离开的地方恢复。</p>
<h3 id="并发区"><a class="markdownIt-Anchor" href="#并发区"></a> 并发区</h3>
<p>一个状态可以被分成几个不同的区，包含同时存在和执行的子状态。下面的例子显示状态 “Applying Brakes”， “front brake&quot;和&quot;rear brakes” 将同时独立运作。注意使用了分叉和结合伪状态而不是选择和合并伪状态。这些符号用来同步并发的线程。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-state-concurrent-regions.gif"/></div>
<h2 id="用例图"><a class="markdownIt-Anchor" href="#用例图"></a> 用例图</h2>
<blockquote>
<p><strong>用例图用来记录系统的需求，它提供系统与用户及其他参与者的一种通信手段。</strong></p>
</blockquote>
<h3 id="执行者"><a class="markdownIt-Anchor" href="#执行者"></a> 执行者</h3>
<p>用例图显示了系统和系统外实体之间的交互。这些实体被引用为执行者。执行者代表角色，可以包括：用户，外部硬件和其他系统。执行者往往被画成简笔画小人。也可以用带«actor»关键字的类矩形表示。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-use-case-actor.gif"/></div>
<p>在下图中，执行者可以详细的泛化其他执行者:</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-use-case-generalize.gif"/></div>
<h3 id="用例"><a class="markdownIt-Anchor" href="#用例"></a> 用例</h3>
<p>用例是有意义的单独工作单元。它向系统外部的人或事提供一个易于观察的高层次行为视图。 用例的标注符号是一个椭圆。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-use-case.gif"/></div>
<p>使用用例的符号是带可选择箭头的连接线，箭头显示控制的方向。下图说明执行者 &quot;Customer&quot;使用 &quot;Withdraw&quot;用例。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-use-case-use.gif"/></div>
<p>用途连接器（uses connector）可以有选择性的在每一个端点有多重性值，如下图，显示客户一次可能只执行一次取款交易。但是银行可以同时执行许多取款交易。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-use-case-multiplicity-use.gif"/></div>
<h3 id="用例定义"><a class="markdownIt-Anchor" href="#用例定义"></a> 用例定义</h3>
<p>一个典型的用例包括:</p>
<ul>
<li><strong>名称和描述</strong> - 用例通常用一个动词词组定义，而且有一个简短的文字说明。</li>
<li><strong>需求</strong> - 需求定义了一个用例必须提供给终端用户的正式功能性需求。它们符合构造方法建立的功能性规范。一个需求是用例将执行一个动作或提供多个值给系统的约定或承诺。</li>
<li><strong>约束</strong> - 一个约束是一个用例运行的条件或限制。它包括：前置条件，后置条件和不变化条件 。前置条件指明了用例在发生之前需要符合的条件。后置条件用来说明在用例执行之后一些条件必须为&quot;真&quot;。不变化条件说明用例整个执行过程中该条件始终为&quot;真&quot;。</li>
<li><strong>情形</strong> - 情形是用例的实例在执行过程中，事件发生流程的形式描述。它定义了系统和外部执行者之间的事件指定顺序。通常用文本方式来表示，并对应时序图中的文字描述。</li>
<li><strong>情形图</strong></li>
<li><strong>附加信息</strong></li>
</ul>
<h3 id="包含用例"><a class="markdownIt-Anchor" href="#包含用例"></a> 包含用例</h3>
<p>用例可能包含其他用例的功能来作为它正常处理的一部分。通常它假设，任何被包含的用例在基本程序运行时每一次都会被调用。下面例子：用例“卡的确认”<Card Identification> 在运行时，被用例“取钱”<Withdraw>当作一个子部分。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-use-case-include.gif"/></div>
<p>用例可以被一个或多个用例包含。通过提炼通用的行为，将它变成可以多次重复使用的用例。有助于降低功能重复级别。</p>
<h3 id="扩展用例"><a class="markdownIt-Anchor" href="#扩展用例"></a> 扩展用例</h3>
<p>一个用例可以被用来扩展另一个用例的行为，通常使用在特别情况下。例如：假设在修改一个特别类型的客户订单之前，用户必须得到某种更高级别的许可，然后“获得许可”<Get Approval>用例将有选择的扩展常规的“修改订单”<Modify Order>用例。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-use-case-extend.gif"/></div>
<p><strong>扩展点</strong> - 扩展用例的加入点被定义为扩展点。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-use-case-extend-with-condition.gif"/></div>
<p><strong>系统边界</strong> - 它用来显示用例在系统内部，执行者在系统的外部。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-use-case-system-boundary.gif"/></div>
<h2 id="通信图"><a class="markdownIt-Anchor" href="#通信图"></a> 通信图</h2>
<blockquote>
<p>通信图，以前称之为协作图，是一种交互图，<strong>所显示消息与时序图相似，但是它更侧重于对象间的联系</strong>。</p>
</blockquote>
<p>在通信图中，对象之间显示关联连接器。消息附加到这些关联上，显示短箭头指向消息流的方向。消息的顺序通过编号码显示。</p>
<p>下面的两个图用通信图和时序图分别显示相同的信息。尽管我们可能从通信图的编号码得到消息顺序，但它不是立即可见的。通信图十分清楚的显示了邻近对象间全部完整的消息传递。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-communications-diagram.gif"/></div>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-sequence-diagram.gif"/></div>
<h2 id="交互概述图"><a class="markdownIt-Anchor" href="#交互概述图"></a> 交互概述图</h2>
<blockquote>
<p><strong>一个交互概览图是活动图的一种形式，它的节点代表交互图。交互图包含时序图，通信图，交互概览图和时间图。 大多数交互概览图标注与活动图一样。例如：起始，结束，判断，合并，分叉和结合节点是完全相同。并且，交互概览图介绍了两种新的元素：交互发生和交互元素。</strong></p>
</blockquote>
<h3 id="交互发生"><a class="markdownIt-Anchor" href="#交互发生"></a> 交互发生</h3>
<p>交互发生引用现有的交互图。显示为一个引用框，左上角显示 “ref” 。被引用的图名显示在框的中央。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-interaction-overview-01.gif"/></div>
<h3 id="交互元素"><a class="markdownIt-Anchor" href="#交互元素"></a> 交互元素</h3>
<p>交互元素与交互发生相似之处在于都是在一个矩形框中显示一个现有的交互图。不同之处在内部显示参考图的内容不同。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-interaction-overview-02.gif"/></div>
<h3 id="将它们放在一起"><a class="markdownIt-Anchor" href="#将它们放在一起"></a> 将它们放在一起</h3>
<p>所有的活动图控件，都可以相同地被使用于交互概览图，如：分叉，结合，合并等等。它把控制逻辑放入较低一级的图中。下面的例子就说明了一个典型的销售过程。子过程是从交互发生抽象而来。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-interaction-overview-diagram.gif"/></div>
<h2 id="时序图"><a class="markdownIt-Anchor" href="#时序图"></a> 时序图</h2>
<blockquote>
<p><strong>时序图是交互图的一种形式，它显示对象沿生命线发展，对象之间随时间的交互表示为从源生命线指向目标生命线的消息。时序图能很好地显示那些对象与其它那些对象通信，什么消息触发了这些通信，时序图不能很好显示复杂过程的逻辑。</strong></p>
</blockquote>
<h3 id="生命线"><a class="markdownIt-Anchor" href="#生命线"></a> 生命线</h3>
<p>一条生命线在时序图中代表一个独立的参与者。表示为包含对象名的矩形，如果它的名字是&quot;self&quot;，则说明该生命线代表控制带时序图的类元。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-sequence-lifelines.gif"/></div>
<p>有时，时序图会包含一个顶端是执行者的生命线。这情况说明掌握这个时序图的是用例。健壮图中的边界，控制和实体元素也可以有生命线。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-sequence-more-lifelines.gif"/></div>
<h3 id="消息"><a class="markdownIt-Anchor" href="#消息"></a> 消息</h3>
<p>消息显示为箭头。消息可以完成传输，也可能丢失和找回，它可以是同步的，也可以是异步的，即可以是调用，也可以是信号。在下图中，第一条消息是同步消息(标为实箭头)完成传输，并隐含一条返回消息。第二条消息是异步消息 (标为实线箭头)，第三条是异步返回消息(标为虚线)。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-sequence-messages.gif"/></div>
<h3 id="执行发生"><a class="markdownIt-Anchor" href="#执行发生"></a> 执行发生</h3>
<p>向下延伸的细条状矩形表示执行事件或控制焦点的激活。在上图中有三个执行事件。第一个是源对象发送两条消息和收到两条回复。第二个是目标对象收到一条同步消息并返回一条回复。第三个是目标对象收到一条异步消息并返回一条回复。</p>
<h3 id="内部通信"><a class="markdownIt-Anchor" href="#内部通信"></a> 内部通信</h3>
<p>内部消息表现为一个操作的递归调用，或一个方法调用属于同一个对象的其他方法。显示为生命线上执行事件的嵌套控制焦点。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-sequence-recursion.gif"/></div>
<h3 id="迷路消息和拾取消息"><a class="markdownIt-Anchor" href="#迷路消息和拾取消息"></a> 迷路消息和拾取消息</h3>
<p>迷路消息是那些发送了却没有到达指定接收者，或者到达的接收者不再当前图中。拾取消息是收到来自那些未知的发送者，或者来自没有显示在当前图的发送者的消息。它们都表明是去往或来自一个终点元素。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-sequence-lost-and-found.gif"/></div>
<h3 id="生命线开始与结束"><a class="markdownIt-Anchor" href="#生命线开始与结束"></a> 生命线开始与结束</h3>
<p>生命线可以在时序图时间刻度范围内创建和销毁，在下面的例子中，生命线被停止符号（叉号）终止。在前面的例子中，生命线顶端的符号（Child）显示在比创建它的对象符号（parent）沿页面要低的位置上。下图显示创建和终止对象。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-sequence-lost-and-found.gif"/></div>
<h3 id="时间和期限约束"><a class="markdownIt-Anchor" href="#时间和期限约束"></a> 时间和期限约束</h3>
<p>消息默认显示为水平线。因为生命线显示为沿屏幕向下的时间通道，所以当给实时系统建模，或是有时间约束的业务过程建模，考虑执行动作所需时间长度是很重要的。因此可以给消息设置一个期限约束，这样的消息显示为下斜线。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-sequence-time.gif"/></div>
<h3 id="复合片段"><a class="markdownIt-Anchor" href="#复合片段"></a> 复合片段</h3>
<p>如前面所说，时序图不适合表达复杂的过程逻辑。在一种情况下，有许多机制允许把一定程度的过程逻辑加入到图中，并把它们放到复合片段的标题下。复合片段是一个或多个处理顺序被包含在一个框架中，并在指定名称的环境下执行。片段可以是:</p>
<ul>
<li>选择性片段 (显示 “alt”) 为 if…then…else 结构建模。</li>
<li>选项片段 (显示 “opt”) 为 “switch”(开关) 结构建模。</li>
<li>中断片段对被处理事件的可选择顺序建模，而不是该图的其他部分。</li>
<li>并行片段(显示 “par”) 为并发处理建模。</li>
<li>弱顺序片段 (显示 “seq”) 包含了一组消息，这组消息必须在后继片段开始之前被处理。但不会把片段内消息的先后顺序强加到不共享同一条生命线的消息上。</li>
<li>严格顺序片段 (显示 “strict”) 包含了一系列需要按照给定顺序处理的消息。</li>
<li>非片段 (显示 “neg”) 包含了一系列不可用的消息。</li>
<li>关键片段 具有关键部分。</li>
<li>忽略片段 声明一个没有意义的消息，如果它出现在当前上下文中。</li>
<li>考虑片段与忽略片段相反，不包含在考虑片段内的消息都应该被忽略。</li>
<li>断言片段 (显示 “assert”)标明任何没有显示为声明操作数的顺序都是无效的。</li>
<li>循环片段 包含一系列被重复的消息。</li>
</ul>
<p>下图显示的是循环片段：</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-sequence-fragment.gif"/></div>
<p>这也是一个类似于复合片段的交互发生。 交互发生被其他图参考，显示为左上角带&quot;ref&quot;，将被参考图名显示在方框的中间。</p>
<h3 id="门"><a class="markdownIt-Anchor" href="#门"></a> 门</h3>
<p>门是连接片段内消息和片段外消息的连接点。 在 EA 中，门显示为片段框架上的小正方形。作用为时序图与页面外的连接器。 用来表示进来的消息源，或者出去消息的终点。下面两个图显示它们在实践中的使用。注意：&quot; top level diagram&quot;中的门用消息箭头指向参考片段，在这里没有必要把它画成方块。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-sequence-top-level-diagram.gif"/></div>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-sequence-nested-diagram.gif"/></div>
<h3 id="部分分解"><a class="markdownIt-Anchor" href="#部分分解"></a> 部分分解</h3>
<p>一个对象可以引出多条生命线，使得对象内部和对象之间的消息显示在同一图上。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-sequence-part-decomposition.gif"/></div>
<h3 id="状态常量延续"><a class="markdownIt-Anchor" href="#状态常量延续"></a> 状态常量/延续</h3>
<p>状态常量是生命线的约束，运行时始终为&quot;真&quot;。显示为两侧半圆的矩形，如下图：</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-sequence-state-invariant.gif"/></div>
<p>延续虽与状态常量有同样的标注，但是被用于复合片段，并可以延伸跨越多条生命线。</p>
<h2 id="时间图"><a class="markdownIt-Anchor" href="#时间图"></a> 时间图</h2>
<blockquote>
<p><strong>UML 时间图被用来显示随时间变化，一个或多个元素的值或状态的更改。也显示时控事件之间的交互和管理它们的时间和期限约束。</strong></p>
</blockquote>
<h3 id="状态生命线"><a class="markdownIt-Anchor" href="#状态生命线"></a> 状态生命线</h3>
<p>状态生命线显示随时间变化，一个单项状态的改变。不论时间单位如何选择，X 轴显示经过的时间，Y 轴被标为给出状态的列表。状态生命线如下所示：</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-state-lifeline.gif"/></div>
<h3 id="值生命线"><a class="markdownIt-Anchor" href="#值生命线"></a> 值生命线</h3>
<p>值生命线显示随时间变化，一个单项的值的变化。X 轴显示经过的时间，时间单位为任意，和状态生命线一样。平行线之间显示值，每次值变化，平行线交叉。如下图所示。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-value-lifeline.gif"/></div>
<h3 id="将它们放在一起-2"><a class="markdownIt-Anchor" href="#将它们放在一起-2"></a> 将它们放在一起</h3>
<p>状态和值的生命线能叠加组合。它们必须有相同的 X 轴。 消息可以从一个生命线传递到另一个。每一个状态和值的变换能有一个定义的事件，一个时间限制是指一个事件何时必须发生，和一个期限限制说明状态或值多长时间必须有效。一旦这些已经被应用，其时间图可能显示如下。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-timing-diagram.gif"/></div>
<h2 id="uml-工具"><a class="markdownIt-Anchor" href="#uml-工具"></a> UML 工具</h2>
<p>UML 工具非常多，到底哪种工具好，真的是仁者见仁智者见智。这里列举一些我接触过的 UML 工具：</p>
<h3 id="亿图"><a class="markdownIt-Anchor" href="#亿图"></a> 亿图</h3>
<blockquote>
<p>国内开发的、收费的绘图工具。图形模板、素材非常全面，样式也很精美，可以导出为 word、pdf、图片。</p>
<p><a href="http://www.edrawsoft.cn/" target="_blank" rel="noopener">亿图官网</a></p>
</blockquote>
<div align="center"><img src="http://www.edrawsoft.cn/images/software/createsoftware.png"/></div>
<h3 id="visio"><a class="markdownIt-Anchor" href="#visio"></a> Visio</h3>
<blockquote>
<p>Office 的绘图工具，特点是简单、清晰。</p>
<p><a href="https://products.office.com/zh-cn/visio/flowchart-software" target="_blank" rel="noopener">Visio 官网</a></p>
</blockquote>
<div align="center"><img src="https://img-prod-cms-rt-microsoft-com.akamaized.net/cms/api/am/imageFileData/RE2jMC4?ver=5361&q=90&h=675&w=830&b=%23FFFFFFFF&aim=true"/></div>
<h3 id="staruml"><a class="markdownIt-Anchor" href="#staruml"></a> StarUML</h3>
<blockquote>
<p>样式精美，功能全面的 UML 工具。</p>
<p><a href="http://staruml.io/" target="_blank" rel="noopener">StarUML 官网</a></p>
</blockquote>
<div align="center"><img src="http://staruml.io/image/screenshot_jumbotron.png"/></div>
<h3 id="astah"><a class="markdownIt-Anchor" href="#astah"></a> Astah</h3>
<blockquote>
<p>样式不错，功能全面的绘图工具。</p>
<p><a href="http://astah.net/" target="_blank" rel="noopener">Astah 官网</a></p>
</blockquote>
<div align="center"><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1539757904141&di=7e4f71d0a00ffcd87e0e5aa62f0ed168&imgtype=jpg&src=http%3A%2F%2Fimg4.imgtn.bdimg.com%2Fit%2Fu%3D3525476819%2C2924170461%26fm%3D214%26gp%3D0.jpg"/></div>
<h3 id="argouml"><a class="markdownIt-Anchor" href="#argouml"></a> ArgoUML</h3>
<blockquote>
<p>UML 工具。</p>
<p><a href="https://argouml.en.softonic.com/?ex=CAT-759.2" target="_blank" rel="noopener">ArgoUML 官网</a></p>
</blockquote>
<div align="center"><img src="https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=f4e8a7c6923df8dcb23087c3ac7819ee/8b13632762d0f70315a83ced05fa513d2697c5ed.jpg"/></div>
<h3 id="processon"><a class="markdownIt-Anchor" href="#processon"></a> ProcessOn</h3>
<blockquote>
<p>在线绘图工具，特点是简洁、清晰。</p>
<p><a href="https://www.processon.com/" target="_blank" rel="noopener">ProcessOn 官网</a></p>
</blockquote>
<h3 id="drawio"><a class="markdownIt-Anchor" href="#drawio"></a> drawio</h3>
<blockquote>
<p>开源的在线绘图工具，特点是简洁、清晰。</p>
<p><a href="https://www.draw.io/" target="_blank" rel="noopener">drawio 官网</a></p>
</blockquote>
<h2 id="更多内容"><a class="markdownIt-Anchor" href="#更多内容"></a> 更多内容</h2>
<blockquote>
<p>📓 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p>
</blockquote>
<h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener">Wiki-UML</a></li>
<li><a href="https://sparxsystems.cn/resources/uml2_tutorial/index.html" target="_blank" rel="noopener">Sparx UML 教程</a></li>
<li><a href="https://www.omg.org/spec/UML" target="_blank" rel="noopener">OMG UML</a></li>
<li><a href="https://www.tutorialspoint.com/uml/index.htm" target="_blank" rel="noopener">UML Tutorial</a></li>
<li><a href="https://www.w3cschool.cn/uml_tutorial/" target="_blank" rel="noopener">W3Cschool UML 教程</a></li>
<li><a href="https://blog.csdn.net/soft_zzti/article/details/79811923" target="_blank" rel="noopener">UML 学习入门就这一篇文章</a></li>
<li><a href="http://www.cnblogs.com/ywqu/category/223486.html" target="_blank" rel="noopener">http://www.cnblogs.com/ywqu/category/223486.html</a></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>设计</tag>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络指南</title>
    <url>/blog/communication/network-guide/</url>
    <content><![CDATA[<blockquote>
<p>计算机网络是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。</p>
</blockquote>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/network.jpg!zp"/></div>
<h2 id="指南"><a class="markdownIt-Anchor" href="#指南"></a> 💡 指南</h2>
<p>学习之前，先看一下入门三问：</p>
<blockquote>
<p><strong>一、什么是计算机网络？</strong></p>
<p>计算机网络是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。</p>
<p>——摘自百度百科</p>
</blockquote>
<blockquote>
<p><strong>二、为什么学习计算机网络？</strong></p>
<p>计算机网络是计算机科学的基础课程，也是计算机专业考研必考科目，可见其重要性。作为一名程序员，了解计算机网络，对于 Web 领域，通信领域的开发有莫大的帮助。</p>
<p>在浏览器中访问网页的原理是什么？Wifi 是如何工作的？防火墙是如何保障网络安全的？什么是安全证书？Cookie 和 Session 是什么东西？。。。</p>
<p>如果你接触过这些技术，如果你想了解这些技术的原理，那么你就有必要学习一下计算机网络了。</p>
</blockquote>
<blockquote>
<p><strong>三、如何学习计算机网络？</strong></p>
<p>本人有 2 年通信领域开发经验，从事通信设备上的协议开发。就我个人的学习经验来看，学习计算机网络可以分为以下阶段：</p>
<ul>
<li><strong>基础阶段——一般性的了解网络协议分层及各层功能</strong>
<ul>
<li>了解计算机网络协议分层（OSI）有哪些层，分层的依据是什么（即每层的功能是什么）</li>
<li>了解每层的主要通信设备有哪些；</li>
<li>了解每层有哪些重要网络协议，这些协议有什么作用，基本原理是什么？</li>
<li>了解每层的传输数据形式（如：报文、帧等）</li>
</ul>
</li>
<li><strong>进阶阶段——系统学习计算机网络知识，将各层主要协议功能串联起来</strong>
<ul>
<li>学习 TCP/IP 详解 卷 1、卷 2、卷 3（内容详实，但文字较为晦涩，不适合初学者）</li>
</ul>
</li>
<li><strong>专业阶段——根据业务领域，有针对性的学习</strong>
<ul>
<li>网络协议很多，而且专业性非常强。精通所有协议，几乎是不可能的，所以有必要根据自己的业务领域，有针对性的深入学习协议。如果你是做 web 开发，那么你很有必要认真学习一下 HTTP、DNS 协议；如果你是做路由器、交换机领域通信开发，那么你应该更深入学习一下 IP/TCP/UDP 协议。。。</li>
<li>如何深入学习协议，最好的学习方式，就是深入学习 RFC，并结合实际的协议报文去了解。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="核心概念"><a class="markdownIt-Anchor" href="#核心概念"></a> 核心概念</h3>
<ul>
<li><strong>计算机网络</strong> - 计算机网络（computer network），通常也简称网络，是利用通信设备和线路将地理位置不同的、功能独立的多个<a href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E5%AD%90%E8%A8%88%E7%AE%97%E6%A9%9F" target="_blank" rel="noopener">计算机</a>系统连接起来，以功能完善的网络<a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6" target="_blank" rel="noopener">软件</a>实现网络的<a href="https://zh.wikipedia.org/wiki/%E7%A1%AC%E4%BB%B6" target="_blank" rel="noopener">硬件</a>、<a href="https://zh.wikipedia.org/wiki/%E8%BB%9F%E4%BB%B6" target="_blank" rel="noopener">软件</a>及资源<a href="https://zh.wikipedia.org/wiki/%E5%85%B1%E4%BA%AB" target="_blank" rel="noopener">共享</a>和<a href="https://zh.wikipedia.org/wiki/%E4%BF%A1%E6%81%AF" target="_blank" rel="noopener">信息</a>传递的系统。简单的说即连接两台或多台计算机进行<a href="https://zh.wikipedia.org/wiki/%E9%80%9A%E4%BF%A1" target="_blank" rel="noopener">通信</a>的系统。</li>
<li><strong>互联网</strong> - 互联网（Internet），即网络的网络。</li>
</ul>
<h3 id="拓扑结构"><a class="markdownIt-Anchor" href="#拓扑结构"></a> 拓扑结构</h3>
<p>计算机网络的拓扑结构可分为：</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/overview/network-topological-structure.gif!zp"/></div>
<ul>
<li>网型拓扑网型网（Mesh network）</li>
<li>环型拓扑环型网（Ring network）</li>
<li>星型拓扑星型网（Star network）</li>
<li>树状拓扑树型网（Tree network）</li>
<li>总线拓扑总线网（Bus network）</li>
</ul>
<h3 id="作用范围"><a class="markdownIt-Anchor" href="#作用范围"></a> 作用范围</h3>
<ul>
<li>广域网 WAN（Wide Area Network）</li>
<li>城域网 MAN（Metropolitan Area Network）</li>
<li>局域网 LAN（Local Area Network）</li>
<li>个人区域网 PAN（Personal Area Network）</li>
</ul>
<h3 id="性能指标"><a class="markdownIt-Anchor" href="#性能指标"></a> 性能指标</h3>
<ul>
<li><strong>速率</strong> - 速率的单位是 bit/s（比特每秒）。</li>
<li><strong>带宽（bandwidth）</strong> - 带宽有以下两种不同的意义。
<ul>
<li>信号的带宽是指该信号所包含的各种不同频率成分所占据的频率范围。这种意义的带宽的单位是赫 （或千赫，兆赫，吉赫等）。</li>
<li>网络的带宽表示在单位时间内从网络中的某一点到另一点所能通过的<strong>最高数据率</strong>。这种意义的带宽的单位是 bit/s（比特每秒）。</li>
</ul>
</li>
<li><strong>吞吐量（throughput）</strong> - 吞吐量表示在单位时间内通过某个网络（或信道、接口）的数据量。例如，对于一个 100 Mbit/s 的以太网，其额定速率是 100 Mbit/s。</li>
<li><strong>时延（delay）</strong>
<ul>
<li>总时延 = 排队时延 + 处理时延 + 传输时延 + 传播时延</li>
</ul>
</li>
</ul>
<h2 id="网络分层"><a class="markdownIt-Anchor" href="#网络分层"></a> 网络分层</h2>
<blockquote>
<p>计算机网络如何分层？各层的作用是什么？各层的主要协议、设备分别是什么？</p>
<p>这是学习计算机网络知识宏观层面必须要了解的核心点。知道了这些，对于网络的体系结构就基本上了解了。</p>
</blockquote>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/overview/network-layers.png!zp"/></div>
<p>计算机网络分层一般有三种划分体系：OSI 分层；五层协议分层；TCP/IP 协议分层。</p>
<ul>
<li>OSI 的七层体系结构概念清楚，理论完整，但是比较复杂且不实用，所以并不流行。</li>
<li>五层协议分层是一种折中方案，在现实中更为流行。</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/overview/网络分层架构图.png!zp"/></div>
<h3 id="物理层"><a class="markdownIt-Anchor" href="#物理层"></a> 物理层</h3>
<blockquote>
<p>物理层（Physical Layer）只接收和发送一串比特(bit)流，不考虑信息的意义和信息结构。</p>
<p>扩展阅读：<a href="network-physical.md">计算机网络之物理层</a></p>
</blockquote>
<ul>
<li>关键词：调制、解调、数字信号、模拟信号、通信媒介、信道复用</li>
<li>数据单元：比特流。</li>
<li>典型设备：光纤、同轴电缆、双绞线、中继器和集线器。</li>
</ul>
<h3 id="数据链路层"><a class="markdownIt-Anchor" href="#数据链路层"></a> 数据链路层</h3>
<blockquote>
<p>网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，数据链路层（Data Link Layer）就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。</p>
<p>扩展阅读：<a href="network-data-link.md">计算机网络之数据链路层</a></p>
</blockquote>
<ul>
<li>关键词：点对点信道、广播信道、<code>PPP</code>、<code>CSMA/CD</code>、局域网、以太网、<code>MAC</code>、适配器、集线器、网桥、交换机</li>
<li>主要协议：<code>PPP</code>、<code>CSMA/CD</code> 等。</li>
<li>数据单元：帧（frame）。</li>
<li>典型设备：二层交换机、网桥、网卡。</li>
</ul>
<h3 id="网络层"><a class="markdownIt-Anchor" href="#网络层"></a> 网络层</h3>
<blockquote>
<p>网络层（network layer）为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。</p>
<p>扩展阅读：<a href="network-network.md">计算机网络之网络层</a></p>
</blockquote>
<ul>
<li>关键词：<code>IP</code>、<code>ICMP</code>、<code>ARP</code>、路由</li>
<li>主要协议：<code>IP</code>。</li>
<li>数据单元：IP 数据报（packet）。</li>
<li>典型设备：网关、路由器。</li>
</ul>
<h3 id="传输层"><a class="markdownIt-Anchor" href="#传输层"></a> 传输层</h3>
<blockquote>
<p>传输层（transport layer）为两台主机中进程间的通信提供通用的数据传输服务。</p>
<p>扩展阅读：<a href="network-network.md">计算机网络之网络层</a></p>
</blockquote>
<ul>
<li>关键词：<code>UDP</code>、<code>TCP</code>、滑动窗口、拥塞控制、三次握手</li>
<li>主要协议：<code>TCP</code>、<code>UDP</code>。</li>
<li>数据单元：报文段（segment）或用户数据报。</li>
</ul>
<h3 id="~会话层~"><a class="markdownIt-Anchor" href="#~会话层~"></a> ~<sub>会话层~</sub></h3>
<blockquote>
<p>~~会话层（Session Layer）不参与具体的传输，它提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制。~~</p>
</blockquote>
<h3 id="~表示层~"><a class="markdownIt-Anchor" href="#~表示层~"></a> ~<sub>表示层~</sub></h3>
<blockquote>
<p>~~表示层（Presentation Layer）是为在应用过程之间传送的信息提供表示方法的服务，它关心的只是发出信息的语法与语义。表示层要完成某些特定的功能，主要有不同数据编码格式的转换，提供数据压缩、解压缩服务，对数据进行加密、解密。~~</p>
</blockquote>
<h3 id="应用层"><a class="markdownIt-Anchor" href="#应用层"></a> 应用层</h3>
<blockquote>
<p>应用层（application layer）通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程间通信和交互的规则。</p>
<p>扩展阅读：<a href="network-application.md">计算机网络之应用层</a></p>
</blockquote>
<ul>
<li>关键词：<code>HTTP</code>、<code>DNS</code>、<code>FTP</code>、<code>TELNET</code>、<code>DHCP</code></li>
<li>主要协议：<code>HTTP</code>、<code>DNS</code>、<code>SMTP</code>、<code>Telnet</code>、<code>FTP</code>、<code>SNMP</code> 等。</li>
<li>数据单元：报文（message）。</li>
</ul>
<h2 id="资源"><a class="markdownIt-Anchor" href="#资源"></a> 资源</h2>
<ul>
<li>书
<ul>
<li><a href="https://book.douban.com/subject/10746113/" target="_blank" rel="noopener">HTTP 权威指南</a></li>
<li><a href="https://book.douban.com/subject/1088054/" target="_blank" rel="noopener">TCP/IP 详解 卷 1：协议</a></li>
<li><a href="https://book.douban.com/subject/1087767/" target="_blank" rel="noopener">TCP/IP 详解 卷 2：实现</a></li>
<li><a href="https://book.douban.com/subject/1058634/" target="_blank" rel="noopener">TCP/IP 详解 卷 3：TCP 事务协议、HTTP、NNTP 和 UNIX 域协议</a></li>
<li><a href="https://book.douban.com/subject/25856314/" target="_blank" rel="noopener">Web性能权威指南</a></li>
<li><a href="https://book.douban.com/subject/25863515/" target="_blank" rel="noopener">图解 HTTP</a></li>
<li><a href="https://book.douban.com/subject/24737674/" target="_blank" rel="noopener">图解TCP/IP</a></li>
<li><a href="https://book.douban.com/subject/26960678/" target="_blank" rel="noopener">计算机网络（第7版）</a> - 谢希仁</li>
</ul>
</li>
<li>站点
<ul>
<li><a href="https://www.rfc-editor.org/" target="_blank" rel="noopener">https://www.rfc-editor.org/</a> - 在线查阅、下载 RFC 文档</li>
</ul>
</li>
<li>工具
<ul>
<li><a href="https://www.wireshark.org/" target="_blank" rel="noopener">WireShark</a></li>
<li><a href="https://www.getpostman.com/" target="_blank" rel="noopener">Postman</a></li>
</ul>
</li>
</ul>
<h2 id="传送门"><a class="markdownIt-Anchor" href="#传送门"></a> 🚪 传送门</h2>
<p>| <a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">回首頁</a> |</p>
]]></content>
      <categories>
        <category>通信</category>
      </categories>
      <tags>
        <tag>通信</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>网络协议之 DNS</title>
    <url>/blog/communication/dns/</url>
    <content><![CDATA[<blockquote>
<p>域名系统（英文：Domain Name System，缩写：DNS）是互联网的一项服务。它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS 使用 TCP 和 UDP 端口 53。当前，对于每一级域名长度的限制是 63 个字符，域名总长度则不能超过 253 个字符。</p>
<p>关键词：DNS, 域名解析</p>
</blockquote>
<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<h3 id="什么是-dns"><a class="markdownIt-Anchor" href="#什么是-dns"></a> 什么是 DNS</h3>
<p>DNS 是一个应用层协议。</p>
<p>域名系统 (DNS) 的作用是将人类可读的域名 (如，<a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a>) 转换为机器可读的 IP 地址 (如，192.0.2.44)。</p>
<h3 id="什么是域名"><a class="markdownIt-Anchor" href="#什么是域名"></a> 什么是域名</h3>
<p>域名是由一串用点分隔符 <code>.</code> 组成的互联网上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的方位。域名可以说是一个 IP 地址的代称，目的是为了便于记忆后者。例如，<a href="http://wikipedia.org" target="_blank" rel="noopener">wikipedia.org</a> 是一个域名，和 IP 地址 208.80.152.2 相对应。人们可以直接访问 <a href="http://wikipedia.org" target="_blank" rel="noopener">wikipedia.org</a> 来代替 IP 地址，然后域名系统（DNS）就会将它转化成便于机器识别的 IP 地址。这样，人们只需要记忆 <a href="http://wikipedia.org" target="_blank" rel="noopener">wikipedia.org</a> 这一串带有特殊含义的字符，而不需要记忆没有含义的数字。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/application/dns/dns-domain.png!zp"/></div>
<h3 id="dns-的分层"><a class="markdownIt-Anchor" href="#dns-的分层"></a> DNS 的分层</h3>
<p><strong>域名系统是分层次的。</strong></p>
<p>在域名系统的层次结构中，各种域名都隶属于域名系统根域的下级。域名的第一级是顶级域，它包括通用顶级域，例如 <code>.com</code>、<code>.net</code> 和 <code>.org</code>；以及国家和地区顶级域，例如 <code>.us</code>、<code>.cn</code> 和 <code>.tk</code>。顶级域名下一层是二级域名，一级一级地往下。这些域名向人们提供注册服务，人们可以用它创建公开的互联网资源或运行网站。顶级域名的管理服务由对应的域名注册管理机构（域名注册局）负责，注册服务通常由域名注册商负责。</p>
<h3 id="dns-服务类型"><a class="markdownIt-Anchor" href="#dns-服务类型"></a> DNS 服务类型</h3>
<ul>
<li><strong>授权型 DNS</strong> - 一种授权型 DNS 服务提供一种更新机制，供开发人员用于管理其公用 DNS 名称。然后，它响应 DNS 查询，将域名转换为 IP 地址，以便计算机可以相互通信。授权型 DNS 对域有最终授权且负责提供递归型 DNS 服务器对 IP 地址信息的响应。Amazon Route 53 是一种授权型 DNS 系统。</li>
<li><strong>递归型 DNS</strong> - 客户端通常不会对授权型 DNS 服务直接进行查询。而是通常连接到称为解析程序的其他类型 DNS 服务，或递归型 DNS 服务。递归型 DNS 服务就像是旅馆的门童：尽管没有任何自身的 DNS 记录，但是可充当代表您获得 DNS 信息的中间程序。如果递归型 DNS 拥有已缓存或存储一段时间的 DNS 参考，那么它会通过提供源或 IP 信息来响应 DNS 查询。如果没有，则它会将查询传递到一个或多个授权型 DNS 服务器以查找信息。</li>
</ul>
<h3 id="记录类型"><a class="markdownIt-Anchor" href="#记录类型"></a> 记录类型</h3>
<p>DNS 中，常见的资源记录类型有：</p>
<ul>
<li><strong>NS 记录（域名服务）</strong> ─ 指定解析域名或子域名的 DNS 服务器。</li>
<li><strong>MX 记录（邮件交换）</strong> ─ 指定接收信息的邮件服务器。</li>
<li><strong>A 记录（地址）</strong> ─ 指定域名对应的 IPv4 地址记录。</li>
<li><strong>AAAA 记录（地址）</strong> ─ 指定域名对应的 IPv6 地址记录。</li>
<li><strong>CNAME（规范）</strong> ─ 一个域名映射到另一个域名或 <code>CNAME</code> 记录（ <a href="http://example.com" target="_blank" rel="noopener">example.com</a> 指向 <a href="http://www.example.com/" target="_blank" rel="noopener">www.example.com</a> ）或映射到一个 <code>A</code>记录。</li>
<li><strong>PTR 记录（反向记录）</strong> ─ PTR 记录用于定义与 IP 地址相关联的名称。 PTR 记录是 A 或 AAAA 记录的逆。 PTR 记录是唯一的，因为它们以 .arpa 根开始并被委派给 IP 地址的所有者。</li>
</ul>
<blockquote>
<p>详细可以参考：<a href="https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%B0%E5%BD%95%E7%B1%BB%E5%9E%8B%E5%88%97%E8%A1%A8" target="_blank" rel="noopener">维基百科 - 域名服务器记录类型列表</a></p>
</blockquote>
<h2 id="域名解析"><a class="markdownIt-Anchor" href="#域名解析"></a> 域名解析</h2>
<p>主机名到 IP 地址的映射有两种方式：</p>
<ul>
<li><strong>静态映射</strong> - 在本机上配置域名和 IP 的映射，旨在本机上使用。Windows 和 Linux 的 hosts 文件中的内容就属于静态映射。</li>
<li><strong>动态映射</strong> - 建立一套域名解析系统（DNS），只在专门的 DNS 服务器上配置主机到 IP 地址的映射，网络上需要使用主机名通信的设备，首先需要到 DNS 服务器查询主机所对应的 IP 地址。</li>
</ul>
<p>通过域名去查询域名服务器，得到 IP 地址的过程叫做域名解析。在解析域名时，一般先静态域名解析，再动态解析域名。可以将一些常用的域名放入静态域名解析表中，这样可以大大提高域名解析效率。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/application/dns/dns-resolve.png!zp"/></div>
<p>上图展示了一个动态域名解析的流程，步骤如下：</p>
<ol>
<li>用户打开 Web 浏览器，在地址栏中输入 <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a>，然后按 Enter 键。</li>
<li><a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> 的请求被路由到 DNS 解析程序，这一般由用户的 Internet 服务提供商 (ISP) 进行管理，例如有线 Internet 服务提供商、DSL 宽带提供商或公司网络。</li>
<li>ISP 的 DNS 解析程序将 <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> 的请求转发到 DNS 根名称服务器。</li>
<li>ISP 的 DNS 解析程序再次转发 <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> 的请求，这次转发到 .com 域的一个 TLD 名称服务器。.com 域的名称服务器使用与 <a href="http://example.com" target="_blank" rel="noopener">example.com</a> 域相关的四个 Amazon Route 53 名称服务器的名称来响应该请求。</li>
<li>ISP 的 DNS 解析程序选择一个 Amazon Route 53 名称服务器，并将 <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> 的请求转发到该名称服务器。</li>
<li>Amazon Route 53 名称服务器在 <a href="http://example.com" target="_blank" rel="noopener">example.com</a> 托管区域中查找 <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> 记录，获得相关值，例如，Web 服务器的 IP 地址 (192.0.2.44)，并将 IP 地址返回至 DNS 解析程序。</li>
<li>ISP 的 DNS 解析程序最终获得用户需要的 IP 地址。解析程序将此值返回至 Web 浏览器。DNS 解析程序还会将 <a href="http://example.com" target="_blank" rel="noopener">example.com</a> 的 IP 地址缓存 (存储) 您指定的时长，以便它能够在下次有人浏览 <a href="http://example.com" target="_blank" rel="noopener">example.com</a> 时更快地作出响应。有关更多信息，请参阅存活期 (TTL)。</li>
<li>Web 浏览器将 <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> 的请求发送到从 DNS 解析程序中获得的 IP 地址。这是您的内容所处位置，例如，在 Amazon EC2 实例中或配置为网站终端节点的 Amazon S3 存储桶中运行的 Web 服务器。</li>
<li>192.0.2.44 上的 Web 服务器或其他资源将 <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> 的 Web 页面返回到 Web 浏览器，且 Web 浏览器会显示该页面。</li>
</ol>
<blockquote>
<p>🔔 注意：只有配置了域名服务器，才能执行域名解析。</p>
<p>例如，在 Linux 中执行 <code>vim /etc/resolv.conf</code> 命令，在其中添加下面的内容来配置域名服务器地址：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">nameserver <span class="number">218.2</span><span class="number">.135</span><span class="number">.1</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="linux-上的域名相关命令"><a class="markdownIt-Anchor" href="#linux-上的域名相关命令"></a> Linux 上的域名相关命令</h2>
<h3 id="hostname"><a class="markdownIt-Anchor" href="#hostname"></a> hostname</h3>
<blockquote>
<p>hostname 命令用于查看和设置系统的主机名称。环境变量 HOSTNAME 也保存了当前的主机名。在使用 hostname 命令设置主机名后，系统并不会永久保存新的主机名，重新启动机器之后还是原来的主机名。如果需要永久修改主机名，需要同时修改 <code>/etc/hosts</code> 和 <code>/etc/sysconfig/network</code> 的相关内容。</p>
<p>参考：<a href="http://man.linuxde.net/hostname" target="_blank" rel="noopener">http://man.linuxde.net/hostname</a></p>
</blockquote>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hostname</span><br><span class="line">AY1307311912260196fcZ</span><br></pre></td></tr></table></figure>
<h3 id="nslookup"><a class="markdownIt-Anchor" href="#nslookup"></a> nslookup</h3>
<blockquote>
<p>nslookup 命令是常用域名查询工具，就是查 DNS 信息用的命令。</p>
<p>参考：<a href="http://man.linuxde.net/nslookup" target="_blank" rel="noopener">http://man.linuxde.net/nslookup</a></p>
</blockquote>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># nslookup www.jsdig.com</span></span><br><span class="line">Server:         202.96.104.15</span><br><span class="line">Address:        202.96.104.15<span class="comment">#53</span></span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">www.jsdig.com canonical name = host.1.jsdig.com.</span><br><span class="line">Name:   host.1.jsdig.com</span><br><span class="line">Address: 100.42.212.8</span><br></pre></td></tr></table></figure>
<h2 id="更多内容"><a class="markdownIt-Anchor" href="#更多内容"></a> 更多内容</h2>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D" target="_blank" rel="noopener">维基百科 - 域名</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">维基百科 - 域名系统</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%B0%E5%BD%95%E7%B1%BB%E5%9E%8B%E5%88%97%E8%A1%A8" target="_blank" rel="noopener">维基百科 - 域名服务器记录类型列表</a></li>
<li><a href="https://aws.amazon.com/cn/route53/what-is-dns/" target="_blank" rel="noopener">什么是 DNS？</a></li>
<li><a href="https://tools.ietf.org/html/rfc1034" target="_blank" rel="noopener">RFC 1034</a></li>
<li><a href="https://tools.ietf.org/html/rfc1035" target="_blank" rel="noopener">RFC 1035</a></li>
</ul>
]]></content>
      <categories>
        <category>通信</category>
      </categories>
      <tags>
        <tag>通信</tag>
        <tag>网络</tag>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title>代码坏味道之变革的障碍</title>
    <url>/blog/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E5%8F%98%E9%9D%A9%E7%9A%84%E9%9A%9C%E7%A2%8D/</url>
    <content><![CDATA[<blockquote>
<p>📓 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p>
<p>翻译自：<a href="https://sourcemaking.com/refactoring/smells/change-preventers" target="_blank" rel="noopener">https://sourcemaking.com/refactoring/smells/change-preventers</a></p>
<p><strong>变革的障碍(Change Preventers)这组坏味道意味着：当你需要改变一处代码时，却发现不得不改变其他的地方。这使得程序开发变得复杂、代价高昂。</strong></p>
</blockquote>
<h2 id="发散式变化"><a class="markdownIt-Anchor" href="#发散式变化"></a> 发散式变化</h2>
<blockquote>
<p><code>发散式变化(Divergent Change)</code> 类似于 <code>霰弹式修改(Shotgun Surgery)</code> ，但实际上完全不同。<code>发散式变化(Divergent Change)</code> 是指一个类受多种变化的影响。<code>霰弹式修改(Shotgun Surgery)</code> 是指多种变化引发多个类相应的修改。</p>
</blockquote>
<h3 id="特征"><a class="markdownIt-Anchor" href="#特征"></a> 特征</h3>
<p>你发现你想要修改一个函数，却必须要同时修改许多不相关的函数。例如，当你想要添加一个新的产品类型时，你需要同步修改对产品进行查找、显示、排序的函数。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/divergent-change-1.png"/></div>
<h3 id="问题原因"><a class="markdownIt-Anchor" href="#问题原因"></a> 问题原因</h3>
<p>通常，这种发散式修改是由于编程结构不合理或者“复制-粘贴式编程”。</p>
<h3 id="解决办法"><a class="markdownIt-Anchor" href="#解决办法"></a> 解决办法</h3>
<ul>
<li>运用 <code>提炼类(Extract Class)</code> 拆分类的行为。</li>
</ul>
<h3 id="收益"><a class="markdownIt-Anchor" href="#收益"></a> 收益</h3>
<ul>
<li>提高代码组织结构</li>
<li>减少重复代码</li>
</ul>
<h3 id="重构方法说明"><a class="markdownIt-Anchor" href="#重构方法说明"></a> 重构方法说明</h3>
<h4 id="提炼类extract-class"><a class="markdownIt-Anchor" href="#提炼类extract-class"></a> 提炼类(Extract Class)</h4>
<p><strong>问题</strong></p>
<p>某个类做了不止一件事。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/extract-class-before.png"/></div>
<p><strong>解决</strong></p>
<p>建立一个新类，将相关的字段和函数从旧类搬移到新类。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/extract-class-after.png"/></div>
<h2 id="平行继承体系"><a class="markdownIt-Anchor" href="#平行继承体系"></a> 平行继承体系</h2>
<blockquote>
<p><code>平行继承体系(Parallel Inheritance Hierarchies)</code> 其实是 <code>霰弹式修改(Shotgun Surgery)</code> 的特殊情况。</p>
</blockquote>
<h3 id="特征-2"><a class="markdownIt-Anchor" href="#特征-2"></a> 特征</h3>
<p>每当你为某个类添加一个子类，必须同时为另一个类相应添加一个子类。这种情况的典型特征是：某个继承体系的类名前缀或类名后缀完全相同。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/parallel-inheritance-hierarchies-1.png"/></div>
<h3 id="问题原因-2"><a class="markdownIt-Anchor" href="#问题原因-2"></a> 问题原因</h3>
<p>起初的继承体系很小，随着不断添加新类，继承体系越来越大，也越来越难修改。</p>
<h3 id="解决方法"><a class="markdownIt-Anchor" href="#解决方法"></a> 解决方法</h3>
<ul>
<li>一般策略是：让一个继承体系的实例引用另一个继承体系的实例。如果再接再厉运用 <code>搬移函数(Move Method)</code> 和 <code>搬移字段(Move Field)</code>，就可以消除引用端的继承体系。</li>
</ul>
<h3 id="收益-2"><a class="markdownIt-Anchor" href="#收益-2"></a> 收益</h3>
<ul>
<li>更好的代码组织</li>
<li>减少重复代码</li>
</ul>
<h3 id="何时忽略"><a class="markdownIt-Anchor" href="#何时忽略"></a> 何时忽略</h3>
<ul>
<li>有时具有并行类层次结构只是一种为了避免程序体系结构更混乱的方法。如果你发现尝试消除平行继承体系导致代码更加丑陋，那么你应该回滚你的修改。</li>
</ul>
<h3 id="重构方法说明-2"><a class="markdownIt-Anchor" href="#重构方法说明-2"></a> 重构方法说明</h3>
<h4 id="搬移函数move-method"><a class="markdownIt-Anchor" href="#搬移函数move-method"></a> 搬移函数(Move Method)</h4>
<p><strong>问题</strong></p>
<p>你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/move-method-before.png"/></div>
<p><strong>解决</strong></p>
<p>在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/move-method-after.png"/></div>
<h4 id="搬移字段move-field"><a class="markdownIt-Anchor" href="#搬移字段move-field"></a> 搬移字段(Move Field)</h4>
<p><strong>问题</strong></p>
<p>在你的程序中，某个字段被其所驻类之外的另一个类更多地用到。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/move-field-before.png"/></div>
<p><strong>解决</strong></p>
<p>在目标类新建一个字段，修改源字段的所有用户，令他们改用新字段。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/move-field-after.png"/></div>
<h2 id="霰弹式修改"><a class="markdownIt-Anchor" href="#霰弹式修改"></a> 霰弹式修改</h2>
<blockquote>
<p><code>霰弹式修改(Shotgun Surgery)</code> 类似于 <code>发散式变化(Divergent Change)</code> ，但实际上完全不同。<code>发散式变化(Divergent Change)</code> 是指一个类受多种变化的影响。<code>霰弹式修改(Shotgun Surgery)</code> 是指多种变化引发多个类相应的修改。</p>
</blockquote>
<h3 id="特征-3"><a class="markdownIt-Anchor" href="#特征-3"></a> 特征</h3>
<p>任何修改都需要在许多不同类上做小幅度修改。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/shotgun-surgery-1.png"/></div>
<h3 id="问题原因-3"><a class="markdownIt-Anchor" href="#问题原因-3"></a> 问题原因</h3>
<p>一个单一的职责被拆分成大量的类。</p>
<h3 id="解决方法-2"><a class="markdownIt-Anchor" href="#解决方法-2"></a> 解决方法</h3>
<ul>
<li>运用<code>搬移函数(Move Method)</code> 和 <code>搬移字段(Move Field)</code> 来搬移不同类中相同的行为到一个独立类中。如果没有适合存放搬移函数或字段的类，就创建一个新类。</li>
<li>通常，可以运用 <code>将类内联化(Inline Class)</code> 将一些列相关行为放进同一个类。</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/shotgun-surgery-2.png"/></div>
<h3 id="收益-3"><a class="markdownIt-Anchor" href="#收益-3"></a> 收益</h3>
<ul>
<li>更好的代码组织</li>
<li>减少重复代码</li>
<li>更易维护</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/shotgun-surgery-3.png"/></div>
<h3 id="重构方法说明-3"><a class="markdownIt-Anchor" href="#重构方法说明-3"></a> 重构方法说明</h3>
<h4 id="搬移函数move-method-2"><a class="markdownIt-Anchor" href="#搬移函数move-method-2"></a> 搬移函数(Move Method)</h4>
<p><strong>问题</strong></p>
<p>你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/move-method-before.png"/></div>
<p><strong>解决</strong></p>
<p>在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/move-method-after.png"/></div>
<h4 id="搬移字段move-field-2"><a class="markdownIt-Anchor" href="#搬移字段move-field-2"></a> 搬移字段(Move Field)</h4>
<p><strong>问题</strong></p>
<p>在你的程序中，某个字段被其所驻类之外的另一个类更多地用到。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/move-field-before.png"/></div>
<p><strong>解决</strong></p>
<p>在目标类新建一个字段，修改源字段的所有用户，令他们改用新字段。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/move-field-after.png"/></div>
<h4 id="将类内联化inline-class"><a class="markdownIt-Anchor" href="#将类内联化inline-class"></a> 将类内联化(Inline Class)</h4>
<p><strong>问题</strong></p>
<p>某个类没有做太多事情。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/inline-class-before.png"/></div>
<p><strong>解决</strong></p>
<p>将这个类的所有特性搬移到另一个类中，然后移除原类。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/inline-class-after.png"/></div>
<h2 id="扩展阅读"><a class="markdownIt-Anchor" href="#扩展阅读"></a> 扩展阅读</h2>
<ul>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/" target="_blank" rel="noopener">代码的坏味道和重构</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%87%83%E8%82%BF.md" target="_blank" rel="noopener">代码坏味道之代码臃肿</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E6%BB%A5%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.md" target="_blank" rel="noopener">代码坏味道之滥用面向对象</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E5%8F%98%E9%9D%A9%E7%9A%84%E9%9A%9C%E7%A2%8D.md" target="_blank" rel="noopener">代码坏味道之变革的障碍</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E9%9D%9E%E5%BF%85%E8%A6%81%E7%9A%84.md" target="_blank" rel="noopener">代码坏味道之非必要的</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E8%80%A6%E5%90%88.md" target="_blank" rel="noopener">代码坏味道之耦合</a></li>
</ul>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><a href="https://book.douban.com/subject/4262627/" target="_blank" rel="noopener">重构——改善既有代码的设计</a> - by Martin Fowler</li>
<li><a href="https://sourcemaking.com/refactoring" target="_blank" rel="noopener">https://sourcemaking.com/refactoring</a></li>
</ul>
]]></content>
      <categories>
        <category>设计</category>
        <category>重构</category>
      </categories>
      <tags>
        <tag>设计</tag>
        <tag>重构</tag>
        <tag>代码坏味道</tag>
      </tags>
  </entry>
  <entry>
    <title>代码坏味道之非必要的</title>
    <url>/blog/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E9%9D%9E%E5%BF%85%E8%A6%81%E7%9A%84/</url>
    <content><![CDATA[<blockquote>
<p>📓 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p>
<p>翻译自：<a href="https://sourcemaking.com/refactoring/smells/dispensables" target="_blank" rel="noopener">https://sourcemaking.com/refactoring/smells/dispensables</a></p>
<p><strong>非必要的(Dispensables)这组坏味道意味着：这样的代码可有可无，它的存在反而影响整体代码的整洁和可读性。</strong></p>
</blockquote>
<h2 id="冗余类"><a class="markdownIt-Anchor" href="#冗余类"></a> 冗余类</h2>
<blockquote>
<p>冗余类(Lazy Class)</p>
<p>理解和维护总是费时费力的。如果一个类不值得你花费精力，它就应该被删除。</p>
</blockquote>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/lazy-class-1.png"/></div>
<h3 id="问题原因"><a class="markdownIt-Anchor" href="#问题原因"></a> 问题原因</h3>
<p>也许一个类的初始设计是一个功能完全的类，然而随着代码的变迁，变得没什么用了。<br />
又或者类起初的设计是为了支持未来的功能扩展，然而却一直未派上用场。</p>
<h3 id="解决方法"><a class="markdownIt-Anchor" href="#解决方法"></a> 解决方法</h3>
<ul>
<li>没什么用的类可以运用 <code>将类内联化(Inline Class)</code> 来干掉。</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/lazy-class-2.png"/></div>
<ul>
<li>如果子类用处不大，试试 <code>折叠继承体系(Collapse Hierarchy)</code> 。</li>
</ul>
<h3 id="收益"><a class="markdownIt-Anchor" href="#收益"></a> 收益</h3>
<ul>
<li>减少代码量</li>
<li>易于维护</li>
</ul>
<h3 id="何时忽略"><a class="markdownIt-Anchor" href="#何时忽略"></a> 何时忽略</h3>
<ul>
<li>有时，创建冗余类是为了描述未来开发的意图。在这种情况下，尝试在代码中保持清晰和简单之间的平衡。</li>
</ul>
<h3 id="重构方法说明"><a class="markdownIt-Anchor" href="#重构方法说明"></a> 重构方法说明</h3>
<h4 id="将类内联化inline-class"><a class="markdownIt-Anchor" href="#将类内联化inline-class"></a> 将类内联化(Inline Class)</h4>
<p><strong>问题</strong></p>
<p>某个类没有做太多事情。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/inline-class-before.png"/></div>
<p><strong>解决</strong></p>
<p>将这个类的所有特性搬移到另一个类中，然后移除原类。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/inline-class-after.png"/></div>
<h4 id="折叠继承体系collapse-hierarchy"><a class="markdownIt-Anchor" href="#折叠继承体系collapse-hierarchy"></a> 折叠继承体系(Collapse Hierarchy)</h4>
<p><strong>问题</strong></p>
<p>超类和子类之间无太大区别。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/collapse-hierarchy-before.png"/></div>
<p><strong>解决</strong></p>
<p>将它们合为一体。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/collapse-hierarchy-after.png"/></div>
<h2 id="夸夸其谈未来性"><a class="markdownIt-Anchor" href="#夸夸其谈未来性"></a> 夸夸其谈未来性</h2>
<blockquote>
<p>夸夸其谈未来性(Speculative Generality)</p>
<p>存在未被使用的类、函数、字段或参数。</p>
</blockquote>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/speculative-generality-1.png"/></div>
<h3 id="问题原因-2"><a class="markdownIt-Anchor" href="#问题原因-2"></a> 问题原因</h3>
<p>有时，代码仅仅为了支持未来的特性而产生，然而却一直未实现。结果，代码变得难以理解和维护。</p>
<h3 id="解决方法-2"><a class="markdownIt-Anchor" href="#解决方法-2"></a> 解决方法</h3>
<ul>
<li>如果你的某个抽象类其实没有太大作用，请运用 <code>折叠继承体系(Collapse Hierarch)</code> 。</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/speculative-generality-2.png"/></div>
<ul>
<li>不必要的委托可运用 <code>将类内联化(Inline Class)</code> 消除。</li>
<li>无用的函数可运用 <code>内联函数(Inline Method)</code> 消除。</li>
<li>函数中有无用的参数应该运用 <code>移除参数(Remove Parameter)</code> 消除。</li>
<li>无用字段可以直接删除。</li>
</ul>
<h3 id="收益-2"><a class="markdownIt-Anchor" href="#收益-2"></a> 收益</h3>
<ul>
<li>减少代码量。</li>
<li>更易维护。</li>
</ul>
<h3 id="何时忽略-2"><a class="markdownIt-Anchor" href="#何时忽略-2"></a> 何时忽略</h3>
<ul>
<li>如果你在一个框架上工作，创建框架本身没有使用的功能是非常合理的，只要框架的用户需要这个功能。</li>
<li>删除元素之前，请确保它们不在单元测试中使用。如果测试需要从类中获取某些内部信息或执行特殊的测试相关操作，就会发生这种情况。</li>
</ul>
<h3 id="重构方法说明-2"><a class="markdownIt-Anchor" href="#重构方法说明-2"></a> 重构方法说明</h3>
<h4 id="折叠继承体系collapse-hierarchy-2"><a class="markdownIt-Anchor" href="#折叠继承体系collapse-hierarchy-2"></a> 折叠继承体系(Collapse Hierarchy)</h4>
<p><strong>问题</strong></p>
<p>超类和子类之间无太大区别。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/collapse-hierarchy-before.png"/></div>
<p><strong>解决</strong></p>
<p>将它们合为一体。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/collapse-hierarchy-after.png"/></div>
<h4 id="将类内联化inline-class-2"><a class="markdownIt-Anchor" href="#将类内联化inline-class-2"></a> 将类内联化(Inline Class)</h4>
<p><strong>问题</strong></p>
<p>某个类没有做太多事情。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/inline-class-before.png"/></div>
<p><strong>解决</strong></p>
<p>将这个类的所有特性搬移到另一个类中，然后移除原类。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/inline-class-after.png"/></div>
<h4 id="内联函数inline-method"><a class="markdownIt-Anchor" href="#内联函数inline-method"></a> 内联函数(Inline Method)</h4>
<p><strong>问题</strong></p>
<p>一个函数的本体比函数名更清楚易懂。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PizzaDelivery</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getRating</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> moreThanFiveLateDeliveries() ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">moreThanFiveLateDeliveries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> numberOfLateDeliveries &gt; <span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>在函数调用点插入函数本体，然后移除该函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PizzaDelivery</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getRating</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> numberOfLateDeliveries &gt; <span class="number">5</span> ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="移除参数remove-parameter"><a class="markdownIt-Anchor" href="#移除参数remove-parameter"></a> 移除参数(Remove Parameter)</h4>
<p><strong>问题</strong></p>
<p>函数本体不再需要某个参数。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/remove-parameter-before.png"/></div>
<p><strong>解决</strong></p>
<p>将该参数去除。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/remove-parameter-after.png"/></div>
<h2 id="纯稚的数据类"><a class="markdownIt-Anchor" href="#纯稚的数据类"></a> 纯稚的数据类</h2>
<blockquote>
<p><code>纯稚的数据类(Data Class)</code> 指的是只包含字段和访问它们的 getter 和 setter 函数的类。这些仅仅是供其他类使用的数据容器。这些类不包含任何附加功能，并且不能对自己拥有的数据进行独立操作。</p>
</blockquote>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/data-class-1.png"/></div>
<h3 id="问题原因-3"><a class="markdownIt-Anchor" href="#问题原因-3"></a> 问题原因</h3>
<p>当一个新创建的类只包含几个公共字段（甚至可能几个 getters / setters）是很正常的。但是对象的真正力量在于它们可以包含作用于数据的行为类型或操作。</p>
<h3 id="解决方法-3"><a class="markdownIt-Anchor" href="#解决方法-3"></a> 解决方法</h3>
<ul>
<li>如果一个类有公共字段，你应该运用 <code>封装字段(Encapsulated Field)</code> 来隐藏字段的直接访问方式。</li>
<li>如果这些类含容器类的字段，你应该检查它们是不是得到了恰当的封装；如果没有，就运用 <code>封装集合(Encapsulated Collection)</code> 把它们封装起来。</li>
<li>找出这些 getter/setter 函数被其他类运用的地点。尝试以 <code>搬移函数(Move Method)</code> 把那些调用行为搬移到 <code>纯稚的数据类(Data Class)</code> 来。如果无法搬移这个函数，就运用 <code>提炼函数(Extract Method)</code> 产生一个可搬移的函数。</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/data-class-2.png"/></div>
<ul>
<li>在类已经充满了深思熟虑的函数之后，你可能想要摆脱旧的数据访问方法，以提供适应面较广的类数据访问接口。为此，可以运用 <code>移除设置函数(Remove Setting Method)</code> 和 <code>隐藏函数(Hide Method)</code> 。</li>
</ul>
<h3 id="收益-3"><a class="markdownIt-Anchor" href="#收益-3"></a> 收益</h3>
<ul>
<li>提高代码的可读性和组织性。特定数据的操作现在被集中在一个地方，而不是在分散在代码各处。</li>
<li>帮助你发现客户端代码的重复处。</li>
</ul>
<h3 id="重构方法说明-3"><a class="markdownIt-Anchor" href="#重构方法说明-3"></a> 重构方法说明</h3>
<h4 id="封装字段encapsulated-field"><a class="markdownIt-Anchor" href="#封装字段encapsulated-field"></a> 封装字段(Encapsulated Field)</h4>
<p><strong>问题</strong></p>
<p>你的类中存在 public 字段。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Person</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>将它声明为 private，并提供相应的访问函数。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">String</span> name;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">String</span> arg)</span> </span>&#123;</span><br><span class="line">    name = arg;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="封装集合encapsulated-collection"><a class="markdownIt-Anchor" href="#封装集合encapsulated-collection"></a> 封装集合(Encapsulated Collection)</h4>
<p><strong>问题</strong></p>
<p>有个函数返回一个集合。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/encapsulate-collection-before.png"/></div>
<p><strong>解决</strong></p>
<p>让该函数返回该集合的一个只读副本，并在这个类中提供添加、移除集合元素的函数。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/encapsulate-collection-after.png"/></div>
<h4 id="搬移函数move-method"><a class="markdownIt-Anchor" href="#搬移函数move-method"></a> 搬移函数(Move Method)</h4>
<p><strong>问题</strong></p>
<p>你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/move-method-before.png"/></div>
<p><strong>解决</strong></p>
<p>在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/move-method-after.png"/></div>
<h4 id="提炼函数extract-method"><a class="markdownIt-Anchor" href="#提炼函数extract-method"></a> 提炼函数(Extract Method)</h4>
<p><strong>问题</strong></p>
<p>你有一段代码可以组织在一起。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printOwing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  printBanner();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//print details</span></span><br><span class="line">  System.out.println(<span class="string">"name: "</span> + name);</span><br><span class="line">  System.out.println(<span class="string">"amount: "</span> + getOutstanding());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>移动这段代码到一个新的函数中，使用函数的调用来替代老代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printOwing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  printBanner();</span><br><span class="line">  printDetails(getOutstanding());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDetails</span><span class="params">(<span class="keyword">double</span> outstanding)</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"name: "</span> + name);</span><br><span class="line">  System.out.println(<span class="string">"amount: "</span> + outstanding);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="移除设置函数remove-setting-method"><a class="markdownIt-Anchor" href="#移除设置函数remove-setting-method"></a> 移除设置函数(Remove Setting Method)</h4>
<p><strong>问题</strong></p>
<p>类中的某个字段应该在对象创建时被设值，然后就不再改变。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/remove-setting-method-before.png"/></div>
<p><strong>解决</strong></p>
<p>去掉该字段的所有设值函数。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/remove-setting-method-after.png"/></div>
<h4 id="隐藏函数hide-method"><a class="markdownIt-Anchor" href="#隐藏函数hide-method"></a> 隐藏函数(Hide Method)</h4>
<p><strong>问题</strong></p>
<p>有一个函数，从来没有被其他任何类用到。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/hide-method-before.png"/></div>
<p><strong>解决</strong></p>
<p>将这个函数修改为 private。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/hide-method-after.png"/></div>
<h2 id="过多的注释"><a class="markdownIt-Anchor" href="#过多的注释"></a> 过多的注释</h2>
<blockquote>
<p>过多的注释(Comments)</p>
<p>注释本身并不是坏事。但是常常有这样的情况：一段代码中出现长长的注释，而它之所以存在，是因为代码很糟糕。</p>
</blockquote>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/comments-1.png"/></div>
<h3 id="问题原因-4"><a class="markdownIt-Anchor" href="#问题原因-4"></a> 问题原因</h3>
<p>注释的作者意识到自己的代码不直观或不明显，所以想使用注释来说明自己的意图。这种情况下，注释就像是烂代码的除臭剂。</p>
<blockquote>
<p>最好的注释是为函数或类起一个恰当的名字。</p>
</blockquote>
<p>如果你觉得一个代码片段没有注释就无法理解，请先尝试重构，试着让所有注释都变得多余。</p>
<h3 id="解决方法-4"><a class="markdownIt-Anchor" href="#解决方法-4"></a> 解决方法</h3>
<ul>
<li>如果一个注释是为了解释一个复杂的表达式，可以运用 <code>提炼变量(Extract Variable)</code> 将表达式切分为易理解的子表达式。</li>
<li>如果你需要通过注释来解释一段代码做了什么，请试试 <code>提炼函数(Extract Method)</code> 。</li>
<li>如果函数已经被提炼，但仍需要注释函数做了什么，试试运用 <code>函数改名(Rename Method)</code> 来为函数起一个可以自解释的名字。</li>
<li>如果需要对系统某状态进行断言，请运用 <code>引入断言(Introduce Assertion)</code> 。</li>
</ul>
<h3 id="收益-4"><a class="markdownIt-Anchor" href="#收益-4"></a> 收益</h3>
<ul>
<li>代码变得更直观和明显。</li>
</ul>
<h3 id="何时忽略-3"><a class="markdownIt-Anchor" href="#何时忽略-3"></a> 何时忽略</h3>
<p>注释有时候很有用：</p>
<ul>
<li>当解释为什么某事物要以特殊方式实现时。</li>
<li>当解释某种复杂算法时。</li>
<li>当你实在不知可以做些什么时。</li>
</ul>
<h3 id="重构方法说明-4"><a class="markdownIt-Anchor" href="#重构方法说明-4"></a> 重构方法说明</h3>
<h4 id="提炼变量extract-variable"><a class="markdownIt-Anchor" href="#提炼变量extract-variable"></a> 提炼变量(Extract Variable)</h4>
<p><strong>问题</strong></p>
<p>你有个难以理解的表达式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">renderBanner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ((platform.toUpperCase().indexOf(<span class="string">"MAC"</span>) &gt; -<span class="number">1</span>) &amp;&amp;</span><br><span class="line">       (browser.toUpperCase().indexOf(<span class="string">"IE"</span>) &gt; -<span class="number">1</span>) &amp;&amp;</span><br><span class="line">        wasInitialized() &amp;&amp; resize &gt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>将表达式的结果或它的子表达式的结果用不言自明的变量来替代。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">renderBanner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">boolean</span> isMacOs = platform.toUpperCase().indexOf(<span class="string">"MAC"</span>) &gt; -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">boolean</span> isIE = browser.toUpperCase().indexOf(<span class="string">"IE"</span>) &gt; -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">boolean</span> wasResized = resize &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isMacOs &amp;&amp; isIE &amp;&amp; wasInitialized() &amp;&amp; wasResized) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="提炼函数extract-method-2"><a class="markdownIt-Anchor" href="#提炼函数extract-method-2"></a> 提炼函数(Extract Method)</h4>
<p><strong>问题</strong></p>
<p>你有一段代码可以组织在一起。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printOwing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  printBanner();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//print details</span></span><br><span class="line">  System.out.println(<span class="string">"name: "</span> + name);</span><br><span class="line">  System.out.println(<span class="string">"amount: "</span> + getOutstanding());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>移动这段代码到一个新的函数中，使用函数的调用来替代老代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printOwing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  printBanner();</span><br><span class="line">  printDetails(getOutstanding());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDetails</span><span class="params">(<span class="keyword">double</span> outstanding)</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"name: "</span> + name);</span><br><span class="line">  System.out.println(<span class="string">"amount: "</span> + outstanding);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="函数改名rename-method"><a class="markdownIt-Anchor" href="#函数改名rename-method"></a> 函数改名(Rename Method)</h4>
<p><strong>问题</strong></p>
<p>函数的名称未能恰当的揭示函数的用途。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getsnm</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>修改函数名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getSecondName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="引入断言introduce-assertion"><a class="markdownIt-Anchor" href="#引入断言introduce-assertion"></a> 引入断言(Introduce Assertion)</h4>
<p><strong>问题</strong></p>
<p>某一段代码需要对程序状态做出某种假设。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getExpenseLimit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// should have either expense limit or a primary project</span></span><br><span class="line">  <span class="keyword">return</span> (expenseLimit != NULL_EXPENSE) ?</span><br><span class="line">    expenseLimit:</span><br><span class="line">    primaryProject.getMemberExpenseLimit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>以断言明确表现这种假设。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getExpenseLimit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Assert.isTrue(expenseLimit != NULL_EXPENSE || primaryProject != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (expenseLimit != NULL_EXPENSE) ?</span><br><span class="line">    expenseLimit:</span><br><span class="line">    primaryProject.getMemberExpenseLimit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>注：请不要滥用断言。不要使用它来检查”应该为真“的条件，只能使用它来检查“一定必须为真”的条件。实际上，断言更多是用于自我检测代码的一种手段。在产品真正交付时，往往都会消除所有断言。</em></p>
<h2 id="重复代码"><a class="markdownIt-Anchor" href="#重复代码"></a> 重复代码</h2>
<blockquote>
<p>重复代码(Duplicate Code)</p>
<p>重复代码堪称为代码坏味道之首。消除重复代码总是有利无害的。</p>
</blockquote>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/duplicate-code-1.png"/></div>
<h3 id="问题原因-5"><a class="markdownIt-Anchor" href="#问题原因-5"></a> 问题原因</h3>
<p>重复代码通常发生在多个程序员同时在同一程序的不同部分上工作时。由于他们正在处理不同的任务，他们可能不知道他们的同事已经写了类似的代码。</p>
<p>还有一种更隐晦的重复，特定部分的代码看上去不同但实际在做同一件事。这种重复代码往往难以找到和消除。</p>
<p>有时重复是有目的性的。当急于满足 deadline，并且现有代码对于要交付的任务是“几乎正确的”时，新手程序员可能无法抵抗复制和粘贴相关代码的诱惑。在某些情况下，程序员只是太懒惰。</p>
<h3 id="解决方法-5"><a class="markdownIt-Anchor" href="#解决方法-5"></a> 解决方法</h3>
<ul>
<li>同一个类的两个函数含有相同的表达式，这时可以采用 <code>提炼函数(Extract Method)</code> 提炼出重复的代码，然后让这两个地点都调用被提炼出来的那段代码。</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/duplicate-code-2.png"/></div>
<ul>
<li>如果两个互为兄弟的子类含有重复代码：
<ul>
<li>首先对两个类都运用 <code>提炼函数(Extract Method)</code> ，然后对被提炼出来的函数运用 <code>函数上移(Pull Up Method)</code> ，将它推入超类。</li>
<li>如果重复代码在构造函数中，运用 <code>构造函数本体上移(Pull Up Constructor Body)</code> 。</li>
<li>如果重复代码只是相似但不是完全相同，运用 <code>塑造模板函数(Form Template Method)</code> 获得一个 <strong>模板方法模式(Template Method)</strong> 。</li>
<li>如果有些函数以不同的算法做相同的事，你可以选择其中较清晰地一个，并运用 <code>替换算法(Substitute Algorithm)</code> 将其他函数的算法替换掉。</li>
</ul>
</li>
<li>如果两个毫不相关的类中有重复代码：
<ul>
<li>请尝试运用 <code>提炼超类(Extract Superclass)</code> ，以便为维护所有先前功能的这些类创建一个超类。</li>
<li>如果创建超类十分困难，可以在一个类中运用 <code>提炼类(Extract Class)</code> ，并在另一个类中使用这个新的组件。</li>
</ul>
</li>
<li>如果存在大量的条件表达式，并且它们执行完全相同的代码（仅仅是它们的条件不同），可以运用 <code>合并条件表达式(Consolidate Conditional Expression)</code> 将这些操作合并为单个条件，并运用 <code>提炼函数(Extract Method)</code> 将该条件放入一个名字容易理解的独立函数中。</li>
<li>如果条件表达式的所有分支都有部分相同的代码片段：可以运用 <code>合并重复的条件片段(Consolidate Duplicate Conditional Fragments)</code> 将它们都存在的代码片段置于条件表达式外部。</li>
</ul>
<h3 id="收益-5"><a class="markdownIt-Anchor" href="#收益-5"></a> 收益</h3>
<ul>
<li>合并重复代码会简化代码的结构，并减少代码量。</li>
<li>代码更简化、更易维护。</li>
</ul>
<h3 id="重构方法说明-5"><a class="markdownIt-Anchor" href="#重构方法说明-5"></a> 重构方法说明</h3>
<h4 id="提炼函数extract-method-3"><a class="markdownIt-Anchor" href="#提炼函数extract-method-3"></a> 提炼函数(Extract Method)</h4>
<p><strong>问题</strong></p>
<p>你有一段代码可以组织在一起。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printOwing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  printBanner();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//print details</span></span><br><span class="line">  System.out.println(<span class="string">"name: "</span> + name);</span><br><span class="line">  System.out.println(<span class="string">"amount: "</span> + getOutstanding());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>移动这段代码到一个新的函数中，使用函数的调用来替代老代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printOwing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  printBanner();</span><br><span class="line">  printDetails(getOutstanding());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDetails</span><span class="params">(<span class="keyword">double</span> outstanding)</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"name: "</span> + name);</span><br><span class="line">  System.out.println(<span class="string">"amount: "</span> + outstanding);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="函数上移pull-up-method"><a class="markdownIt-Anchor" href="#函数上移pull-up-method"></a> 函数上移(Pull Up Method)</h4>
<p><strong>问题</strong></p>
<p>有些函数，在各个子类中产生完全相同的结果。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/pull-up-method-before.png"/></div>
<p><strong>解决</strong></p>
<p>将该函数移至超类。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/pull-up-method-after.png"/></div>
<h4 id="构造函数本体上移pull-up-constructor-body"><a class="markdownIt-Anchor" href="#构造函数本体上移pull-up-constructor-body"></a> 构造函数本体上移(Pull Up Constructor Body)</h4>
<p><strong>问题</strong></p>
<p>你在各个子类中拥有一些构造函数，它们的本体几乎完全一致。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">(String name, String id, <span class="keyword">int</span> grade)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">    <span class="keyword">this</span>.grade = grade;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>在超类中新建一个构造函数，并在子类构造函数中调用它。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">(String name, String id, <span class="keyword">int</span> grade)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(name, id);</span><br><span class="line">    <span class="keyword">this</span>.grade = grade;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="塑造模板函数form-template-method"><a class="markdownIt-Anchor" href="#塑造模板函数form-template-method"></a> 塑造模板函数(Form Template Method)</h4>
<p><strong>问题</strong></p>
<p>你有一些子类，其中相应的某些函数以相同的顺序执行类似的操作，但各个操作的细节上有所不同。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/form-template-method-before.png"/></div>
<p><strong>解决</strong></p>
<p>将这些操作分别放进独立函数中，并保持它们都有相同的签名，于是原函数也就变得相同了。然后将原函数上移至超类。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/form-template-method-after.png"/></div>
<p><em>注：这里只提到具体做法，建议了解一下模板方法设计模式。</em></p>
<h4 id="替换算法substitute-algorithm"><a class="markdownIt-Anchor" href="#替换算法substitute-algorithm"></a> 替换算法(Substitute Algorithm)</h4>
<p><strong>问题</strong></p>
<p>你想要把某个算法替换为另一个更清晰的算法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">foundPerson</span><span class="params">(String[] people)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; people.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (people[i].equals(<span class="string">"Don"</span>))&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Don"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (people[i].equals(<span class="string">"John"</span>))&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"John"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (people[i].equals(<span class="string">"Kent"</span>))&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Kent"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>将函数本体替换为另一个算法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">foundPerson</span><span class="params">(String[] people)</span></span>&#123;</span><br><span class="line">  List candidates =</span><br><span class="line">    Arrays.asList(<span class="keyword">new</span> String[] &#123;<span class="string">"Don"</span>, <span class="string">"John"</span>, <span class="string">"Kent"</span>&#125;);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; people.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (candidates.contains(people[i])) &#123;</span><br><span class="line">      <span class="keyword">return</span> people[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="提炼超类extract-superclass"><a class="markdownIt-Anchor" href="#提炼超类extract-superclass"></a> 提炼超类(Extract Superclass)</h4>
<p><strong>问题</strong></p>
<p>两个类有相似特性。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/extract-superclass-before.png"/></div>
<p><strong>解决</strong></p>
<p>为这两个类建立一个超类，将相同特性移至超类。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/extract-superclass-after.png"/></div>
<h4 id="提炼类extract-class"><a class="markdownIt-Anchor" href="#提炼类extract-class"></a> 提炼类(Extract Class)</h4>
<p><strong>问题</strong></p>
<p>某个类做了不止一件事。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/extract-class-before.png"/></div>
<p><strong>解决</strong></p>
<p>建立一个新类，将相关的字段和函数从旧类搬移到新类。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/extract-class-after.png"/></div>
<h4 id="合并条件表达式consolidate-conditional-expression"><a class="markdownIt-Anchor" href="#合并条件表达式consolidate-conditional-expression"></a> 合并条件表达式(Consolidate Conditional Expression)</h4>
<p><strong>问题</strong></p>
<p>你有一系列条件分支，都得到相同结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">disabilityAmount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (seniority &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (monthsDisabled &gt; <span class="number">12</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isPartTime) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// compute the disability amount</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>将这些条件分支合并为一个条件，并将这个条件提炼为一个独立函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">disabilityAmount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isNotEligableForDisability()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// compute the disability amount</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="合并重复的条件片段consolidate-duplicate-conditional-fragments"><a class="markdownIt-Anchor" href="#合并重复的条件片段consolidate-duplicate-conditional-fragments"></a> 合并重复的条件片段(Consolidate Duplicate Conditional Fragments)</h4>
<p><strong>问题</strong></p>
<p>在条件表达式的每个分支上有着相同的一段代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isSpecialDeal()) &#123;</span><br><span class="line">  total = price * <span class="number">0.95</span>;</span><br><span class="line">  send();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  total = price * <span class="number">0.98</span>;</span><br><span class="line">  send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>将这段重复代码搬移到条件表达式之外。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isSpecialDeal()) &#123;</span><br><span class="line">  total = price * <span class="number">0.95</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  total = price * <span class="number">0.98</span>;</span><br><span class="line">&#125;</span><br><span class="line">send();</span><br></pre></td></tr></table></figure>
<h2 id="扩展阅读"><a class="markdownIt-Anchor" href="#扩展阅读"></a> 扩展阅读</h2>
<ul>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/" target="_blank" rel="noopener">代码的坏味道和重构</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%87%83%E8%82%BF.md" target="_blank" rel="noopener">代码坏味道之代码臃肿</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E6%BB%A5%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.md" target="_blank" rel="noopener">代码坏味道之滥用面向对象</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E5%8F%98%E9%9D%A9%E7%9A%84%E9%9A%9C%E7%A2%8D.md" target="_blank" rel="noopener">代码坏味道之变革的障碍</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E9%9D%9E%E5%BF%85%E8%A6%81%E7%9A%84.md" target="_blank" rel="noopener">代码坏味道之非必要的</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E8%80%A6%E5%90%88.md" target="_blank" rel="noopener">代码坏味道之耦合</a></li>
</ul>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><a href="https://book.douban.com/subject/4262627/" target="_blank" rel="noopener">重构——改善既有代码的设计</a> - by Martin Fowler</li>
<li><a href="https://sourcemaking.com/refactoring" target="_blank" rel="noopener">https://sourcemaking.com/refactoring</a></li>
</ul>
]]></content>
      <categories>
        <category>设计</category>
        <category>重构</category>
      </categories>
      <tags>
        <tag>设计</tag>
        <tag>重构</tag>
        <tag>代码坏味道</tag>
      </tags>
  </entry>
  <entry>
    <title>代码坏味道之滥用面向对象</title>
    <url>/blog/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E6%BB%A5%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<blockquote>
<p>📓 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p>
<p>翻译自：<a href="https://sourcemaking.com/refactoring/smells/oo-abusers" target="_blank" rel="noopener">https://sourcemaking.com/refactoring/smells/oo-abusers</a></p>
<p><strong>滥用面向对象(Object-Orientation Abusers)这组坏味道意味着：代码部分或完全地违背了面向对象编程原则。</strong></p>
</blockquote>
<h2 id="switch-声明"><a class="markdownIt-Anchor" href="#switch-声明"></a> Switch 声明</h2>
<blockquote>
<p>Switch 声明(Switch Statements)</p>
<p>你有一个复杂的 <code>switch</code> 语句或 <code>if</code> 序列语句。</p>
</blockquote>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/switch-statements-1.png"/></div>
<h3 id="问题原因"><a class="markdownIt-Anchor" href="#问题原因"></a> 问题原因</h3>
<p>面向对象程序的一个最明显特征就是：少用 <code>switch</code> 和 <code>case</code> 语句。从本质上说，<code>switch</code> 语句的问题在于重复（<code>if</code> 序列也同样如此）。你常会发现 <code>switch</code> 语句散布于不同地点。如果要为它添加一个新的 <code>case</code> 子句，就必须找到所有 <code>switch</code> 语句并修改它们。面向对象中的多态概念可为此带来优雅的解决办法。</p>
<p>大多数时候，一看到 <code>switch</code> 语句，就应该考虑以多态来替换它。</p>
<h3 id="解决方法"><a class="markdownIt-Anchor" href="#解决方法"></a> 解决方法</h3>
<ul>
<li>问题是多态该出现在哪？switch 语句常常根据类型码进行选择，你要的是“与该类型码相关的函数或类”，所以应该运用 <code>提炼函数(Extract Method)</code> 将 <code>switch</code> 语句提炼到一个独立函数中，再以 <code>搬移函数(Move Method)</code> 将它搬移到需要多态性的那个类里。</li>
<li>如果你的 <code>switch</code> 是基于类型码来识别分支，这时可以运用 <code>以子类取代类型码(Replace Type Code with Subclass)</code> 或 <code>以状态/策略模式取代类型码(Replace Type Code with State/Strategy)</code> 。</li>
<li>一旦完成这样的继承结构后，就可以运用 <code>以多态取代条件表达式(Replace Conditional with Polymorphism)</code> 了。</li>
<li>如果条件分支并不多并且它们使用不同参数调用相同的函数，多态就没必要了。在这种情况下，你可以运用 <code>以明确函数取代参数(Replace Parameter with Explicit Methods)</code> 。</li>
<li>如果你的选择条件之一是 null，可以运用 <code>引入 Null 对象(Introduce Null Object)</code> 。</li>
</ul>
<h3 id="收益"><a class="markdownIt-Anchor" href="#收益"></a> 收益</h3>
<ul>
<li>提升代码组织性。</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/switch-statements-2.png"/></div>
<h3 id="何时忽略"><a class="markdownIt-Anchor" href="#何时忽略"></a> 何时忽略</h3>
<ul>
<li>如果一个 <code>switch</code> 操作只是执行简单的行为，就没有重构的必要了。</li>
<li><code>switch</code> 常被工厂设计模式族（<code>工厂方法模式(Factory Method)</code>和<code>抽象工厂模式(Abstract Factory)</code>）所使用，这种情况下也没必要重构。</li>
</ul>
<h3 id="重构方法说明"><a class="markdownIt-Anchor" href="#重构方法说明"></a> 重构方法说明</h3>
<h4 id="提炼函数extract-method"><a class="markdownIt-Anchor" href="#提炼函数extract-method"></a> 提炼函数(Extract Method)</h4>
<p><strong>问题</strong></p>
<p>你有一段代码可以组织在一起。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printOwing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  printBanner();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//print details</span></span><br><span class="line">  System.out.println(<span class="string">"name: "</span> + name);</span><br><span class="line">  System.out.println(<span class="string">"amount: "</span> + getOutstanding());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>移动这段代码到一个新的函数中，使用函数的调用来替代老代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printOwing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  printBanner();</span><br><span class="line">  printDetails(getOutstanding());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDetails</span><span class="params">(<span class="keyword">double</span> outstanding)</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"name: "</span> + name);</span><br><span class="line">  System.out.println(<span class="string">"amount: "</span> + outstanding);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="搬移函数move-method"><a class="markdownIt-Anchor" href="#搬移函数move-method"></a> 搬移函数(Move Method)</h4>
<p><strong>问题</strong></p>
<p>你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/move-method-before.png"/></div>
<p><strong>解决</strong></p>
<p>在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/move-method-after.png"/></div>
<h4 id="以子类取代类型码replace-type-code-with-subclass"><a class="markdownIt-Anchor" href="#以子类取代类型码replace-type-code-with-subclass"></a> 以子类取代类型码(Replace Type Code with Subclass)</h4>
<p><strong>问题</strong></p>
<p>你有一个不可变的类型码，它会影响类的行为。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/replace-type-code-with-subclasses-before.png"/></div>
<p><strong>解决</strong></p>
<p>以子类取代这个类型码。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/replace-type-code-with-subclasses-after.png"/></div>
<h4 id="以状态策略模式取代类型码replace-type-code-with-statestrategy"><a class="markdownIt-Anchor" href="#以状态策略模式取代类型码replace-type-code-with-statestrategy"></a> 以状态/策略模式取代类型码(Replace Type Code with State/Strategy)</h4>
<p><strong>问题</strong></p>
<p>你有一个类型码，它会影响类的行为，但你无法通过继承消除它。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/replace-type-code-with-state-strategy-before.png"/></div>
<p><strong>解决</strong></p>
<p>以状态对象取代类型码。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/replace-type-code-with-state-strategy-after.png"/></div>
<h4 id="以多态取代条件表达式replace-conditional-with-polymorphism"><a class="markdownIt-Anchor" href="#以多态取代条件表达式replace-conditional-with-polymorphism"></a> 以多态取代条件表达式(Replace Conditional with Polymorphism)</h4>
<p><strong>问题</strong></p>
<p>你手上有个条件表达式，它根据对象类型的不同而选择不同的行为。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">getSpeed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">      <span class="keyword">case</span> EUROPEAN:</span><br><span class="line">        <span class="keyword">return</span> getBaseSpeed();</span><br><span class="line">      <span class="keyword">case</span> AFRICAN:</span><br><span class="line">        <span class="keyword">return</span> getBaseSpeed() - getLoadFactor() * numberOfCoconuts;</span><br><span class="line">      <span class="keyword">case</span> NORWEGIAN_BLUE:</span><br><span class="line">        <span class="keyword">return</span> (isNailed) ? <span class="number">0</span> : getBaseSpeed(voltage);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Should be unreachable"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>将这个条件表达式的每个分支放进一个子类内的覆写函数中，然后将原始函数声明为抽象函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">getSpeed</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">European</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">getSpeed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getBaseSpeed();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">African</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">getSpeed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getBaseSpeed() - getLoadFactor() * numberOfCoconuts;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NorwegianBlue</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">getSpeed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (isNailed) ? <span class="number">0</span> : getBaseSpeed(voltage);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Somewhere in client code</span></span><br><span class="line">speed = bird.getSpeed();</span><br></pre></td></tr></table></figure>
<h4 id="以明确函数取代参数replace-parameter-with-explicit-methods"><a class="markdownIt-Anchor" href="#以明确函数取代参数replace-parameter-with-explicit-methods"></a> 以明确函数取代参数(Replace Parameter with Explicit Methods)</h4>
<p><strong>问题</strong></p>
<p>你有一个函数，其中完全取决于参数值而采取不同的行为。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String name, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (name.equals(<span class="string">"height"</span>)) &#123;</span><br><span class="line">    height = value;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (name.equals(<span class="string">"width"</span>)) &#123;</span><br><span class="line">    width = value;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Assert.shouldNeverReachHere();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>针对该参数的每一个可能值，建立一个独立函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  height = arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  width = arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="引入-null-对象introduce-null-object"><a class="markdownIt-Anchor" href="#引入-null-对象introduce-null-object"></a> 引入 Null 对象(Introduce Null Object)</h4>
<p><strong>问题</strong></p>
<p>你需要再三检查某对象是否为 null。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (customer == <span class="keyword">null</span>) &#123;</span><br><span class="line">  plan = BillingPlan.basic();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  plan = customer.getPlan();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>将 null 值替换为 null 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NullCustomer</span> <span class="keyword">extends</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">  <span class="function">Plan <span class="title">getPlan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> NullPlan();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Some other NULL functionality.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Replace null values with Null-object.</span></span><br><span class="line">customer = (order.customer != <span class="keyword">null</span>) ? order.customer : <span class="keyword">new</span> NullCustomer();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use Null-object as if it's normal subclass.</span></span><br><span class="line">plan = customer.getPlan();</span><br></pre></td></tr></table></figure>
<h2 id="临时字段"><a class="markdownIt-Anchor" href="#临时字段"></a> 临时字段</h2>
<blockquote>
<p>临时字段(Temporary Field)的值只在特定环境下有意义，离开这个环境，它们就什么也不是了。</p>
</blockquote>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/temporary-field-1.png"/></div>
<h3 id="问题原因-2"><a class="markdownIt-Anchor" href="#问题原因-2"></a> 问题原因</h3>
<p>有时你会看到这样的对象：其内某个实例变量仅为某种特定情况而设。这样的代码让人不易理解，因为你通常认为对象在所有时候都需要它的所有变量。在变量未被使用的情况下猜测当初设置目的，会让你发疯。<br />
通常，临时字段是在某一算法需要大量输入时而创建。因此，为了避免函数有过多参数，程序员决定在类中创建这些数据的临时字段。这些临时字段仅仅在算法中使用，其他时候却毫无用处。<br />
这种代码不好理解。你期望查看对象字段的数据，但是出于某种原因，它们总是为空。</p>
<h3 id="解决方法-2"><a class="markdownIt-Anchor" href="#解决方法-2"></a> 解决方法</h3>
<ul>
<li>可以通过 <code>提炼类(Extract Class)</code> 将临时字段和操作它们的所有代码提炼到一个单独的类中。此外，你可以运用 <code>以函数对象取代函数(Replace Method with Method Object)</code> 来实现同样的目的。</li>
<li><code>引入 Null 对象(Introduce Null Object)</code> 在“变量不合法”的情况下创建一个 null 对象，从而避免写出条件表达式。</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/temporary-field-2.png"/></div>
<h3 id="收益-2"><a class="markdownIt-Anchor" href="#收益-2"></a> 收益</h3>
<ul>
<li>更好的代码清晰度和组织性。</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/temporary-field-3.png"/></div>
<h3 id="重构方法说明-2"><a class="markdownIt-Anchor" href="#重构方法说明-2"></a> 重构方法说明</h3>
<h4 id="提炼类extract-class"><a class="markdownIt-Anchor" href="#提炼类extract-class"></a> 提炼类(Extract Class)</h4>
<p><strong>问题</strong></p>
<p>某个类做了不止一件事。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/extract-class-before.png"/></div>
<p><strong>解决</strong></p>
<p>建立一个新类，将相关的字段和函数从旧类搬移到新类。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/extract-class-after.png"/></div>
<h4 id="以函数对象取代函数replace-method-with-method-object"><a class="markdownIt-Anchor" href="#以函数对象取代函数replace-method-with-method-object"></a> 以函数对象取代函数(Replace Method with Method Object)</h4>
<p><strong>问题</strong></p>
<p>你有一个过长函数，它的局部变量交织在一起，以致于你无法应用提炼函数(Extract Method) 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">price</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> primaryBasePrice;</span><br><span class="line">    <span class="keyword">double</span> secondaryBasePrice;</span><br><span class="line">    <span class="keyword">double</span> tertiaryBasePrice;</span><br><span class="line">    <span class="comment">// long computation.</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>将函数移到一个独立的类中，使得局部变量成了这个类的字段。然后，你可以将函数分割成这个类中的多个函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">price</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PriceCalculator(<span class="keyword">this</span>).compute();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriceCalculator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> primaryBasePrice;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> secondaryBasePrice;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> tertiaryBasePrice;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PriceCalculator</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// copy relevant information from order object.</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// long computation.</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="引入-null-对象introduce-null-object-2"><a class="markdownIt-Anchor" href="#引入-null-对象introduce-null-object-2"></a> 引入 Null 对象(Introduce Null Object)</h4>
<p><strong>问题</strong></p>
<p>你需要再三检查某对象是否为 null。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (customer == <span class="keyword">null</span>) &#123;</span><br><span class="line">  plan = BillingPlan.basic();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  plan = customer.getPlan();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>将 null 值替换为 null 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NullCustomer</span> <span class="keyword">extends</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">  <span class="function">Plan <span class="title">getPlan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> NullPlan();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Some other NULL functionality.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Replace null values with Null-object.</span></span><br><span class="line">customer = (order.customer != <span class="keyword">null</span>) ? order.customer : <span class="keyword">new</span> NullCustomer();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use Null-object as if it's normal subclass.</span></span><br><span class="line">plan = customer.getPlan();</span><br></pre></td></tr></table></figure>
<h2 id="异曲同工的类"><a class="markdownIt-Anchor" href="#异曲同工的类"></a> 异曲同工的类</h2>
<blockquote>
<p>异曲同工的类(Alternative Classes with Different Interfaces)</p>
<p>两个类中有着不同的函数，却在做着同一件事。</p>
</blockquote>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/alternative-classes-with-different-interfaces-1.png"/></div>
<h3 id="问题原因-3"><a class="markdownIt-Anchor" href="#问题原因-3"></a> 问题原因</h3>
<p>这种情况往往是因为：创建这个类的程序员并不知道已经有实现这个功能的类存在了。</p>
<h3 id="解决方法-3"><a class="markdownIt-Anchor" href="#解决方法-3"></a> 解决方法</h3>
<ul>
<li>如果两个函数做同一件事，却有着不同的签名，请运用 <code>函数改名(Rename Method)</code> 根据它们的用途重新命名。</li>
<li>运用 <code>搬移函数(Move Method)</code> 、 <code>添加参数(Add Parameter)</code> 和 <code>令函数携带参数(Parameterize Method)</code> 来使得方法的名称和实现一致。</li>
<li>如果两个类仅有部分功能是重复的，尝试运用 <code>提炼超类(Extract Superclass)</code> 。这种情况下，已存在的类就成了超类。</li>
<li>当最终选择并运用某种方法来重构后，也许你就能删除其中一个类了。</li>
</ul>
<h3 id="收益-3"><a class="markdownIt-Anchor" href="#收益-3"></a> 收益</h3>
<ul>
<li>消除了不必要的重复代码，为代码瘦身了。</li>
<li>代码更易读（不再需要猜测为什么要有两个功能相同的类）。</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/alternative-classes-with-different-interfaces-2.png"/></div>
<h3 id="何时忽略-2"><a class="markdownIt-Anchor" href="#何时忽略-2"></a> 何时忽略</h3>
<ul>
<li>有时合并类是不可能的，或者是如此困难以至于没有意义。例如：两个功能相似的类存在于不同的 lib 库中。</li>
</ul>
<h3 id="重构方法说明-3"><a class="markdownIt-Anchor" href="#重构方法说明-3"></a> 重构方法说明</h3>
<h4 id="函数改名rename-method"><a class="markdownIt-Anchor" href="#函数改名rename-method"></a> 函数改名(Rename Method)</h4>
<p><strong>问题</strong></p>
<p>函数的名称未能恰当的揭示函数的用途。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getsnm</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>修改函数名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getSecondName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="搬移函数move-method-2"><a class="markdownIt-Anchor" href="#搬移函数move-method-2"></a> 搬移函数(Move Method)</h4>
<p><strong>问题</strong></p>
<p>你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/move-method-before.png"/></div>
<p><strong>解决</strong></p>
<p>在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/move-method-after.png"/></div>
<h4 id="添加参数add-parameter"><a class="markdownIt-Anchor" href="#添加参数add-parameter"></a> 添加参数(Add Parameter)</h4>
<p><strong>问题</strong><br />
某个函数需要从调用端得到更多信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Contact <span class="title">getContact</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong><br />
为此函数添加一个对象函数，让改对象带进函数所需信息。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">class<span class="built_in"> Customer </span>&#123;</span><br><span class="line">  public Contact getContact(Date date);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="令函数携带参数parameterize-method"><a class="markdownIt-Anchor" href="#令函数携带参数parameterize-method"></a> 令函数携带参数(Parameterize Method)</h4>
<p><strong>问题</strong></p>
<p>若干函数做了类似的工作，但在函数本体中却包含了不同的值。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/parameterize-method-before.png"/></div>
**解决**
<p>建立单一函数，以参数表达哪些不同的值。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/parameterize-method-after.png"/></div>
<h4 id="提炼超类extract-superclass"><a class="markdownIt-Anchor" href="#提炼超类extract-superclass"></a> 提炼超类(Extract Superclass)</h4>
<p><strong>问题</strong></p>
<p>两个类有相似特性。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/extract-superclass-before.png"/></div>
<p><strong>解决</strong></p>
<p>为这两个类建立一个超类，将相同特性移至超类。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/extract-superclass-after.png"/></div>
<h2 id="被拒绝的馈赠"><a class="markdownIt-Anchor" href="#被拒绝的馈赠"></a> 被拒绝的馈赠</h2>
<blockquote>
<p>被拒绝的馈赠(Refused Bequest)</p>
<p>子类仅仅使用父类中的部分方法和属性。其他来自父类的馈赠成为了累赘。</p>
</blockquote>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/refused-bequest-1.png"/></div>
<h3 id="问题原因-4"><a class="markdownIt-Anchor" href="#问题原因-4"></a> 问题原因</h3>
<p>有些人仅仅是想重用超类中的部分代码而创建了子类。但实际上超类和子类完全不同。</p>
<h3 id="解决方法-4"><a class="markdownIt-Anchor" href="#解决方法-4"></a> 解决方法</h3>
<ul>
<li>如果继承没有意义并且子类和父类之间确实没有共同点，可以运用 <code>以委托取代继承(Replace Inheritance with Delegation)</code> 消除继承。</li>
<li>如果继承是适当的，则去除子类中不需要的字段和方法。运用 <code>提炼超类(Extract Superclass)</code> 将所有超类中对于子类有用的字段和函数提取出来，置入一个新的超类中，然后让两个类都继承自它。</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/refused-bequest-2.png"/></div>
<h3 id="收益-4"><a class="markdownIt-Anchor" href="#收益-4"></a> 收益</h3>
<ul>
<li>提高代码的清晰度和组织性。</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/refused-bequest-3.png"/></div>
<h3 id="重构方法说明-4"><a class="markdownIt-Anchor" href="#重构方法说明-4"></a> 重构方法说明</h3>
<h4 id="以委托取代继承replace-inheritance-with-delegation"><a class="markdownIt-Anchor" href="#以委托取代继承replace-inheritance-with-delegation"></a> 以委托取代继承(Replace Inheritance with Delegation)</h4>
<p><strong>问题</strong></p>
<p>某个子类只使用超类接口中的一部分，或是根本不需要继承而来的数据。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/replace-inheritance-with-delegation-before.png"/></div>
<p><strong>解决</strong></p>
<ol>
<li>在子类中新建一个字段用以保存超类；</li>
<li>调整子类函数，令它改而委托超类；</li>
<li>然后去掉两者之间的继承关系。</li>
</ol>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/replace-inheritance-with-delegation-after.png"/></div>
<h4 id="提炼超类extract-superclass-2"><a class="markdownIt-Anchor" href="#提炼超类extract-superclass-2"></a> 提炼超类(Extract Superclass)</h4>
<p><strong>问题</strong></p>
<p>两个类有相似特性。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/extract-superclass-before.png"/></div>
<p><strong>解决</strong></p>
<p>为这两个类建立一个超类，将相同特性移至超类。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/extract-superclass-after.png"/></div>
<h2 id="扩展阅读"><a class="markdownIt-Anchor" href="#扩展阅读"></a> 扩展阅读</h2>
<ul>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/" target="_blank" rel="noopener">代码的坏味道和重构</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%87%83%E8%82%BF.md" target="_blank" rel="noopener">代码坏味道之代码臃肿</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E6%BB%A5%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.md" target="_blank" rel="noopener">代码坏味道之滥用面向对象</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E5%8F%98%E9%9D%A9%E7%9A%84%E9%9A%9C%E7%A2%8D.md" target="_blank" rel="noopener">代码坏味道之变革的障碍</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E9%9D%9E%E5%BF%85%E8%A6%81%E7%9A%84.md" target="_blank" rel="noopener">代码坏味道之非必要的</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E8%80%A6%E5%90%88.md" target="_blank" rel="noopener">代码坏味道之耦合</a></li>
</ul>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><a href="https://book.douban.com/subject/4262627/" target="_blank" rel="noopener">重构——改善既有代码的设计</a> - by Martin Fowler</li>
<li><a href="https://sourcemaking.com/refactoring" target="_blank" rel="noopener">https://sourcemaking.com/refactoring</a></li>
</ul>
]]></content>
      <categories>
        <category>设计</category>
        <category>重构</category>
      </categories>
      <tags>
        <tag>设计</tag>
        <tag>重构</tag>
        <tag>代码坏味道</tag>
      </tags>
  </entry>
  <entry>
    <title>代码坏味道之代码臃肿</title>
    <url>/blog/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%87%83%E8%82%BF/</url>
    <content><![CDATA[<blockquote>
<p>📓 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p>
<p>翻译自：<a href="https://sourcemaking.com/refactoring/smells/bloaters" target="_blank" rel="noopener">https://sourcemaking.com/refactoring/smells/bloaters</a></p>
<p><strong>代码臃肿(Bloated)这组坏味道意味着：代码中的类、函数、字段没有经过合理的组织，只是简单的堆砌起来。这一类型的问题通常在代码的初期并不明显，但是随着代码规模的增长而逐渐积累（特别是当没有人努力去根除它们时）。</strong></p>
</blockquote>
<h2 id="基本类型偏执"><a class="markdownIt-Anchor" href="#基本类型偏执"></a> 基本类型偏执</h2>
<blockquote>
<p>基本类型偏执(Primitive Obsession)</p>
<ul>
<li>使用基本类型而不是小对象来实现简单任务（例如货币、范围、电话号码字符串等）。</li>
<li>使用常量编码信息（例如一个用于引用管理员权限的常量<code>USER_ADMIN_ROLE = 1</code> ）。</li>
<li>使用字符串常量作为字段名在数组中使用。</li>
</ul>
</blockquote>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/primitive-obsession-1.png"/></div>
<h3 id="问题原因"><a class="markdownIt-Anchor" href="#问题原因"></a> 问题原因</h3>
<p>类似其他大部分坏味道，基本类型偏执诞生于类初建的时候。一开始，可能只是不多的字段，随着表示的特性越来越多，基本数据类型字段也越来越多。</p>
<p>基本类型常常被用于表示模型的类型。你有一组数字或字符串用来表示某个实体。</p>
<p>还有一个场景：在模拟场景，大量的字符串常量被用于数组的索引。</p>
<h3 id="解决方法"><a class="markdownIt-Anchor" href="#解决方法"></a> 解决方法</h3>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/primitive-obsession-2.png"/></div>
<p>大多数编程语言都支持基本数据类型和结构类型（类、结构体等）。结构类型允许程序员将基本数据类型组织起来，以代表某一事物的模型。</p>
<p>基本数据类型可以看成是机构类型的积木块。当基本数据类型数量成规模后，将它们有组织地结合起来，可以更方便的管理这些数据。</p>
<ul>
<li>如果你有大量的基本数据类型字段，就有可能将其中部分存在逻辑联系的字段组织起来，形成一个类。更进一步的是，将与这些数据有关联的方法也一并移入类中。为了实现这个目标，可以尝试 <code>以类取代类型码(Replace Type Code with Class)</code> 。</li>
<li>如果基本数据类型字段的值是用于方法的参数，可以使用 <code>引入参数对象(Introduce Parameter Object)</code> 或 <code>保持对象完整(Preserve Whole Object)</code> 。</li>
<li>如果想要替换的数据值是类型码，而它并不影响行为，则可以运用 <code>以类取代类型码(Replace Type Code with Class)</code> 将它替换掉。如果你有与类型码相关的条件表达式，可运用 <code>以子类取代类型码(Replace Type Code with Subclass)</code> 或 <code>以状态/策略模式取代类型码(Replace Type Code with State/Strategy)</code> 加以处理。</li>
<li>如果你发现自己正从数组中挑选数据，可运用 <code>以对象取代数组(Replace Array with Object)</code> 。</li>
</ul>
<h3 id="收益"><a class="markdownIt-Anchor" href="#收益"></a> 收益</h3>
<ul>
<li>多亏了使用对象替代基本数据类型，使得代码变得更加灵活。</li>
<li>代码变得更加易读和更加有组织。特殊数据可以集中进行操作，而不像之前那样分散。不用再猜测这些陌生的常量的意义以及它们为什么在数组中。</li>
<li>更容易发现重复代码。</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/primitive-obsession-3.png"/></div>
<h3 id="重构方法说明"><a class="markdownIt-Anchor" href="#重构方法说明"></a> 重构方法说明</h3>
<h4 id="以类取代类型码replace-type-code-with-class"><a class="markdownIt-Anchor" href="#以类取代类型码replace-type-code-with-class"></a> 以类取代类型码(Replace Type Code with Class)</h4>
<p><strong>问题</strong></p>
<p>类之中有一个数值类型码，但它并不影响类的行为。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/replace-type-code-with-class-before.png"/></div>
<p><strong>解决</strong></p>
<p>以一个新的类替换该数值类型码。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/replace-type-code-with-class-after.png"/></div>
<h4 id="引入参数对象introduce-parameter-object"><a class="markdownIt-Anchor" href="#引入参数对象introduce-parameter-object"></a> 引入参数对象(Introduce Parameter Object)</h4>
<p><strong>问题</strong></p>
<p>某些参数总是很自然地同时出现。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/introduce-parameter-object-before.png"/></div>
<p><strong>解决</strong></p>
<p>以一个对象来取代这些参数。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/introduce-parameter-object-after.png"/></div>
<h4 id="保持对象完整preserve-whole-object"><a class="markdownIt-Anchor" href="#保持对象完整preserve-whole-object"></a> 保持对象完整(Preserve Whole Object)</h4>
<p><strong>问题</strong></p>
<p>你从某个对象中取出若干值，将它们作为某一次函数调用时的参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> low = daysTempRange.getLow();</span><br><span class="line"><span class="keyword">int</span> high = daysTempRange.getHigh();</span><br><span class="line"><span class="keyword">boolean</span> withinPlan = plan.withinRange(low, high);</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>改为传递整个对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> withinPlan = plan.withinRange(daysTempRange);</span><br></pre></td></tr></table></figure>
<h4 id="以子类取代类型码replace-type-code-with-subclass"><a class="markdownIt-Anchor" href="#以子类取代类型码replace-type-code-with-subclass"></a> 以子类取代类型码(Replace Type Code with Subclass)</h4>
<p><strong>问题</strong></p>
<p>你有一个不可变的类型码，它会影响类的行为。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/replace-type-code-with-subclasses-before.png"/></div>
<p><strong>解决</strong></p>
<p>以子类取代这个类型码。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/replace-type-code-with-subclasses-after.png"/></div>
<h4 id="以状态策略模式取代类型码replace-type-code-with-statestrategy"><a class="markdownIt-Anchor" href="#以状态策略模式取代类型码replace-type-code-with-statestrategy"></a> 以状态/策略模式取代类型码(Replace Type Code with State/Strategy)</h4>
<p><strong>问题</strong></p>
<p>你有一个类型码，它会影响类的行为，但你无法通过继承消除它。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/replace-type-code-with-state-strategy-before.png"/></div>
<p><strong>解决</strong></p>
<p>以状态对象取代类型码。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/replace-type-code-with-state-strategy-after.png"/></div>
<h4 id="以对象取代数组replace-array-with-object"><a class="markdownIt-Anchor" href="#以对象取代数组replace-array-with-object"></a> 以对象取代数组(Replace Array with Object)</h4>
<p><strong>问题</strong></p>
<p>你有一个数组，其中的元素各自代表不同的东西。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] row = <span class="keyword">new</span> String[<span class="number">3</span>];</span><br><span class="line">row[<span class="number">0</span>] = <span class="string">"Liverpool"</span>;</span><br><span class="line">row[<span class="number">1</span>] = <span class="string">"15"</span>;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>以对象替换数组。对于数组中的每个元素，以一个字段来表示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Performance row = <span class="keyword">new</span> Performance();</span><br><span class="line">row.setName(<span class="string">"Liverpool"</span>);</span><br><span class="line">row.setWins(<span class="string">"15"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="数据泥团"><a class="markdownIt-Anchor" href="#数据泥团"></a> 数据泥团</h2>
<blockquote>
<p>数据泥团(Data Clumps)</p>
<p>有时，代码的不同部分包含相同的变量组（例如用于连接到数据库的参数）。这些绑在一起出现的数据应该拥有自己的对象。</p>
</blockquote>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/data-clumps-1.png"/></div>
<h3 id="问题原因-2"><a class="markdownIt-Anchor" href="#问题原因-2"></a> 问题原因</h3>
<p>通常，数据泥团的出现时因为糟糕的编程结构或“复制-粘贴式编程”。</p>
<p>有一个判断是否是数据泥团的好办法：删掉众多数据中的一项。这么做，其他数据有没有因而失去意义？如果它们不再有意义，这就是个明确的信号：你应该为它们产生一个新的对象。</p>
<h3 id="解决方法-2"><a class="markdownIt-Anchor" href="#解决方法-2"></a> 解决方法</h3>
<ul>
<li>首先找出这些数据以字段形式出现的地方，运用 <code>提炼类(Extract Class)</code> 将它们提炼到一个独立对象中。</li>
<li>如果数据泥团在函数的参数列中出现，运用 <code>引入参数对象(Introduce Parameter Object)</code> 将它们组织成一个类。</li>
<li>如果数据泥团的部分数据出现在其他函数中，考虑运用 <code>保持对象完整(Preserve Whole Object)</code> 将整个数据对象传入到函数中。</li>
<li>检视一下使用这些字段的代码，也许，将它们移入一个数据类是个不错的主意。</li>
</ul>
<h3 id="收益-2"><a class="markdownIt-Anchor" href="#收益-2"></a> 收益</h3>
<ul>
<li>提高代码易读性和组织性。对于特殊数据的操作，可以集中进行处理，而不像以前那样分散。</li>
<li>减少代码量。</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/data-clumps-3.png"/></div>
<h3 id="何时忽略"><a class="markdownIt-Anchor" href="#何时忽略"></a> 何时忽略</h3>
<ul>
<li>有时为了对象中的部分数据而将整个对象作为参数传递给函数，可能会产生让两个类之间不收欢迎的依赖关系，这中情况下可以不传递整个对象。</li>
</ul>
<h3 id="重构方法说明-2"><a class="markdownIt-Anchor" href="#重构方法说明-2"></a> 重构方法说明</h3>
<h4 id="提炼类extract-class"><a class="markdownIt-Anchor" href="#提炼类extract-class"></a> 提炼类(Extract Class)</h4>
<p><strong>问题</strong></p>
<p>某个类做了不止一件事。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/extract-class-before.png"/></div>
<p><strong>解决</strong></p>
<p>建立一个新类，将相关的字段和函数从旧类搬移到新类。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/extract-class-after.png"/></div>
<h4 id="引入参数对象introduce-parameter-object-2"><a class="markdownIt-Anchor" href="#引入参数对象introduce-parameter-object-2"></a> 引入参数对象(Introduce Parameter Object)</h4>
<p><strong>问题</strong></p>
<p>某些参数总是很自然地同时出现。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/introduce-parameter-object-before.png"/></div>
<p><strong>解决</strong></p>
<p>以一个对象来取代这些参数。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/introduce-parameter-object-after.png"/></div>
<h4 id="保持对象完整preserve-whole-object-2"><a class="markdownIt-Anchor" href="#保持对象完整preserve-whole-object-2"></a> 保持对象完整(Preserve Whole Object)</h4>
<p><strong>问题</strong></p>
<p>你从某个对象中取出若干值，将它们作为某一次函数调用时的参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> low = daysTempRange.getLow();</span><br><span class="line"><span class="keyword">int</span> high = daysTempRange.getHigh();</span><br><span class="line"><span class="keyword">boolean</span> withinPlan = plan.withinRange(low, high);</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>改为传递整个对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> withinPlan = plan.withinRange(daysTempRange);</span><br></pre></td></tr></table></figure>
<h2 id="过大的类"><a class="markdownIt-Anchor" href="#过大的类"></a> 过大的类</h2>
<blockquote>
<p>过大的类(Large Class)</p>
<p>一个类含有过多字段、函数、代码行。</p>
</blockquote>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/large-class-1.png"/></div>
<h3 id="问题原因-3"><a class="markdownIt-Anchor" href="#问题原因-3"></a> 问题原因</h3>
<p>类通常一开始很小，但是随着程序的增长而逐渐膨胀。</p>
<p>类似于过长函数，程序员通常觉得在一个现存类中添加新特性比创建一个新的类要容易。</p>
<h3 id="解决方法-3"><a class="markdownIt-Anchor" href="#解决方法-3"></a> 解决方法</h3>
<p>设计模式中有一条重要原则：职责单一原则。一个类应该只赋予它一个职责。如果它所承担的职责太多，就该考虑为它减减负。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/large-class-2.png"/></div>
<ul>
<li>如果过大类中的部分行为可以提炼到一个独立的组件中，可以使用 <code>提炼类(Extract Class)</code>。</li>
<li>如果过大类中的部分行为可以用不同方式实现或使用于特殊场景，可以使用 <code>提炼子类(Extract Subclass)</code>。</li>
<li>如果有必要为客户端提供一组操作和行为，可以使用 <code>提炼接口(Extract Interface)</code>。</li>
<li>如果你的过大类是个 GUI 类，可能需要把数据和行为移到一个独立的领域对象去。你可能需要两边各保留一些重复数据，并保持两边同步。 <code>复制被监视数据(Duplicate Observed Data)</code> 可以告诉你怎么做。</li>
</ul>
<h3 id="收益-3"><a class="markdownIt-Anchor" href="#收益-3"></a> 收益</h3>
<ul>
<li>重构过大的类可以使程序员不必记住一个类中大量的属性。</li>
<li>在大多数情况下，分割过大的类可以避免代码和功能的重复。</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/large-class-3.png"/></div>
<h3 id="重构方法说明-3"><a class="markdownIt-Anchor" href="#重构方法说明-3"></a> 重构方法说明</h3>
<h4 id="提炼类extract-class-2"><a class="markdownIt-Anchor" href="#提炼类extract-class-2"></a> 提炼类(Extract Class)</h4>
<p><strong>问题</strong></p>
<p>某个类做了不止一件事。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/extract-class-before.png"/></div>
<p><strong>解决</strong></p>
<p>建立一个新类，将相关的字段和函数从旧类搬移到新类。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/extract-class-after.png"/></div>
<h4 id="提炼子类extract-subclass"><a class="markdownIt-Anchor" href="#提炼子类extract-subclass"></a> 提炼子类(Extract Subclass)</h4>
<p><strong>问题</strong></p>
<p>一个类中有些特性仅用于特定场景。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/extract-subclass-before.png"/></div>
<p><strong>解决</strong></p>
<p>创建一个子类，并将用于特殊场景的特性置入其中。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/extract-subclass-after.png"/></div>
<h4 id="提炼接口extract-interface"><a class="markdownIt-Anchor" href="#提炼接口extract-interface"></a> 提炼接口(Extract Interface)</h4>
<p><strong>问题</strong></p>
<p>多个客户端使用一个类部分相同的函数。另一个场景是两个类中的部分函数相同。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/extract-interface-before.png"/></div>
<p><strong>解决</strong></p>
<p>移动相同的部分函数到接口中。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/extract-interface-after.png"/></div>
<h4 id="复制被监视数据duplicate-observed-data"><a class="markdownIt-Anchor" href="#复制被监视数据duplicate-observed-data"></a> 复制被监视数据(Duplicate Observed Data)</h4>
<p><strong>问题</strong></p>
<p>如果存储在类中的数据是负责 GUI 的。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/duplicate-observed-data-before.png"/></div>
<p><strong>解决</strong></p>
<p>一个比较好的方法是将负责 GUI 的数据放入一个独立的类，以确保 GUI 数据与域类之间的连接和同步。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/duplicate-observed-data-after.png"/></div>
<h2 id="过长函数"><a class="markdownIt-Anchor" href="#过长函数"></a> 过长函数</h2>
<blockquote>
<p>过长函数(Long Method)</p>
<p>一个函数含有太多行代码。一般来说，任何函数超过 10 行时，你就可以考虑是不是过长了。<br />
函数中的代码行数原则上不要超过 100 行。</p>
</blockquote>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/long-method-1.png"/></div>
<h3 id="问题的原因"><a class="markdownIt-Anchor" href="#问题的原因"></a> 问题的原因</h3>
<p>通常情况下，创建一个新函数的难度要大于添加功能到一个已存在的函数。大部分人都觉得：“我就添加这么两行代码，为此新建一个函数实在是小题大做了。”于是，张三加两行，李四加两行，王五加两行。。。函数日益庞大，最终烂的像一锅浆糊，再也没人能完全看懂了。于是大家就更不敢轻易动这个函数了，只能恶性循环的往其中添加代码。所以，如果你看到一个超过 200 行的函数，通常都是多个程序员东拼西凑出来的。</p>
<h3 id="解决函数"><a class="markdownIt-Anchor" href="#解决函数"></a> 解决函数</h3>
<p>一个很好的技巧是：<strong>寻找注释</strong>。添加注释，一般有这么几个原因：代码逻辑较为晦涩或复杂；这段代码功能相对独立；特殊处理。<br />
如果代码前方有一行注释，就是在提醒你：可以将这段代码替换成一个函数，而且可以在注释的基础上给这个函数命名。如果函数有一个描述恰当的名字，就不需要去看内部代码究竟是如何实现的。就算只有一行代码，如果它需要以注释来说明，那也值得将它提炼到独立函数中。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/long-method-2.png"/></div>
<ul>
<li>为了给一个函数瘦身，可以使用 <code>提炼函数(Extract Method)</code>。</li>
<li>如果局部变量和参数干扰提炼函数，可以使用 <code>以查询取代临时变量(Replace Temp with Query)</code>，<code>引入参数对象(Introduce Parameter Object)</code> 或 <code>保持对象完整(Preserve Whole Object)</code> 。</li>
<li>如果前面两条没有帮助，可以通过 <code>以函数对象取代函数(Replace Method with Method Object)</code> 尝试移动整个函数到一个独立的对象中。</li>
<li>条件表达式和循环常常也是提炼的信号。对于条件表达式，可以使用 <code>分解条件表达式(Decompose Conditional)</code> 。至于循环，应该使用 <code>提炼函数(Extract Method)</code> 将循环和其内的代码提炼到独立函数中。</li>
</ul>
<h3 id="收益-4"><a class="markdownIt-Anchor" href="#收益-4"></a> 收益</h3>
<ul>
<li>在所有类型的面向对象代码中，函数比较短小精悍的类往往生命周期较长。一个函数越长，就越不容易理解和维护。</li>
<li>此外，过长函数中往往含有难以发现的重复代码。</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/long-method-3.png"/></div>
<h3 id="性能"><a class="markdownIt-Anchor" href="#性能"></a> 性能</h3>
<p>是否像许多人说的那样，增加函数的数量会影响性能？在几乎绝大多数情况下，这种影响是可以忽略不计，所以不用担心。<br />
此外，现在有了清晰和易读的代码，在需要的时候，你将更容易找到真正有效的函数来重组代码和提高性能。</p>
<h3 id="重构方法说明-4"><a class="markdownIt-Anchor" href="#重构方法说明-4"></a> 重构方法说明</h3>
<h4 id="提炼函数extract-method"><a class="markdownIt-Anchor" href="#提炼函数extract-method"></a> 提炼函数(Extract Method)</h4>
<p><strong>问题</strong></p>
<p>你有一段代码可以组织在一起。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printOwing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  printBanner();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//print details</span></span><br><span class="line">  System.out.println(<span class="string">"name: "</span> + name);</span><br><span class="line">  System.out.println(<span class="string">"amount: "</span> + getOutstanding());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>移动这段代码到一个新的函数中，使用函数的调用来替代老代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printOwing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  printBanner();</span><br><span class="line">  printDetails(getOutstanding());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDetails</span><span class="params">(<span class="keyword">double</span> outstanding)</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"name: "</span> + name);</span><br><span class="line">  System.out.println(<span class="string">"amount: "</span> + outstanding);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="以查询取代临时变量replace-temp-with-query"><a class="markdownIt-Anchor" href="#以查询取代临时变量replace-temp-with-query"></a> 以查询取代临时变量(Replace Temp with Query)</h4>
<p><strong>问题</strong></p>
<p>将表达式的结果放在局部变量中，然后在代码中使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calculateTotal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> basePrice = quantity * itemPrice;</span><br><span class="line">  <span class="keyword">if</span> (basePrice &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> basePrice * <span class="number">0.95</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> basePrice * <span class="number">0.98</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>将整个表达式移动到一个独立的函数中并返回结果。使用查询函数来替代使用变量。如果需要，可以在其他函数中合并新函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calculateTotal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (basePrice() &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> basePrice() * <span class="number">0.95</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> basePrice() * <span class="number">0.98</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">basePrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> quantity * itemPrice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="引入参数对象introduce-parameter-object-3"><a class="markdownIt-Anchor" href="#引入参数对象introduce-parameter-object-3"></a> 引入参数对象(Introduce Parameter Object)</h4>
<p><strong>问题</strong></p>
<p>某些参数总是很自然地同时出现。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/introduce-parameter-object-before.png"/></div>
<p><strong>解决</strong></p>
<p>以一个对象来取代这些参数。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/introduce-parameter-object-after.png"/></div>
<h4 id="保持对象完整preserve-whole-object-3"><a class="markdownIt-Anchor" href="#保持对象完整preserve-whole-object-3"></a> 保持对象完整(Preserve Whole Object)</h4>
<p><strong>问题</strong></p>
<p>你从某个对象中取出若干值，将它们作为某一次函数调用时的参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> low = daysTempRange.getLow();</span><br><span class="line"><span class="keyword">int</span> high = daysTempRange.getHigh();</span><br><span class="line"><span class="keyword">boolean</span> withinPlan = plan.withinRange(low, high);</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>改为传递整个对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> withinPlan = plan.withinRange(daysTempRange);</span><br></pre></td></tr></table></figure>
<h4 id="以函数对象取代函数replace-method-with-method-object"><a class="markdownIt-Anchor" href="#以函数对象取代函数replace-method-with-method-object"></a> 以函数对象取代函数(Replace Method with Method Object)</h4>
<p><strong>问题</strong></p>
<p>你有一个过长函数，它的局部变量交织在一起，以致于你无法应用提炼函数(Extract Method) 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">price</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> primaryBasePrice;</span><br><span class="line">    <span class="keyword">double</span> secondaryBasePrice;</span><br><span class="line">    <span class="keyword">double</span> tertiaryBasePrice;</span><br><span class="line">    <span class="comment">// long computation.</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>将函数移到一个独立的类中，使得局部变量成了这个类的字段。然后，你可以将函数分割成这个类中的多个函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">price</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PriceCalculator(<span class="keyword">this</span>).compute();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriceCalculator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> primaryBasePrice;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> secondaryBasePrice;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> tertiaryBasePrice;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PriceCalculator</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// copy relevant information from order object.</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// long computation.</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分解条件表达式decompose-conditional"><a class="markdownIt-Anchor" href="#分解条件表达式decompose-conditional"></a> 分解条件表达式(Decompose Conditional)</h4>
<p><strong>问题</strong></p>
<p>你有复杂的条件表达式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (date.before(SUMMER_START) || date.after(SUMMER_END)) &#123;</span><br><span class="line">  charge = quantity * winterRate + winterServiceCharge;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  charge = quantity * summerRate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>根据条件分支将整个条件表达式分解成几个函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (notSummer(date)) &#123;</span><br><span class="line">  charge = winterCharge(quantity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  charge = summerCharge(quantity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="过长参数列"><a class="markdownIt-Anchor" href="#过长参数列"></a> 过长参数列</h2>
<blockquote>
<p>过长参数列(Long Parameter List)</p>
<p>一个函数有超过 3、4 个入参。</p>
</blockquote>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/long-parameter-list-1.png"/></div>
<h3 id="问题原因-4"><a class="markdownIt-Anchor" href="#问题原因-4"></a> 问题原因</h3>
<p>过长参数列可能是将多个算法并到一个函数中时发生的。函数中的入参可以用来控制最终选用哪个算法去执行。</p>
<p>过长参数列也可能是解耦类之间依赖关系时的副产品。例如，用于创建函数中所需的特定对象的代码已从函数移动到调用函数的代码处，但创建的对象是作为参数传递到函数中。因此，原始类不再知道对象之间的关系，并且依赖性也已经减少。但是如果创建的这些对象，每一个都将需要它自己的参数，这意味着过长参数列。</p>
<p>太长的参数列难以理解，太多参数会造成前后不一致、不易使用，而且一旦需要更多数据，就不得不修改它。</p>
<h3 id="解决方案"><a class="markdownIt-Anchor" href="#解决方案"></a> 解决方案</h3>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/long-parameter-list-2.png"/></div>
<ul>
<li>如果向已有的对象发出一条请求就可以取代一个参数，那么你应该使用 <code>以函数取代参数(Replace Parameter with Methods)</code> 。在这里，，“已有的对象”可能是函数所属类里的一个字段，也可能是另一个参数。</li>
<li>你还可以运用 <code>保持对象完整(Preserve Whole Object)</code> 将来自同一对象的一堆数据收集起来，并以该对象替换它们。</li>
<li>如果某些数据缺乏合理的对象归属，可使用 <code>引入参数对象(Introduce Parameter Object)</code> 为它们制造出一个“参数对象”。</li>
</ul>
<h3 id="收益-5"><a class="markdownIt-Anchor" href="#收益-5"></a> 收益</h3>
<ul>
<li>更易读，更简短的代码。</li>
<li>重构可能会暴露出之前未注意到的重复代码。</li>
</ul>
<h3 id="何时忽略-2"><a class="markdownIt-Anchor" href="#何时忽略-2"></a> 何时忽略</h3>
<ul>
<li>这里有一个重要的例外：有时候你明显不想造成&quot;被调用对象&quot;与&quot;较大对象&quot;间的某种依赖关系。这时候将数据从对象中拆解出来单独作为参数，也很合情理。但是请注意其所引发的代价。如果参数列太长或变化太频繁，就需要重新考虑自己的依赖结构了。</li>
</ul>
<h3 id="重构方法说明-5"><a class="markdownIt-Anchor" href="#重构方法说明-5"></a> 重构方法说明</h3>
<h4 id="以函数取代参数replace-parameter-with-methods"><a class="markdownIt-Anchor" href="#以函数取代参数replace-parameter-with-methods"></a> 以函数取代参数(Replace Parameter with Methods)</h4>
<p><strong>问题</strong></p>
<p>对象调用某个函数，并将所得结果作为参数，传递给另一个函数。而接受该参数的函数本身也能够调用前一个函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> basePrice = quantity * itemPrice;</span><br><span class="line"><span class="keyword">double</span> seasonDiscount = <span class="keyword">this</span>.getSeasonalDiscount();</span><br><span class="line"><span class="keyword">double</span> fees = <span class="keyword">this</span>.getFees();</span><br><span class="line"><span class="keyword">double</span> finalPrice = discountedPrice(basePrice, seasonDiscount, fees);</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>让参数接受者去除该项参数，并直接调用前一个函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> basePrice = quantity * itemPrice;</span><br><span class="line"><span class="keyword">double</span> finalPrice = discountedPrice(basePrice);</span><br></pre></td></tr></table></figure>
<h4 id="保持对象完整preserve-whole-object-4"><a class="markdownIt-Anchor" href="#保持对象完整preserve-whole-object-4"></a> 保持对象完整(Preserve Whole Object)</h4>
<p><strong>问题</strong></p>
<p>你从某个对象中取出若干值，将它们作为某一次函数调用时的参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> low = daysTempRange.getLow();</span><br><span class="line"><span class="keyword">int</span> high = daysTempRange.getHigh();</span><br><span class="line"><span class="keyword">boolean</span> withinPlan = plan.withinRange(low, high);</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>改为传递整个对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> withinPlan = plan.withinRange(daysTempRange);</span><br></pre></td></tr></table></figure>
<h4 id="引入参数对象introduce-parameter-object-4"><a class="markdownIt-Anchor" href="#引入参数对象introduce-parameter-object-4"></a> 引入参数对象(Introduce Parameter Object)</h4>
<p><strong>问题</strong></p>
<p>某些参数总是很自然地同时出现。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/introduce-parameter-object-before.png"/></div>
<p><strong>解决</strong></p>
<p>以一个对象来取代这些参数。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/introduce-parameter-object-after.png"/></div>
<h2 id="扩展阅读"><a class="markdownIt-Anchor" href="#扩展阅读"></a> 扩展阅读</h2>
<ul>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/" target="_blank" rel="noopener">代码的坏味道和重构</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%87%83%E8%82%BF.md" target="_blank" rel="noopener">代码坏味道之代码臃肿</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E6%BB%A5%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.md" target="_blank" rel="noopener">代码坏味道之滥用面向对象</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E5%8F%98%E9%9D%A9%E7%9A%84%E9%9A%9C%E7%A2%8D.md" target="_blank" rel="noopener">代码坏味道之变革的障碍</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E9%9D%9E%E5%BF%85%E8%A6%81%E7%9A%84.md" target="_blank" rel="noopener">代码坏味道之非必要的</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E8%80%A6%E5%90%88.md" target="_blank" rel="noopener">代码坏味道之耦合</a></li>
</ul>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><a href="https://book.douban.com/subject/4262627/" target="_blank" rel="noopener">重构——改善既有代码的设计</a> - by Martin Fowler</li>
<li><a href="https://sourcemaking.com/refactoring" target="_blank" rel="noopener">https://sourcemaking.com/refactoring</a></li>
</ul>
]]></content>
      <categories>
        <category>设计</category>
        <category>重构</category>
      </categories>
      <tags>
        <tag>设计</tag>
        <tag>重构</tag>
        <tag>代码坏味道</tag>
      </tags>
  </entry>
  <entry>
    <title>代码坏味道之耦合</title>
    <url>/blog/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E8%80%A6%E5%90%88/</url>
    <content><![CDATA[<blockquote>
<p>📓 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p>
<p>翻译自：<a href="https://sourcemaking.com/refactoring/smells/couplers" target="_blank" rel="noopener">https://sourcemaking.com/refactoring/smells/couplers</a></p>
<p><strong>耦合(Couplers)这组坏味道意味着：不同类之间过度耦合。</strong></p>
</blockquote>
<h2 id="不完美的库类"><a class="markdownIt-Anchor" href="#不完美的库类"></a> 不完美的库类</h2>
<blockquote>
<p>不完美的库类(Incomplete Library Class)</p>
<p>当一个类库已经不能满足实际需要时，你就不得不改变这个库（如果这个库是只读的，那就没辙了）。</p>
</blockquote>
<h3 id="问题原因"><a class="markdownIt-Anchor" href="#问题原因"></a> 问题原因</h3>
<p>许多编程技术都建立在库类的基础上。库类的作者没用未卜先知的能力，不能因此责怪他们。麻烦的是库往往构造的不够好，而且往往不可能让我们修改其中的类以满足我们的需要。</p>
<h3 id="解决方法"><a class="markdownIt-Anchor" href="#解决方法"></a> 解决方法</h3>
<ul>
<li>如果你只想修改类库的一两个函数，可以运用 <code>引入外加函数(Introduce Foreign Method)</code>；</li>
<li>如果想要添加一大堆额外行为，就得运用 <code>引入本地扩展(Introduce Local Extension)</code> 。</li>
</ul>
<h3 id="收益"><a class="markdownIt-Anchor" href="#收益"></a> 收益</h3>
<ul>
<li>减少代码重复（你不用一言不合就自己动手实现一个库的全部功能，代价太高）</li>
</ul>
<h3 id="何时忽略"><a class="markdownIt-Anchor" href="#何时忽略"></a> 何时忽略</h3>
<ul>
<li>如果扩展库会带来额外的工作量。</li>
</ul>
<h3 id="重构方法说明"><a class="markdownIt-Anchor" href="#重构方法说明"></a> 重构方法说明</h3>
<h4 id="引入外加函数introduce-foreign-method"><a class="markdownIt-Anchor" href="#引入外加函数introduce-foreign-method"></a> 引入外加函数(Introduce Foreign Method)</h4>
<p><strong>问题</strong></p>
<p>你需要为提供服务的类增加一个函数，但你无法修改这个类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Report</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sendReport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Date nextDay = <span class="keyword">new</span> Date(previousEnd.getYear(),</span><br><span class="line">      previousEnd.getMonth(), previousEnd.getDate() + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>在客户类中建立一个函数，并一个第一个参数形式传入一个服务类实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Report</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sendReport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Date newStart = nextDay(previousEnd);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Date <span class="title">nextDay</span><span class="params">(Date arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Date(arg.getYear(), arg.getMonth(), arg.getDate() + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="引入本地扩展introduce-local-extension"><a class="markdownIt-Anchor" href="#引入本地扩展introduce-local-extension"></a> 引入本地扩展(Introduce Local Extension)</h4>
<p><strong>问题</strong></p>
<p>你需要为服务类提供一些额外函数，但你无法修改这个类。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/introduce-local-extension-before.png"/></div>
<p><strong>解决</strong></p>
<p>建立一个新类，使它包含这些额外函数，让这个扩展品成为源类的子类或包装类。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/introduce-local-extension-after.png"/></div>
<h2 id="中间人"><a class="markdownIt-Anchor" href="#中间人"></a> 中间人</h2>
<blockquote>
<p>中间人(Middle Man)</p>
<p>如果一个类的作用仅仅是指向另一个类的委托，为什么要存在呢？</p>
</blockquote>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/middle-man-1.png"/></div>
<h3 id="问题原因-2"><a class="markdownIt-Anchor" href="#问题原因-2"></a> 问题原因</h3>
<p>对象的基本特征之一就是封装：对外部世界隐藏其内部细节。封装往往伴随委托。但是人们可能过度运用委托。比如，你也许会看到一个类的大部分有用工作都委托给了其他类，类本身成了一个空壳，除了委托之外不做任何事情。</p>
<h3 id="解决方法-2"><a class="markdownIt-Anchor" href="#解决方法-2"></a> 解决方法</h3>
<p>应该运用 <code>移除中间人(Remove Middle Man)</code>，直接和真正负责的对象打交道。</p>
<h3 id="收益-2"><a class="markdownIt-Anchor" href="#收益-2"></a> 收益</h3>
<ul>
<li>减少笨重的代码。</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/middle-man-2.png"/></div>
<h3 id="何时忽略-2"><a class="markdownIt-Anchor" href="#何时忽略-2"></a> 何时忽略</h3>
<p>如果是以下情况，不要删除已创建的中间人：</p>
<ul>
<li>添加中间人是为了避免类之间依赖关系。</li>
<li>一些设计模式有目的地创建中间人（例如代理模式和装饰器模式）。</li>
</ul>
<h3 id="重构方法说明-2"><a class="markdownIt-Anchor" href="#重构方法说明-2"></a> 重构方法说明</h3>
<h4 id="移除中间人remove-middle-man"><a class="markdownIt-Anchor" href="#移除中间人remove-middle-man"></a> 移除中间人(Remove Middle Man)</h4>
<p><strong>问题</strong></p>
<p>某个类做了过多的简单委托动作。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/remove-middle-man-before.png"/></div>
<p><strong>解决</strong></p>
<p>让客户直接调用委托类。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/remove-middle-man-after.png"/></div>
<h2 id="依恋情结"><a class="markdownIt-Anchor" href="#依恋情结"></a> 依恋情结</h2>
<blockquote>
<p>依恋情结(Feature Envy)</p>
<p>一个函数访问其它对象的数据比访问自己的数据更多。</p>
</blockquote>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/feature-envy-1.png"/></div>
<h3 id="问题原因-3"><a class="markdownIt-Anchor" href="#问题原因-3"></a> 问题原因</h3>
<p>这种气味可能发生在字段移动到数据类之后。如果是这种情况，你可能想将数据类的操作移动到这个类中。</p>
<h3 id="解决方法-3"><a class="markdownIt-Anchor" href="#解决方法-3"></a> 解决方法</h3>
<p>As a basic rule, if things change at the same time, you should keep them in the same place. Usually data and functions that use this data are changed together (although exceptions are possible).</p>
<p>有一个基本原则：同时会发生改变的事情应该被放在同一个地方。通常，数据和使用这些数据的函数是一起改变的。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/feature-envy-2.png"/></div>
<ul>
<li>如果一个函数明显应该被移到另一个地方，可运用 <code>搬移函数(Move Method)</code> 。</li>
<li>如果仅仅是函数的部分代码访问另一个对象的数据，运用 <code>提炼函数(Extract Method)</code> 将这部分代码移到独立的函数中。</li>
<li>如果一个方法使用来自其他几个类的函数，首先确定哪个类包含大多数使用的数据。然后，将该方法与其他数据一起放在此类中。或者，使用 <code>提炼函数(Extract Method)</code> 将方法拆分为几个部分，可以放置在不同类中的不同位置。</li>
</ul>
<h3 id="收益-3"><a class="markdownIt-Anchor" href="#收益-3"></a> 收益</h3>
<ul>
<li>减少重复代码（如果数据处理的代码放在中心位置）。</li>
<li>更好的代码组织性（处理数据的函数靠近实际数据）。</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/feature-envy-3.png"/></div>
<h3 id="何时忽略-3"><a class="markdownIt-Anchor" href="#何时忽略-3"></a> 何时忽略</h3>
<ul>
<li>有时，行为被有意地与保存数据的类分开。这通常的优点是能够动态地改变行为（见策略设计模式，访问者设计模式和其他模式）。</li>
</ul>
<h3 id="重构方法说明-3"><a class="markdownIt-Anchor" href="#重构方法说明-3"></a> 重构方法说明</h3>
<h4 id="搬移函数move-method"><a class="markdownIt-Anchor" href="#搬移函数move-method"></a> 搬移函数(Move Method)</h4>
<p><strong>问题</strong></p>
<p>你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/move-method-before.png"/></div>
<p><strong>解决</strong></p>
<p>在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/move-method-after.png"/></div>
<h4 id="提炼函数extract-method"><a class="markdownIt-Anchor" href="#提炼函数extract-method"></a> 提炼函数(Extract Method)</h4>
<p><strong>问题</strong></p>
<p>你有一段代码可以组织在一起。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printOwing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  printBanner();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//print details</span></span><br><span class="line">  System.out.println(<span class="string">"name: "</span> + name);</span><br><span class="line">  System.out.println(<span class="string">"amount: "</span> + getOutstanding());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>移动这段代码到一个新的函数中，使用函数的调用来替代老代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printOwing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  printBanner();</span><br><span class="line">  printDetails(getOutstanding());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDetails</span><span class="params">(<span class="keyword">double</span> outstanding)</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"name: "</span> + name);</span><br><span class="line">  System.out.println(<span class="string">"amount: "</span> + outstanding);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="狎昵关系"><a class="markdownIt-Anchor" href="#狎昵关系"></a> 狎昵关系</h2>
<blockquote>
<p>狎昵关系(Inappropriate Intimacy)</p>
<p>一个类大量使用另一个类的内部字段和方法。</p>
</blockquote>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/inappropriate-intimacy-1.png"/></div>
<h3 id="问题原因-4"><a class="markdownIt-Anchor" href="#问题原因-4"></a> 问题原因</h3>
<p>类和类之间应该尽量少的感知彼此（减少耦合）。这样的类更容易维护和复用。</p>
<h3 id="解决方法-4"><a class="markdownIt-Anchor" href="#解决方法-4"></a> 解决方法</h3>
<ul>
<li>最简单的解决方法是运用 <code>搬移函数(Move Method)</code> 和 <code>搬移字段(Move Field)</code> 来让类之间斩断羁绊。</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/inappropriate-intimacy-2.png"/></div>
<ul>
<li>
<p>你也可以看看是否能运用 <code>将双向关联改为单向关联(Change Bidirectional Association to Unidirectional)</code> 让其中一个类对另一个说分手。</p>
</li>
<li>
<p>如果这两个类实在是情比金坚，难分难舍，可以运用 <code>提炼类(Extract Class)</code> 把二者共同点提炼到一个新类中，让它们产生爱的结晶。或者，可以尝试运用 <code>隐藏委托关系(Hide Delegate)</code> 让另一个类来为它们牵线搭桥。</p>
</li>
<li>
<p>继承往往造成类之间过分紧密，因为子类对超类的了解总是超过后者的主观愿望，如果你觉得该让这个子类自己闯荡，请运用 <code>以委托取代继承(Replace Inheritance with Delegation)</code> 来让超类和子类分家。</p>
</li>
</ul>
<h3 id="收益-4"><a class="markdownIt-Anchor" href="#收益-4"></a> 收益</h3>
<ul>
<li>提高代码组织性。</li>
<li>提高代码复用性。</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/inappropriate-intimacy-3.png"/></div>
<h3 id="重构方法说明-4"><a class="markdownIt-Anchor" href="#重构方法说明-4"></a> 重构方法说明</h3>
<h4 id="搬移函数move-method-2"><a class="markdownIt-Anchor" href="#搬移函数move-method-2"></a> 搬移函数(Move Method)</h4>
<p><strong>问题</strong></p>
<p>你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/move-method-before.png"/></div>
<p><strong>解决</strong></p>
<p>在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/move-method-after.png"/></div>
<h4 id="搬移字段move-field"><a class="markdownIt-Anchor" href="#搬移字段move-field"></a> 搬移字段(Move Field)</h4>
<p><strong>问题</strong></p>
<p>在你的程序中，某个字段被其所驻类之外的另一个类更多地用到。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/move-field-before.png"/></div>
<p><strong>解决</strong></p>
<p>在目标类新建一个字段，修改源字段的所有用户，令他们改用新字段。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/move-field-after.png"/></div>
<h4 id="将双向关联改为单向关联change-bidirectional-association-to-unidirectional"><a class="markdownIt-Anchor" href="#将双向关联改为单向关联change-bidirectional-association-to-unidirectional"></a> 将双向关联改为单向关联(Change Bidirectional Association to Unidirectional)</h4>
<p><strong>问题</strong></p>
<p>两个类之间有双向关联，但其中一个类如今不再需要另一个类的特性。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/change-bidirectional-association-to-unidirectional-before.png"/></div>
<p><strong>解决</strong></p>
<p>去除不必要的关联。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/change-bidirectional-association-to-unidirectional-after.png"/></div>
<h4 id="提炼类extract-class"><a class="markdownIt-Anchor" href="#提炼类extract-class"></a> 提炼类(Extract Class)</h4>
<p><strong>问题</strong></p>
<p>某个类做了不止一件事。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/extract-class-before.png"/></div>
<p><strong>解决</strong></p>
<p>建立一个新类，将相关的字段和函数从旧类搬移到新类。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/extract-class-after.png"/></div>
<h4 id="隐藏委托关系hide-delegate"><a class="markdownIt-Anchor" href="#隐藏委托关系hide-delegate"></a> 隐藏委托关系(Hide Delegate)</h4>
<p><strong>问题</strong></p>
<p>客户通过一个委托类来调用另一个对象。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/hide-delegate-before.png"/></div>
<p><strong>解决</strong></p>
<p>在服务类上建立客户所需的所有函数，用以隐藏委托关系。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/hide-delegate-after.png"/></div>
<h4 id="以委托取代继承replace-inheritance-with-delegation"><a class="markdownIt-Anchor" href="#以委托取代继承replace-inheritance-with-delegation"></a> 以委托取代继承(Replace Inheritance with Delegation)</h4>
<p><strong>问题</strong></p>
<p>某个子类只使用超类接口中的一部分，或是根本不需要继承而来的数据。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/replace-delegation-with-inheritance-before.png"/></div>
<p><strong>解决</strong></p>
<p>在子类中新建一个字段用以保存超类；调整子类函数，令它改而委托超类；然后去掉两者之间的继承关系。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/replace-delegation-with-inheritance-after.png"/></div>
<h2 id="过度耦合的消息链"><a class="markdownIt-Anchor" href="#过度耦合的消息链"></a> 过度耦合的消息链</h2>
<blockquote>
<p>过度耦合的消息链(Message Chains)</p>
<p>消息链的形式类似于：<code>obj.getA().getB().getC()</code>。</p>
</blockquote>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/message-chains-1.png"/></div>
<h3 id="问题原因-5"><a class="markdownIt-Anchor" href="#问题原因-5"></a> 问题原因</h3>
<p>如果你看到用户向一个对象请求另一个对象，然后再向后者请求另一个对象，然后再请求另一个对象……这就是消息链。实际代码中你看到的可能是一长串 getThis()或一长串临时变量。采取这种方式，意味客户代码将与查找过程中的导航紧密耦合。一旦对象间关系发生任何变化，客户端就不得不做出相应的修改。</p>
<h3 id="解决方法-5"><a class="markdownIt-Anchor" href="#解决方法-5"></a> 解决方法</h3>
<ul>
<li>可以运用 <code>隐藏委托关系(Hide Delegate)</code> 删除一个消息链。</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/message-chains-2.png"/></div>
<ul>
<li>有时更好的选择是：先观察消息链最终得到的对象是用来干什么的。看看能否以 <code>提炼函数(Extract Method)</code>把使用该对象的代码提炼到一个独立函数中，再运用 <code>搬移函数(Move Method)</code> 把这个函数推入消息链。</li>
</ul>
<h3 id="收益-5"><a class="markdownIt-Anchor" href="#收益-5"></a> 收益</h3>
<ul>
<li>能减少链中类之间的依赖。</li>
<li>能减少代码量。</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/message-chains-3.png"/></div>
<h3 id="何时忽略-4"><a class="markdownIt-Anchor" href="#何时忽略-4"></a> 何时忽略</h3>
<ul>
<li>过于侵略性的委托可能会使程序员难以理解功能是如何触发的。</li>
</ul>
<h3 id="重构方法说明-5"><a class="markdownIt-Anchor" href="#重构方法说明-5"></a> 重构方法说明</h3>
<h4 id="隐藏委托关系hide-delegate-2"><a class="markdownIt-Anchor" href="#隐藏委托关系hide-delegate-2"></a> 隐藏委托关系(Hide Delegate)</h4>
<p><strong>问题</strong></p>
<p>客户通过一个委托类来调用另一个对象。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/hide-delegate-before.png"/></div>
<p><strong>解决</strong></p>
<p>在服务类上建立客户所需的所有函数，用以隐藏委托关系。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/hide-delegate-after.png"/></div>
<h4 id="提炼函数extract-method-2"><a class="markdownIt-Anchor" href="#提炼函数extract-method-2"></a> 提炼函数(Extract Method)</h4>
<p><strong>问题</strong></p>
<p>你有一段代码可以组织在一起。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printOwing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  printBanner();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//print details</span></span><br><span class="line">  System.out.println(<span class="string">"name: "</span> + name);</span><br><span class="line">  System.out.println(<span class="string">"amount: "</span> + getOutstanding());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>移动这段代码到一个新的函数中，使用函数的调用来替代老代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printOwing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  printBanner();</span><br><span class="line">  printDetails(getOutstanding());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDetails</span><span class="params">(<span class="keyword">double</span> outstanding)</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"name: "</span> + name);</span><br><span class="line">  System.out.println(<span class="string">"amount: "</span> + outstanding);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="搬移函数move-method-3"><a class="markdownIt-Anchor" href="#搬移函数move-method-3"></a> 搬移函数(Move Method)</h4>
<p><strong>问题</strong></p>
<p>你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/move-method-before.png"/></div>
<p><strong>解决</strong></p>
<p>在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/move-method-after.png"/></div>
<h2 id="扩展阅读"><a class="markdownIt-Anchor" href="#扩展阅读"></a> 扩展阅读</h2>
<ul>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/" target="_blank" rel="noopener">代码的坏味道和重构</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%87%83%E8%82%BF.md" target="_blank" rel="noopener">代码坏味道之代码臃肿</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E6%BB%A5%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.md" target="_blank" rel="noopener">代码坏味道之滥用面向对象</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E5%8F%98%E9%9D%A9%E7%9A%84%E9%9A%9C%E7%A2%8D.md" target="_blank" rel="noopener">代码坏味道之变革的障碍</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E9%9D%9E%E5%BF%85%E8%A6%81%E7%9A%84.md" target="_blank" rel="noopener">代码坏味道之非必要的</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E8%80%A6%E5%90%88.md" target="_blank" rel="noopener">代码坏味道之耦合</a></li>
</ul>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><a href="https://book.douban.com/subject/4262627/" target="_blank" rel="noopener">重构——改善既有代码的设计</a> - by Martin Fowler</li>
<li><a href="https://sourcemaking.com/refactoring" target="_blank" rel="noopener">https://sourcemaking.com/refactoring</a></li>
</ul>
]]></content>
      <categories>
        <category>设计</category>
        <category>重构</category>
      </categories>
      <tags>
        <tag>设计</tag>
        <tag>重构</tag>
        <tag>代码坏味道</tag>
      </tags>
  </entry>
  <entry>
    <title>代码的坏味道和重构</title>
    <url>/blog/design/refactor/%E4%BB%A3%E7%A0%81%E7%9A%84%E5%9D%8F%E5%91%B3%E9%81%93%E5%92%8C%E9%87%8D%E6%9E%84/</url>
    <content><![CDATA[<blockquote>
<p>📓 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p>
</blockquote>
<p>第一次读《重构:改善既有代码的设计》时，我曾整理过一个简单的笔记。最近，因为参与一个重构项目，再一次温习了《重构:改善既有代码的设计》。过程中，萌发了认真总结、整理重构方法的冲动，于是有了这系列文字。</p>
<p>代码的坏味道还有几篇没有完稿，后面我会陆续补充。。。</p>
<h2 id="症与药"><a class="markdownIt-Anchor" href="#症与药"></a> 症与药</h2>
<h3 id="对代码的坏味道的思考"><a class="markdownIt-Anchor" href="#对代码的坏味道的思考"></a> 对代码的坏味道的思考</h3>
<p>“有病要早治，不要放弃治疗”。多么朴素的道理 ，人人都懂。</p>
<p>病，就是不健康。</p>
<p>人有病，可以通过打针、吃药、做手术来进行治疗。</p>
<p><strong>如果把代码的坏味道（代码质量问题）比作病症，那么重构就是治疗代码的坏味道的药。</strong></p>
<p>个人认为，在重构这件事上，也可以应用治病的道理：</p>
<ul>
<li>
<p><strong>防病于未然。</strong><br />
—— 春秋战国时期的一代名医扁鹊，曾经有个很著名的医学主张：<strong>防病于未然</strong>。 我觉得这个道理应用于软件代码的重构亦然。编程前要有合理的设计、编程时要有良好的编程风格，尽量减少问题。从这个层面上说，了解代码的坏味道，不仅仅是为了发现问题、解决问题。更重要的作用是：指导我们在编程过程中有意识的去规避这些问题。</p>
</li>
<li>
<p><strong>小病不医，易得大病。</strong><br />
—— 刘备说过：“勿以善小而不为，勿以恶小而为之”。发现问题就及时修改，代码质量自然容易进入良性循环；反之，亦然。要重视积累的力量，别总以为代码出现点小问题，那都不是事儿。</p>
</li>
<li>
<p><strong>对症下药。</strong><br />
—— 程序出现了问题，要分析出问题的根本，有针对性的制定合理的重构方案。大家都知道吃错药的后果，同样的，<strong>瞎改还不如不改</strong>。</p>
</li>
<li>
<p><strong>忌猛药</strong><br />
—— 医病用猛药容易产生副作用。换一句俗语：步子大了容易扯着蛋。重构如果大刀阔斧的干，那你就要有随时可能扑街的心理准备。推倒重来不是重构，而是重写。重构应该是循序渐进，步步为营的过程。当你发现重写代码比重构代码更简单，往往说明你早就该重构了。</p>
</li>
</ul>
<h3 id="重构的原则"><a class="markdownIt-Anchor" href="#重构的原则"></a> 重构的原则</h3>
<p>前面把代码质量问题比作病症，而把重构比作药。这里，我们再进一步讨论一下重构的原则。</p>
<h4 id="何谓重构what"><a class="markdownIt-Anchor" href="#何谓重构what"></a> 何谓重构(What)</h4>
<p><code>重构（Refactoring）</code> 的常见定义是：不改变软件系统外部行为的前提下，改善它的内部结构。</p>
<p>个人觉得这个定义有点生涩。不妨理解为：重构是给代码治病的行为。而代码有病是指代码的质量（可靠性、安全性、可复用性、可维护性）和性能有问题。</p>
<p><strong>重构的目的是为了提高代码的质量和性能</strong>。</p>
<p><em>注：功能不全或者不正确，那是残疾代码。就像治病治不了残疾，重构也解决不了功能问题。</em></p>
<h4 id="为何重构why"><a class="markdownIt-Anchor" href="#为何重构why"></a> 为何重构(Why)</h4>
<p>翻翻书，上网搜一下，谈到重构的理由大体相同：</p>
<ul>
<li>重构改进软件设计</li>
<li>重构使软件更容易理解</li>
<li>重构帮助找到 bug</li>
<li>重构提高编程速度</li>
</ul>
<p>总之就是，<strong>重构可以提高代码质量</strong>。</p>
<h4 id="何时重构when"><a class="markdownIt-Anchor" href="#何时重构when"></a> 何时重构(When)</h4>
<p>关于何时重构，我先引用一下 <a href="http://mt.sohu.com/20160812/n463980993.shtml" target="_blank" rel="noopener"><u>重构并非难在如何做，而是难在何时开始做</u></a> 一文的观点。</p>
<blockquote>
<p>对于一个高速发展的公司来说，停止业务开发，专门来做重构项目，<strong>从来就不是一个可接受的选项</strong>，“边开飞机边换引擎”才是这种公司想要的。</p>
</blockquote>
<p>我们不妨来衡量一下重构的成本和收益。</p>
<ul>
<li>
<p><strong>重构的成本</strong></p>
<p>重构是有成本的，费时费力（时间、人力）不说，还有可能会使本来正常运行的程序出错。所以，很多人都抱着“不求有功，但求无过”的心理得过且过。</p>
<p>还有一种成本：重构使用较新且较为复杂的技术，学习曲线不平滑，团队成员技术切换困难，短期内开发效率可能不升反降。</p>
<p>但是，如果一直放任代码腐朽下去，技术债务会越来越沉重。当代码最终快要跑不动时，架构师们往往还是不得不使用激进的手段来治疗代码的顽疾。但是，这个过程通常都是非常痛苦的，而且有着很高的失败风险。</p>
</li>
<li>
<p><strong>重构的收益</strong></p>
<p>重构的收益是提高代码的质量和性能，并提高未来的开发效率。但是，应当看到，重构往往并不能在短期内带来实际的效益，或者很难直观看出效益。而对于一个企业来说，没有什么比效益更重要。换句话说，没有实际效益的事，通常也没有价值。很多领导，尤其是非技术方向的领导，并不关心你应用了什么新技术，让代码变得多么优雅等等。</p>
</li>
<li>
<p><strong>重构的合适时机</strong></p>
<p>从以上来看，重构实在是个吃力不讨好的事情。</p>
<p>于是，很多人屈服于万恶的 KPI 和要命的 deadline，一边吐槽着以前的代码是垃圾，一边自己也在造垃圾。</p>
<p>但是，**重构本应该是个渐进式的过程，不是只有伤筋动骨的改造才叫重构。**如果非要等到代码已经烂到病入膏肓，再使用激进方式来重构，那必然是困难重重，风险极高。</p>
<p>《重构》书中提到的重构时机应该在添加功能、修复功能、审查代码时，不建议专门抽出时间专门做重构项目。</p>
<p>我认为，其思想就是指：<strong>重构应该是在开发过程中实时的、渐进的演化过程。</strong></p>
</li>
<li>
<p><strong>重构的不恰当时机</strong></p>
<p>但是，这里我也要强调一下：<strong>不是所有软件开发过程都一定要重构。</strong></p>
<p>较能<strong>凸显重构价值的场景</strong>是：代码规模较大、生命周期还较长、承担了较多责任、有一个较大（且较不稳定，人员流动频繁）团队在其上工作的单一代码库。</p>
<p>与之相反，有一些场景的重构价值就很小：</p>
<ul>
<li>代码库生命周期快要走到尾声，开发逐渐减少，以维护为主。</li>
<li>代码库当前版本马上要发布了，这时重构无疑是给自己找麻烦。</li>
<li>重构代价过于沉重：重构后功能的正确性、稳定性难以保障；技术过于超前，团队成员技术迁移难度太大。</li>
</ul>
</li>
</ul>
<h4 id="如何重构how"><a class="markdownIt-Anchor" href="#如何重构how"></a> 如何重构(How)</h4>
<p>重构行为在我看来，也是可以分层级的。由高到低，越高层级难度越大：</p>
<ul>
<li>
<p>服务、数据库<br />
现代软件往往业务复杂、庞大。使用微服务、数据迁移来拆分业务，降低业务复杂度成为了主流。但是，这些技术的测试、部署复杂，技术难度很高。</p>
</li>
<li>
<p>组件、模块、框架<br />
组件、模块、框架的重构，主要是针对代码的设计问题。解决的是代码的整体结构问题。需要对框架、设计模式、分布式、并发等等有足够的了解。</p>
</li>
<li>
<p>类、接口、函数、字段<br />
《重构》一书提到了**“代码的坏味道”**以及相关的重构方法。这些都是对类、接口、函数、字段级别代码的重构手段。由于这一级别的重构方法较为简单，所以可操作性较强。具体细节可以阅读《代码的坏味道》篇章。</p>
</li>
</ul>
<p>前两种层级的重构已经涉及到架构层面，影响较大，难度较高，如果功力不够不要轻易变动。由于这两个层级涉及领域较广，这里不做论述。</p>
<p><u><strong><em>此处为分割线。下面是代码的坏味道系列。。。</em></strong></u></p>
<h2 id="代码的坏味道"><a class="markdownIt-Anchor" href="#代码的坏味道"></a> 代码的坏味道</h2>
<p>《重构:改善既有代码的设计》中介绍了 22 种代码的坏味道以及重构手法。这些坏味道可以进一步归类。我总觉得将事物分类有助于理解和记忆。所以本系列将坏味道按照特性分类，然后逐一讲解。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/code-smell.png"/></div>
<h3 id="代码坏味道之代码臃肿"><a class="markdownIt-Anchor" href="#代码坏味道之代码臃肿"></a> 代码坏味道之代码臃肿</h3>
<blockquote>
<p><strong><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%87%83%E8%82%BF.md" target="_blank" rel="noopener">代码臃肿(Bloated)</a>这组坏味道意味着：代码中的类、函数、字段没有经过合理的组织，只是简单的堆砌起来。这一类型的问题通常在代码的初期并不明显，但是随着代码规模的增长而逐渐积累（特别是当没有人努力去根除它们时）。</strong></p>
</blockquote>
<ul>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%87%83%E8%82%BF.md#%E8%BF%87%E9%95%BF%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">过长函数</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%87%83%E8%82%BF.md#%E8%BF%87%E5%A4%A7%E7%9A%84%E7%B1%BB" target="_blank" rel="noopener">过大的类</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%87%83%E8%82%BF.md#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%81%8F%E6%89%A7" target="_blank" rel="noopener">基本类型偏执</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%87%83%E8%82%BF.md#%E8%BF%87%E9%95%BF%E5%8F%82%E6%95%B0%E5%88%97" target="_blank" rel="noopener">过长参数列</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%87%83%E8%82%BF.md#%E6%95%B0%E6%8D%AE%E6%B3%A5%E5%9B%A2" target="_blank" rel="noopener">数据泥团</a></li>
</ul>
<h3 id="代码坏味道之滥用面向对象"><a class="markdownIt-Anchor" href="#代码坏味道之滥用面向对象"></a> 代码坏味道之滥用面向对象</h3>
<blockquote>
<p><strong><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E6%BB%A5%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.md" target="_blank" rel="noopener">滥用面向对象(Object-Orientation Abusers)</a>这组坏味道意味着：代码部分或完全地违背了面向对象编程原则。</strong></p>
</blockquote>
<ul>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E6%BB%A5%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.md#switch-%E5%A3%B0%E6%98%8E" target="_blank" rel="noopener">switch 声明</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E6%BB%A5%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.md#%E4%B8%B4%E6%97%B6%E5%AD%97%E6%AE%B5" target="_blank" rel="noopener">临时字段</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E6%BB%A5%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.md#%E8%A2%AB%E6%8B%92%E7%BB%9D%E7%9A%84%E9%A6%88%E8%B5%A0" target="_blank" rel="noopener">被拒绝的馈赠</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E6%BB%A5%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.md#%E5%BC%82%E6%9B%B2%E5%90%8C%E5%B7%A5%E7%9A%84%E7%B1%BB" target="_blank" rel="noopener">异曲同工的类</a></li>
</ul>
<h3 id="代码坏味道之变革的障碍"><a class="markdownIt-Anchor" href="#代码坏味道之变革的障碍"></a> 代码坏味道之变革的障碍</h3>
<blockquote>
<p><strong><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E5%8F%98%E9%9D%A9%E7%9A%84%E9%9A%9C%E7%A2%8D.md" target="_blank" rel="noopener">变革的障碍(Change Preventers)</a>这组坏味道意味着：当你需要改变一处代码时，却发现不得不改变其他的地方。这使得程序开发变得复杂、代价高昂。</strong></p>
</blockquote>
<ul>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E5%8F%98%E9%9D%A9%E7%9A%84%E9%9A%9C%E7%A2%8D.md#%E5%8F%91%E6%95%A3%E5%BC%8F%E5%8F%98%E5%8C%96" target="_blank" rel="noopener">发散式变化</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E5%8F%98%E9%9D%A9%E7%9A%84%E9%9A%9C%E7%A2%8D.md#%E9%9C%B0%E5%BC%B9%E5%BC%8F%E4%BF%AE%E6%94%B9" target="_blank" rel="noopener">霰弹式修改</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E5%8F%98%E9%9D%A9%E7%9A%84%E9%9A%9C%E7%A2%8D.md#%E5%B9%B3%E8%A1%8C%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB" target="_blank" rel="noopener">平行继承体系</a></li>
</ul>
<h3 id="代码坏味道之非必要的"><a class="markdownIt-Anchor" href="#代码坏味道之非必要的"></a> 代码坏味道之非必要的</h3>
<blockquote>
<p><strong><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E9%9D%9E%E5%BF%85%E8%A6%81%E7%9A%84.md" target="_blank" rel="noopener">非必要的(Dispensables)</a>这组坏味道意味着：这样的代码可有可无，它的存在反而影响整体代码的整洁和可读性。</strong></p>
</blockquote>
<ul>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E9%9D%9E%E5%BF%85%E8%A6%81%E7%9A%84.md#%E8%BF%87%E5%A4%9A%E7%9A%84%E6%B3%A8%E9%87%8A" target="_blank" rel="noopener">过多的注释</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E9%9D%9E%E5%BF%85%E8%A6%81%E7%9A%84.md#%E9%87%8D%E5%A4%8D%E4%BB%A3%E7%A0%81" target="_blank" rel="noopener">重复代码</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E9%9D%9E%E5%BF%85%E8%A6%81%E7%9A%84.md#%E5%86%97%E4%BD%99%E7%B1%BB" target="_blank" rel="noopener">冗余类</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E9%9D%9E%E5%BF%85%E8%A6%81%E7%9A%84.md#%E7%BA%AF%E7%A8%9A%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB" target="_blank" rel="noopener">纯稚的数据类</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E9%9D%9E%E5%BF%85%E8%A6%81%E7%9A%84.md#%E5%A4%B8%E5%A4%B8%E5%85%B6%E8%B0%88%E6%9C%AA%E6%9D%A5%E6%80%A7" target="_blank" rel="noopener">夸夸其谈未来性</a></li>
</ul>
<h3 id="代码坏味道之耦合"><a class="markdownIt-Anchor" href="#代码坏味道之耦合"></a> 代码坏味道之耦合</h3>
<blockquote>
<p><strong><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E8%80%A6%E5%90%88.md" target="_blank" rel="noopener">耦合(Couplers)</a>这组坏味道意味着：不同类之间过度耦合。</strong></p>
</blockquote>
<ul>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E8%80%A6%E5%90%88.md#%E4%BE%9D%E6%81%8B%E6%83%85%E7%BB%93" target="_blank" rel="noopener">依恋情结</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E8%80%A6%E5%90%88.md#%E7%8B%8E%E6%98%B5%E5%85%B3%E7%B3%BB" target="_blank" rel="noopener">狎昵关系</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E8%80%A6%E5%90%88.md#%E8%BF%87%E5%BA%A6%E8%80%A6%E5%90%88%E7%9A%84%E6%B6%88%E6%81%AF%E9%93%BE" target="_blank" rel="noopener">过度耦合的消息链</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E8%80%A6%E5%90%88.md#%E4%B8%AD%E9%97%B4%E4%BA%BA" target="_blank" rel="noopener">中间人</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E8%80%A6%E5%90%88.md#%E4%B8%8D%E5%AE%8C%E7%BE%8E%E7%9A%84%E5%BA%93%E7%B1%BB" target="_blank" rel="noopener">不完美的库类</a></li>
</ul>
<h2 id="扩展阅读"><a class="markdownIt-Anchor" href="#扩展阅读"></a> 扩展阅读</h2>
<ul>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/" target="_blank" rel="noopener">代码的坏味道和重构</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%87%83%E8%82%BF.md" target="_blank" rel="noopener">代码坏味道之代码臃肿</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E6%BB%A5%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.md" target="_blank" rel="noopener">代码坏味道之滥用面向对象</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E5%8F%98%E9%9D%A9%E7%9A%84%E9%9A%9C%E7%A2%8D.md" target="_blank" rel="noopener">代码坏味道之变革的障碍</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E9%9D%9E%E5%BF%85%E8%A6%81%E7%9A%84.md" target="_blank" rel="noopener">代码坏味道之非必要的</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E8%80%A6%E5%90%88.md" target="_blank" rel="noopener">代码坏味道之耦合</a></li>
</ul>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><a href="https://book.douban.com/subject/4262627/" target="_blank" rel="noopener">重构——改善既有代码的设计</a> - by Martin Fowler</li>
<li><a href="https://sourcemaking.com/refactoring" target="_blank" rel="noopener">https://sourcemaking.com/refactoring</a></li>
</ul>
]]></content>
      <categories>
        <category>设计</category>
        <category>重构</category>
      </categories>
      <tags>
        <tag>设计</tag>
        <tag>重构</tag>
        <tag>代码坏味道</tag>
      </tags>
  </entry>
  <entry>
    <title>Sqoop</title>
    <url>/blog/bigdata/Sqoop/</url>
    <content><![CDATA[<h1 id="sqoop"><a class="markdownIt-Anchor" href="#sqoop"></a> Sqoop</h1>
<blockquote>
<p><strong>Sqoop 是一个主要在 Hadoop 和关系数据库之间进行批量数据迁移的工具。</strong></p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#sqoop-%E7%AE%80%E4%BB%8B">Sqoop 简介</a>
<ul>
<li><a href="#%E6%8F%90%E4%BE%9B%E5%A4%9A%E7%A7%8D-sqoop-%E8%BF%9E%E6%8E%A5%E5%99%A8">提供多种 Sqoop 连接器</a></li>
<li><a href="#sqoop-%E7%89%88%E6%9C%AC">Sqoop 版本</a></li>
</ul>
</li>
<li><a href="#sqoop-%E5%8E%9F%E7%90%86">Sqoop 原理</a>
<ul>
<li><a href="#%E5%AF%BC%E5%85%A5">导入</a></li>
<li><a href="#%E5%AF%BC%E5%87%BA">导出</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h2 id="sqoop-简介"><a class="markdownIt-Anchor" href="#sqoop-简介"></a> Sqoop 简介</h2>
<p><strong>Sqoop 是一个主要在 Hadoop 和关系数据库之间进行批量数据迁移的工具。</strong></p>
<ul>
<li>Hadoop：HDFS、Hive、HBase、Inceptor、Hyperbase</li>
<li>面向大数据集的批量导入导出</li>
<li>将输入数据集分为 N 个切片，然后启动 N 个 Map 任务并行传输</li>
<li>支持全量、增量两种传输方式</li>
</ul>
<h3 id="提供多种-sqoop-连接器"><a class="markdownIt-Anchor" href="#提供多种-sqoop-连接器"></a> 提供多种 Sqoop 连接器</h3>
<h4 id="内置连接器"><a class="markdownIt-Anchor" href="#内置连接器"></a> 内置连接器</h4>
<ul>
<li>经过优化的专用 RDBMS 连接器：MySQL、PostgreSQL、Oracle、DB2、SQL Server、Netzza 等</li>
<li>通用的 JDBC 连接器：支持 JDBC 协议的数据库</li>
</ul>
<h4 id="第三方连接器"><a class="markdownIt-Anchor" href="#第三方连接器"></a> 第三方连接器</h4>
<ul>
<li>数据仓库：Teradata</li>
<li>NoSQL 数据库：Couchbase</li>
</ul>
<h3 id="sqoop-版本"><a class="markdownIt-Anchor" href="#sqoop-版本"></a> Sqoop 版本</h3>
<h4 id="sqoop-1-优缺点"><a class="markdownIt-Anchor" href="#sqoop-1-优缺点"></a> Sqoop 1 优缺点</h4>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/bigdata/Sqoop/sqoop-architecture.png"/></div>
<p>优点</p>
<ul>
<li>架构简单</li>
<li>部署简单</li>
<li>功能全面</li>
<li>稳定性较高</li>
<li>速度较快</li>
</ul>
<p>缺点</p>
<ul>
<li>访问方式单一</li>
<li>命令行方式容易出错，格式紧耦合</li>
<li>安全机制不够完善，存在密码泄露风险</li>
</ul>
<h4 id="sqoop-2-优缺点"><a class="markdownIt-Anchor" href="#sqoop-2-优缺点"></a> Sqoop 2 优缺点</h4>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/bigdata/Sqoop/sqoop-v2-architecture.png"/></div>
<p>优点</p>
<ul>
<li>访问方式多样</li>
<li>集中管理连接器</li>
<li>安全机制较完善</li>
<li>支持多用户</li>
</ul>
<p>缺点</p>
<ul>
<li>架构较复杂</li>
<li>部署较繁琐</li>
<li>稳定性一般</li>
<li>速度一般</li>
</ul>
<h2 id="sqoop-原理"><a class="markdownIt-Anchor" href="#sqoop-原理"></a> Sqoop 原理</h2>
<h3 id="导入"><a class="markdownIt-Anchor" href="#导入"></a> 导入</h3>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/bigdata/Sqoop/sqoop-import.png"/></div>
<h3 id="导出"><a class="markdownIt-Anchor" href="#导出"></a> 导出</h3>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/bigdata/Sqoop/sqoop-export.png"/></div>
]]></content>
      <categories>
        <category>bigdata</category>
      </categories>
      <tags>
        <tag>bigdata</tag>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Flume</title>
    <url>/blog/bigdata/Flume/</url>
    <content><![CDATA[<h1 id="flume"><a class="markdownIt-Anchor" href="#flume"></a> Flume</h1>
<blockquote>
<p><strong>Sqoop 是一个主要在 Hadoop 和关系数据库之间进行批量数据迁移的工具。</strong></p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#flume-%E7%AE%80%E4%BB%8B">Flume 简介</a>
<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF-flume-">什么是 Flume ？</a></li>
<li><a href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">应用场景</a></li>
</ul>
</li>
<li><a href="#flume-%E5%8E%9F%E7%90%86">Flume 原理</a>
<ul>
<li><a href="#flume-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">Flume 基本概念</a></li>
<li><a href="#flume-%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6">Flume 基本组件</a></li>
<li><a href="#flume-%E6%95%B0%E6%8D%AE%E6%B5%81">Flume 数据流</a></li>
</ul>
</li>
<li><a href="#%E8%B5%84%E6%BA%90">资源</a></li>
</ul>
<!-- /TOC -->
<h2 id="flume-简介"><a class="markdownIt-Anchor" href="#flume-简介"></a> Flume 简介</h2>
<h3 id="什么是-flume"><a class="markdownIt-Anchor" href="#什么是-flume"></a> 什么是 Flume ？</h3>
<p>Flume 是一个分布式海量数据采集、聚合和传输系统。</p>
<p>特点</p>
<ul>
<li>基于事件的海量数据采集</li>
<li>数据流模型：Source -&gt; Channel -&gt; Sink</li>
<li>事务机制：支持重读重写，保证消息传递的可靠性</li>
<li>内置丰富插件：轻松与各种外部系统集成</li>
<li>高可用：Agent 主备切换</li>
<li>Java 实现：开源，优秀的系统设计</li>
</ul>
<h3 id="应用场景"><a class="markdownIt-Anchor" href="#应用场景"></a> 应用场景</h3>
<h2 id="flume-原理"><a class="markdownIt-Anchor" href="#flume-原理"></a> Flume 原理</h2>
<h3 id="flume-基本概念"><a class="markdownIt-Anchor" href="#flume-基本概念"></a> Flume 基本概念</h3>
<ul>
<li>Event：事件，最小数据传输单元，由 Header 和 Body 组成。</li>
<li>Agent：代理，JVM 进程，最小运行单元，由 Source、Channel、Sink 三个基本组件构成，负责将外部数据源产生的数据以 Event 的形式传输到目的地
<ul>
<li>Source：负责对接各种外部数据源，将采集到的数据封装成 Event，然后写入 Channel</li>
<li>Channel：Event 暂存容器，负责保存 Source 发送的 Event，直至被 Sink 成功读取</li>
<li>Sink：负责从 Channel 读取 Event，然后将其写入外部存储，或传输给下一阶段的 Agent</li>
<li>映射关系：1 个 Source -&gt; 多个 Channel，1 个 Channel -&gt; 多个 Sink，1 个 Sink -&gt; 1 个 Channel</li>
</ul>
</li>
</ul>
<h3 id="flume-基本组件"><a class="markdownIt-Anchor" href="#flume-基本组件"></a> Flume 基本组件</h3>
<h4 id="source-组件"><a class="markdownIt-Anchor" href="#source-组件"></a> Source 组件</h4>
<ul>
<li>对接各种外部数据源，将采集到的数据封装成 Event，然后写入 Channel</li>
<li>一个 Source 可向多个 Channel 发送 Event</li>
<li>Flume 内置类型丰富的 Source，同时用户可自定义 Source</li>
</ul>
<h4 id="channel-组件"><a class="markdownIt-Anchor" href="#channel-组件"></a> Channel 组件</h4>
<ul>
<li>Event 中转暂存区，存储 Source 采集但未被 Sink 读取的 Event</li>
<li>为了平衡 Source 采集、Sink 读取的速度，可视为 Flume 内部的消息队列</li>
<li>线程安全并具有事务性，支持 Source 写失败重写和 Sink 读失败重读</li>
</ul>
<h4 id="sink-组件"><a class="markdownIt-Anchor" href="#sink-组件"></a> Sink 组件</h4>
<ul>
<li>从 Channel 读取 Event，将其写入外部存储，或传输到下一阶段的 Agent</li>
<li>一个 Sink 只能从一个 Channel 中读取 Event</li>
<li>Sink 成功读取 Event 后，向 Channel 提交事务，Event 被删除，否则 Channel 会等待 Sink 重新读取</li>
</ul>
<h3 id="flume-数据流"><a class="markdownIt-Anchor" href="#flume-数据流"></a> Flume 数据流</h3>
<p>单层架构</p>
<p>优点：架构简单，使用方便，占用资源较少<br />
缺点<br />
如果采集的数据源或Agent较多，将Event写入到HDFS会产生很多小文件<br />
外部存储升级维护或发生故障，需对采集层的所有Agent做处理，人力成本较高，系统稳定性较差<br />
系统安全性较差<br />
数据源管理较混乱</p>
<h2 id="资源"><a class="markdownIt-Anchor" href="#资源"></a> 资源</h2>
]]></content>
      <categories>
        <category>bigdata</category>
      </categories>
      <tags>
        <tag>bigdata</tag>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>MapReduce</title>
    <url>/blog/bigdata/MapReduce/</url>
    <content><![CDATA[<h1 id="mapreduce"><a class="markdownIt-Anchor" href="#mapreduce"></a> MapReduce</h1>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#mapreduce-%E7%AE%80%E4%BB%8B">MapReduce 简介</a>
<ul>
<li><a href="#%E6%A6%82%E5%BF%B5">概念</a></li>
<li><a href="#%E6%80%9D%E6%83%B3">思想</a></li>
<li><a href="#%E7%89%B9%E7%82%B9">特点</a></li>
<li><a href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">适用场景</a></li>
<li><a href="#%E4%B8%8D%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">不适用场景</a></li>
</ul>
</li>
<li><a href="#mapreduce-%E5%8E%9F%E7%90%86">MapReduce 原理</a>
<ul>
<li><a href="#job--task%E4%BD%9C%E4%B8%9A%E4%B8%8E%E4%BB%BB%E5%8A%A1">Job &amp; Task（作业与任务）</a></li>
<li><a href="#split%E5%88%87%E7%89%87">Split（切片）</a></li>
<li><a href="#map-%E9%98%B6%E6%AE%B5%E6%98%A0%E5%B0%84">Map 阶段（映射）</a></li>
<li><a href="#reduce-%E9%98%B6%E6%AE%B5%E5%8C%96%E7%AE%80">Reduce 阶段（化简）</a></li>
<li><a href="#shuffle-%E9%98%B6%E6%AE%B5%E6%B4%97%E7%89%8C">Shuffle 阶段（洗牌）</a></li>
</ul>
</li>
<li><a href="#shuffle-%E8%AF%A6%E8%A7%A3">Shuffle 详解</a>
<ul>
<li><a href="#map-%E7%AB%AF">Map 端</a></li>
<li><a href="#reduce-%E7%AB%AF">Reduce 端</a></li>
</ul>
</li>
<li><a href="#%E4%BD%9C%E4%B8%9A%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F">作业运行模式</a>
<ul>
<li><a href="#jobtrackertasktracker-%E6%A8%A1%E5%BC%8Fhadoop-1x">JobTracker/TaskTracker 模式（Hadoop 1.X）</a></li>
<li><a href="#yarn-%E6%A8%A1%E5%BC%8Fhadoop-2x">YARN 模式（Hadoop 2.X）</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h2 id="mapreduce-简介"><a class="markdownIt-Anchor" href="#mapreduce-简介"></a> MapReduce 简介</h2>
<h3 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h3>
<p>MapReduce 是一个面向批处理的分布式计算框架。</p>
<p>编程模型：MapReduce 程序被分为 Map（映射）阶段和 Reduce（化简）阶段。</p>
<h3 id="思想"><a class="markdownIt-Anchor" href="#思想"></a> 思想</h3>
<p>分而治之，并行计算<br />
移动计算，而非移动数据</p>
<h3 id="特点"><a class="markdownIt-Anchor" href="#特点"></a> 特点</h3>
<ul>
<li>计算跟着数据走</li>
<li>良好的扩展性：计算能力随着节点数增加，近似线性递增</li>
<li>高容错</li>
<li>状态监控</li>
<li>适合海量数据的离线批处理</li>
<li>降低了分布式编程的门槛</li>
</ul>
<h3 id="适用场景"><a class="markdownIt-Anchor" href="#适用场景"></a> 适用场景</h3>
<ul>
<li>数据统计，如：网站的 PV、UV 统计</li>
<li>搜索引擎构建索引</li>
<li>海量数据查询</li>
</ul>
<h3 id="不适用场景"><a class="markdownIt-Anchor" href="#不适用场景"></a> 不适用场景</h3>
<ul>
<li>OLAP
<ul>
<li>要求毫秒或秒级返回结果</li>
</ul>
</li>
<li>流计算
<ul>
<li>流计算的输入数据集是动态的，而 MapReduce 是静态的</li>
</ul>
</li>
<li>DAG 计算
<ul>
<li>多个作业存在依赖关系，后一个的输入是前一个的输出，构成有向无环图 DAG</li>
<li>每个 MapReduce 作业的输出结果都会落盘，造成大量磁盘 IO，导致性能非常低下</li>
</ul>
</li>
</ul>
<h2 id="mapreduce-原理"><a class="markdownIt-Anchor" href="#mapreduce-原理"></a> MapReduce 原理</h2>
<h3 id="job-task作业与任务"><a class="markdownIt-Anchor" href="#job-task作业与任务"></a> Job &amp; Task（作业与任务）</h3>
<ul>
<li>作业是客户端请求执行的一个工作单元
<ul>
<li>包括输入数据、MapReduce 程序、配置信息</li>
</ul>
</li>
<li>任务是将作业分解后得到的细分工作单元
<ul>
<li>分为 Map 任务和 Reduce 任务</li>
</ul>
</li>
</ul>
<h3 id="split切片"><a class="markdownIt-Anchor" href="#split切片"></a> Split（切片）</h3>
<ul>
<li>输入数据被划分成等长的小数据块，称为输入切片（Input Split），简称切片</li>
<li>Split 是逻辑概念，仅包含元数据信息，如：数据的起始位置、长度、所在节点等</li>
<li>每个 Split 交给一个 Map 任务处理，Split 的数量决定 Map 任务的数量</li>
<li>Split 的划分方式由程序设定，Split 与 HDFS Block 没有严格的对应关系</li>
<li>Split 的大小默认等于 Block 大小</li>
<li>Split 越小，负载越均衡，但集群的开销越大</li>
</ul>
<h3 id="map-阶段映射"><a class="markdownIt-Anchor" href="#map-阶段映射"></a> Map 阶段（映射）</h3>
<ul>
<li>由若干 Map 任务组成，任务数量由 Split 数量决定</li>
<li>输入：Split 切片（key-value），输出：中间计算结果（key-value）</li>
</ul>
<h3 id="reduce-阶段化简"><a class="markdownIt-Anchor" href="#reduce-阶段化简"></a> Reduce 阶段（化简）</h3>
<ul>
<li>由若干 Reduce 任务组成，任务数量由程序指定</li>
<li>输入：Map 阶段输出的中间结果（key-value），输出：最终结果（key-value）</li>
</ul>
<h3 id="shuffle-阶段洗牌"><a class="markdownIt-Anchor" href="#shuffle-阶段洗牌"></a> Shuffle 阶段（洗牌）</h3>
<ul>
<li>Map、Reduce 阶段的中间环节，负责执行 Partition（分区）、Sort（排序）、Spill（溢写）、Merge（合并）、抓取（Fetch）等工作</li>
<li>Partition 决定了 Map 任务输出的每条数据放入哪个分区，交给哪个 Reduce 任务处理</li>
<li>Reduce 任务的数量决定了 Partition 数量</li>
<li>Partition 编号 = Reduce 任务编号 =“key hashcode % reduce task number”</li>
<li>避免和减少 Shuffle 是 MapReduce 程序调优的重点</li>
</ul>
<h2 id="shuffle-详解"><a class="markdownIt-Anchor" href="#shuffle-详解"></a> Shuffle 详解</h2>
<h3 id="map-端"><a class="markdownIt-Anchor" href="#map-端"></a> Map 端</h3>
<p>Map 任务将中间结果写入专用内存缓冲区 Buffer（默认 100M），同时进行 Partition 和 Sort（先按“key hashcode % reduce task number”对数据进行分区，分区内再按 key 排序）<br />
当 Buffer 的数据量达到阈值（默认 80%）时，将数据溢写（Spill）到磁盘的一个临时文件中，文件内数据先分区后排序<br />
Map 任务结束前，将多个临时文件合并（Merge）为一个 Map 输出文件，文件内数据先分区后排序</p>
<h3 id="reduce-端"><a class="markdownIt-Anchor" href="#reduce-端"></a> Reduce 端</h3>
<p>Reduce 任务从多个 Map 输出文件中主动抓取（Fetch）属于自己的分区数据，先写入 Buffer，数据量达到阈值后，溢写到磁盘的一个临时文件中<br />
数据抓取完成后，将多个临时文件合并为一个 Reduce 输入文件，文件内数据按 key 排序</p>
<h2 id="作业运行模式"><a class="markdownIt-Anchor" href="#作业运行模式"></a> 作业运行模式</h2>
<h3 id="jobtrackertasktracker-模式hadoop-1x"><a class="markdownIt-Anchor" href="#jobtrackertasktracker-模式hadoop-1x"></a> JobTracker/TaskTracker 模式（Hadoop 1.X）</h3>
<p><strong>JobTracker 节点（Master）</strong></p>
<ul>
<li>调度任务在 TaskTracker 上运行</li>
<li>若任务失败，指定新 TaskTracker 重新运行</li>
</ul>
<p><strong>TaskTracker 节点（Slave）</strong></p>
<ul>
<li>执行任务，发送进度报告</li>
</ul>
<p><strong>存在的问题</strong></p>
<ul>
<li>JobTracker 存在单点故障</li>
<li>JobTracker 负载太重（上限 4000 节点）</li>
<li>JobTracker 缺少对资源的全面管理</li>
<li>TaskTracker 对资源的描述过于简单</li>
<li>源码很难理解</li>
</ul>
<h3 id="yarn-模式hadoop-2x"><a class="markdownIt-Anchor" href="#yarn-模式hadoop-2x"></a> YARN 模式（Hadoop 2.X）</h3>
<ul>
<li>提交作业</li>
<li>查看作业</li>
<li>终止作业</li>
</ul>
]]></content>
      <categories>
        <category>bigdata</category>
      </categories>
      <tags>
        <tag>bigdata</tag>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据简介</title>
    <url>/blog/bigdata/overview/</url>
    <content><![CDATA[<h1 id="大数据简介"><a class="markdownIt-Anchor" href="#大数据简介"></a> 大数据简介</h1>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#%E7%AE%80%E4%BB%8B">简介</a>
<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%A7%E6%95%B0%E6%8D%AE">什么是大数据</a></li>
<li><a href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">应用场景</a></li>
<li><a href="#hadoop-%E7%BC%96%E5%B9%B4%E5%8F%B2">Hadoop 编年史</a></li>
</ul>
</li>
<li><a href="#%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB">技术体系</a>
<ul>
<li><a href="#hdfs">HDFS</a></li>
<li><a href="#mapreduce">MapReduce</a></li>
<li><a href="#spark">Spark</a></li>
<li><a href="#yarn">YARN</a></li>
<li><a href="#hive">Hive</a></li>
<li><a href="#hbase">HBase</a></li>
<li><a href="#elasticsearch">ElasticSearch</a></li>
</ul>
</li>
<li><a href="#%E6%9C%AF%E8%AF%AD">术语</a></li>
<li><a href="#%E8%B5%84%E6%BA%90">资源</a></li>
</ul>
<!-- /TOC -->
<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<h3 id="什么是大数据"><a class="markdownIt-Anchor" href="#什么是大数据"></a> 什么是大数据</h3>
<p>大数据是指超出传统数据库工具收集、存储、管理和分析能力的数据集。与此同时，及时采集、存储、聚合、管理数据，以及对数据深度分析的新技术和新能力，正在快速增长，就像预测计算芯片增长速度的摩尔定律一样。</p>
<ul>
<li><strong>Volume</strong> - 数据规模巨大</li>
<li><strong>Velocity</strong> - 生成和处理速度极快</li>
<li><strong>Variety</strong> - 数据规模巨大</li>
<li><strong>Value</strong> - 生成和处理速度极快</li>
</ul>
<h3 id="应用场景"><a class="markdownIt-Anchor" href="#应用场景"></a> 应用场景</h3>
<p>基于大数据的数据仓库</p>
<p>基于大数据的实时流处理</p>
<h3 id="hadoop-编年史"><a class="markdownIt-Anchor" href="#hadoop-编年史"></a> Hadoop 编年史</h3>
<table>
<thead>
<tr>
<th style="text-align:left">时间</th>
<th style="text-align:left">事件</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">2003.01</td>
<td style="text-align:left">Google发表了Google File System论文</td>
</tr>
<tr>
<td style="text-align:left">2004.01</td>
<td style="text-align:left">Google发表了MapReduce论文</td>
</tr>
<tr>
<td style="text-align:left">2006.02</td>
<td style="text-align:left">Apache Hadoop项目正式启动，并支持MapReduce和HDFS独立发展</td>
</tr>
<tr>
<td style="text-align:left">2006.11</td>
<td style="text-align:left">Google发表了Bigtable论文</td>
</tr>
<tr>
<td style="text-align:left">2008.01</td>
<td style="text-align:left">Hadoop成为Apache顶级项目</td>
</tr>
<tr>
<td style="text-align:left">2009.03</td>
<td style="text-align:left">Cloudera推出世界上首个Hadoop发行版——CDH，并完全开放源码</td>
</tr>
<tr>
<td style="text-align:left">2012.03</td>
<td style="text-align:left">HDFS NameNode HA加入Hadoop主版本</td>
</tr>
<tr>
<td style="text-align:left">2014.02</td>
<td style="text-align:left">Spark代替MapReduce成为Hadoop的缺省计算引擎，并成为Apache顶级项目</td>
</tr>
</tbody>
</table>
<h2 id="技术体系"><a class="markdownIt-Anchor" href="#技术体系"></a> 技术体系</h2>
<h3 id="hdfs"><a class="markdownIt-Anchor" href="#hdfs"></a> HDFS</h3>
<p><strong>概念</strong></p>
<ul>
<li>Hadoop 分布式文件系统（Hadoop Distributed File System）</li>
<li>在开源大数据技术体系中，地位无可替代</li>
</ul>
<p><strong>特点</strong></p>
<ul>
<li>高容错：数据多副本，副本丢失后自动恢复</li>
<li>高可用：NameNode HA，安全模式</li>
<li>高扩展：10K 节点规模</li>
<li>简单一致性模型：一次写入多次读取，支持追加，不允许修改</li>
<li>流式数据访问：批量读而非随机读，关注吞吐量而非时间</li>
<li>大规模数据集：典型文件大小 GB~TB 级，百万以上文件数量， PB 以上数据规模</li>
<li>构建成本低且安全可靠：运行在大量的廉价商用机器上，硬件错误是常态，提供容错机制</li>
</ul>
<h3 id="mapreduce"><a class="markdownIt-Anchor" href="#mapreduce"></a> MapReduce</h3>
<p><strong>概念</strong></p>
<ul>
<li>面向批处理的分布式计算框架</li>
<li>编程模型：将 MapReduce 程序分为 Map、Reduce 两个阶段</li>
</ul>
<p><strong>核心思想</strong></p>
<ul>
<li>分而治之，分布式计算</li>
<li>移动计算，而非移动数据</li>
</ul>
<p><strong>特点</strong></p>
<ul>
<li>高容错：任务失败，自动调度到其他节点重新执行</li>
<li>高扩展：计算能力随着节点数增加，近似线性递增</li>
<li>适用于海量数据的离线批处理</li>
<li>降低了分布式编程的门槛</li>
</ul>
<h3 id="spark"><a class="markdownIt-Anchor" href="#spark"></a> Spark</h3>
<p>高性能分布式通用计算引擎</p>
<ul>
<li>Spark Core - 基础计算框架（批处理、交互式分析）</li>
<li>Spark SQL - SQL 引擎（海量结构化数据的高性能查询）</li>
<li>Spark Streaming - 实时流处理（微批）</li>
<li>Spark MLlib - 机器学习</li>
<li>Spark GraphX - 图计算</li>
</ul>
<p>采用 Scala 语言开发</p>
<p><strong>特点</strong></p>
<ul>
<li>计算高效 - 内存计算、Cache 缓存机制、DAG 引擎、多线程池模型</li>
<li>通用易用 - 适用于批处理、交互式计算、流处理、机器学习、图计算等多种场景</li>
<li>运行模式多样 - Local、Standalone、YARN/Mesos</li>
</ul>
<h3 id="yarn"><a class="markdownIt-Anchor" href="#yarn"></a> YARN</h3>
<p><strong>概念</strong></p>
<ul>
<li>Yet Another Resource Negotiator，另一种资源管理器</li>
<li>为了解决 Hadoop 1.x 中 MapReduce 的先天缺陷</li>
<li>分布式通用资源管理系统</li>
<li>负责集群资源的统一管理</li>
<li>从 Hadoop 2.x 开始，YARN 成为 Hadoop 的核心组件</li>
</ul>
<p><strong>特点</strong></p>
<ul>
<li>专注于资源管理和作业调度</li>
<li>通用 - 适用各种计算框架，如 - MapReduce、Spark</li>
<li>高可用 - ResourceManager 高可用、HDFS 高可用</li>
<li>高扩展</li>
</ul>
<h3 id="hive"><a class="markdownIt-Anchor" href="#hive"></a> Hive</h3>
<p><strong>概念</strong></p>
<ul>
<li>Hadoop 数据仓库 - 企业决策支持</li>
<li>SQL 引擎 - 对海量结构化数据进行高性能的 SQL 查询</li>
<li>采用 HDFS 或 HBase 为数据存储</li>
<li>采用 MapReduce 或 Spark 为计算框架</li>
</ul>
<p><strong>特点</strong></p>
<ul>
<li>提供类 SQL 查询语言</li>
<li>支持命令行或 JDBC/ODBC</li>
<li>提供灵活的扩展性</li>
<li>提供复杂数据类型、扩展函数、脚本等</li>
</ul>
<h3 id="hbase"><a class="markdownIt-Anchor" href="#hbase"></a> HBase</h3>
<p><strong>概念</strong></p>
<ul>
<li>Hadoop Database</li>
<li>Google BigTable 的开源实现</li>
<li>分布式 NoSQL 数据库</li>
<li>列式存储 - 主要用于半结构化、非结构化数据</li>
<li>采用 HDFS 为文件存储系统</li>
</ul>
<p><strong>特点</strong></p>
<ul>
<li>高性能 - 支持高并发写入和查询</li>
<li>高可用 - HDFS 高可用、Region 高可用</li>
<li>高扩展 - 数据自动切分和分布，可动态扩容，无需停机</li>
<li>海量存储 - 单表可容纳数十亿行，上百万列</li>
</ul>
<h3 id="elasticsearch"><a class="markdownIt-Anchor" href="#elasticsearch"></a> ElasticSearch</h3>
<ul>
<li>开源的分布式全文检索引擎</li>
<li>基于 Lucene 实现全文数据的快速存储、搜索和分析</li>
<li>处理大规模数据 - PB 级以上</li>
<li>具有较强的扩展性，集群规模可达上百台</li>
<li>首选的分布式搜索引擎</li>
</ul>
<h2 id="术语"><a class="markdownIt-Anchor" href="#术语"></a> 术语</h2>
<p><strong>数据仓库（Data Warehouse）</strong> - 数据仓库，是为企业所有级别的决策制定过程，提供所有类型数据支持的战略集合。它是单个数据存储，出于分析性报告和决策支持目的而创建。 为需要业务智能的企业，提供指导业务流程改进、监视时间、成本、质量以及控制。</p>
<h2 id="资源"><a class="markdownIt-Anchor" href="#资源"></a> 资源</h2>
<ul>
<li><a href="https://github.com/onurakpolat/awesome-bigdata" target="_blank" rel="noopener">awesome-bigdata</a></li>
<li><a href="http://hadoop.apache.org/" target="_blank" rel="noopener">Hadoop</a></li>
<li><a href="http://hbase.apache.org/" target="_blank" rel="noopener">HBase</a></li>
<li><a href="http://hive.apache.org/" target="_blank" rel="noopener">Hive</a></li>
<li><a href="http://impala.apache.org/" target="_blank" rel="noopener">Impala</a></li>
<li><a href="http://flume.apache.org/" target="_blank" rel="noopener">Flume</a></li>
<li><a href="http://kafka.apache.org/" target="_blank" rel="noopener">Kafka</a></li>
<li><a href="http://spark.apache.org/" target="_blank" rel="noopener">Spark</a></li>
<li><a href="http://sqoop.apache.org/" target="_blank" rel="noopener">Sqoop</a></li>
<li><a href="https://www.elastic.co/guide/index.html" target="_blank" rel="noopener">ElasticSearch</a></li>
</ul>
]]></content>
      <categories>
        <category>bigdata</category>
      </categories>
      <tags>
        <tag>bigdata</tag>
      </tags>
  </entry>
  <entry>
    <title>YARN</title>
    <url>/blog/bigdata/YARN/</url>
    <content><![CDATA[<h1 id="yarn"><a class="markdownIt-Anchor" href="#yarn"></a> YARN</h1>
<blockquote>
<p>YARN 的目标是解决 MapReduce 的缺陷。</p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#mapreduce-%E7%9A%84%E7%BC%BA%E9%99%B7hadoop-1x">MapReduce 的缺陷（Hadoop 1.x）</a></li>
<li><a href="#yarn-%E7%AE%80%E4%BB%8B">YARN 简介</a></li>
<li><a href="#yarn-%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84">YARN 系统架构</a>
<ul>
<li><a href="#resourcemanagerrm">ResourceManager（RM）</a></li>
<li><a href="#nodemanagernm">NodeManager（NM）</a></li>
<li><a href="#applicationmasteram">ApplicationMaster（AM）</a></li>
<li><a href="#container">Container</a></li>
</ul>
</li>
<li><a href="#yarn-%E9%AB%98%E5%8F%AF%E7%94%A8">YARN 高可用</a></li>
<li><a href="#yarn-%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5">YARN 资源调度策略</a>
<ul>
<li><a href="#fifo-scheduler%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E8%B0%83%E5%BA%A6%E5%99%A8">FIFO Scheduler（先进先出调度器）</a></li>
<li><a href="#capacity-scheduler%E5%AE%B9%E9%87%8F%E8%B0%83%E5%BA%A6%E5%99%A8">Capacity Scheduler（容量调度器）</a></li>
<li><a href="#fair-scheduler%E5%85%AC%E5%B9%B3%E8%B0%83%E5%BA%A6%E5%99%A8">Fair Scheduler（公平调度器）</a></li>
</ul>
</li>
<li><a href="#%E8%B5%84%E6%BA%90">资源</a></li>
</ul>
<!-- /TOC -->
<h2 id="mapreduce-的缺陷hadoop-1x"><a class="markdownIt-Anchor" href="#mapreduce-的缺陷hadoop-1x"></a> MapReduce 的缺陷（Hadoop 1.x）</h2>
<ul>
<li>身兼两职：计算框架 + 资源管理框架</li>
<li>JobTracker
<ul>
<li>既做资源管理，又做任务调度</li>
<li>任务太重，开销过大</li>
<li>存在单点故障</li>
</ul>
</li>
<li>资源描述模型过于简单，资源利用率较低
<ul>
<li>仅把 Task 数量看作资源，没有考虑 CPU 和内存</li>
<li>强制把资源分成 Map Task Slot 和 Reduce Task Slot</li>
</ul>
</li>
<li>扩展性较差，集群规模上限 4K</li>
<li>源码难于理解，升级维护困难</li>
</ul>
<h2 id="yarn-简介"><a class="markdownIt-Anchor" href="#yarn-简介"></a> YARN 简介</h2>
<p>YARN(Yet Another Resource Negotiator，另一种资源管理器)是一个<strong>分布式通用资源管理系统</strong>。</p>
<p>设计目标：聚焦资源管理、通用（适用各种计算框架）、高可用、高扩展。</p>
<h2 id="yarn-系统架构"><a class="markdownIt-Anchor" href="#yarn-系统架构"></a> YARN 系统架构</h2>
<ul>
<li>主从结构（master/slave）</li>
<li>将 JobTracker 的资源管理、任务调度功能分离</li>
<li>三种角色：
<ul>
<li>ResourceManager（Master） - 集群资源的统一管理和分配</li>
<li>NodeManager（Slave） - 管理节点资源，以及容器的生命周期</li>
<li>ApplicationMaster（新角色） - 管理应用程序实例，包括任务调度和资源申请</li>
</ul>
</li>
</ul>
<h3 id="resourcemanagerrm"><a class="markdownIt-Anchor" href="#resourcemanagerrm"></a> ResourceManager（RM）</h3>
<p><strong>主要功能</strong></p>
<ul>
<li>统一管理集群的所有资源</li>
<li>将资源按照一定策略分配给各个应用（ApplicationMaster）</li>
<li>接收 NodeManager 的资源上报信息</li>
</ul>
<p><strong>核心组件</strong></p>
<ul>
<li>用户交互服务（User Service）</li>
<li>NodeManager 管理</li>
<li>ApplicationMaster 管理</li>
<li>Application 管理</li>
<li>安全管理</li>
<li>资源管理</li>
</ul>
<h3 id="nodemanagernm"><a class="markdownIt-Anchor" href="#nodemanagernm"></a> NodeManager（NM）</h3>
<p><strong>主要功能</strong></p>
<ul>
<li>管理单个节点的资源</li>
<li>向 ResourceManager 汇报节点资源使用情况</li>
<li>管理 Container 的生命周期</li>
</ul>
<p><strong>核心组件</strong></p>
<ul>
<li>NodeStatusUpdater</li>
<li>ContainerManager</li>
<li>ContainerExecutor</li>
<li>NodeHealthCheckerService</li>
<li>Security</li>
<li>WebServer</li>
</ul>
<h3 id="applicationmasteram"><a class="markdownIt-Anchor" href="#applicationmasteram"></a> ApplicationMaster（AM）</h3>
<p><strong>主要功能</strong></p>
<ul>
<li>管理应用程序实例</li>
<li>向 ResourceManager 申请任务执行所需的资源</li>
<li>任务调度和监管</li>
</ul>
<p><strong>实现方式</strong></p>
<ul>
<li>需要为每个应用开发一个 AM 组件</li>
<li>YARN 提供 MapReduce 的 ApplicationMaster 实现</li>
<li>采用基于事件驱动的异步编程模型，由中央事件调度器统一管理所有事件</li>
<li>每种组件都是一种事件处理器，在中央事件调度器中注册</li>
</ul>
<h3 id="container"><a class="markdownIt-Anchor" href="#container"></a> Container</h3>
<ul>
<li>概念：Container 封装了节点上进程的相关资源，是 YARN 中资源的抽象</li>
<li>分类：运行 ApplicationMaster 的 Container 、运行应用任务的 Container</li>
</ul>
<h2 id="yarn-高可用"><a class="markdownIt-Anchor" href="#yarn-高可用"></a> YARN 高可用</h2>
<p>ResourceManager 高可用</p>
<ul>
<li>1 个 Active RM、多个 Standby RM</li>
<li>宕机后自动实现主备切换</li>
<li>ZooKeeper 的核心作用
<ul>
<li>Active 节点选举</li>
<li>恢复 Active RM 的原有状态信息</li>
</ul>
</li>
<li>重启 AM，杀死所有运行中的 Container</li>
<li>切换方式：手动、自动</li>
</ul>
<h2 id="yarn-资源调度策略"><a class="markdownIt-Anchor" href="#yarn-资源调度策略"></a> YARN 资源调度策略</h2>
<h3 id="fifo-scheduler先进先出调度器"><a class="markdownIt-Anchor" href="#fifo-scheduler先进先出调度器"></a> FIFO Scheduler（先进先出调度器）</h3>
<p><strong>调度策略</strong></p>
<p>将所有任务放入一个队列，先进队列的先获得资源，排在后面的任务只有等待</p>
<p><strong>缺点</strong></p>
<ul>
<li>资源利用率低，无法交叉运行任务</li>
<li>灵活性差，如：紧急任务无法插队，耗时长的任务拖慢耗时短的任务</li>
</ul>
<h3 id="capacity-scheduler容量调度器"><a class="markdownIt-Anchor" href="#capacity-scheduler容量调度器"></a> Capacity Scheduler（容量调度器）</h3>
<p><strong>核心思想</strong> - 提前<strong>做预算</strong>，在预算指导下分享集群资源。</p>
<p><strong>调度策略</strong></p>
<ul>
<li>集群资源由多个队列分享</li>
<li>每个队列都要预设资源分配的比例（提前做预算）</li>
<li>空闲资源优先分配给“实际资源/预算资源”比值最低的队列</li>
<li>队列内部采用 FIFO 调度策略</li>
</ul>
<p><strong>特点</strong></p>
<ul>
<li>层次化的队列设计：子队列可使用父队列资源</li>
<li>容量保证：每个队列都要预设资源占比，防止资源独占</li>
<li>弹性分配：空闲资源可以分配给任何队列，当多个队列争用时，会按比例进行平衡</li>
<li>支持动态管理：可以动态调整队列的容量、权限等参数，也可动态增加、暂停队列</li>
<li>访问控制：用户只能向自己的队列中提交任务，不能访问其他队列</li>
<li>多租户：多用户共享集群资源</li>
</ul>
<h3 id="fair-scheduler公平调度器"><a class="markdownIt-Anchor" href="#fair-scheduler公平调度器"></a> Fair Scheduler（公平调度器）</h3>
<p><strong>调度策略</strong></p>
<ul>
<li>多队列公平共享集群资源</li>
<li>通过平分的方式，动态分配资源，无需预先设定资源分配比例</li>
<li>队列内部可配置调度策略：FIFO、Fair（默认）</li>
</ul>
<p><strong>资源抢占</strong></p>
<ul>
<li>终止其他队列的任务，使其让出所占资源，然后将资源分配给占用资源量少于最小资源量限制的队列</li>
</ul>
<p><strong>队列权重</strong></p>
<ul>
<li>当队列中有任务等待，并且集群中有空闲资源时，每个队列可以根据权重获得不同比例的空闲资源</li>
</ul>
<h2 id="资源"><a class="markdownIt-Anchor" href="#资源"></a> 资源</h2>
]]></content>
      <categories>
        <category>bigdata</category>
      </categories>
      <tags>
        <tag>bigdata</tag>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>HDFS</title>
    <url>/blog/bigdata/HDFS/</url>
    <content><![CDATA[<h1 id="hdfs"><a class="markdownIt-Anchor" href="#hdfs"></a> HDFS</h1>
<blockquote>
<p><strong>HDFS 是 Hadoop 分布式文件系统。</strong></p>
<p>关键词：分布式、文件系统</p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#%E6%A6%82%E8%BF%B0">概述</a>
<ul>
<li><a href="#hdfs-%E7%9A%84%E7%89%B9%E7%82%B9">HDFS 的特点</a></li>
</ul>
</li>
<li><a href="#hdfs-%E7%9A%84%E6%A6%82%E5%BF%B5">HDFS 的概念</a>
<ul>
<li><a href="#namenode">NameNode</a></li>
<li><a href="#datanode">DataNode</a></li>
<li><a href="#block-%E6%95%B0%E6%8D%AE%E5%9D%97">Block 数据块</a></li>
<li><a href="#client">Client</a></li>
</ul>
</li>
<li><a href="#block-%E5%89%AF%E6%9C%AC%E7%AD%96%E7%95%A5">Block 副本策略</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E6%B5%81">数据流</a>
<ul>
<li><a href="#hdfs-%E8%AF%BB%E6%96%87%E4%BB%B6">HDFS 读文件</a></li>
<li><a href="#hdfs-%E5%86%99%E6%96%87%E4%BB%B6">HDFS 写文件</a></li>
</ul>
</li>
<li><a href="#hdfs-%E5%AE%89%E5%85%A8%E6%A8%A1%E5%BC%8F">HDFS 安全模式</a>
<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%89%E5%85%A8%E6%A8%A1%E5%BC%8F">什么是安全模式？</a></li>
<li><a href="#%E4%BD%95%E6%97%B6%E6%AD%A3%E5%B8%B8%E7%A6%BB%E5%BC%80%E5%AE%89%E5%85%A8%E6%A8%A1%E5%BC%8F">何时正常离开安全模式</a></li>
<li><a href="#%E8%A7%A6%E5%8F%91%E5%AE%89%E5%85%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E5%9B%A0">触发安全模式的原因</a></li>
<li><a href="#%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5">故障排查</a></li>
</ul>
</li>
<li><a href="#hdfs-%E9%AB%98%E5%8F%AF%E7%94%A8">HDFS 高可用</a>
<ul>
<li><a href="#namenode-%E7%9A%84-ha-%E6%9C%BA%E5%88%B6">NameNode 的 HA 机制</a></li>
<li><a href="#%E5%88%A9%E7%94%A8-qjm-%E5%AE%9E%E7%8E%B0%E5%85%83%E6%95%B0%E6%8D%AE%E9%AB%98%E5%8F%AF%E7%94%A8">利用 QJM 实现元数据高可用</a></li>
</ul>
</li>
<li><a href="#%E8%B5%84%E6%BA%90">资源</a></li>
</ul>
<!-- /TOC -->
<h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2>
<blockquote>
<p>HDFS 是 Hadoop 的核心子项目。</p>
<p><strong>HDFS</strong> 是 <strong>Hadoop Distributed File System</strong> 的缩写，即 Hadoop 分布式文件系统。</p>
<p>HDFS 是一种用于存储具有流数据访问模式的超大文件的文件系统，它运行在廉价的机器集群上。</p>
</blockquote>
<h3 id="hdfs-的特点"><a class="markdownIt-Anchor" href="#hdfs-的特点"></a> HDFS 的特点</h3>
<p><strong>优点</strong></p>
<ul>
<li><strong>高容错</strong> - 数据冗余多副本，副本丢失后自动恢复</li>
<li><strong>高可用</strong> - NameNode HA、安全模式</li>
<li><strong>高扩展</strong> - 能够处理 10K 节点的规模；处理数据达到 GB、TB、甚至 PB 级别的数据；能够处理百万规模以上的文件数量，数量相当之大。</li>
<li><strong>批处理</strong> - 流式数据访问；数据位置暴露给计算框架</li>
<li><strong>构建在廉价商用机器上</strong> - 提供了容错和恢复机制</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li><strong>不适合低延迟数据访问</strong> - 适合高吞吐率的场景，就是在某一时间内写入大量的数据。但是它在低延时的情况下是不行的，比如毫秒级以内读取数据，它是很难做到的。</li>
<li><strong>不适合大量小文件存储</strong>
<ul>
<li>存储大量小文件(这里的小文件是指小于 HDFS 系统的 Block 大小的文件（默认 64M）)的话，它会占用 NameNode 大量的内存来存储文件、目录和块信息。这样是不可取的，因为 NameNode 的内存总是有限的。</li>
<li>磁盘寻道时间超过读取时间</li>
</ul>
</li>
<li><strong>不支持并发写入</strong> - 一个文件同时只能有一个写入者</li>
<li><strong>不支持文件随机修改</strong> - 仅支持追加写入</li>
</ul>
<h2 id="hdfs-的概念"><a class="markdownIt-Anchor" href="#hdfs-的概念"></a> HDFS 的概念</h2>
<p>HDFS 采用 Master/Slave 架构。</p>
<p>一个 HDFS 集群是由一个 Namenode 和一定数目的 Datanodes 组成。Namenode 是一个中心服务器，负责管理文件系统的名字空间(namespace)以及客户端对文件的访问。集群中的 Datanode 一般是一个节点一个，负责管理它所在节点上的存储。HDFS 暴露了文件系统的名字空间，用户能够以文件的形式在上面存储数据。从内部看，一个文件其实被分成一个或多个数据块，这些块存储在一组 Datanode 上。Namenode 执行文件系统的名字空间操作，比如打开、关闭、重命名文件或目录。它也负责确定数据块到具体 Datanode 节点的映射。Datanode 负责处理文件系统客户端的读写请求。在 Namenode 的统一调度下进行数据块的创建、删除和复制。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/bigdata/hdfs/hdfs-architecture.png"/></div>
<h3 id="namenode"><a class="markdownIt-Anchor" href="#namenode"></a> NameNode</h3>
<p><strong>NameNode 就是 master 工作节点。</strong></p>
<ul>
<li>管理命名空间</li>
<li>管理元数据：文件的位置、所有者、权限、数据块等</li>
<li>管理 Block 副本策略：默认 3 个副本</li>
<li>处理客户端读写请求，为 DataNode 分配任务</li>
</ul>
<h4 id="active-namenode-和-standby-namenode"><a class="markdownIt-Anchor" href="#active-namenode-和-standby-namenode"></a> Active NameNode 和 Standby NameNode</h4>
<p>NameNode 通过 HA 机制来容错。</p>
<ul>
<li><strong>Active NameNode</strong> - 是正在工作的 NameNode；</li>
<li><strong>Standby NameNode</strong> - 是备份的 NameNode。</li>
</ul>
<p>Active NameNode 宕机后，Standby NameNode 快速升级为新的 Active NameNode。</p>
<p>Standby NameNode 周期性同步 edits 编辑日志，定期合并 fsimage 与 edits 到本地磁盘。</p>
<p>Hadoop 3.0 允许配置多个 Standby NameNode。</p>
<h4 id="元数据文件"><a class="markdownIt-Anchor" href="#元数据文件"></a> 元数据文件</h4>
<ul>
<li><strong>edits（编辑日志文件）</strong> - 保存了自最新检查点（Checkpoint）之后的所有文件更新操作。</li>
<li><strong>fsimage（元数据检查点镜像文件）</strong> - 保存了文件系统中所有的目录和文件信息，如：某个目录下有哪些子目录和文件，以及文件名、文件副本数、文件由哪些 Block 组成等。</li>
</ul>
<p>Active NameNode 内存中有一份最新的元数据（= fsimage + edits）。</p>
<p>Standby NameNode 在检查点定期将内存中的元数据保存到 fsimage 文件中。</p>
<h3 id="datanode"><a class="markdownIt-Anchor" href="#datanode"></a> DataNode</h3>
<p>**DataNode 就是 slave 工作节点。**NameNode 下达命令，DataNode 执行实际的操作。</p>
<ul>
<li>存储 Block 和数据校验和</li>
<li>执行客户端发送的读写操作</li>
<li>通过心跳机制定期（默认 3 秒）向 NameNode 汇报运行状态和 Block 列表信息</li>
<li>集群启动时，DataNode 向 NameNode 提供 Block 列表信息</li>
</ul>
<h3 id="block-数据块"><a class="markdownIt-Anchor" href="#block-数据块"></a> Block 数据块</h3>
<ul>
<li>HDFS 最小存储单元</li>
<li>文件写入 HDFS 会被切分成若干个 Block</li>
<li>Block 大小固定，默认为 128MB，可自定义</li>
<li>若一个 Block 的大小小于设定值，不会占用整个块空间</li>
<li>默认情况下每个 Block 有 3 个副本</li>
</ul>
<h3 id="client"><a class="markdownIt-Anchor" href="#client"></a> Client</h3>
<ul>
<li>将文件切分为 Block 数据块</li>
<li>与 NameNode 交互，获取文件元数据</li>
<li>与 DataNode 交互，读取或写入数据</li>
<li>管理 HDFS</li>
</ul>
<h2 id="block-副本策略"><a class="markdownIt-Anchor" href="#block-副本策略"></a> Block 副本策略</h2>
<p>HDFS 被设计成能够在一个大集群中跨机器可靠地存储超大文件。它将每个文件存储成一系列的数据块，除了最后一个，所有的数据块都是同样大小的。为了容错，文件的所有数据块都会有副本。每个文件的数据块大小和副本系数都是可配置的。应用程序可以指定某个文件的副本数目。副本系数可以在文件创建的时候指定，也可以在之后改变。HDFS 中的文件都是一次性写入的，并且严格要求在任何时候只能有一个写入者。</p>
<p><strong>Namenode 全权管理数据块的复制</strong>，它周期性地从集群中的每个 Datanode 接收心跳信号和块状态报告(Blockreport)。接收到心跳信号意味着该 Datanode 节点工作正常。块状态报告包含了一个该 Datanode 上所有数据块的列表。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/bigdata/hdfs/hdfs-replica.png"/></div>
<ul>
<li>副本 1：放在 Client 所在节点
<ul>
<li>对于远程 Client，系统会随机选择节点</li>
</ul>
</li>
<li>副本 2：放在不同的机架节点上</li>
<li>副本 3：放在与第二个副本同一机架的不同节点上</li>
<li>副本 N：随机选择</li>
<li>节点选择：同等条件下优先选择空闲节点</li>
</ul>
<h2 id="数据流"><a class="markdownIt-Anchor" href="#数据流"></a> 数据流</h2>
<h3 id="hdfs-读文件"><a class="markdownIt-Anchor" href="#hdfs-读文件"></a> HDFS 读文件</h3>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/bigdata/hdfs/hdfs-read.png"/></div>
<ol>
<li>客户端调用 FileSyste 对象的 open() 方法在分布式文件系统中<strong>打开要读取的文件</strong>。</li>
<li>分布式文件系统通过使用 RPC（远程过程调用）来调用 namenode，<strong>确定文件起始块的位置</strong>。</li>
<li>分布式文件系统的 DistributedFileSystem 类返回一个支持文件定位的输入流 FSDataInputStream 对象，FSDataInputStream 对象接着封装 DFSInputStream 对象（<strong>存储着文件起始几个块的 datanode 地址</strong>），客户端对这个输入流调用 read()方法。</li>
<li>DFSInputStream 连接距离最近的 datanode，通过反复调用 read 方法，<strong>将数据从 datanode 传输到客户端</strong>。</li>
<li>到达块的末端时，DFSInputStream 关闭与该 datanode 的连接，<strong>寻找下一个块的最佳 datanode</strong>。</li>
<li>客户端完成读取，对 FSDataInputStream 调用 close()方法<strong>关闭连接</strong>。</li>
</ol>
<h3 id="hdfs-写文件"><a class="markdownIt-Anchor" href="#hdfs-写文件"></a> HDFS 写文件</h3>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/bigdata/hdfs/hdfs-write.png"/></div>
<ol>
<li>客户端通过对 DistributedFileSystem 对象调用 create() 函数来<strong>新建文件</strong>。</li>
<li>分布式文件系统对 namenod 创建一个 RPC 调用，在文件系统的<strong>命名空间中新建一个文件</strong>。</li>
<li>Namenode 对新建文件进行检查无误后，分布式文件系统返回给客户端一个 FSDataOutputStream 对象，FSDataOutputStream 对象封装一个 DFSoutPutstream 对象，负责处理 namenode 和 datanode 之间的通信，<strong>客户端开始写入数据</strong>。</li>
<li>FSDataOutputStream 将<strong>数据分成一个一个的数据包，写入内部队列“数据队列”</strong>，DataStreamer 负责将数据包依次流式传输到由一组 namenode 构成的管线中。</li>
<li>DFSOutputStream 维护着确认队列来等待 datanode 收到确认回执，<strong>收到管道中所有 datanode 确认后，数据包从确认队列删</strong>除。</li>
<li><strong>客户端完成数据的写入</strong>，对数据流调用 close() 方法。</li>
<li>namenode <strong>确认完成</strong>。</li>
</ol>
<h2 id="hdfs-安全模式"><a class="markdownIt-Anchor" href="#hdfs-安全模式"></a> HDFS 安全模式</h2>
<h3 id="什么是安全模式"><a class="markdownIt-Anchor" href="#什么是安全模式"></a> 什么是安全模式？</h3>
<ul>
<li>安全模式是 HDFS 的一种特殊状态，在这种状态下，HDFS 只接收读数据请求，而不接收写入、删除、修改等变更请求。</li>
<li>安全模式是 HDFS 确保 Block 数据安全的一种保护机制。</li>
<li>Active NameNode 启动时，HDFS 会进入安全模式，DataNode 主动向 NameNode 汇报可用 Block 列表等信息，在系统达到安全标准前，HDFS 一直处于“只读”状态。</li>
</ul>
<h3 id="何时正常离开安全模式"><a class="markdownIt-Anchor" href="#何时正常离开安全模式"></a> 何时正常离开安全模式</h3>
<ul>
<li>Block 上报率：DataNode 上报的可用 Block 个数 / NameNode 元数据记录的 Block 个数</li>
<li>当 Block 上报率 &gt;= 阈值时，HDFS 才能离开安全模式，默认阈值为 0.999</li>
<li>不建议手动强制退出安全模式</li>
</ul>
<h3 id="触发安全模式的原因"><a class="markdownIt-Anchor" href="#触发安全模式的原因"></a> 触发安全模式的原因</h3>
<ul>
<li>NameNode 重启</li>
<li>NameNode 磁盘空间不足</li>
<li>Block 上报率低于阈值</li>
<li>DataNode 无法正常启动</li>
<li>日志中出现严重异常</li>
<li>用户操作不当，如：<strong>强制关机（特别注意！）</strong></li>
</ul>
<h3 id="故障排查"><a class="markdownIt-Anchor" href="#故障排查"></a> 故障排查</h3>
<ul>
<li>找到 DataNode 不能正常启动的原因，重启 DataNode</li>
<li>清理 NameNode 磁盘</li>
<li>谨慎操作，有问题找星环，以免丢失数据</li>
</ul>
<h2 id="hdfs-高可用"><a class="markdownIt-Anchor" href="#hdfs-高可用"></a> HDFS 高可用</h2>
<h3 id="namenode-的-ha-机制"><a class="markdownIt-Anchor" href="#namenode-的-ha-机制"></a> NameNode 的 HA 机制</h3>
<p>Active NameNode 和 Standby NameNode 实现主备。</p>
<h3 id="利用-qjm-实现元数据高可用"><a class="markdownIt-Anchor" href="#利用-qjm-实现元数据高可用"></a> 利用 QJM 实现元数据高可用</h3>
<blockquote>
<p>基于 Paxos 算法</p>
</blockquote>
<p>QJM 机制（Quorum Journal Manager）</p>
<p>只要保证 Quorum（法定人数）数量的操作成功，就认为这是一次最终成功的操作</p>
<p>QJM 共享存储系统</p>
<ul>
<li>部署奇数（2N+1）个 JournalNode</li>
<li>JournalNode 负责存储 edits 编辑日志</li>
<li>写 edits 的时候，只要超过半数（N+1）的 JournalNode 返回成功，就代表本次写入成功</li>
<li>最多可容忍 N 个 JournalNode 宕机</li>
</ul>
<p>利用 ZooKeeper 实现 Active 节点选举。</p>
<h2 id="资源"><a class="markdownIt-Anchor" href="#资源"></a> 资源</h2>
<ul>
<li><a href="http://hadoop.apache.org/docs/current/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html" target="_blank" rel="noopener">HDFS 官方文档</a></li>
<li><a href="https://www.cnblogs.com/caiyisen/p/7395843.html" target="_blank" rel="noopener">HDFS 知识点总结</a></li>
<li><a href="http://shop.oreilly.com/product/0636920033448.do" target="_blank" rel="noopener">《Hadoop: The Definitive Guide, Fourth Edition》</a> by Tom White</li>
<li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_design.html" target="_blank" rel="noopener">http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_design.html</a></li>
</ul>
]]></content>
      <categories>
        <category>bigdata</category>
      </categories>
      <tags>
        <tag>bigdata</tag>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark</title>
    <url>/blog/bigdata/Spark/</url>
    <content><![CDATA[<h1 id="spark"><a class="markdownIt-Anchor" href="#spark"></a> Spark</h1>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#spark-%E7%AE%80%E4%BB%8B">Spark 简介</a>
<ul>
<li><a href="#spark-%E6%A6%82%E5%BF%B5">Spark 概念</a></li>
<li><a href="#spark-%E7%89%B9%E7%82%B9">Spark 特点</a></li>
</ul>
</li>
<li><a href="#spark-%E5%8E%9F%E7%90%86">Spark 原理</a>
<ul>
<li><a href="#%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B">编程模型</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h2 id="spark-简介"><a class="markdownIt-Anchor" href="#spark-简介"></a> Spark 简介</h2>
<h3 id="spark-概念"><a class="markdownIt-Anchor" href="#spark-概念"></a> Spark 概念</h3>
<ul>
<li>大规模分布式通用计算引擎
<ul>
<li>Spark Core：核心计算框架</li>
<li>Spark SQL：结构化数据查询</li>
<li>Spark Streaming：实时流处理</li>
<li>Spark MLib：机器学习</li>
<li>Spark GraphX：图计算</li>
</ul>
</li>
<li>具有高吞吐、低延时、通用易扩展、高容错等特点</li>
<li>采用 Scala 语言开发</li>
<li>提供多种运行模式</li>
</ul>
<h3 id="spark-特点"><a class="markdownIt-Anchor" href="#spark-特点"></a> Spark 特点</h3>
<ul>
<li>计算高效
<ul>
<li>利用内存计算、Cache 缓存机制，支持迭代计算和数据共享，减少数据读取的 IO 开销</li>
<li>利用 DAG 引擎，减少中间计算结果写入 HDFS 的开销</li>
<li>利用多线程池模型，减少任务启动开销，避免 Shuffle 中不必要的排序和磁盘 IO 操作</li>
</ul>
</li>
<li>通用易用
<ul>
<li>适用于批处理、流处理、交互式计算、机器学习算法等场景</li>
<li>提供了丰富的开发 API，支持 Scala、Java、Python、R 等</li>
</ul>
</li>
<li>运行模式多样
<ul>
<li>Local 模式</li>
<li>Standalone 模式</li>
<li>YARN/Mesos 模式</li>
</ul>
</li>
<li>计算高效
<ul>
<li>利用内存计算、Cache 缓存机制，支持迭代计算和数据共享，减少数据读取的 IO 开销</li>
<li>利用 DAG 引擎，减少中间计算结果写入 HDFS 的开销</li>
<li>利用多线程池模型，减少任务启动开销，避免 Shuffle 中不必要的排序和磁盘 IO 操作</li>
</ul>
</li>
<li>通用易用
<ul>
<li>适用于批处理、流处理、交互式计算、机器学习等场景</li>
<li>提供了丰富的开发 API，支持 Scala、Java、Python、R 等</li>
</ul>
</li>
</ul>
<h2 id="spark-原理"><a class="markdownIt-Anchor" href="#spark-原理"></a> Spark 原理</h2>
<h3 id="编程模型"><a class="markdownIt-Anchor" href="#编程模型"></a> 编程模型</h3>
<h4 id="rdd"><a class="markdownIt-Anchor" href="#rdd"></a> RDD</h4>
<ul>
<li>弹性分布式数据集（Resilient Distributed Datesets）
<ul>
<li>分布在集群中的只读对象集合</li>
<li>由多个 Partition 组成</li>
<li>通过转换操作构造</li>
<li>失效后自动重构（弹性）</li>
<li>存储在内存或磁盘中</li>
</ul>
</li>
<li>Spark 基于 RDD 进行计算</li>
</ul>
<h4 id="rdd-操作operator"><a class="markdownIt-Anchor" href="#rdd-操作operator"></a> RDD 操作（Operator）</h4>
<ul>
<li>Transformation（转换）
<ul>
<li>将 Scala 集合或 Hadoop 输入数据构造成一个新 RDD</li>
<li>通过已有的 RDD 产生新 RDD</li>
<li>惰性执行：只记录转换关系，不触发计算</li>
<li>例如：map、filter、flatmap、union、distinct、sortbykey</li>
</ul>
</li>
<li>Action（动作）
<ul>
<li>通过 RDD 计算得到一个值或一组值</li>
<li>真正触发计算</li>
<li>例如：first、count、collect、foreach、saveAsTextFile</li>
</ul>
</li>
</ul>
<h4 id="rdd-依赖dependency"><a class="markdownIt-Anchor" href="#rdd-依赖dependency"></a> RDD 依赖（Dependency）</h4>
<ul>
<li>窄依赖（Narrow Dependency）
<ul>
<li>父 RDD 中的分区最多只能被一个子 RDD 的一个分区使用</li>
<li>子 RDD 如果有部分分区数据丢失或损坏，只需从对应的父 RDD 重新计算恢复</li>
<li>例如：map、filter、union</li>
</ul>
</li>
<li>宽依赖（Shuffle/Wide Dependency ）
<ul>
<li>子 RDD 分区依赖父 RDD 的所有分区</li>
<li>子 RDD 如果部分或全部分区数据丢失或损坏，必须从所有父 RDD 分区重新计算</li>
<li>相对于窄依赖，宽依赖付出的代价要高很多，尽量避免使用</li>
<li>例如：groupByKey、reduceByKey、sortByKey</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>bigdata</category>
      </categories>
      <tags>
        <tag>bigdata</tag>
      </tags>
  </entry>
  <entry>
    <title>系统原理面试题</title>
    <url>/blog/design/theory/system-theory-interview/</url>
    <content><![CDATA[<h1 id="系统原理面试题"><a class="markdownIt-Anchor" href="#系统原理面试题"></a> 系统原理面试题</h1>
<h2 id="1-分布式缓存"><a class="markdownIt-Anchor" href="#1-分布式缓存"></a> 1. 分布式缓存</h2>
<h3 id="11-redis-有什么数据类型分别用于什么场景"><a class="markdownIt-Anchor" href="#11-redis-有什么数据类型分别用于什么场景"></a> 1.1. Redis 有什么数据类型？分别用于什么场景</h3>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>可以存储的值</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>STRING</td>
<td>字符串、整数或者浮点数</td>
<td>对整个字符串或者字符串的其中一部分执行操作</br> 对整数和浮点数执行自增或者自减操作</td>
</tr>
<tr>
<td>LIST</td>
<td>列表</td>
<td>从两端压入或者弹出元素</br> 读取单个或者多个元素</br> 进行修剪，只保留一个范围内的元素</td>
</tr>
<tr>
<td>SET</td>
<td>无序集合</td>
<td>添加、获取、移除单个元素</br> 检查一个元素是否存在于集合中</br> 计算交集、并集、差集</br> 从集合里面随机获取元素</td>
</tr>
<tr>
<td>HASH</td>
<td>包含键值对的无序散列表</td>
<td>添加、获取、移除单个键值对</br> 获取所有键值对</br> 检查某个键是否存在</td>
</tr>
<tr>
<td>ZSET</td>
<td>有序集合</td>
<td>添加、获取、删除元素</br> 根据分值范围或者成员来获取元素</br> 计算一个键的排名</td>
</tr>
</tbody>
</table>
<blockquote>
<p><a href="https://redislabs.com/ebook/part-1-getting-started/chapter-1-getting-to-know-redis/1-2-what-redis-data-structures-look-like/" target="_blank" rel="noopener">What Redis data structures look like</a></p>
</blockquote>
<h3 id="12-redis-的主从复制是如何实现的"><a class="markdownIt-Anchor" href="#12-redis-的主从复制是如何实现的"></a> 1.2. Redis 的主从复制是如何实现的</h3>
<ol>
<li>从服务器连接主服务器，发送 SYNC 命令；</li>
<li>主服务器接收到 SYNC 命名后，开始执行 BGSAVE 命令生成 RDB 文件并使用缓冲区记录此后执行的所有写命令；</li>
<li>主服务器 BGSAVE 执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令；</li>
<li>从服务器收到快照文件后丢弃所有旧数据，载入收到的快照；</li>
<li>主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令；</li>
<li>从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；</li>
</ol>
<h3 id="13-redis-的-key-是如何寻址的"><a class="markdownIt-Anchor" href="#13-redis-的-key-是如何寻址的"></a> 1.3. Redis 的 key 是如何寻址的</h3>
<h4 id="131-背景"><a class="markdownIt-Anchor" href="#131-背景"></a> 1.3.1. 背景</h4>
<p>（1）redis 中的每一个数据库，都由一个 redisDb 的结构存储。其中：</p>
<ul>
<li><a href="http://redisDb.id" target="_blank" rel="noopener">redisDb.id</a> 存储着 redis 数据库以整数表示的号码。</li>
<li>redisDb.dict 存储着该库所有的键值对数据。</li>
<li>redisDb.expires 保存着每一个键的过期时间。</li>
</ul>
<p>（2）当 redis 服务器初始化时，会预先分配 16 个数据库（该数量可以通过配置文件配置），所有数据库保存到结构 redisServer 的一个成员 redisServer.db 数组中。当我们选择数据库 select number 时，程序直接通过 redisServer.db[number] 来切换数据库。有时候当程序需要知道自己是在哪个数据库时，直接读取 <a href="http://redisDb.id" target="_blank" rel="noopener">redisDb.id</a> 即可。</p>
<p>（3）redis 的字典使用哈希表作为其底层实现。dict 类型使用的两个指向哈希表的指针，其中 0 号哈希表（ht[0]）主要用于存储数据库的所有键值，而 1 号哈希表主要用于程序对 0 号哈希表进行 rehash 时使用，rehash 一般是在添加新值时会触发，这里不做过多的赘述。所以 redis 中查找一个 key，其实就是对进行该 dict 结构中的 ht[0] 进行查找操作。</p>
<p>（4）既然是哈希，那么我们知道就会有哈希碰撞，那么当多个键哈希之后为同一个值怎么办呢？redis 采取链表的方式来存储多个哈希碰撞的键。也就是说，当根据 key 的哈希值找到该列表后，如果列表的长度大于 1，那么我们需要遍历该链表来找到我们所查找的 key。当然，一般情况下链表长度都为是 1，所以时间复杂度可看作 o(1)。</p>
<h4 id="132-寻址-key-的步骤"><a class="markdownIt-Anchor" href="#132-寻址-key-的步骤"></a> 1.3.2. 寻址 key 的步骤</h4>
<ol>
<li>当拿到一个 key 后，redis 先判断当前库的 0 号哈希表是否为空，即：if (dict-&gt;ht[0].size == 0)。如果为 true 直接返回 NULL。</li>
<li>判断该 0 号哈希表是否需要 rehash，因为如果在进行 rehash，那么两个表中者有可能存储该 key。如果正在进行 rehash，将调用一次<code>_dictRehashStep</code> 方法，<code>_dictRehashStep</code> 用于对数据库字典、以及哈希键的字典进行被动 rehash，这里不作赘述。</li>
<li>计算哈希表，根据当前字典与 key 进行哈希值的计算。</li>
<li>根据哈希值与当前字典计算哈希表的索引值。</li>
<li>根据索引值在哈希表中取出链表，遍历该链表找到 key 的位置。一般情况，该链表长度为 1。</li>
<li>当 ht[0] 查找完了之后，再进行了次 rehash 判断，如果未在 rehashing，则直接结束，否则对 ht[1]重复 345 步骤。</li>
</ol>
<h3 id="14-redis-的集群模式是如何实现的"><a class="markdownIt-Anchor" href="#14-redis-的集群模式是如何实现的"></a> 1.4. Redis 的集群模式是如何实现的？</h3>
<p>Redis Cluster 是 Redis 的分布式解决方案，在 Redis 3.0 版本正式推出的。</p>
<p>Redis Cluster 去中心化，每个节点保存数据和整个集群状态，每个节点都和其他所有节点连接。</p>
<h4 id="141-redis-cluster-节点分配"><a class="markdownIt-Anchor" href="#141-redis-cluster-节点分配"></a> 1.4.1. Redis Cluster 节点分配</h4>
<p>Redis Cluster 特点：</p>
<ol>
<li>所有的 redis 节点彼此互联(PING-PONG 机制)，内部使用二进制协议优化传输速度和带宽。</li>
<li>节点的 fail 是通过集群中超过半数的节点检测失效时才生效。</li>
<li>客户端与 redis 节点直连,不需要中间 proxy 层。客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可。</li>
<li>redis-cluster 把所有的物理节点映射到[0-16383] 哈希槽 (hash slot)上（不一定是平均分配）,cluster 负责维护 node&lt;-&gt;slot&lt;-&gt;value。</li>
<li>Redis 集群预分好 16384 个桶，当需要在 Redis 集群中放置一个 key-value 时，根据 CRC16(key) mod 16384 的值，决定将一个 key 放到哪个桶中。</li>
</ol>
<h4 id="142-redis-cluster-主从模式"><a class="markdownIt-Anchor" href="#142-redis-cluster-主从模式"></a> 1.4.2. Redis Cluster 主从模式</h4>
<p>Redis Cluster 为了保证数据的高可用性，加入了主从模式。</p>
<p>一个主节点对应一个或多个从节点，主节点提供数据存取，从节点则是从主节点拉取数据备份。当这个主节点挂掉后，就会有这个从节点选取一个来充当主节点，从而保证集群不会挂掉。所以，在集群建立的时候，一定要为每个主节点都添加了从节点。</p>
<h4 id="143-redis-sentinel"><a class="markdownIt-Anchor" href="#143-redis-sentinel"></a> 1.4.3. Redis Sentinel</h4>
<p>Redis Sentinel 用于管理多个 Redis 服务器，它有三个功能：</p>
<ul>
<li><strong>监控（Monitoring）</strong> - Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。</li>
<li><strong>提醒（Notification）</strong> - 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</li>
<li><strong>自动故障迁移（Automatic failover）</strong> - 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。</li>
</ul>
<p>Redis 集群中应该有奇数个节点，所以至少有三个节点。</p>
<p>哨兵监控集群中的主服务器出现故障时，需要根据 quorum 选举出一个哨兵来执行故障转移。选举需要 majority，即大多数哨兵是运行的（2 个哨兵的 majority=2，3 个哨兵的 majority=2，5 个哨兵的 majority=3，4 个哨兵的 majority=2）。</p>
<p>假设集群仅仅部署 2 个节点</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">+----+         +----+</span><br><span class="line">|<span class="string"> M1 </span>|<span class="string">---------</span>|<span class="string"> R1 </span>|</span><br><span class="line">|<span class="string"> S1 </span>|<span class="string">         </span>|<span class="string"> S2 </span>|</span><br><span class="line">+----+         +----+</span><br></pre></td></tr></table></figure>
<p>如果 M1 和 S1 所在服务器宕机，则哨兵只有 1 个，无法满足 majority 来进行选举，就不能执行故障转移。</p>
<h3 id="15-redis-如何实现分布式锁zookeeper-如何实现分布式锁比较二者优劣"><a class="markdownIt-Anchor" href="#15-redis-如何实现分布式锁zookeeper-如何实现分布式锁比较二者优劣"></a> 1.5. Redis 如何实现分布式锁？ZooKeeper 如何实现分布式锁？比较二者优劣？</h3>
<p>分布式锁的三种实现：</p>
<ul>
<li>基于数据库实现分布式锁；</li>
<li>基于缓存（Redis 等）实现分布式锁；</li>
<li>基于 Zookeeper 实现分布式锁；</li>
</ul>
<h4 id="151-数据库实现"><a class="markdownIt-Anchor" href="#151-数据库实现"></a> 1.5.1. 数据库实现</h4>
<h4 id="152-redis-实现"><a class="markdownIt-Anchor" href="#152-redis-实现"></a> 1.5.2. Redis 实现</h4>
<ol>
<li>获取锁的时候，使用 setnx 加锁，并使用 expire 命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的 value 值为一个随机生成的 UUID，通过此在释放锁的时候进行判断。</li>
<li>获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。</li>
<li>释放锁的时候，通过 UUID 判断是不是该锁，若是该锁，则执行 delete 进行锁释放。</li>
</ol>
<h4 id="153-zookeeper-实现"><a class="markdownIt-Anchor" href="#153-zookeeper-实现"></a> 1.5.3. ZooKeeper 实现</h4>
<ol>
<li>创建一个目录 mylock；</li>
<li>线程 A 想获取锁就在 mylock 目录下创建临时顺序节点；</li>
<li>获取 mylock 目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；</li>
<li>线程 B 获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；</li>
<li>线程 A 处理完，删除自己的节点，线程 B 监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。</li>
</ol>
<h4 id="154-实现对比"><a class="markdownIt-Anchor" href="#154-实现对比"></a> 1.5.4. 实现对比</h4>
<p>ZooKeeper 具备高可用、可重入、阻塞锁特性，可解决失效死锁问题。<br />
但 ZooKeeper 因为需要频繁的创建和删除节点，性能上不如 Redis 方式。</p>
<h3 id="16-redis-的持久化方式有什么优缺点持久化实现原理"><a class="markdownIt-Anchor" href="#16-redis-的持久化方式有什么优缺点持久化实现原理"></a> 1.6. Redis 的持久化方式？有什么优缺点？持久化实现原理？</h3>
<h4 id="161-rdb-快照snapshot"><a class="markdownIt-Anchor" href="#161-rdb-快照snapshot"></a> 1.6.1. RDB 快照（snapshot）</h4>
<p>将存在于某一时刻的所有数据都写入到硬盘中。</p>
<h5 id="快照的原理"><a class="markdownIt-Anchor" href="#快照的原理"></a> 快照的原理</h5>
<p>在默认情况下，Redis 将数据库快照保存在名字为 dump.rdb 的二进制文件中。你可以对 Redis 进行设置， 让它在“N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动保存一次数据集。你也可以通过调用 SAVE 或者 BGSAVE，手动让 Redis 进行数据集保存操作。这种持久化方式被称为快照。</p>
<p>当 Redis 需要保存 dump.rdb 文件时， 服务器执行以下操作:</p>
<ul>
<li>Redis 创建一个子进程。</li>
<li>子进程将数据集写入到一个临时快照文件中。</li>
<li>当子进程完成对新快照文件的写入时，Redis 用新快照文件替换原来的快照文件，并删除旧的快照文件。</li>
</ul>
<p>这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益。</p>
<h5 id="快照的优点"><a class="markdownIt-Anchor" href="#快照的优点"></a> 快照的优点</h5>
<ul>
<li>它保存了某个时间点的数据集，非常适用于数据集的备份。</li>
<li>很方便传送到另一个远端数据中心或者亚马逊的 S3（可能加密），非常适用于灾难恢复。</li>
<li>快照在保存 RDB 文件时父进程唯一需要做的就是 fork 出一个子进程，接下来的工作全部由子进程来做，父进程不需要再做其他 IO 操作，所以快照持久化方式可以最大化 redis 的性能。</li>
<li>与 AOF 相比，在恢复大的数据集的时候，DB 方式会更快一些。</li>
</ul>
<h5 id="快照的缺点"><a class="markdownIt-Anchor" href="#快照的缺点"></a> 快照的缺点</h5>
<ul>
<li>如果你希望在 redis 意外停止工作（例如电源中断）的情况下丢失的数据最少的话，那么快照不适合你。</li>
<li>快照需要经常 fork 子进程来保存数据集到硬盘上。当数据集比较大的时候，fork 的过程是非常耗时的，可能会导致 Redis 在一些毫秒级内不能响应客户端的请求。</li>
</ul>
<h4 id="162-aof"><a class="markdownIt-Anchor" href="#162-aof"></a> 1.6.2. AOF</h4>
<p>AOF 持久化方式记录每次对服务器执行的写操作。当服务器重启的时候会重新执行这些命令来恢复原始的数据。</p>
<h4 id="163-aof-的原理"><a class="markdownIt-Anchor" href="#163-aof-的原理"></a> 1.6.3. AOF 的原理</h4>
<ul>
<li>Redis 创建一个子进程。</li>
<li>子进程开始将新 AOF 文件的内容写入到临时文件。</li>
<li>对于所有新执行的写入命令，父进程一边将它们累积到一个内存缓存中，一边将这些改动追加到现有 AOF 文件的末尾，这样样即使在重写的中途发生停机，现有的 AOF 文件也还是安全的。</li>
<li>当子进程完成重写工作时，它给父进程发送一个信号，父进程在接收到信号之后，将内存缓存中的所有数据追加到新 AOF 文件的末尾。</li>
<li>搞定！现在 Redis 原子地用新文件替换旧文件，之后所有命令都会直接追加到新 AOF 文件的末尾。</li>
</ul>
<h4 id="164-aof-的优点"><a class="markdownIt-Anchor" href="#164-aof-的优点"></a> 1.6.4. AOF 的优点</h4>
<ul>
<li>使用默认的每秒 fsync 策略，Redis 的性能依然很好(fsync 是由后台线程进行处理的,主线程会尽力处理客户端请求)，一旦出现故障，使用 AOF ，你最多丢失 1 秒的数据。</li>
<li>AOF 文件是一个只进行追加的日志文件，所以不需要写入 seek，即使由于某些原因(磁盘空间已满，写的过程中宕机等等)未执行完整的写入命令，你也也可使用 redis-check-aof 工具修复这些问题。</li>
<li>Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写：重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。整个重写操作是绝对安全的。</li>
<li>AOF 文件有序地保存了对数据库执行的所有写入操作，这些写入操作以 Redis 协议的格式保存。因此 AOF 文件的内容非常容易被人读懂，对文件进行分析（parse）也很轻松。</li>
</ul>
<h4 id="165-aof-的缺点"><a class="markdownIt-Anchor" href="#165-aof-的缺点"></a> 1.6.5. AOF 的缺点</h4>
<ul>
<li>对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。</li>
<li>根据所使用的 fsync 策略，AOF 的速度可能会慢于快照。在一般情况下，每秒 fsync 的性能依然非常高，而关闭 fsync 可以让 AOF 的速度和快照一样快，即使在高负荷之下也是如此。不过在处理巨大的写入载入时，快照可以提供更有保证的最大延迟时间（latency）。</li>
</ul>
<h3 id="17-redis-过期策略有哪些"><a class="markdownIt-Anchor" href="#17-redis-过期策略有哪些"></a> 1.7. Redis 过期策略有哪些？</h3>
<ul>
<li><strong>noeviction</strong> - 当内存使用达到阈值的时候，所有引起申请内存的命令会报错。</li>
<li><strong>allkeys-lru</strong> - 在主键空间中，优先移除最近未使用的 key。</li>
<li><strong>allkeys-random</strong> - 在主键空间中，随机移除某个 key。</li>
<li><strong>volatile-lru</strong> - 在设置了过期时间的键空间中，优先移除最近未使用的 key。</li>
<li><strong>volatile-random</strong> - 在设置了过期时间的键空间中，随机移除某个 key。</li>
<li><strong>volatile-ttl</strong> - 在设置了过期时间的键空间中，具有更早过期时间的 key 优先移除。</li>
</ul>
<h3 id="18-redis-和-memcached-有什么区别"><a class="markdownIt-Anchor" href="#18-redis-和-memcached-有什么区别"></a> 1.8. Redis 和 Memcached 有什么区别？</h3>
<p>两者都是非关系型内存键值数据库。有以下主要不同：</p>
<p><strong>数据类型</strong></p>
<ul>
<li>Memcached 仅支持字符串类型；</li>
<li>而 Redis 支持五种不同种类的数据类型，使得它可以更灵活地解决问题。</li>
</ul>
<p><strong>数据持久化</strong></p>
<ul>
<li>Memcached 不支持持久化；</li>
<li>Redis 支持两种持久化策略：RDB 快照和 AOF 日志。</li>
</ul>
<p><strong>分布式</strong></p>
<ul>
<li>Memcached 不支持分布式，只能通过在客户端使用像一致性哈希这样的分布式算法来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。</li>
<li>Redis Cluster 实现了分布式的支持。</li>
</ul>
<p><strong>内存管理机制</strong></p>
<ul>
<li>Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题，但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。</li>
<li>在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘。而 Memcached 的数据则会一直在内存中。</li>
</ul>
<h3 id="19-为什么单线程的-redis-性能反而优于多线程的-memcached"><a class="markdownIt-Anchor" href="#19-为什么单线程的-redis-性能反而优于多线程的-memcached"></a> 1.9. 为什么单线程的 Redis 性能反而优于多线程的 Memcached？</h3>
<p>Redis 快速的原因：</p>
<ol>
<li>绝大部分请求是纯粹的内存操作（非常快速）</li>
<li>采用单线程,避免了不必要的上下文切换和竞争条件</li>
<li>非阻塞 IO</li>
</ol>
<p>内部实现采用 epoll，采用了 epoll+自己实现的简单的事件框架。epoll 中的读、写、关闭、连接都转化成了事件，然后利用 epoll 的多路复用特性，绝不在 io 上浪费一点时间。</p>
<h2 id="2-分布式消息队列mq"><a class="markdownIt-Anchor" href="#2-分布式消息队列mq"></a> 2. 分布式消息队列（MQ）</h2>
<h3 id="21-为什么使用-mq"><a class="markdownIt-Anchor" href="#21-为什么使用-mq"></a> 2.1. 为什么使用 MQ？</h3>
<ul>
<li>异步处理 - 相比于传统的串行、并行方式，提高了系统吞吐量。</li>
<li>应用解耦 - 系统间通过消息通信，不用关心其他系统的处理。</li>
<li>流量削锋 - 可以通过消息队列长度控制请求量；可以缓解短时间内的高并发请求。</li>
<li>日志处理 - 解决大量日志传输。</li>
<li>消息通讯 - 消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等。</li>
</ul>
<h3 id="22-如何保证-mq-的高可用"><a class="markdownIt-Anchor" href="#22-如何保证-mq-的高可用"></a> 2.2. 如何保证 MQ 的高可用？</h3>
<h4 id="221-数据复制"><a class="markdownIt-Anchor" href="#221-数据复制"></a> 2.2.1. 数据复制</h4>
<ol>
<li>将所有 Broker 和待分配的 Partition 排序</li>
<li>将第 i 个 Partition 分配到第（i mod n）个 Broker 上</li>
<li>将第 i 个 Partition 的第 j 个 Replica 分配到第（(i + j) mode n）个 Broker 上</li>
</ol>
<h4 id="222-选举主服务器"><a class="markdownIt-Anchor" href="#222-选举主服务器"></a> 2.2.2. 选举主服务器</h4>
<h3 id="23-mq-有哪些常见问题如何解决这些问题"><a class="markdownIt-Anchor" href="#23-mq-有哪些常见问题如何解决这些问题"></a> 2.3. MQ 有哪些常见问题？如何解决这些问题？</h3>
<p>MQ 的常见问题有：</p>
<ol>
<li>消息的顺序问题</li>
<li>消息的重复问题</li>
</ol>
<h4 id="231-消息的顺序问题"><a class="markdownIt-Anchor" href="#231-消息的顺序问题"></a> 2.3.1. 消息的顺序问题</h4>
<p>消息有序指的是可以按照消息的发送顺序来消费。</p>
<p>假如生产者产生了 2 条消息：M1、M2，假定 M1 发送到 S1，M2 发送到 S2，如果要保证 M1 先于 M2 被消费，怎么做？</p>
<div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-23145c8b554a0f2f.jpg"/></div>
<p>解决方案：</p>
<p>（1）保证生产者 - MQServer - 消费者是一对一对一的关系</p>
<div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-034106d7e04c062d.jpg"/></div>
<p>缺陷：</p>
<ul>
<li>并行度就会成为消息系统的瓶颈（吞吐量不够）</li>
<li>更多的异常处理，比如：只要消费端出现问题，就会导致整个处理流程阻塞，我们不得不花费更多的精力来解决阻塞的问题。</li>
</ul>
<p>（2）通过合理的设计或者将问题分解来规避。</p>
<ul>
<li>不关注乱序的应用实际大量存在</li>
<li>队列无序并不意味着消息无序</li>
</ul>
<p>所以从业务层面来保证消息的顺序而不仅仅是依赖于消息系统，是一种更合理的方式。</p>
<h4 id="232-消息的重复问题"><a class="markdownIt-Anchor" href="#232-消息的重复问题"></a> 2.3.2. 消息的重复问题</h4>
<p>造成消息重复的根本原因是：网络不可达。</p>
<p>所以解决这个问题的办法就是绕过这个问题。那么问题就变成了：如果消费端收到两条一样的消息，应该怎样处理？</p>
<p>消费端处理消息的业务逻辑保持幂等性。只要保持幂等性，不管来多少条重复消息，最后处理的结果都一样。<br />
保证每条消息都有唯一编号且保证消息处理成功与去重表的日志同时出现。利用一张日志表来记录已经处理成功的消息的 ID，如果新到的消息 ID 已经在日志表中，那么就不再处理这条消息。</p>
<h3 id="24-kafka-activemq-rabbitmq-rocketmq-各有什么优缺点"><a class="markdownIt-Anchor" href="#24-kafka-activemq-rabbitmq-rocketmq-各有什么优缺点"></a> 2.4. Kafka, ActiveMQ, RabbitMQ, RocketMQ 各有什么优缺点？</h3>
<div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-c26f4a3048c38af4.jpg"/></div>
<h2 id="3-分布式服务rpc"><a class="markdownIt-Anchor" href="#3-分布式服务rpc"></a> 3. 分布式服务（RPC）</h2>
<h3 id="31-dubbo-的实现过程"><a class="markdownIt-Anchor" href="#31-dubbo-的实现过程"></a> 3.1. Dubbo 的实现过程？</h3>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/distributed/rpc/dubbo/dubbo基本架构.png!zp" width="500"/>
</div>
<p>节点角色：</p>
<table>
<thead>
<tr>
<th>节点</th>
<th>角色说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Provider</td>
<td>暴露服务的服务提供方</td>
</tr>
<tr>
<td>Consumer</td>
<td>调用远程服务的服务消费方</td>
</tr>
<tr>
<td>Registry</td>
<td>服务注册与发现的注册中心</td>
</tr>
<tr>
<td>Monitor</td>
<td>统计服务的调用次数和调用时间的监控中心</td>
</tr>
<tr>
<td>Container</td>
<td>服务运行容器</td>
</tr>
</tbody>
</table>
<p>调用关系：</p>
<ol>
<li>务容器负责启动，加载，运行服务提供者。</li>
<li>服务提供者在启动时，向注册中心注册自己提供的服务。</li>
<li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li>
<li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li>
<li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li>
<li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li>
</ol>
<h3 id="32-dubbo-负载均衡策略有哪些"><a class="markdownIt-Anchor" href="#32-dubbo-负载均衡策略有哪些"></a> 3.2. Dubbo 负载均衡策略有哪些？</h3>
<h5 id="random"><a class="markdownIt-Anchor" href="#random"></a> Random</h5>
<ul>
<li>随机，按权重设置随机概率。</li>
<li>在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</li>
</ul>
<h5 id="roundrobin"><a class="markdownIt-Anchor" href="#roundrobin"></a> RoundRobin</h5>
<ul>
<li>轮循，按公约后的权重设置轮循比率。</li>
<li>存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</li>
</ul>
<h5 id="leastactive"><a class="markdownIt-Anchor" href="#leastactive"></a> LeastActive</h5>
<ul>
<li>最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。</li>
<li>使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</li>
</ul>
<h5 id="consistenthash"><a class="markdownIt-Anchor" href="#consistenthash"></a> ConsistentHash</h5>
<ul>
<li>一致性 Hash，相同参数的请求总是发到同一提供者。</li>
<li>当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</li>
<li>算法参见：<a href="http://en.wikipedia.org/wiki/Consistent_hashing" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Consistent_hashing</a></li>
<li>缺省只对第一个参数 Hash，如果要修改，请配置 <code>&lt;dubbo:parameter key=&quot;hash.arguments&quot; value=&quot;0,1&quot; /&gt;</code></li>
<li>缺省用 160 份虚拟节点，如果要修改，请配置 <code>&lt;dubbo:parameter key=&quot;hash.nodes&quot; value=&quot;320&quot; /&gt;</code></li>
</ul>
<h3 id="33-dubbo-集群容错策略"><a class="markdownIt-Anchor" href="#33-dubbo-集群容错策略"></a> 3.3. Dubbo 集群容错策略 ？</h3>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/java/javaweb/distributed/rpc/dubbo/dubbo%E9%9B%86%E7%BE%A4%E5%AE%B9%E9%94%99.jpg!zp"/></div>
<ul>
<li><strong>Failover</strong> - 失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 retries=“2” 来设置重试次数(不含第一次)。</li>
<li><strong>Failfast</strong> - 快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</li>
<li><strong>Failsafe</strong> - 失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</li>
<li><strong>Failback</strong> - 失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</li>
<li><strong>Forking</strong> - 并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=“2” 来设置最大并行数。</li>
<li><strong>Broadcast</strong> - 播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。</li>
</ul>
<h3 id="34-动态代理策略"><a class="markdownIt-Anchor" href="#34-动态代理策略"></a> 3.4. 动态代理策略？</h3>
<p>Dubbo 作为 RPC 框架，首先要完成的就是跨系统，跨网络的服务调用。消费方与提供方遵循统一的接口定义，消费方调用接口时，Dubbo 将其转换成统一格式的数据结构，通过网络传输，提供方根据规则找到接口实现，通过反射完成调用。也就是说，消费方获取的是对远程服务的一个代理(Proxy)，而提供方因为要支持不同的接口实现，需要一个包装层(Wrapper)。调用的过程大概是这样：</p>
<div align="center"><img src="https://oscimg.oschina.net/oscnet/bef19cd5a31b5ae13aff35a8cb4898faaf0.jpg"/></div>
<p>消费方的 Proxy 和提供方的 Wrapper 得以让 Dubbo 构建出复杂、统一的体系。而这种动态代理与包装也是通过基于 SPI 的插件方式实现的，它的接口就是<strong>ProxyFactory</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SPI</span>(<span class="string">"javassist"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.PROXY_KEY&#125;)</span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.PROXY_KEY&#125;)</span><br><span class="line">    &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">(T proxy, Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ProxyFactory 有两种实现方式，一种是基于 JDK 的代理实现，一种是基于 javassist 的实现。ProxyFactory 接口上定义了@SPI(“javassist”)，默认为 javassist 的实现。</p>
<h3 id="35-dubbo-支持哪些序列化协议hessianhessian-的数据结构"><a class="markdownIt-Anchor" href="#35-dubbo-支持哪些序列化协议hessianhessian-的数据结构"></a> 3.5. Dubbo 支持哪些序列化协议？Hessian？Hessian 的数据结构？</h3>
<ol>
<li>dubbo 序列化，阿里尚不成熟的 java 序列化实现。</li>
<li>hessian2 序列化：hessian 是一种跨语言的高效二进制的序列化方式，但这里实际不是原生的 hessian2 序列化，而是阿里修改过的 hessian lite，它是 dubbo RPC 默认启用的序列化方式。</li>
<li>json 序列化：目前有两种实现，一种是采用的阿里的 fastjson 库，另一种是采用 dubbo 中自已实现的简单 json 库，一般情况下，json 这种文本序列化性能不如二进制序列化。</li>
<li>java 序列化：主要是采用 JDK 自带的 java 序列化实现，性能很不理想。</li>
<li>Kryo 和 FST：Kryo 和 FST 的性能依然普遍优于 hessian 和 dubbo 序列化。</li>
</ol>
<p>Hessian 序列化与 Java 默认的序列化区别？</p>
<p>Hessian 是一个轻量级的 remoting on http 工具，采用的是 Binary RPC 协议，所以它很适合于发送二进制数据，同时又具有防火墙穿透能力。</p>
<ol>
<li>Hessian 支持跨语言串行</li>
<li>比 java 序列化具有更好的性能和易用性</li>
<li>支持的语言比较多</li>
</ol>
<h3 id="36-protoco-buffer-是什么"><a class="markdownIt-Anchor" href="#36-protoco-buffer-是什么"></a> 3.6. Protoco Buffer 是什么？</h3>
<p>Protocol Buffer 是 Google 出品的一种轻量 &amp; 高效的结构化数据存储格式，性能比 Json、XML 真的强！太！多！</p>
<p>Protocol Buffer 的序列化 &amp; 反序列化简单 &amp; 速度快的原因是：</p>
<ol>
<li>编码 / 解码 方式简单（只需要简单的数学运算 = 位移等等）</li>
<li>采用 Protocol Buffer 自身的框架代码 和 编译器 共同完成</li>
</ol>
<p>Protocol Buffer 的数据压缩效果好（即序列化后的数据量体积小）的原因是：</p>
<ol>
<li>采用了独特的编码方式，如 Varint、Zigzag 编码方式等等</li>
<li>采用 T - L - V 的数据存储方式：减少了分隔符的使用 &amp; 数据存储得紧凑</li>
</ol>
<h3 id="37-注册中心挂了可以继续通信吗"><a class="markdownIt-Anchor" href="#37-注册中心挂了可以继续通信吗"></a> 3.7. 注册中心挂了可以继续通信吗？</h3>
<p>可以。Dubbo 消费者在应用启动时会从注册中心拉取已注册的生产者的地址接口，并缓存在本地。每次调用时，按照本地存储的地址进行调用。</p>
<h3 id="38-zookeeper-原理是什么zookeeper-有什么用"><a class="markdownIt-Anchor" href="#38-zookeeper-原理是什么zookeeper-有什么用"></a> 3.8. ZooKeeper 原理是什么？ZooKeeper 有什么用？</h3>
<p>ZooKeeper 是一个分布式应用协调系统，已经用到了许多分布式项目中，用来完成统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等工作。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/distributed/rpc/zookeeper/zookeeper-service.png!zp" />
</div>
<ol>
<li>每个 Server 在内存中存储了一份数据；</li>
<li>Zookeeper 启动时，将从实例中选举一个 leader（Paxos 协议）；</li>
<li>Leader 负责处理数据更新等操作（Zab 协议）；</li>
<li>一个更新操作成功，当且仅当大多数 Server 在内存中成功修改数据。</li>
</ol>
<h3 id="39-netty-有什么用niobioaio-有什么用有什么区别"><a class="markdownIt-Anchor" href="#39-netty-有什么用niobioaio-有什么用有什么区别"></a> 3.9. Netty 有什么用？NIO/BIO/AIO 有什么用？有什么区别？</h3>
<p>Netty 是一个“网络通讯框架”。</p>
<p>Netty 进行事件处理的流程。<code>Channel</code>是连接的通道，是 ChannelEvent 的产生者，而<code>ChannelPipeline</code>可以理解为 ChannelHandler 的集合。</p>
<div align="center"><img src="https://camo.githubusercontent.com/5f7331d15c79fba29474c5be6e9e86db465637c3/687474703a2f2f7374617469632e6f736368696e612e6e65742f75706c6f6164732f73706163652f323031332f303932312f3137343033325f313872625f3139303539312e706e67"/></div>
<blockquote>
<p>参考：<a href="https://github.com/code4craft/netty-learning/blob/master/posts/ch1-overview.md" target="_blank" rel="noopener">https://github.com/code4craft/netty-learning/blob/master/posts/ch1-overview.md</a></p>
</blockquote>
<p>IO 的方式通常分为几种：</p>
<ul>
<li>同步阻塞的 BIO</li>
<li>同步非阻塞的 NIO</li>
<li>异步非阻塞的 AIO</li>
</ul>
<p>在使用同步 I/O 的网络应用中，如果要同时处理多个客户端请求，或是在客户端要同时和多个服务器进行通讯，就必须使用多线程来处理。</p>
<p>NIO 基于 Reactor，当 socket 有流可读或可写入 socket 时，操作系统会相应的通知引用程序进行处理，应用再将流读取到缓冲区或写入操作系统。也就是说，这个时候，已经不是一个连接就要对应一个处理线程了，而是有效的请求，对应一个线程，当连接没有数据时，是没有工作线程来处理的。</p>
<p>与 NIO 不同，当进行读写操作时，只须直接调用 API 的 read 或 write 方法即可。这两种方法均为异步的，对于读操作而言，当有流可读取时，操作系统会将可读的流传入 read 方法的缓冲区，并通知应用程序；对于写操作而言，当操作系统将 write 方法传递的流写入完毕时，操作系统主动通知应用程序。 即可以理解为，read/write 方法都是异步的，完成后会主动调用回调函数。</p>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/skiof007/article/details/52873421" target="_blank" rel="noopener">https://blog.csdn.net/skiof007/article/details/52873421</a></p>
</blockquote>
<h3 id="310-为什么要进行系统拆分拆分不用-dubbo-可以吗"><a class="markdownIt-Anchor" href="#310-为什么要进行系统拆分拆分不用-dubbo-可以吗"></a> 3.10. 为什么要进行系统拆分？拆分不用 Dubbo 可以吗？</h3>
<p>系统拆分从资源角度分为：应用拆分和数据库拆分。</p>
<p>从采用的先后顺序可分为：水平扩展、垂直拆分、业务拆分、水平拆分。</p>
<div align="center"><img src="http://misc.linkedkeeper.com/misc/img/blog/201804/linkedkeeper0_9c2ed2ed-6156-40f7-ad08-20af067047ca.jpg"/></div>
<p>是否使用服务依据实际业务场景来决定。</p>
<p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。</p>
<p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。</p>
<h3 id="311-dubbo-和-thrift-有什么区别"><a class="markdownIt-Anchor" href="#311-dubbo-和-thrift-有什么区别"></a> 3.11. Dubbo 和 Thrift 有什么区别？</h3>
<ul>
<li>Thrift 是跨语言的 RPC 框架。</li>
<li>Dubbo 支持服务治理，而 Thrift 不支持。</li>
</ul>
]]></content>
      <categories>
        <category>设计</category>
        <category>系统原理</category>
      </categories>
      <tags>
        <tag>设计</tag>
        <tag>系统原理</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式系统基本原理</title>
    <url>/blog/design/theory/distributed-base-theory/</url>
    <content><![CDATA[<h1 id="分布式系统基本原理"><a class="markdownIt-Anchor" href="#分布式系统基本原理"></a> 分布式系统基本原理</h1>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#1-%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%AF%E8%AF%AD">1. 分布式术语</a>
<ul>
<li><a href="#11-%E5%BC%82%E5%B8%B8">1.1. 异常</a></li>
<li><a href="#12-%E8%B6%85%E6%97%B6">1.2. 超时</a></li>
<li><a href="#13-%E8%A1%A1%E9%87%8F%E6%8C%87%E6%A0%87">1.3. 衡量指标</a></li>
</ul>
</li>
<li><a href="#2-%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83">2. 数据分布</a>
<ul>
<li><a href="#21-%E5%93%88%E5%B8%8C%E5%88%86%E5%B8%83">2.1. 哈希分布</a></li>
<li><a href="#22-%E9%A1%BA%E5%BA%8F%E5%88%86%E5%B8%83">2.2. 顺序分布</a></li>
<li><a href="#23-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">2.3. 负载均衡</a></li>
</ul>
</li>
<li><a href="#3-%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA">3. 分布式理论</a>
<ul>
<li><a href="#31-cap">3.1. CAP</a></li>
<li><a href="#32-base">3.2. BASE</a></li>
</ul>
</li>
<li><a href="#4-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98">4. 分布式事务问题</a>
<ul>
<li><a href="#41-%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A42pc">4.1. 两阶段提交（2PC）</a></li>
<li><a href="#42-%E8%A1%A5%E5%81%BF%E4%BA%8B%E5%8A%A1tcc">4.2. 补偿事务（TCC）</a></li>
<li><a href="#43-%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF%E8%A1%A8%E5%BC%82%E6%AD%A5%E7%A1%AE%E4%BF%9D">4.3. 本地消息表（异步确保）</a></li>
<li><a href="#44-mq-%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF">4.4. MQ 事务消息</a></li>
</ul>
</li>
<li><a href="#5-%E5%85%B1%E8%AF%86%E6%80%A7%E9%97%AE%E9%A2%98">5. 共识性问题</a>
<ul>
<li><a href="#51-paxos">5.1. Paxos</a></li>
<li><a href="#52-raft">5.2. Raft</a></li>
</ul>
</li>
<li><a href="#6-%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98">6. 分布式缓存问题</a>
<ul>
<li><a href="#61-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9">6.1. 缓存雪崩</a></li>
<li><a href="#62-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F">6.2. 缓存穿透</a></li>
<li><a href="#63-%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD">6.3. 缓存预热</a></li>
<li><a href="#64-%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0">6.4. 缓存更新</a></li>
<li><a href="#65-%E7%BC%93%E5%AD%98%E9%99%8D%E7%BA%A7">6.5. 缓存降级</a></li>
</ul>
</li>
<li><a href="#7-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">7. 参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="1-分布式术语"><a class="markdownIt-Anchor" href="#1-分布式术语"></a> 1. 分布式术语</h2>
<h3 id="11-异常"><a class="markdownIt-Anchor" href="#11-异常"></a> 1.1. 异常</h3>
<h4 id="服务器宕机"><a class="markdownIt-Anchor" href="#服务器宕机"></a> 服务器宕机</h4>
<p>内存错误、服务器停电等都会导致服务器宕机，此时节点无法正常工作，称为不可用。</p>
<p>服务器宕机会导致节点失去所有内存信息，因此需要将内存信息保存到持久化介质上。</p>
<h4 id="网络异常"><a class="markdownIt-Anchor" href="#网络异常"></a> 网络异常</h4>
<p>有一种特殊的网络异常称为——<strong>网络分区</strong> ，即集群的所有节点被划分为多个区域，每个区域内部可以通信，但是区域之间无法通信。</p>
<h4 id="磁盘故障"><a class="markdownIt-Anchor" href="#磁盘故障"></a> 磁盘故障</h4>
<p>磁盘故障是一种发生概率很高的异常。</p>
<p>使用冗余机制，将数据存储到多台服务器。</p>
<h3 id="12-超时"><a class="markdownIt-Anchor" href="#12-超时"></a> 1.2. 超时</h3>
<p>在分布式系统中，一个请求除了成功和失败两种状态，还存在着超时状态。</p>
<p>可以将服务器的操作设计为具有 <strong>幂等性</strong> ，即执行多次的结果与执行一次的结果相同。如果使用这种方式，当出现超时的时候，可以不断地重新请求直到成功。</p>
<h3 id="13-衡量指标"><a class="markdownIt-Anchor" href="#13-衡量指标"></a> 1.3. 衡量指标</h3>
<h4 id="性能"><a class="markdownIt-Anchor" href="#性能"></a> 性能</h4>
<p>常见的性能指标有：吞吐量、响应时间。</p>
<p>其中，吞吐量指系统在某一段时间可以处理的请求总数，通常为每秒的读操作数或者写操作数；响应时间指从某个请求发出到接收到返回结果消耗的时间。</p>
<p>这两个指标往往是矛盾的，追求高吞吐的系统，往往很难做到低响应时间，解释如下：</p>
<ul>
<li>
<p>在无并发的系统中，吞吐量为响应时间的倒数，例如响应时间为 10 ms，那么吞吐量为 100 req/s，因此高吞吐也就意味着低响应时间。</p>
</li>
<li>
<p>但是在并发的系统中，由于一个请求在调用 I/O 资源的时候，需要进行等待。服务器端一般使用的是异步等待方式，即等待的请求被阻塞之后不需要一直占用 CPU 资源。这种方式能大大提高 CPU 资源的利用率，例如上面的例子中，单个请求在无并发的系统中响应时间为 10 ms，如果在并发的系统中，那么吞吐量将大于 100 req/s。因此为了追求高吞吐量，通常会提高并发程度。但是并发程度的增加，会导致请求的平均响应时间也增加，因为请求不能马上被处理，需要和其它请求一起进行并发处理，响应时间自然就会增高。</p>
</li>
</ul>
<h4 id="可用性"><a class="markdownIt-Anchor" href="#可用性"></a> 可用性</h4>
<p>可用性指系统在面对各种异常时可以提供正常服务的能力。可以用系统可用时间占总时间的比值来衡量，4 个 9 的可用性表示系统 99.99% 的时间是可用的。</p>
<h4 id="一致性"><a class="markdownIt-Anchor" href="#一致性"></a> 一致性</h4>
<p>可以从两个角度理解一致性：从客户端的角度，读写操作是否满足某种特性；从服务器的角度，多个数据副本之间是否一致。</p>
<h4 id="可扩展性"><a class="markdownIt-Anchor" href="#可扩展性"></a> 可扩展性</h4>
<p>指系统通过扩展集群服务器规模来提高性能的能力。理想的分布式系统需要实现“线性可扩展”，即随着集群规模的增加，系统的整体性能也会线性增加。</p>
<h2 id="2-数据分布"><a class="markdownIt-Anchor" href="#2-数据分布"></a> 2. 数据分布</h2>
<p>分布式存储系统的数据分布在多个节点中，常用的数据分布方式有哈希分布和顺序分布。</p>
<p>数据库的水平切分（Sharding）也是一种分布式存储方法，下面的数据分布方法同样适用于 Sharding。</p>
<h3 id="21-哈希分布"><a class="markdownIt-Anchor" href="#21-哈希分布"></a> 2.1. 哈希分布</h3>
<p>哈希分布就是将数据计算哈希值之后，按照哈希值分配到不同的节点上。例如有 N 个节点，数据的主键为 key，则将该数据分配的节点序号为：hash(key)%N。</p>
<p>传统的哈希分布算法存在一个问题：当节点数量变化时，也就是 N 值变化，那么几乎所有的数据都需要重新分布，将导致大量的数据迁移。</p>
<p><strong>一致性哈希</strong></p>
<p>Distributed Hash Table（DHT）：对于哈希空间 [0, 2<sup>n</sup>-1]，将该哈希空间看成一个哈希环，将每个节点都配置到哈希环上。每个数据对象通过哈希取模得到哈希值之后，存放到哈希环中顺时针方向第一个大于等于该哈希值的节点上。</p>
<p>一致性哈希的优点是在增加或者删除节点时只会影响到哈希环中相邻的节点，例如下图中新增节点 X，只需要将数据对象 C 重新存放到节点 X 上即可，对于节点 A、B、D 都没有影响。</p>
<h3 id="22-顺序分布"><a class="markdownIt-Anchor" href="#22-顺序分布"></a> 2.2. 顺序分布</h3>
<p>哈希分布式破坏了数据的有序性，顺序分布则不会。</p>
<p>顺序分布的数据划分为多个连续的部分，按数据的 ID 或者时间分布到不同节点上。例如下图中，User 表的 ID 范围为 1 ~ 7000，使用顺序分布可以将其划分成多个子表，对应的主键范围为 1 ~ 1000，1001 ~ 2000，…，6001 ~ 7000。</p>
<p>顺序分布的优点是可以充分利用每个节点的空间，而哈希分布很难控制一个节点存储多少数据。</p>
<p>但是顺序分布需要使用一个映射表来存储数据到节点的映射，这个映射表通常使用单独的节点来存储。当数据量非常大时，映射表也随着变大，那么一个节点就可能无法存放下整个映射表。并且单个节点维护着整个映射表的开销很大，查找速度也会变慢。为了解决以上问题，引入了一个中间层，也就是 Meta 表，从而分担映射表的维护工作。</p>
<h3 id="23-负载均衡"><a class="markdownIt-Anchor" href="#23-负载均衡"></a> 2.3. 负载均衡</h3>
<p>衡量负载的因素很多，如 CPU、内存、磁盘等资源使用情况、读写请求数等。</p>
<p>分布式系统存储应当能够自动负载均衡，当某个节点的负载较高，将它的部分数据迁移到其它节点。</p>
<p>每个集群都有一个总控节点，其它节点为工作节点，由总控节点根据全局负载信息进行整体调度，工作节点定时发送心跳包（Heartbeat）将节点负载相关的信息发送给总控节点。</p>
<p>一个新上线的工作节点，由于其负载较低，如果不加控制，总控节点会将大量数据同时迁移到该节点上，造成该节点一段时间内无法工作。因此负载均衡操作需要平滑进行，新加入的节点需要较长的一段时间来达到比较均衡的状态。</p>
<h2 id="3-分布式理论"><a class="markdownIt-Anchor" href="#3-分布式理论"></a> 3. 分布式理论</h2>
<h3 id="31-cap"><a class="markdownIt-Anchor" href="#31-cap"></a> 3.1. CAP</h3>
<p>分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容忍性（P：Partition Tolerance），最多只能同时满足其中两项。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/分布式理论-CAP.jpg" width="450"/>
</div>
<h4 id="一致性-2"><a class="markdownIt-Anchor" href="#一致性-2"></a> 一致性</h4>
<p>一致性指的是多个数据副本是否能保持一致的特性。</p>
<p>在一致性的条件下，系统在执行数据更新操作之后能够从一致性状态转移到另一个一致性状态。</p>
<p>对系统的一个数据更新成功之后，如果所有用户都能够读取到最新的值，该系统就被认为具有强一致性。</p>
<h4 id="可用性-2"><a class="markdownIt-Anchor" href="#可用性-2"></a> 可用性</h4>
<p>可用性指分布式系统在面对各种异常时可以提供正常服务的能力，可以用系统可用时间占总时间的比值来衡量，4 个 9 的可用性表示系统 99.99% 的时间是可用的。</p>
<p>在可用性条件下，系统提供的服务一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。</p>
<h4 id="分区容忍性"><a class="markdownIt-Anchor" href="#分区容忍性"></a> 分区容忍性</h4>
<p>网络分区指分布式系统中的节点被划分为多个区域，每个区域内部可以通信，但是区域之间无法通信。</p>
<p>在分区容忍性条件下，分布式系统在遇到任何网络分区故障的时候，仍然需要能对外提供一致性和可用性的服务，除非是整个网络环境都发生了故障。</p>
<h4 id="权衡"><a class="markdownIt-Anchor" href="#权衡"></a> 权衡</h4>
<p>在分布式系统中，分区容忍性必不可少，因为需要总是假设网络是不可靠的。因此，CAP 理论实际在是要在可用性和一致性之间做权衡。</p>
<p>可用性和一致性往往是冲突的，很难都使它们同时满足。在多个节点之间进行数据同步时，</p>
<ul>
<li>为了保证一致性（CP），就需要让所有节点下线成为不可用的状态，等待同步完成；</li>
<li>为了保证可用性（AP），在同步过程中允许读取所有节点的数据，但是数据可能不一致。</li>
</ul>
<h3 id="32-base"><a class="markdownIt-Anchor" href="#32-base"></a> 3.2. BASE</h3>
<p>BASE 是基本可用（Basically Available）、软状态（Soft State）和最终一致性（Eventually Consistent）三个短语的缩写。</p>
<p>BASE 理论是对 CAP 中一致性和可用性权衡的结果，它的理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/distributed/architecture/分布式理论-BASE.png" />
</div>
<h4 id="基本可用"><a class="markdownIt-Anchor" href="#基本可用"></a> 基本可用</h4>
<p>指分布式系统在出现故障的时候，保证核心可用，允许损失部分可用性。</p>
<p>例如，电商在做促销时，为了保证购物系统的稳定性，部分消费者可能会被引导到一个降级的页面。</p>
<h4 id="软状态"><a class="markdownIt-Anchor" href="#软状态"></a> 软状态</h4>
<p>指允许系统中的数据存在中间状态，并认为该中间状态不会影响系统整体可用性，即允许系统不同节点的数据副本之间进行同步的过程存在延时。</p>
<h4 id="最终一致性"><a class="markdownIt-Anchor" href="#最终一致性"></a> 最终一致性</h4>
<p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能达到一致的状态。</p>
<p>ACID 要求强一致性，通常运用在传统的数据库系统上。而 BASE 要求最终一致性，通过牺牲强一致性来达到可用性，通常运用在大型分布式系统中。</p>
<p>在实际的分布式场景中，不同业务单元和组件对一致性的要求是不同的，因此 ACID 和 BASE 往往会结合在一起使用。</p>
<h2 id="4-分布式事务问题"><a class="markdownIt-Anchor" href="#4-分布式事务问题"></a> 4. 分布式事务问题</h2>
<h3 id="41-两阶段提交2pc"><a class="markdownIt-Anchor" href="#41-两阶段提交2pc"></a> 4.1. 两阶段提交（2PC）</h3>
<p>两阶段提交（Two-phase Commit，2PC）</p>
<p>主要用于实现分布式事务，分布式事务指的是事务操作跨越多个节点，并且要求满足事务的 ACID 特性。</p>
<p>通过引入协调者（Coordinator）来调度参与者的行为，并最终决定这些参与者是否要真正执行事务。</p>
<h4 id="运行过程"><a class="markdownIt-Anchor" href="#运行过程"></a> 运行过程</h4>
<h5 id="准备阶段"><a class="markdownIt-Anchor" href="#准备阶段"></a> 准备阶段</h5>
<p>协调者询问参与者事务是否执行成功，参与者发回事务执行结果。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/分布式事务两阶段提交-01.jpg" />
</div>
<h5 id="提交阶段"><a class="markdownIt-Anchor" href="#提交阶段"></a> 提交阶段</h5>
<p>如果事务在每个参与者上都执行成功，事务协调者发送通知让参与者提交事务；否则，协调者发送通知让参与者回滚事务。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/分布式事务两阶段提交-02.jpg" />
</div>
<p>需要注意的是，在准备阶段，参与者执行了事务，但是还未提交。只有在提交阶段接收到协调者发来的通知后，才进行提交或者回滚。</p>
<h4 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h4>
<h5 id="同步阻塞"><a class="markdownIt-Anchor" href="#同步阻塞"></a> 同步阻塞</h5>
<p>所有事务参与者在等待其它参与者响应的时候都处于同步阻塞状态，无法进行其它操作。</p>
<h5 id="单点问题"><a class="markdownIt-Anchor" href="#单点问题"></a> 单点问题</h5>
<p>协调者在 2PC 中起到非常大的作用，发生故障将会造成很大影响，特别是在阶段二发生故障，所有参与者会一直等待状态，无法完成其它操作。</p>
<h5 id="数据不一致"><a class="markdownIt-Anchor" href="#数据不一致"></a> 数据不一致</h5>
<p>在阶段二，如果协调者只发送了部分 Commit 消息，此时网络发生异常，那么只有部分参与者接收到 Commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。</p>
<h5 id="太过保守"><a class="markdownIt-Anchor" href="#太过保守"></a> 太过保守</h5>
<p>任意一个节点失败就会导致整个事务失败，没有完善的容错机制。</p>
<h4 id="pc-优缺点"><a class="markdownIt-Anchor" href="#pc-优缺点"></a> PC 优缺点</h4>
<p>优点：尽量保证了数据的强一致，适合对数据强一致要求很高的关键领域。（其实也不能 100%保证强一致）<br />
缺点：实现复杂，牺牲了可用性，对性能影响较大，不适合高并发高性能场景。</p>
<h3 id="42-补偿事务tcc"><a class="markdownIt-Anchor" href="#42-补偿事务tcc"></a> 4.2. 补偿事务（TCC）</h3>
<p>补偿事务（TCC）其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。它分为三个阶段：</p>
<ol>
<li>Try 阶段主要是对业务系统做检测及资源预留。</li>
<li>Confirm 阶段主要是对业务系统做确认提交，Try 阶段执行成功并开始执行 Confirm 阶段时，默认 Confirm 阶段是不会出错的。即：只要 Try 成功，Confirm 一定成功。</li>
<li>Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。</li>
</ol>
<p>举个例子，假设 Bob 要向 Smith 转账，思路大概是：</p>
<ol>
<li>首先在 Try 阶段，要先调用远程接口把 Smith 和 Bob 的钱给冻结起来。</li>
<li>在 Confirm 阶段，执行远程调用的转账的操作，转账成功进行解冻。</li>
<li>如果第 2 步执行成功，那么转账成功，如果第二步执行失败，则调用远程冻结接口对应的解冻方法 (Cancel)。</li>
</ol>
<h4 id="tcc-优缺点"><a class="markdownIt-Anchor" href="#tcc-优缺点"></a> TCC 优缺点</h4>
<ul>
<li>优点：跟 2PC 比起来，实现以及流程相对简单了一些，但数据的一致性比 2PC 也要差一些。</li>
<li>缺点：缺点还是比较明显的，在 2,3 步中都有可能失败。TCC 属于应用层的一种补偿方式，所以需要程序员在实现的时候多写很多补偿的代码，在一些场景中，一些业务流程可能用 TCC 不太好定义及处理。</li>
</ul>
<h3 id="43-本地消息表异步确保"><a class="markdownIt-Anchor" href="#43-本地消息表异步确保"></a> 4.3. 本地消息表（异步确保）</h3>
<p>本地消息表与业务数据表处于同一个数据库中，这样就能利用本地事务来保证在对这两个表的操作满足事务特性。</p>
<ol>
<li>在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送一个消息，本地事务能保证这个消息一定会被写入本地消息表中。</li>
<li>之后将本地消息表中的消息转发到 Kafka 等消息队列（MQ）中，如果转发成功则将消息从本地消息表中删除，否则继续重新转发。</li>
<li>在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作。</li>
</ol>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/分布式事务本地消息.jpg" />
</div>
<p>这种方案遵循 BASE 理论，采用的是最终一致性。</p>
<p>本地消息表利用了本地事务来实现分布式事务，并且使用了消息队列来保证最终一致性。</p>
<h4 id="本地消息表优缺点"><a class="markdownIt-Anchor" href="#本地消息表优缺点"></a> 本地消息表优缺点</h4>
<ul>
<li>优点：一种非常经典的实现，避免了分布式事务，实现了最终一致性。</li>
<li>缺点：消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。</li>
</ul>
<h3 id="44-mq-事务消息"><a class="markdownIt-Anchor" href="#44-mq-事务消息"></a> 4.4. MQ 事务消息</h3>
<p>有一些第三方的 MQ 是支持事务消息的，比如 RocketMQ，他们支持事务消息的方式也是类似于采用的二阶段提交。但是市面上一些主流的 MQ 都是不支持事务消息的，比如 RabbitMQ 和 Kafka 都不支持。</p>
<p>以阿里的 RocketMQ 中间件为例，其思路大致为：</p>
<ol>
<li>Prepared 消息，会拿到消息的地址。</li>
<li>执行本地事务。</li>
<li>通过第一阶段拿到的地址去访问消息，并修改状态。</li>
</ol>
<p>也就是说在业务方法内要想消息队列提交两次请求，一次发送消息和一次确认消息。如果确认消息发送失败了 RocketMQ 会定期扫描消息集群中的事务消息，这时候发现了 Prepared 消息，它会向消息发送者确认，所以生产方需要实现一个 check 接口，RocketMQ 会根据发送端设置的策略来决定是回滚还是继续发送确认消息。这样就保证了消息发送与本地事务同时成功或同时失败。</p>
<h4 id="mq-事务消息优缺点"><a class="markdownIt-Anchor" href="#mq-事务消息优缺点"></a> MQ 事务消息优缺点</h4>
<ul>
<li>优点：实现了最终一致性，不需要依赖本地数据库事务。</li>
<li>缺点：实现难度大，主流 MQ 不支持。</li>
</ul>
<h2 id="5-共识性问题"><a class="markdownIt-Anchor" href="#5-共识性问题"></a> 5. 共识性问题</h2>
<h3 id="51-paxos"><a class="markdownIt-Anchor" href="#51-paxos"></a> 5.1. Paxos</h3>
<p>用于达成共识性问题，即对多个节点产生的值，该算法能保证只选出唯一一个值。</p>
<p>主要有三类节点：</p>
<ul>
<li>提议者（Proposer）：提议一个值；</li>
<li>接受者（Acceptor）：对每个提议进行投票；</li>
<li>告知者（Learner）：被告知投票的结果，不参与投票过程。</li>
</ul>
<p>算法需要满足 safety 和 liveness 两方面的约束要求（实际上这两个基础属性是大部分分布式算法都该考虑的）：</p>
<ul>
<li>safety：保证决议结果是对的，无歧义的，不会出现错误情况。
<ul>
<li>决议（value）只有在被 proposers 提出的 proposal 才能被最终批准；</li>
<li>在一次执行实例中，只批准（chosen）一个最终决议，意味着多数接受（accept）的结果能成为决议；</li>
</ul>
</li>
<li>liveness：保证决议过程能在有限时间内完成。
<ul>
<li>决议总会产生，并且 learners 能获得被批准（chosen）的决议。</li>
</ul>
</li>
</ul>
<p>基本过程包括 proposer 提出提案，先争取大多数 acceptor 的支持，超过一半支持时，则发送结案结果给所有人进行确认。一个潜在的问题是 proposer 在此过程中出现故障，可以通过超时机制来解决。极为凑巧的情况下，每次新的一轮提案的 proposer 都恰好故障，系统则永远无法达成一致（概率很小）。</p>
<p>Paxos 能保证在超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">1/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord">2</span></span></span></span> 的正常节点存在时，系统能达成共识。</p>
<h4 id="单个提案者多接收者"><a class="markdownIt-Anchor" href="#单个提案者多接收者"></a> 单个提案者+多接收者</h4>
<p>如果系统中限定只有某个特定节点是提案者，那么一致性肯定能达成（只有一个方案，要么达成，要么失败）。提案者只要收到了来自多数接收者的投票，即可认为通过，因为系统中不存在其他的提案。</p>
<p>但一旦提案者故障，则系统无法工作。</p>
<h4 id="多个提案者单个接收者"><a class="markdownIt-Anchor" href="#多个提案者单个接收者"></a> 多个提案者+单个接收者</h4>
<p>限定某个节点作为接收者。这种情况下，共识也很容易达成，接收者收到多个提案，选第一个提案作为决议，拒绝掉后续的提案即可。</p>
<p>缺陷也是容易发生单点故障，包括接收者故障或首个提案者节点故障。</p>
<p>以上两种情形其实类似主从模式，虽然不那么可靠，但因为原理简单而被广泛采用。</p>
<p>当提案者和接收者都推广到多个的情形，会出现一些挑战。</p>
<h4 id="多个提案者多个接收者"><a class="markdownIt-Anchor" href="#多个提案者多个接收者"></a> 多个提案者+多个接收者</h4>
<p>既然限定单提案者或单接收者都会出现故障，那么就得允许出现多个提案者和多个接收者。问题一下子变得复杂了。</p>
<p>一种情况是同一时间片段（如一个提案周期）内只有一个提案者，这时可以退化到单提案者的情形。需要设计一种机制来保障提案者的正确产生，例如按照时间、序列、或者大家猜拳（出一个数字来比较）之类。考虑到分布式系统要处理的工作量很大，这个过程要尽量高效，满足这一条件的机制非常难设计。</p>
<p>另一种情况是允许同一时间片段内可以出现多个提案者。那同一个节点可能收到多份提案，怎么对他们进行区分呢？这个时候采用只接受第一个提案而拒绝后续提案的方法也不适用。很自然的，提案需要带上不同的序号。节点需要根据提案序号来判断接受哪个。比如接受其中序号较大（往往意味着是接受新提出的，因为旧提案者故障概率更大）的提案。</p>
<p>如何为提案分配序号呢？一种可能方案是每个节点的提案数字区间彼此隔离开，互相不冲突。为了满足递增的需求可以配合用时间戳作为前缀字段。</p>
<p>此外，提案者即便收到了多数接收者的投票，也不敢说就一定通过。因为在此过程中系统可能还有其它的提案。</p>
<h3 id="52-raft"><a class="markdownIt-Anchor" href="#52-raft"></a> 5.2. Raft</h3>
<p>Raft 算法是 Paxos 算法的一种简化实现。</p>
<p>包括三种角色：leader、candidate 和 follower，其基本过程为：</p>
<ul>
<li><strong>Leader 选举</strong> - 每个 candidate 随机经过一定时间都会提出选举方案，最近阶段中得票最多者被选为 leader；</li>
<li><strong>同步 log</strong> - leader 会找到系统中 log 最新的记录，并强制所有的 follower 来刷新到这个记录；</li>
</ul>
<p><em>注：此处 log 并非是指日志消息，而是各种事件的发生记录。</em></p>
<h4 id="单个-candidate-的竞选"><a class="markdownIt-Anchor" href="#单个-candidate-的竞选"></a> 单个 Candidate 的竞选</h4>
<p>有三种节点：Follower、Candidate 和 Leader。Leader 会周期性的发送心跳包给 Follower。每个 Follower 都设置了一个随机的竞选超时时间，一般为 150ms~300ms，如果在这个时间内没有收到 Leader 的心跳包，就会变成 Candidate，进入竞选阶段。</p>
<ul>
<li>下图表示一个分布式系统的最初阶段，此时只有 Follower，没有 Leader。Follower A 等待一个随机的竞选超时时间之后，没收到 Leader 发来的心跳包，因此进入竞选阶段。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/raft-candidate-01.gif" />
</div>
<ul>
<li>此时 A 发送投票请求给其它所有节点。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/raft-candidate-02.gif" />
</div>
<ul>
<li>其它节点会对请求进行回复，如果超过一半的节点回复了，那么该 Candidate 就会变成 Leader。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/raft-candidate-03.gif" />
</div>
<ul>
<li>之后 Leader 会周期性地发送心跳包给 Follower，Follower 接收到心跳包，会重新开始计时。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/raft-candidate-04.gif" />
</div>
<h4 id="多个-candidate-竞选"><a class="markdownIt-Anchor" href="#多个-candidate-竞选"></a> 多个 Candidate 竞选</h4>
<ul>
<li>如果有多个 Follower 成为 Candidate，并且所获得票数相同，那么就需要重新开始投票，例如下图中 Candidate B 和 Candidate D 都获得两票，因此需要重新开始投票。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/raft-multi-candidate-01.gif" />
</div>
<ul>
<li>当重新开始投票时，由于每个节点设置的随机竞选超时时间不同，因此能下一次再次出现多个 Candidate 并获得同样票数的概率很低。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/raft-multi-candidate-02.gif" />
</div>
<h4 id="同步日志"><a class="markdownIt-Anchor" href="#同步日志"></a> 同步日志</h4>
<ul>
<li>来自客户端的修改都会被传入 Leader。注意该修改还未被提交，只是写入日志中。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/raft-sync-log-01.gif" />
</div>
<ul>
<li>Leader 会把修改复制到所有 Follower。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/raft-sync-log-02.gif" />
</div>
<ul>
<li>Leader 会等待大多数的 Follower 也进行了修改，然后才将修改提交。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/raft-sync-log-03.gif" />
</div>
<ul>
<li>此时 Leader 会通知的所有 Follower 让它们也提交修改，此时所有节点的值达成一致。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/raft-sync-log-04.gif" />
</div>
<h2 id="6-分布式缓存问题"><a class="markdownIt-Anchor" href="#6-分布式缓存问题"></a> 6. 分布式缓存问题</h2>
<h3 id="61-缓存雪崩"><a class="markdownIt-Anchor" href="#61-缓存雪崩"></a> 6.1. 缓存雪崩</h3>
<p>缓存雪崩是指：在高并发场景下，由于原有缓存失效，新缓存未到期间(例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库 CPU 和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。</p>
<p>解决方案：</p>
<ul>
<li>用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。</li>
<li>还有一个简单的方案，就是将缓存失效时间分散开，不要所有缓存时间长度都设置成 5 分钟或者 10 分钟；比如我们可以在原有的失效时间基础上增加一个随机值，比如 1-5 分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</li>
</ul>
<p>缓存失效时产生的雪崩效应，将所有请求全部放在数据库上，这样很容易就达到数据库的瓶颈，导致服务无法正常提供。尽量避免这种场景的发生。</p>
<h3 id="62-缓存穿透"><a class="markdownIt-Anchor" href="#62-缓存穿透"></a> 6.2. 缓存穿透</h3>
<p>缓存穿透是指：用户查询的数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。</p>
<p>当在流量较大时，出现这样的情况，一直请求 DB，很容易导致服务挂掉。</p>
<p>解决方案：</p>
<ol>
<li>在封装的缓存 SET 和 GET 部分增加个步骤，如果查询一个 KEY 不存在，就以这个 KEY 为前缀设定一个标识 KEY；以后再查询该 KEY 的时候，先查询标识 KEY，如果标识 KEY 存在，就返回一个协定好的非 false 或者 NULL 值，然后 APP 做相应的处理，这样缓存层就不会被穿透。当然这个验证 KEY 的失效时间不能太长。</li>
<li>如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，一般只有几分钟。</li>
<li>采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。</li>
</ol>
<h3 id="63-缓存预热"><a class="markdownIt-Anchor" href="#63-缓存预热"></a> 6.3. 缓存预热</h3>
<p>缓存预热这个应该是一个比较常见的概念，相信很多小伙伴都应该可以很容易的理解，缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p>
<p>解决方案：</p>
<ol>
<li>直接写个缓存刷新页面，上线时手工操作下；</li>
<li>数据量不大，可以在项目启动的时候自动进行加载；</li>
<li>定时刷新缓存；</li>
</ol>
<h3 id="64-缓存更新"><a class="markdownIt-Anchor" href="#64-缓存更新"></a> 6.4. 缓存更新</h3>
<p>除了缓存服务器自带的缓存失效策略之外（Redis 默认的有 6 中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：</p>
<ol>
<li>定时去清理过期的缓存；</li>
<li>当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。</li>
</ol>
<p>两者各有优劣，第一种的缺点是维护大量缓存的 key 是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。</p>
<h3 id="65-缓存降级"><a class="markdownIt-Anchor" href="#65-缓存降级"></a> 6.5. 缓存降级</h3>
<p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</p>
<p>降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。</p>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li>杨传辉. 大规模分布式存储系统: 原理解析与架构实战[M]. 机械工业出版社, 2013.</li>
<li><a href="https://www.gitbook.com/book/yeasy/blockchain_guide/details" target="_blank" rel="noopener">区块链技术指南</a></li>
<li><a href="http://harry.me/blog/2014/12/27/neat-algorithms-paxos/" target="_blank" rel="noopener">NEAT ALGORITHMS - PAXOS</a></li>
<li><a href="http://thesecretlivesofdata.com/raft" target="_blank" rel="noopener">Raft: Understandable Distributed Consensus</a></li>
<li><a href="https://angus.nyc/2012/paxos-by-example/" target="_blank" rel="noopener">Paxos By Example</a></li>
<li><a href="https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html" target="_blank" rel="noopener">聊聊分布式事务，再说说解决方案</a></li>
</ul>
]]></content>
      <categories>
        <category>设计</category>
        <category>系统原理</category>
      </categories>
      <tags>
        <tag>设计</tag>
        <tag>系统原理</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>大型系统核心技术</title>
    <url>/blog/design/architecture/system-core-technologies/</url>
    <content><![CDATA[<h1 id="大型系统核心技术"><a class="markdownIt-Anchor" href="#大型系统核心技术"></a> 大型系统核心技术</h1>
<blockquote>
<p>大型系统的设计目标就是为了快速、高效、稳定的处理海量的数据以及高并发的请求。</p>
<p>单机服务受限于硬件，客观存在着资源瓶颈，难以应对不断增长的数据量和请求量，为了打破瓶颈，大型系统基本上都被设计为分布式系统。</p>
<p>分布式系统由于其面临的共性问题，在很多场景下的解决方案往往也存在着共性。因此，我们会发现，很多优秀的大型系统在设计方案上存在着很多的共同点。</p>
<p>本文主要讨论应对分布式系统共性问题的解决方案，这既可以加深对分布式系统运作原理的理解，也可以作为设计大型分布式系统时的借鉴。</p>
</blockquote>
<h2 id="1-分布式事务"><a class="markdownIt-Anchor" href="#1-分布式事务"></a> 1. 分布式事务</h2>
<blockquote>
<p>参考：<a href="%E5%88%86%E5%B8%83%E5%BC%8F%E5%8E%9F%E7%90%86.md#4-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98">分布式原理#4-分布式事务问题</a></p>
</blockquote>
<h2 id="2-分布式锁"><a class="markdownIt-Anchor" href="#2-分布式锁"></a> 2. 分布式锁</h2>
<p>Java 原生 API 虽然有并发锁，但并没有提供分布式锁的能力，所以针对分布式场景中的锁需要解决的方案。</p>
<p>分布式锁的解决方案大致有以下几种：</p>
<ul>
<li>基于数据库实现</li>
<li>基于缓存（redis，memcached 等）实现</li>
<li>基于 Zookeeper 实现</li>
</ul>
<h3 id="21-基于数据库实现分布式锁"><a class="markdownIt-Anchor" href="#21-基于数据库实现分布式锁"></a> 2.1. 基于数据库实现分布式锁</h3>
<h4 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h4>
<h5 id="1-创建表"><a class="markdownIt-Anchor" href="#1-创建表"></a> 1. 创建表</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`methodLock`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">  <span class="string">`method_name`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'锁定的方法名'</span>,</span><br><span class="line">  <span class="string">`desc`</span> <span class="built_in">varchar</span>(<span class="number">1024</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'备注信息'</span>,</span><br><span class="line">  <span class="string">`update_time`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'保存数据时间，自动生成'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`uidx_method_name`</span> (<span class="string">`method_name `</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'锁定中的方法'</span>;</span><br></pre></td></tr></table></figure>
<h5 id="2-获取锁"><a class="markdownIt-Anchor" href="#2-获取锁"></a> 2. 获取锁</h5>
<p>想要锁住某个方法时，执行以下 SQL：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> methodLock(method_name,<span class="keyword">desc</span>) <span class="keyword">values</span> (‘method_name’,‘<span class="keyword">desc</span>’)</span><br></pre></td></tr></table></figure>
<p>因为我们对 <code>method_name</code> 做了唯一性约束，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，可以执行方法体内容。</p>
<p>成功插入则获取锁。</p>
<h5 id="3-释放锁"><a class="markdownIt-Anchor" href="#3-释放锁"></a> 3. 释放锁</h5>
<p>当方法执行完毕之后，想要释放锁的话，需要执行以下 Sql:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> methodLock <span class="keyword">where</span> method_name =<span class="string">'method_name'</span></span><br></pre></td></tr></table></figure>
<h4 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h4>
<ol>
<li>这把锁强依赖数据库的可用性。如果数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。</li>
<li>这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。</li>
<li>这把锁只能是非阻塞的，因为数据的 insert 操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。</li>
<li>这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。</li>
</ol>
<h4 id="解决办法"><a class="markdownIt-Anchor" href="#解决办法"></a> 解决办法</h4>
<ol>
<li>单点问题可以用多数据库实例，同时塞 N 个表，N/2+1 个成功就任务锁定成功</li>
<li>写一个定时任务，隔一段时间清除一次过期的数据。</li>
<li>写一个 while 循环，不断的重试插入，直到成功。</li>
<li>在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。</li>
</ol>
<h4 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h4>
<ul>
<li>优点: 直接借助数据库，容易理解。</li>
<li>缺点: 会有各种各样的问题，在解决问题的过程中会使整个方案变得越来越复杂。操作数据库需要一定的开销，性能问题需要考虑。</li>
</ul>
<h3 id="22-基于-redis-实现分布式锁"><a class="markdownIt-Anchor" href="#22-基于-redis-实现分布式锁"></a> 2.2. 基于 Redis 实现分布式锁</h3>
<p>相比于用数据库来实现分布式锁，基于缓存实现的分布式锁的性能会更好一些。目前有很多成熟的分布式产品，包括 Redis、memcache、Tair 等。这里以 Redis 举例。</p>
<h4 id="redis-命令"><a class="markdownIt-Anchor" href="#redis-命令"></a> Redis 命令</h4>
<ul>
<li>setnx - setnx key val：当且仅当 key 不存在时，set 一个 key 为 val 的字符串，返回 1；若 key 存在，则什么都不做，返回 0。</li>
<li>expire - expire key timeout：为 key 设置一个超时时间，单位为 second，超过这个时间锁会自动释放，避免死锁。</li>
<li>delete - delete key：删除 key</li>
</ul>
<h4 id="实现-2"><a class="markdownIt-Anchor" href="#实现-2"></a> 实现</h4>
<p>单点实现步骤：</p>
<ol>
<li>获取锁的使用，使用 setnx 加锁，锁的 value 值为一个随机生成的 UUID，再使用 expire 设置一个过期值。</li>
<li>获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。</li>
<li>释放锁的时候，通过 UUID 判断是不是该锁，若是该锁，则执行 delete 进行锁释放。</li>
</ol>
<h4 id="问题-2"><a class="markdownIt-Anchor" href="#问题-2"></a> 问题</h4>
<ul>
<li>单点问题。如果单机 redis 挂掉了，那么程序会跟着出错。</li>
<li>如果转移使用 slave 节点，复制不是同步复制，会出现多个程序获取锁的情况</li>
</ul>
<h4 id="小结-2"><a class="markdownIt-Anchor" href="#小结-2"></a> 小结</h4>
<p>可以考虑使用 <a href="https://github.com/redisson/redisson/wiki/8.-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E5%99%A8" target="_blank" rel="noopener">redisson 的解决方案</a>。</p>
<h3 id="23-基于-zookeeper-实现分布式锁"><a class="markdownIt-Anchor" href="#23-基于-zookeeper-实现分布式锁"></a> 2.3. 基于 ZooKeeper 实现分布式锁</h3>
<h4 id="实现-3"><a class="markdownIt-Anchor" href="#实现-3"></a> 实现</h4>
<p>这也是 ZooKeeper 客户端 curator 的分布式锁实现。</p>
<ol>
<li>创建一个目录 mylock；</li>
<li>线程 A 想获取锁就在 mylock 目录下创建临时顺序节点；</li>
<li>获取 mylock 目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；</li>
<li>线程 B 获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；</li>
<li>线程 A 处理完，删除自己的节点，线程 B 监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。</li>
</ol>
<h4 id="小结-3"><a class="markdownIt-Anchor" href="#小结-3"></a> 小结</h4>
<p>ZooKeeper 版本的分布式锁问题相对比较来说少。</p>
<ul>
<li>锁的占用时间限制：redis 就有占用时间限制，而 ZooKeeper 则没有，最主要的原因是 redis 目前没有办法知道已经获取锁的客户端的状态，是已经挂了呢还是正在执行耗时较长的业务逻辑。而 ZooKeeper 通过临时节点就能清晰知道，如果临时节点存在说明还在执行业务逻辑，如果临时节点不存在说明已经执行完毕释放锁或者是挂了。由此看来 redis 如果能像 ZooKeeper 一样添加一些与客户端绑定的临时键，也是一大好事。</li>
<li>是否单点故障：redis 本身有很多中玩法，如客户端一致性 hash，服务器端 sentinel 方案或者 cluster 方案，很难做到一种分布式锁方式能应对所有这些方案。而 ZooKeeper 只有一种玩法，多台机器的节点数据是一致的，没有 redis 的那么多的麻烦因素要考虑。</li>
</ul>
<p>总体上来说 ZooKeeper 实现分布式锁更加的简单，可靠性更高。但 ZooKeeper 因为需要频繁的创建和删除节点，性能上不如 Redis 方式。</p>
<h2 id="3-分布式-session"><a class="markdownIt-Anchor" href="#3-分布式-session"></a> 3. 分布式 Session</h2>
<p>在分布式场景下，一个用户的 Session 如果只存储在一个服务器上，那么当负载均衡器把用户的下一个请求转发到另一个服务器上，该服务器没有用户的 Session，就可能导致用户需要重新进行登录等操作。</p>
<p>分布式 Session 的几种实现策略：</p>
<ol>
<li>粘性 session</li>
<li>应用服务器间的 session 复制共享</li>
<li>基于 cache DB 缓存的 session 共享</li>
</ol>
<h3 id="31-sticky-sessions"><a class="markdownIt-Anchor" href="#31-sticky-sessions"></a> 3.1. Sticky Sessions</h3>
<p>需要配置负载均衡器，使得一个用户的所有请求都路由到一个服务器节点上，这样就可以把用户的 Session 存放在该服务器节点中。</p>
<p>缺点：当服务器节点宕机时，将丢失该服务器节点上的所有 Session。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/MultiNode-StickySessions.jpg" />
</div>
<h3 id="32-session-replication"><a class="markdownIt-Anchor" href="#32-session-replication"></a> 3.2. Session Replication</h3>
<p>在服务器节点之间进行 Session 同步操作，这样的话用户可以访问任何一个服务器节点。</p>
<p>缺点：占用过多内存；同步过程占用网络带宽以及服务器处理器时间。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/MultiNode-SessionReplication.jpg" />
</div>
<h3 id="33-session-server"><a class="markdownIt-Anchor" href="#33-session-server"></a> 3.3. Session Server</h3>
<p>使用一个单独的服务器存储 Session 数据，可以存在 MySQL 数据库上，也可以存在 Redis 或者 Memcached 这种内存型数据库。</p>
<p>缺点：需要去实现存取 Session 的代码。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/MultiNode-SpringSession.jpg" />
</div>
<h2 id="4-分布式存储"><a class="markdownIt-Anchor" href="#4-分布式存储"></a> 4. 分布式存储</h2>
<p>通常有两种解决方案：</p>
<ol>
<li>数据分布：就是把数据分块存在不同的服务器上（分库分表）。</li>
<li>数据复制：让所有的服务器都有相同的数据，提供相当的服务。</li>
</ol>
<blockquote>
<p>参考：<a href="%E5%88%86%E5%B8%83%E5%BC%8F%E5%8E%9F%E7%90%86.md#2-%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83">分布式原理.md#2-数据分布</a></p>
</blockquote>
<h2 id="5-分布式缓存"><a class="markdownIt-Anchor" href="#5-分布式缓存"></a> 5. 分布式缓存</h2>
<p>使用缓存的好处：</p>
<ul>
<li>提升数据读取速度</li>
<li>提升系统扩展能力，通过扩展缓存，提升系统承载能力</li>
<li>降低存储成本，Cache+DB 的方式可以承担原有需要多台 DB 才能承担的请求量，节省机器成本</li>
</ul>
<p>根据业务场景，通常缓存有以下几种使用方式</p>
<ul>
<li>懒汉式(读时触发)：写入 DB 后, 然后把相关的数据也写入 Cache</li>
<li>饥饿式(写时触发)：先查询 DB 里的数据, 然后把相关的数据写入 Cache</li>
<li>定期刷新：适合周期性的跑数据的任务，或者列表型的数据，而且不要求绝对实时性</li>
</ul>
<p>缓存分类：</p>
<ul>
<li>应用内缓存：如：EHCache</li>
<li>分布式缓存：如：Memached、Redis</li>
</ul>
<blockquote>
<p>参考：<a href="%E5%88%86%E5%B8%83%E5%BC%8F%E5%8E%9F%E7%90%86.md#6-%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98">分布式原理.md#6-分布式缓存问题</a></p>
</blockquote>
<h2 id="6-分布式计算"><a class="markdownIt-Anchor" href="#6-分布式计算"></a> 6. 分布式计算</h2>
<h2 id="7-负载均衡"><a class="markdownIt-Anchor" href="#7-负载均衡"></a> 7. 负载均衡</h2>
<h3 id="71-算法"><a class="markdownIt-Anchor" href="#71-算法"></a> 7.1. 算法</h3>
<h4 id="轮询round-robin"><a class="markdownIt-Anchor" href="#轮询round-robin"></a> 轮询（Round Robin）</h4>
<p>轮询算法把每个请求轮流发送到每个服务器上。下图中，一共有 6 个客户端产生了 6 个请求，这 6 个请求按 (1, 2, 3, 4, 5, 6) 的顺序发送。最后，(1, 3, 5) 的请求会被发送到服务器 1，(2, 4, 6) 的请求会被发送到服务器 2。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/负载均衡算法之轮询-01.jpg" width="640"/>
</div>
<p>该算法比较适合每个服务器的性能差不多的场景，如果有性能存在差异的情况下，那么性能较差的服务器可能无法承担过大的负载（下图的 Server 2）。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/负载均衡算法之轮询-02.jpg" width="640"/>
</div>
<h4 id="加权轮询weighted-round-robbin"><a class="markdownIt-Anchor" href="#加权轮询weighted-round-robbin"></a> 加权轮询（Weighted Round Robbin）</h4>
<p>加权轮询是在轮询的基础上，根据服务器的性能差异，为服务器赋予一定的权值。例如下图中，服务器 1 被赋予的权值为 5，服务器 2 被赋予的权值为 1，那么 (1, 2, 3, 4, 5) 请求会被发送到服务器 1，(6) 请求会被发送到服务器 2。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/负载均衡算法之加权轮询.jpg" width="640"/>
</div>
<h4 id="最少连接least-connections"><a class="markdownIt-Anchor" href="#最少连接least-connections"></a> 最少连接（least Connections）</h4>
<p>由于每个请求的连接时间不一样，使用轮询或者加权轮询算法的话，可能会让一台服务器当前连接数过大，而另一台服务器的连接过小，造成负载不均衡。例如下图中，(1, 3, 5) 请求会被发送到服务器 1，但是 (1, 3) 很快就断开连接，此时只有 (5) 请求连接服务器 1；(2, 4, 6) 请求被发送到服务器 2，只有 (2) 的连接断开。该系统继续运行时，服务器 2 会承担过大的负载。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/负载均衡算法之最少连接-01.jpg" width="640"/>
</div>
<p>最少连接算法就是将请求发送给当前最少连接数的服务器上。例如下图中，服务器 1 当前连接数最小，那么新到来的请求 6 就会被发送到服务器 1 上。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/负载均衡算法之最少连接-02.jpg" width="640"/>
</div>
<h4 id="加权最少连接weighted-least-connection"><a class="markdownIt-Anchor" href="#加权最少连接weighted-least-connection"></a> 加权最少连接（Weighted Least Connection）</h4>
<p>在最少连接的基础上，根据服务器的性能为每台服务器分配权重，再根据权重计算出每台服务器能处理的连接数。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/负载均衡算法之加权最少连接.jpg" width="640"/>
</div>
<h4 id="随机算法random"><a class="markdownIt-Anchor" href="#随机算法random"></a> 随机算法（Random）</h4>
<p>把请求随机发送到服务器上。和轮询算法类似，该算法比较适合服务器性能差不多的场景。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/负载均衡算法之随机.jpg" width="640"/>
</div>
<h4 id="源地址哈希法-ip-hash"><a class="markdownIt-Anchor" href="#源地址哈希法-ip-hash"></a> 源地址哈希法 (IP Hash)</h4>
<p>源地址哈希通过对客户端 IP 哈希计算得到的一个数值，用该数值对服务器数量进行取模运算，取模结果便是目标服务器的序号。</p>
<ul>
<li>优点：保证同一 IP 的客户端都会被 hash 到同一台服务器上。</li>
<li>缺点：不利于集群扩展，后台服务器数量变更都会影响 hash 结果。可以采用一致性 Hash 改进。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/负载均衡算法之IpHash.jpg" width="640"/>
</div>
<h3 id="72-实现"><a class="markdownIt-Anchor" href="#72-实现"></a> 7.2. 实现</h3>
<h4 id="http-重定向"><a class="markdownIt-Anchor" href="#http-重定向"></a> HTTP 重定向</h4>
<p>HTTP 重定向负载均衡服务器收到 HTTP 请求之后会返回服务器的地址，并将该地址写入 HTTP 重定向响应中返回给浏览器，浏览器收到后需要再次发送请求。</p>
<p>缺点：</p>
<ul>
<li>用户访问的延迟会增加；</li>
<li>如果负载均衡器宕机，就无法访问该站点。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/Http重定向.png" width="640"/>
</div>
<h4 id="dns-重定向"><a class="markdownIt-Anchor" href="#dns-重定向"></a> DNS 重定向</h4>
<p>使用 DNS 作为负载均衡器，根据负载情况返回不同服务器的 IP 地址。大型网站基本使用了这种方式做为第一级负载均衡手段，然后在内部使用其它方式做第二级负载均衡。</p>
<p>缺点：</p>
<ul>
<li>DNS 查找表可能会被客户端缓存起来，那么之后的所有请求都会被重定向到同一个服务器。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/Dns重定向.png" width="640"/>
</div>
<h4 id="修改-mac-地址"><a class="markdownIt-Anchor" href="#修改-mac-地址"></a> 修改 MAC 地址</h4>
<p>使用 LVS（Linux Virtual Server）这种链路层负载均衡器，根据负载情况修改请求的 MAC 地址。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/修改Mac地址.png" width="640"/>
</div>
<h4 id="修改-ip-地址"><a class="markdownIt-Anchor" href="#修改-ip-地址"></a> 修改 IP 地址</h4>
<p>在网络层修改请求的目的 IP 地址。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/修改IP地址.png" width="640"/>
</div>
<h4 id="代理自动配置"><a class="markdownIt-Anchor" href="#代理自动配置"></a> 代理自动配置</h4>
<p>正向代理与反向代理的区别：</p>
<ul>
<li>正向代理：发生在客户端，是由用户主动发起的。比如翻墙，客户端通过主动访问代理服务器，让代理服务器获得需要的外网数据，然后转发回客户端。</li>
<li>反向代理：发生在服务器端，用户不知道代理的存在。</li>
</ul>
<p>PAC 服务器是用来判断一个请求是否要经过代理。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/代理自动配置.jpg" width="640"/>
</div>
<h2 id="8-资料"><a class="markdownIt-Anchor" href="#8-资料"></a> 8. 资料</h2>
<ul>
<li><a href="https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html" target="_blank" rel="noopener">https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html</a></li>
<li><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90.md" target="_blank" rel="noopener">https://github.com/CyC2018/Interview-Notebook/blob/master/notes/分布式问题分析.md</a></li>
<li><a href="https://www.jianshu.com/p/453c6e7ff81c" target="_blank" rel="noopener">https://www.jianshu.com/p/453c6e7ff81c</a></li>
<li><a href="https://juejin.im/post/5a20cd8bf265da43163cdd9a" target="_blank" rel="noopener">https://juejin.im/post/5a20cd8bf265da43163cdd9a</a></li>
<li><a href="https://github.com/redisson/redisson/wiki/8.-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E5%99%A8" target="_blank" rel="noopener">https://github.com/redisson/redisson/wiki/8.-分布式锁和同步器</a></li>
<li><a href="https://github.com/L316476844/distributed-session" target="_blank" rel="noopener">https://github.com/L316476844/distributed-session</a></li>
<li><a href="https://juejin.im/entry/57e39e320e3dd90058021bff" target="_blank" rel="noopener">分布式缓存架构基础</a></li>
<li><a href="https://www.toutiao.com/i6533812974807679495/?tt_from=weixin&amp;utm_campaign=client_share&amp;from=singlemessage&amp;timestamp=1521281305&amp;app=news_article&amp;utm_source=weixin&amp;iid=28128279343&amp;utm_medium=toutiao_android&amp;weixin_list=1&amp;wxshare_count=2&amp;pbid=6517746516513195523" target="_blank" rel="noopener">阿里 P8 技术专家细究分布式缓存问题</a></li>
</ul>
]]></content>
      <categories>
        <category>设计</category>
        <category>架构</category>
      </categories>
      <tags>
        <tag>设计</tag>
        <tag>架构</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>负载均衡基本原理</title>
    <url>/blog/design/theory/load-balance-theory/</url>
    <content><![CDATA[<h1 id="负载均衡基本原理"><a class="markdownIt-Anchor" href="#负载均衡基本原理"></a> 负载均衡基本原理</h1>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#1-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%80%E4%BB%8B">1. 负载均衡简介</a>
<ul>
<li><a href="#11-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E4%BD%9C%E7%94%A8">1.1. 负载均衡的作用</a></li>
<li><a href="#12-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E5%88%86%E7%B1%BB">1.2. 负载均衡的分类</a></li>
</ul>
</li>
<li><a href="#2-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95">2. 负载均衡算法</a>
<ul>
<li><a href="#21-%E8%BD%AE%E8%AF%A2">2.1. 轮询</a></li>
<li><a href="#22-%E9%9A%8F%E6%9C%BA">2.2. 随机</a></li>
<li><a href="#23-%E6%9C%80%E5%B0%91%E8%BF%9E%E6%8E%A5">2.3. 最少连接</a></li>
<li><a href="#24-%E6%BA%90%E5%9C%B0%E5%9D%80%E5%93%88%E5%B8%8C">2.4. 源地址哈希</a></li>
<li><a href="#25-%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C">2.5. 一致性哈希</a></li>
</ul>
</li>
<li><a href="#3-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%8A%80%E6%9C%AF">3. 负载均衡技术</a>
<ul>
<li><a href="#31-dns-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">3.1. DNS 负载均衡</a></li>
<li><a href="#32-http-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">3.2. HTTP 负载均衡</a></li>
<li><a href="#33-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86">3.3. 反向代理</a></li>
<li><a href="#34-%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E5%8F%91">3.4. 网络地址转发</a></li>
<li><a href="#35-%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF">3.5. 隧道技术</a></li>
<li><a href="#36-%E7%9B%B4%E6%8E%A5%E8%B7%AF%E7%94%B1">3.6. 直接路由</a></li>
<li><a href="#37-%E6%B7%B7%E5%90%88%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">3.7. 混合负载均衡</a></li>
</ul>
</li>
<li><a href="#4-%E6%9C%AF%E8%AF%AD">4. 术语</a></li>
<li><a href="#5-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">5. 参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="1-负载均衡简介"><a class="markdownIt-Anchor" href="#1-负载均衡简介"></a> 1. 负载均衡简介</h2>
<h3 id="11-负载均衡的作用"><a class="markdownIt-Anchor" href="#11-负载均衡的作用"></a> 1.1. 负载均衡的作用</h3>
<p>负载均衡（Load Balance，简称 LB）是高可用基础架构的关键组件，通常 <strong>用于将网络流量分发到多个服务器上，以提高应用的响应速度和可用性</strong>。</p>
<p>系统的扩展可分为垂直扩展和水平扩展。</p>
<ul>
<li><strong>垂直扩展</strong>，是从单机的角度通过<strong>增加硬件处理能力</strong>，比如 CPU 处理能力，内存容量，磁盘等方面，实现服务器处理能力的提升。这种方式不能满足大型分布式系统（网站），大流量，高并发，海量数据的问题。</li>
<li><strong>水平扩展</strong>，是通过<strong>添加机器</strong>来满足大型网站服务的处理能力。比如：一台机器不能满足，则增加两台或者多台机器，共同承担访问压力。
<ul>
<li>应用集群：将同一应用部署到多台机器上，组成处理集群，接收负载均衡设备分发的请求，进行处理，并返回相应数据。</li>
<li>负载均衡设备：将用户访问的请求，根据负载均衡算法，分发到集群中的一台处理服务器。（一种把网络请求分散到一个服务器集群中的可用服务器上去的设备）</li>
</ul>
</li>
</ul>
<p>负载均衡的作用：</p>
<ul>
<li><strong>高并发</strong> - 负载均衡通过调整负载，尽力让应用集群中的节点工作量达到均匀，以此提高应用集群的并发处理能力（吞吐量）。</li>
<li><strong>伸缩性</strong> - 添加或减少服务器数量，然后由负载均衡进行分发控制。这使得应用集群具备伸缩性。</li>
<li><strong>故障转移</strong> - 负载均衡器可以监控候选服务器，当服务器不可用时，自动跳过，将请求分发给可用的服务器。这使得应用集群具备高可用的特性。</li>
<li><strong>安全防护</strong> - 有些负载均衡软件或硬件提供了安全性功能，如：黑白名单处理、防火墙，防 DDos 攻击等。</li>
</ul>
<h3 id="12-负载均衡的分类"><a class="markdownIt-Anchor" href="#12-负载均衡的分类"></a> 1.2. 负载均衡的分类</h3>
<p>负载均衡大致可以分为两大类：</p>
<ul>
<li>软件负载均衡</li>
<li>硬件负载均衡</li>
</ul>
<h4 id="软件负载均衡"><a class="markdownIt-Anchor" href="#软件负载均衡"></a> 软件负载均衡</h4>
<p>软件负载均衡，应用最为广泛，无论大公司还是小公司都会使用。</p>
<p>软件负载均衡从软件层面实现负载均衡，一般可以在任何标准物理设备上运行。</p>
<p>软件负载均衡的 <strong>主流产品</strong> 有：<a href="https://www.nginx.com/" target="_blank" rel="noopener">Nginx</a>、<a href="http://www.haproxy.org/" target="_blank" rel="noopener">HAProxy</a>、<a href="https://github.com/alibaba/LVS" target="_blank" rel="noopener">LVS</a>。</p>
<ul>
<li><a href="https://github.com/alibaba/LVS" target="_blank" rel="noopener">LVS</a> 可以作为四层负载均衡器。其负载均衡的性能要优于 Nginx。</li>
<li><a href="http://www.haproxy.org/" target="_blank" rel="noopener">HAProxy</a> 可以作为 HTTP 和 TCP 负载均衡器。</li>
<li><a href="https://www.nginx.com/" target="_blank" rel="noopener">Nginx</a>、<a href="http://www.haproxy.org/" target="_blank" rel="noopener">HAProxy</a> 可以作为四层或七层负载均衡器。</li>
</ul>
<p>软件负载均衡的 <strong>优点</strong>：</p>
<ul>
<li><strong>扩展性好</strong> - 适应动态变化，可以通过添加软件负载均衡实例，动态扩展到超出初始容量的能力。</li>
<li><strong>成本低廉</strong> - 软件负载均衡可以在任何标准物理设备上运行，降低了购买和运维的成本。</li>
</ul>
<p>软件负载均衡的 <strong>缺点</strong>：</p>
<ul>
<li><strong>性能略差</strong> - 相比于硬件负载均衡，软件负载均衡的性能要略低一些。</li>
</ul>
<p>软件负载负载均衡从通信层面来看，又可以分为四层和七层负载均衡。</p>
<ul>
<li>四层负载均衡 - 基于 IP 地址和端口进行请求的转发。</li>
<li>七层负载均衡 - 就是可以根据访问用户的 HTTP 请求头、URL 信息将请求转发到特定的主机。</li>
</ul>
<h4 id="硬件负载均衡"><a class="markdownIt-Anchor" href="#硬件负载均衡"></a> 硬件负载均衡</h4>
<p>硬件负载均衡，一般是在定制处理器上运行的独立负载均衡服务器，价格昂贵，土豪专属。</p>
<p>硬件负载均衡的 <strong>主流产品</strong> 有：<a href="https://f5.com/zh" target="_blank" rel="noopener">F5</a> 和 <a href="https://www.a10networks.com.cn/" target="_blank" rel="noopener">A10</a>。</p>
<p>硬件负载均衡的 <strong>优点</strong>：</p>
<ul>
<li><strong>功能强大</strong> - 支持全局负载均衡并提供较全面的、复杂的负载均衡算法。</li>
<li><strong>性能强悍</strong> - 硬件负载均衡由于是在专用处理器上运行，因此吞吐量大，可支持单机百万以上的并发。</li>
<li><strong>安全性高</strong> - 往往具备防火墙，防 DDos 攻击等安全功能。</li>
</ul>
<p>硬件负载均衡的 <strong>缺点</strong>：</p>
<ul>
<li><strong>成本昂贵</strong> - 购买和维护硬件负载均衡的成本都很高。</li>
<li><strong>扩展性差</strong> - 当访问量突增时，超过限度不能动态扩容。</li>
</ul>
<h2 id="2-负载均衡算法"><a class="markdownIt-Anchor" href="#2-负载均衡算法"></a> 2. 负载均衡算法</h2>
<p>负载均衡产品多种多样，但是各种负载均衡算法原理是共性的。</p>
<p>负载均衡算法有很多种，分别适用于不同的应用场景，本文仅介绍最为常见的负载均衡算法的特性及原理：轮询、随机、最少连接、一致性 Hash。</p>
<h3 id="21-轮询"><a class="markdownIt-Anchor" href="#21-轮询"></a> 2.1. 轮询</h3>
<p><strong><code>轮询（Round Robin）</code></strong> 算法 <strong>将请求依次分发到候选服务器</strong>。</p>
<ul>
<li>特点：<strong>请求完全均匀分发</strong>，即服务器请求被完全均匀的分发到集群的各节点上。</li>
<li>场景：<strong>适合服务器硬件相同的场景</strong>。</li>
</ul>
<p>下图中，一共有 6 个客户端产生了 6 个请求，这 6 个请求按 (1, 2, 3, 4, 5, 6) 的顺序发送。最后，(1, 3, 5) 的请求会被发送到服务器 1，(2, 4, 6) 的请求会被发送到服务器 2。</p>
<p><img src="http://dunwu.test.upcdn.net/cs/design/architecture/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E4%B9%8B%E8%BD%AE%E8%AF%A2-01.jpg" alt="img" /></p>
<p>该算法比较适合每个服务器的性能差不多的场景，如果有性能存在差异的情况下，那么性能较差的服务器可能无法承担过大的负载（下图的 Server 2）。</p>
<p><img src="http://dunwu.test.upcdn.net/cs/design/architecture/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E4%B9%8B%E8%BD%AE%E8%AF%A2-02.jpg" alt="img" /></p>
<p>节点存储结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;V&gt; nodeList = Collections.emptyList();</span><br></pre></td></tr></table></figure>
<p>算法实现示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtil.isEmpty(<span class="keyword">this</span>.nodeList)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size = <span class="keyword">this</span>.nodeList.size();</span><br><span class="line">    offset.compareAndSet(size, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> nodeList.get(offset.getAndIncrement());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="加权轮询"><a class="markdownIt-Anchor" href="#加权轮询"></a> 加权轮询</h4>
<p><strong><code>加权轮询（Weighted Round Robbin）</code></strong> 算法在轮询算法的基础上，增加了权重属性。性能高、处理速度快的机器应该设置更高的权重，使得分发时优先将请求分发到权重较高的服务器上。</p>
<ul>
<li>优点：根据权重，调节转发服务器的请求数目。</li>
<li>缺点：比轮询算法复杂。</li>
</ul>
<p>加权轮询是在轮询的基础上，根据服务器的性能差异，为服务器赋予一定的权值。例如下图中，服务器 1 被赋予的权值为 5，服务器 2 被赋予的权值为 1，那么 (1, 2, 3, 4, 5) 请求会被发送到服务器 1，(6) 请求会被发送到服务器 2。</p>
<p><img src="http://dunwu.test.upcdn.net/cs/design/architecture/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8A%A0%E6%9D%83%E8%BD%AE%E8%AF%A2.jpg" alt="img" /></p>
<p>节点存储结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// key 存储实际节点内容，value 存储节点的权重</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;V, Integer&gt; nodeMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>算法实现示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (MapUtil.isEmpty(nodeMap)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> totalWeight = nodeMap.values().stream().mapToInt(a -&gt; a).sum();</span><br><span class="line">    <span class="keyword">int</span> number = offset.getAndIncrement() % totalWeight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;V, Integer&gt; item : nodeMap.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (item.getValue() &gt; number) &#123;</span><br><span class="line">            <span class="keyword">return</span> item.getKey();</span><br><span class="line">        &#125;</span><br><span class="line">        number -= item.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="22-随机"><a class="markdownIt-Anchor" href="#22-随机"></a> 2.2. 随机</h3>
<p><strong><code>随机（Random）</code></strong> 算法 <strong>将请求随机分发到候选服务器</strong>。</p>
<ul>
<li>特点：调用量较小的时候，可能负载并不均匀，<strong>调用量越大，负载越均衡</strong>。</li>
<li>场景：<strong>适合服务器硬件相同的场景</strong>。</li>
</ul>
<p><img src="http://dunwu.test.upcdn.net/cs/design/architecture/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E4%B9%8B%E9%9A%8F%E6%9C%BA.jpg" alt="img" /></p>
<p>节点存储结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;V&gt; nodeList = Collections.emptyList();</span><br></pre></td></tr></table></figure>
<p>算法实现示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtil.isEmpty(<span class="keyword">this</span>.nodeList)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> offset = random.nextInt(nodeList.size());</span><br><span class="line">    <span class="keyword">return</span> nodeList.get(offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="加权随机"><a class="markdownIt-Anchor" href="#加权随机"></a> 加权随机</h4>
<p><strong><code>加权随机（Weighted Random）</code></strong> 算法在随机算法的基础上，按照概率调整权重，进行负载分配。</p>
<p>节点存储结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// key 存储实际节点内容，value 存储节点的权重</span></span><br><span class="line">Map&lt;V, Integer&gt; nodeMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>算法实现示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (MapUtil.isEmpty(keyWeightMap)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;V&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;V, Integer&gt; item : keyWeightMap.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; item.getValue(); i++) &#123;</span><br><span class="line">            list.add(item.getKey());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> totalWeight = keyWeightMap.values().stream().mapToInt(a -&gt; a).sum();</span><br><span class="line">    <span class="keyword">int</span> number = random.nextInt(totalWeight);</span><br><span class="line">    <span class="keyword">return</span> list.get(number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="23-最少连接"><a class="markdownIt-Anchor" href="#23-最少连接"></a> 2.3. 最少连接</h3>
<p><strong><code>最少连接（Least Connection）</code></strong> 算法 <strong>将请求分发到连接数最少的候选服务器</strong>（目前处理请求最少的服务器）。</p>
<ul>
<li>特点：根据候选服务器当前的请求连接数，动态分配。</li>
<li>场景：<strong>适用于对系统负载较为敏感或请求连接时长相差较大的场景</strong>。</li>
</ul>
<p>由于每个请求的连接时长不一样，如果采用简单的轮循或随机算法，都可能出现<strong>某些服务器当前连接数过大，而另一些服务器的连接过小</strong>的情况，这就造成了负载并非真正均衡。虽然，轮询或算法都可以通过加权重属性的方式进行负载调整，但加权方式难以应对动态变化。</p>
<p>例如下图中，(1, 3, 5) 请求会被发送到服务器 1，但是 (1, 3) 很快就断开连接，此时只有 (5) 请求连接服务器 1；(2, 4, 6) 请求被发送到服务器 2，只有 (2) 的连接断开。该系统继续运行时，服务器 2 会承担过大的负载。</p>
<p><img src="http://dunwu.test.upcdn.net/cs/design/architecture/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E4%B9%8B%E6%9C%80%E5%B0%91%E8%BF%9E%E6%8E%A5-01.jpg" alt="img" /></p>
<p>最少连接算法会记录当前时刻，每个候选节点正在处理的连接数，然后选择连接数最小的节点。该策略能够动态、实时地反应服务器的当前状况，较为合理地将负责分配均匀，适用于对当前系统负载较为敏感的场景。</p>
<p>例如下图中，服务器 1 当前连接数最小，那么新到来的请求 6 就会被发送到服务器 1 上。</p>
<p><img src="http://dunwu.test.upcdn.net/cs/design/architecture/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E4%B9%8B%E6%9C%80%E5%B0%91%E8%BF%9E%E6%8E%A5-02.jpg" alt="img" /></p>
<h4 id="加权最少连接"><a class="markdownIt-Anchor" href="#加权最少连接"></a> 加权最少连接</h4>
<p>加权最少连接（Weighted Least Connection）在最少连接的基础上，根据服务器的性能为每台服务器分配权重，再根据权重计算出每台服务器能处理的连接数。</p>
<p><img src="http://dunwu.test.upcdn.net/cs/design/architecture/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8A%A0%E6%9D%83%E6%9C%80%E5%B0%91%E8%BF%9E%E6%8E%A5.jpg" alt="img" /></p>
<h3 id="24-源地址哈希"><a class="markdownIt-Anchor" href="#24-源地址哈希"></a> 2.4. 源地址哈希</h3>
<p>**<code>源地址哈希（IP Hash）</code>**算法 <strong>根据请求源 IP，通过哈希计算得到一个数值，用该数值在候选服务器列表的进行取模运算，得到的结果便是选中的服务器</strong>。</p>
<ul>
<li>特点：保证特定用户总是请求到相同的服务器，若服务器宕机，会话会丢失。</li>
<li>场景：会话粘滞。</li>
</ul>
<p><img src="http://dunwu.test.upcdn.net/cs/design/architecture/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E4%B9%8BIpHash.jpg" alt="img" /></p>
<p>算法示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">select</span><span class="params">(<span class="keyword">final</span> String key)</span> </span>&#123;</span><br><span class="line">    List&lt;V&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(nodes);</span><br><span class="line">    <span class="keyword">int</span> hashCode = key.hashCode();</span><br><span class="line">    <span class="keyword">int</span> idx = hashCode % list.size();</span><br><span class="line">    <span class="keyword">return</span> list.get(Math.abs(idx));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="25-一致性哈希"><a class="markdownIt-Anchor" href="#25-一致性哈希"></a> 2.5. 一致性哈希</h3>
<p>一致性哈希（Consistent Hash）算法的目标是：<strong>相同的请求尽可能落到同一个服务器上</strong>。</p>
<ul>
<li>相同的请求是指：一般在使用一致性哈希时，需要指定一个 key 用于 hash 计算，可能是：
<ul>
<li>用户 ID</li>
<li>请求方 IP</li>
<li>请求服务名称，参数列表构成的串</li>
</ul>
</li>
<li>尽可能是指：服务器可能发生上下线，少数服务器的变化不应该影响大多数的请求。</li>
</ul>
<p>当某台候选服务器宕机时，原本发往该服务器的请求，会基于虚拟节点，平摊到其它候选服务器，不会引起剧烈变动。</p>
<p>一致性哈希算法示例：</p>
<ul>
<li>构建虚拟 Hash 环</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> VIRTUAL_NODE_SIZE = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String VIRTUAL_NODE_SUFFIX = <span class="string">"&amp;&amp;"</span>;</span><br><span class="line"><span class="keyword">private</span> Set&lt;V&gt; nodes = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(collection);</span><br><span class="line"><span class="keyword">private</span> TreeMap&lt;Integer, V&gt; hashRing = buildConsistentHashRing(<span class="keyword">this</span>.nodes);</span><br><span class="line"></span><br><span class="line"><span class="function">TreeMap&lt;Integer, V&gt; <span class="title">buildConsistentHashRing</span><span class="params">(Set&lt;V&gt; nodes)</span> </span>&#123;</span><br><span class="line">    TreeMap&lt;Integer, V&gt; hashRing = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (V node : nodes) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; VIRTUAL_NODE_SIZE; i++) &#123;</span><br><span class="line">            <span class="comment">// 新增虚拟节点的方式如果有影响，也可以抽象出一个由物理节点扩展虚拟节点的类</span></span><br><span class="line">            hashRing.put(hashStrategy.hashCode(node + VIRTUAL_NODE_SUFFIX + i), node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hashRing;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心算法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">select</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hashCode = hashStrategy.hashCode(key);</span><br><span class="line">    <span class="comment">// 向右找到第一个 key</span></span><br><span class="line">    Map.Entry&lt;Integer, V&gt; entry = hashRing.ceilingEntry(hashCode);</span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 想象成一个环，超过尾部则取第一个 key</span></span><br><span class="line">        entry = hashRing.firstEntry();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-负载均衡技术"><a class="markdownIt-Anchor" href="#3-负载均衡技术"></a> 3. 负载均衡技术</h2>
<p>根据实现技术不同，可分划分如下：</p>
<ul>
<li>七层负载均衡
<ul>
<li>DNS 重定向</li>
<li>HTTP 重定向</li>
<li>反向代理</li>
</ul>
</li>
<li>四层负载均衡
<ul>
<li>修改 IP 地址</li>
<li>修改 MAC 地址</li>
</ul>
</li>
</ul>
<h3 id="31-dns-负载均衡"><a class="markdownIt-Anchor" href="#31-dns-负载均衡"></a> 3.1. DNS 负载均衡</h3>
<p>DNS 负载均衡一般用于互联网公司，复杂的业务系统不适合使用。大型网站一般使用 DNS 负载均衡作为 <strong>第一级负载均衡手段</strong>，然后在内部使用其它方式做第二级负载均衡。DNS 负载均衡属于七层负载均衡。</p>
<p>DNS 即 <strong>域名解析服务</strong>，是 OSI 第七层网络协议。DNS 被设计为一个树形结构的分布式应用，自上而下依次为：根域名服务器，一级域名服务器，二级域名服务器，… ，本地域名服务器。显然，如果所有数据都存储在根域名服务器，那么 DNS 查询的负载和开销会非常庞大。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200125143248.png" alt="img" /></p>
<p>因此，DNS 查询相对于 DNS 层级结构，是一个逆向的递归流程，DNS 客户端依次请求本地 DNS 服务器，上一级 DNS 服务器，上上一级 DNS 服务器，… ，根 DNS 服务器（又叫权威 DNS 服务器），一旦命中，立即返回。为了减少查询次数，每一级 DNS 服务器都会设置 DNS 查询缓存。</p>
<p>DNS 负载均衡的工作原理就是：<strong>基于 DNS 查询缓存，按照负载情况返回不同服务器的 IP 地址</strong>。</p>
<p><img src="http://dunwu.test.upcdn.net/cs/design/architecture/Dns%E9%87%8D%E5%AE%9A%E5%90%91.png" alt="img" /></p>
<p>DNS 重定向的 <strong>优点</strong>：</p>
<ul>
<li><strong>使用简单</strong> - 负载均衡工作，交给 DNS 服务器处理，省掉了负载均衡服务器维护的麻烦</li>
<li><strong>提高性能</strong> - 可以支持基于地址的域名解析，解析成距离用户最近的服务器地址（类似 CDN 的原理），可以加快访问速度，改善性能；</li>
</ul>
<p>DNS 重定向的 <strong>缺点</strong>：</p>
<ul>
<li><strong>可用性差</strong> - DNS 解析是多级解析，新增/修改 DNS 后，解析时间较长；解析过程中，用户访问网站将失败；</li>
<li><strong>扩展性低</strong> - DNS 负载均衡的控制权在域名商那里，无法对其做更多的改善和扩展；</li>
<li><strong>维护性差</strong> - 也不能反映服务器的当前运行状态；支持的算法少；不能区分服务器的差异（不能根据系统与服务的状态来判断负载）</li>
</ul>
<h3 id="32-http-负载均衡"><a class="markdownIt-Anchor" href="#32-http-负载均衡"></a> 3.2. HTTP 负载均衡</h3>
<p><strong>HTTP 负载均衡是基于 HTTP 重定向实现的</strong>。HTTP 负载均衡属于七层负载均衡。</p>
<p>HTTP 重定向原理是：<strong>根据用户的 HTTP 请求计算出一个真实的服务器地址，将该服务器地址写入 HTTP 重定向响应中，返回给浏览器，由浏览器重新进行访问</strong>。</p>
<p><img src="http://dunwu.test.upcdn.net/cs/design/architecture/Http%E9%87%8D%E5%AE%9A%E5%90%91.png" alt="img" /></p>
<p>HTTP 重定向的 <strong>优点</strong>：<strong>方案简单</strong>。</p>
<p>HTTP 重定向的 <strong>缺点</strong>：</p>
<ul>
<li><strong>性能较差</strong> - 每次访问需要两次请求服务器，增加了访问的延迟。</li>
<li><strong>降低搜索排名</strong> - 使用重定向后，搜索引擎会视为 SEO 作弊。</li>
<li>如果负载均衡器宕机，就无法访问该站点。</li>
</ul>
<p>由于其缺点比较明显，所以这种负载均衡策略实际应用较少。</p>
<h3 id="33-反向代理"><a class="markdownIt-Anchor" href="#33-反向代理"></a> 3.3. 反向代理</h3>
<p>反向代理（Reverse Proxy）方式是指以 <strong>代理服务器</strong> 来接受网络请求，然后 <strong>将请求转发给内网中的服务器</strong>，并将从内网中的服务器上得到的结果返回给网络请求的客户端。反向代理负载均衡属于七层负载均衡。</p>
<p><img src="http://dunwu.test.upcdn.net/cs/design/architecture/%E4%BB%A3%E7%90%86%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE.png" alt="img" /></p>
<p>反向代理服务的主流产品：Nginx、Apache。</p>
<p>正向代理与反向代理有什么区别？</p>
<ul>
<li>正向代理：发生在 <strong>客户端</strong>，是由用户主动发起的。翻墙软件就是典型的正向代理，客户端通过主动访问代理服务器，让代理服务器获得需要的外网数据，然后转发回客户端。</li>
<li>反向代理：发生在 <strong>服务端</strong>，用户不知道代理的存在。</li>
</ul>
<p><img src="http://dunwu.test.upcdn.net/cs/web/nginx/reverse-proxy.png" alt="img" /></p>
<p>反向代理的 <strong>优点</strong>：</p>
<ul>
<li><strong>多种负载均衡算法</strong> - 支持多种负载均衡算法，以应对不同的场景需求。</li>
<li><strong>可以监控服务器</strong> - 基于 HTTP 协议，可以监控转发服务器的状态，如：系统负载、响应时间、是否可用、连接数、流量等，从而根据这些数据调整负载均衡的策略。</li>
</ul>
<p>反向代理的 <strong>缺点</strong>：</p>
<ul>
<li>
<p><strong>额外的转发开销</strong> - 反向代理的转发操作本身是有性能开销的，可能会包括，创建连接，等待连接响应，分析响应结果等操作。</p>
</li>
<li>
<p><strong>增加系统复杂度</strong> - 反向代理常用于做分布式应用的水平扩展，但反向代理服务存在以下问题，为了解决以下问题会给系统整体增加额外的复杂度和运维成本：</p>
<ul>
<li>反向代理服务如果宕机，就无法访问站点，所以需要有 <strong>高可用</strong> 方案，常见的方案有：主备模式（一主一备）、双主模式（互为主备）。</li>
<li>反向代理服务自身也存在性能瓶颈，随着需要转发的请求量不断攀升，需要有 <strong>可扩展</strong> 方案。</li>
</ul>
</li>
</ul>
<h3 id="34-网络地址转发"><a class="markdownIt-Anchor" href="#34-网络地址转发"></a> 3.4. 网络地址转发</h3>
<p><strong><code>网络地址转发（Network Address Translation，简称 NAT）</code></strong> 是指 <strong>通过修改目的 IP 地址实现负载均衡</strong>。NAT 属于四层负载均衡。</p>
<p>NAT 工作原理：</p>
<ul>
<li>用户请求数据包到达 LB 后，LB 在操作系统内核进程获取网络数据包。</li>
<li>LB 器根据负载均衡算法得到 RIP，并将请求目的地址修改为 RIP，不需要经过用户进程处理。然后，将请求发送给 RS。</li>
<li>RS 处理完成请求后，将响应数据包返回到 LB。</li>
<li>LB 再将数据包源地址修改为自身的 IP 地址，发送给用户浏览器。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200125131843.png" alt="img" /></p>
<p>NAT 的 <strong>优点</strong>：在内核进程完成数据分发，比在应用层分发 <strong>性能更好</strong>；</p>
<p>NAT 的 <strong>缺点</strong>：所有请求响应都需要经过负载均衡服务器，集群 <strong>最大吞吐量受限于负载均衡服务器网卡带宽</strong>；</p>
<p>网络层负载均衡主流的产品是：</p>
<ul>
<li><a href="https://github.com/alibaba/LVS" target="_blank" rel="noopener">LVS</a> 的 NAT 模式。</li>
<li>HAProxy 的 TCP 四层负载均衡。</li>
</ul>
<p>在 NAT 模式下，HAProxy 使用比 LVS 更方便。</p>
<h3 id="35-隧道技术"><a class="markdownIt-Anchor" href="#35-隧道技术"></a> 3.5. 隧道技术</h3>
<p><strong><code>隧道技术（ IP Tunneling，简称 TUN）</code></strong> 是指：采用 NAT 模式时，由于请求和响应的报文必须通过负载均衡器重写地址，当客户请求越来越多时，负载均衡器处理能力将成为瓶颈。为了解决这个问题，负载均衡器把请求的报文<strong>通过 IP 隧道转发到真实的服务器</strong>。真实的服务器将响应处理后的数据直接返回给客户端。这样负载均衡器就只需处理请求报文。</p>
<p>TUN 工作原理：</p>
<ul>
<li>客户请求数据包，根据目标地址 VIP 发送到 LB 上。</li>
<li>LB 接收到客户请求包，根据负载均衡算法计算出分发的 RS。</li>
<li>然后，进行 IP Tunnel 封装。即在原有的请求包上封装 IP Tunnel 的包头。然后发送出去。</li>
<li>RS 根据 IP Tunnel 包头信息（此时就又一种逻辑上的隐形隧道，只有 LB 和 RS 之间懂）收到请求包，然后解开 IP Tunnel 包头信息，得到客户的请求包并进行响应处理。</li>
<li>响应处理完毕之后，RS 使用自己的出公网的线路，将这个响应数据包发送给客户端。源 IP 地址还是 VIP 地址。</li>
</ul>
<h3 id="36-直接路由"><a class="markdownIt-Anchor" href="#36-直接路由"></a> 3.6. 直接路由</h3>
<p><strong><code>直接路由（Direct Routing，简称 DR）</code></strong> 是指 <strong>通过修改目的 MAC 地址实现负载均衡</strong>。DR 属于四层负载均衡。</p>
<p>DR 工作原理：</p>
<ul>
<li>客户请求数据包到达 LB 后，LB 根据调度算法选出一台 RS，将数据帧的 MAC 地址改写为 RS 的 MAC 地址，然后发送出去。</li>
<li>交换机会根据 MAC 地址将数据封包发送给 RS，RS 将处理完的结果直接返回给客户端。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200125131811.png" alt="img" /></p>
<p>数据链路层负载均衡主流的产品是：<a href="https://github.com/alibaba/LVS" target="_blank" rel="noopener">LVS</a> 的 DR 模式。</p>
<p>DR 的 <strong>优点</strong>：</p>
<ul>
<li>不需要负载均衡服务器进行地址的转换。</li>
<li>数据响应时不需要经过负载均衡服务器，性能高于 NAT。</li>
</ul>
<p>DR 的 <strong>缺点</strong>：</p>
<ul>
<li>对网卡带宽要求较高。</li>
<li>提供服务的端口必须一致。VIP 的端口对外端口为 80，但后端服务的真实端口为 8080，通过 LVS 的 DR 模式无法实现。</li>
<li>LVS 和真实服务器必须在同一网络。</li>
</ul>
<h3 id="37-混合负载均衡"><a class="markdownIt-Anchor" href="#37-混合负载均衡"></a> 3.7. 混合负载均衡</h3>
<p>混合负载均衡就是集各家之所长，让不同的负载均衡技术在合适的场景发挥作用。</p>
<p>由于多个服务器群内硬件设备、各自的规模、提供的服务等的差异，可以考虑给每个服务器群采用最合适的负载均衡方式，然后又在这多个服务器群间再一次负载均衡或群集起来以一个整体向外界提供服务（即把这多个服务器群当做一个新的服务器群），从而达到最佳的性能。将这种方式称之为混合型负载均衡。</p>
<p>此种方式有时也用于单台均衡设备的性能不能满足大量连接请求的情况下。是目前大型互联网公司，普遍使用的方式。</p>
<p>方式一，如下图：</p>
<p><img src="https://images2015.cnblogs.com/blog/820332/201512/820332-20151213200106747-94797427.png" alt="img" /></p>
<p>以上模式适合有动静分离的场景，反向代理服务器（集群）可以起到缓存和动态请求分发的作用，当时静态资源缓存在代理服务器时，则直接返回到浏览器。如果动态页面则请求后面的应用负载均衡（应用集群）。</p>
<p>方式二，如下图：</p>
<p><img src="https://images2015.cnblogs.com/blog/820332/201512/820332-20151213200117825-1452672107.png" alt="img" /></p>
<p>以上模式，适合动态请求场景。</p>
<p>因混合模式，可以根据具体场景，灵活搭配各种方式，以上两种方式仅供参考。</p>
<h2 id="4-术语"><a class="markdownIt-Anchor" href="#4-术语"></a> 4. 术语</h2>
<ul>
<li>LB - Load Balancer，即负载均衡器。</li>
<li>RS - Real Server，即真实服务器。</li>
<li>RIP - Real Server IP，即真实服务器 IP。</li>
<li>VIP - Virtual IP，即虚拟 IP，是外部直接面向用户请求，作为用户请求的目标 IP 地址。</li>
<li>DIP - Director Server IP，即直连服务器 IP，主要用于和内部主机通信的 IP 地址。</li>
<li>CIP - Client IP，即客户端 IP。</li>
<li>NAT - Network Address Translation，即网络地址转发。</li>
<li>TUN - IP Tunneling，即 IP 隧道技术。</li>
<li>DR - Direct Routing，即直接路由。</li>
</ul>
<h2 id="5-参考资料"><a class="markdownIt-Anchor" href="#5-参考资料"></a> 5. 参考资料</h2>
<ul>
<li><a href="https://item.jd.com/11322972.html" target="_blank" rel="noopener">《大型网站技术架构：核心原理与案例分析》</a></li>
<li><a href="https://www.cnblogs.com/itfly8/p/5043435.html" target="_blank" rel="noopener">大型网站架构系列：负载均衡详解（1）</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/32841479" target="_blank" rel="noopener">什么是负载均衡</a></li>
<li><a href="https://avinetworks.com/what-is-load-balancing/" target="_blank" rel="noopener">What Is Load Balancing</a></li>
<li><a href="https://segmentfault.com/a/1190000004492447" target="_blank" rel="noopener">负载均衡算法及手段</a></li>
<li><a href="https://dubbo.apache.org/zh-cn/docs/source_code_guide/loadbalance.html" target="_blank" rel="noopener">Dubbo 负载均衡实现</a></li>
<li><a href="https://segmentfault.com/a/1190000002578457" target="_blank" rel="noopener">利用 dns 解析来实现网站的负载均衡</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/31777732" target="_blank" rel="noopener">原理上搞懂 LVS 的 DR 和 NAT 模式的缺陷，不看小心踩坑</a></li>
<li><a href="https://www.cnblogs.com/liwei0526vip/p/6370103.html" target="_blank" rel="noopener">使用 LVS 实现负载均衡原理及安装配置详解</a></li>
</ul>
]]></content>
      <categories>
        <category>设计</category>
        <category>系统原理</category>
      </categories>
      <tags>
        <tag>设计</tag>
        <tag>系统原理</tag>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title>伸缩性架构</title>
    <url>/blog/design/architecture/scalable-architecture/</url>
    <content><![CDATA[<h1 id="伸缩性架构"><a class="markdownIt-Anchor" href="#伸缩性架构"></a> 伸缩性架构</h1>
<blockquote>
<p>伸缩性架构是指不需要改变系统的软硬件设计，仅通过改变部署服务器数量就可以扩大或缩小系统的服务处理能力。</p>
</blockquote>
<h2 id="1-系统架构的伸缩性设计"><a class="markdownIt-Anchor" href="#1-系统架构的伸缩性设计"></a> 1. 系统架构的伸缩性设计</h2>
<h3 id="11-不同功能进行物理分离实现伸缩"><a class="markdownIt-Anchor" href="#11-不同功能进行物理分离实现伸缩"></a> 1.1. 不同功能进行物理分离实现伸缩</h3>
<ul>
<li><strong>纵向分离（分层后分离）</strong> - 将业务处理流程上的不同部分分离部署，实现系统伸缩性。</li>
<li><strong>横向分离（业务分割后分离）</strong> - 将不同的业务模块分离部署，实现系统伸缩性。</li>
</ul>
<h3 id="12-单一功能通过集群规模实现伸缩"><a class="markdownIt-Anchor" href="#12-单一功能通过集群规模实现伸缩"></a> 1.2. 单一功能通过集群规模实现伸缩</h3>
<p>将不同功能分离部署可以实现一定程度的伸缩性，但是随着访问量逐步增加，即使分离到最小粒度的独立部署，单一的服务器也不能满足业务规模的要求。因此必须使用服务器集群，即将相同服务部署在多态服务器上构成一个集群整体对外提供服务。</p>
<h2 id="2-应用服务器集群的伸缩性设计"><a class="markdownIt-Anchor" href="#2-应用服务器集群的伸缩性设计"></a> 2. 应用服务器集群的伸缩性设计</h2>
<p>如果 HTTP 请求分发装置可以感知或者可以配置集群的服务器数量，可以及时发现集群中新上线或下线的服务器，并能向新上线的服务器分发请求，停止向已下线的服务器分发请求，那么就实现了应用服务器集群的伸缩性。</p>
<h3 id="21-http-重定向负载均衡"><a class="markdownIt-Anchor" href="#21-http-重定向负载均衡"></a> 2.1. HTTP 重定向负载均衡</h3>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/architecture/负载均衡-HTTP重定向.png!zp" width="500"/>
</div>
<p>利用 HTTP 重定向协议实现负载均衡。</p>
<p>这种负载均衡方案的优点是比较简单。</p>
<p>缺点是浏览器需要两次请求服务器才能完成一次访问，性能较差：重定向服务器自身的处理能力有可能成为瓶颈，整个集群的伸缩性规模有限；使用 HTTP 302 响应码重定向，可能使搜索引擎判断为 SEO 作弊，降低搜索排名。</p>
<h3 id="22-dns-域名解析负载均衡"><a class="markdownIt-Anchor" href="#22-dns-域名解析负载均衡"></a> 2.2. DNS 域名解析负载均衡</h3>
<p>利用 DNS 处理域名解析请求的同时进行负载均衡处理的一种方案。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/architecture/负载均衡-DNS域名解析.png!zp" width="500"/>
</div>
<p>在 DNS 服务器中配置多个 A 记录，如：</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line"><span class="number">114.100.40.1</span> www.mysite.com</span><br><span class="line"><span class="number">114.100.40.2</span> www.mysite.com</span><br><span class="line"><span class="number">114.100.40.3</span> www.mysite.com</span><br></pre></td></tr></table></figure>
<p>每次域名解析请求都会根据负载均衡算法计算一个不同的 IP 地址返回，这样 A 记录中配置的多个服务器就构成一个集群，并可以实现负载均衡。</p>
<p>DNS 域名解析负载均衡的优点：</p>
<ul>
<li>将负载均衡的工作转交给了 DNS，省掉了网站管理维护的麻烦。</li>
<li>同时，许多 DNS 服务器还支持基于地理位置的域名解析，即将域名解析成距离用户地理最近的一个服务器地址，这样可以加快用户访问速度，改善性能。</li>
</ul>
<p>DNS 域名解析负载均衡的缺点：</p>
<ul>
<li>DNS 是多级解析，每一级 DNS 都可能缓存 A 记录，当某台服务器下线后，即使修改了 DNS 的 A 记录，要使其生效也需要较长时间。这段时间，依然会域名解析到已经下线的服务器，导致用户访问失败。</li>
<li>DNS 的负载均衡的控制权在域名服务商那里，网站无法对其做更多改善和更强大的管理。</li>
</ul>
<h3 id="23-反向代理负载均衡"><a class="markdownIt-Anchor" href="#23-反向代理负载均衡"></a> 2.3. 反向代理负载均衡</h3>
<p>大多数反向代理服务器同时提供反向代理和负载均衡的功能。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/architecture/负载均衡-反向代理.png!zp" width="500"/>
</div>
<p>反向代理服务器的优点是部署简单。缺点是反向代理服务器是所有请求和响应的中转站，其性能可能会成为瓶颈。</p>
<h3 id="24-ip-负载均衡"><a class="markdownIt-Anchor" href="#24-ip-负载均衡"></a> 2.4. IP 负载均衡</h3>
<p>在网络层通过修改请求目标地址进行负载均衡。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/architecture/负载均衡-IP层.png!zp" width="500"/>
</div>
<p>负载均衡服务器（网关服务器）在操作系统内核获取网络数据包，根据负载均衡算法计算得到一台真实 Web 服务器 10.0.0.1，然后将目的 IP 地址修改为 10.0.0.1，不需要通过用户进程。真实 Web 服务器处理完成后，响应数据包回到负载均衡服务器，负载均衡服务器再将数据包原地址修改为自身的 IP 地址（114.100.80.10）发送给浏览器。</p>
<p>IP 负载均衡在内核完成数据分发，所以处理性能优于反向代理负载均衡。但是因为所有请求响应都要经过负载均衡服务器，集群的最大响应数据吞吐量受制于负载均衡服务器网卡带宽。</p>
<h3 id="25-数据链路层负载均衡"><a class="markdownIt-Anchor" href="#25-数据链路层负载均衡"></a> 2.5. 数据链路层负载均衡</h3>
<p>数据链路层负载均衡是指在通信协议的数据链路层修改 mac 地址进行负载均衡。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/architecture/负载均衡-数据链路层.png!zp" width="500"/>
</div>
<p>这种方式又称作三角传输方式，负载均衡数据分发过程中不修改 IP 地址，只修改目的 mac 地址，通过配置真实物理服务器集群所有机器虚拟 IP 和负载均衡服务器 IP 地址一致，从而达到不修改数据包的源地址和目的地址就可以进行数据分发的目的，由于实际处理请求的真实物理服务器 IP 和数据请求目的 IP 一致，不需要通过负载均衡服务器进行地址转换，可将响应数据包直接返回给用户浏览器，避免负载均衡服务器网卡带宽成为瓶颈。这种负载方式又称作直接路由方式。</p>
<p>在 Linux 平台上最好的链路层负载均衡开源产品是 <strong>LVS(Linux Virtual Server)</strong>。</p>
<h3 id="26-负载均衡算法"><a class="markdownIt-Anchor" href="#26-负载均衡算法"></a> 2.6. 负载均衡算法</h3>
<p>负载均衡服务器的实现可以分为两个部分：</p>
<ol>
<li>根据负载均衡算法和 Web 服务器列表计算得到集群中一台 Web 服务器的地址。</li>
<li>将请求数据发送到该地址对应的 Web 服务器上。</li>
</ol>
<p>负载均衡算法通常有以下几种：</p>
<ul>
<li><strong>轮询（Round Robin）</strong> - 所有请求被依次分发到每台应用服务器上，即每台服务器需要处理的请求数据都相同，适合于所有服务器硬件都相同的场景。</li>
<li><strong>加权轮询（Weighted Round Robin）</strong> - 根据服务器硬件性能情况，在轮询的基础上，按照配置权重将请求分发到每个服务器，高性能服务器能分配更多请求。</li>
<li><strong>随机（Random）</strong> - 请求被随机分配到各个应用服务器，在许多场合下，这种方案都很简单实用，因为好的随机数本身就很平均，即使应用服务器硬件配置不同，也可以使用加权随机算法。</li>
<li><strong>最少连接（Least Connection）</strong> - 记录每个应用服务器正在处理的连接数，将新到的请求分发到最少连接的服务器上，应该说，这是最符合负载均衡定义的算法。</li>
<li><strong>源地址 Hash（Source Hash）</strong> - 根据请求来源的 IP 地址进行 Hash 计算，得到应用服务器，这样来自同一个 IP 地址的请求总在同一个服务器上处理，该请求的上下文信息可以存储在这台服务器上，在一个会话周期内重复使用，从而实现会话粘滞。</li>
</ul>
<h2 id="3-分布式缓存集群的伸缩性设计"><a class="markdownIt-Anchor" href="#3-分布式缓存集群的伸缩性设计"></a> 3. 分布式缓存集群的伸缩性设计</h2>
<p>目前比较流行的分布式集群伸缩性方案就是：一致性 HASH 算法</p>
<h2 id="4-数据存储服务集群的伸缩性设计"><a class="markdownIt-Anchor" href="#4-数据存储服务集群的伸缩性设计"></a> 4. 数据存储服务集群的伸缩性设计</h2>
<h3 id="41-关系型数据库的伸缩性设计"><a class="markdownIt-Anchor" href="#41-关系型数据库的伸缩性设计"></a> 4.1. 关系型数据库的伸缩性设计</h3>
<ul>
<li><strong>主从复制</strong> - 主流关系型数据库一般都支持主从复制。</li>
<li><strong>分库</strong> - 根据业务对数据库进行分割。制约条件是跨库的表不能进行 Join 操作。</li>
<li><strong>分表</strong> - 使用数据库分片中间件，如 Cobar 等。</li>
</ul>
<h3 id="42-nosql-数据库的伸缩性设计"><a class="markdownIt-Anchor" href="#42-nosql-数据库的伸缩性设计"></a> 4.2. NoSql 数据库的伸缩性设计</h3>
<p>一般而言，Nosql 不支持 SQL 和 ACID，但是强化了对于高可用和伸缩性的支持。</p>
<h2 id="5-参考资料"><a class="markdownIt-Anchor" href="#5-参考资料"></a> 5. 参考资料</h2>
<ul>
<li><a href="https://item.jd.com/11322972.html" target="_blank" rel="noopener">大型网站技术架构：核心原理与案例分析</a></li>
</ul>
]]></content>
      <categories>
        <category>设计</category>
        <category>架构</category>
      </categories>
      <tags>
        <tag>设计</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>高可用架构</title>
    <url>/blog/design/architecture/high-availability-architecture/</url>
    <content><![CDATA[<h1 id="高可用架构"><a class="markdownIt-Anchor" href="#高可用架构"></a> 高可用架构</h1>
<h2 id="1-网站可用性的度量"><a class="markdownIt-Anchor" href="#1-网站可用性的度量"></a> 1. 网站可用性的度量</h2>
<p>网站不可用也被称作网站故障，业界通常用多个 9 来衡量网站的可用性。如 QQ 的可用性为 4 个 9，即 99.99% 可用。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">网站不可用时间 = 故障修复时间点 - 故障发现时间点</span><br><span class="line">网站年度可用性指标 = (<span class="number">1</span> - 网站不可用时间/年度总时间) * <span class="number">100</span>%</span><br></pre></td></tr></table></figure>
<p>一般来说：</p>
<ul>
<li>2 个 9 是基本可用，一年不可用时间小于 88 小时；</li>
<li>3 个 9 是较高可用，一年不可用时间小于 9 小时；</li>
<li>4 个 9 是具有自动恢复能力的高可用，一年不可用时间小于 55 分钟；</li>
<li>5 个 9 是极高可用，一年不可用时间小于 5 分钟。</li>
</ul>
<h2 id="2-高可用的系统架构"><a class="markdownIt-Anchor" href="#2-高可用的系统架构"></a> 2. 高可用的系统架构</h2>
<p>通常，企业级应用系统为提高系统可用性，会采用较昂贵的软硬件设备，当然这样的设备也比较稳定。</p>
<p>互联网公司或一些初创型公司基于成本考虑，更多采用 PC 级软硬件设备，节约成本所付出的代价就是设备较为不稳定。服务器一年中出现几次宕机，高强度读写磁盘导致磁盘损坏等事件实属正常。</p>
<p>综上，硬件出现故障应视为必然的，而<strong>高可用的系统架构设计目标就是要保证当出现硬件故障时，服务依然可用，数据依然能够保存并被访问</strong>。</p>
<p><strong>实现高可用的系统架构的主要手段是数据和服务的冗余备份及失效转移</strong>，一旦某些服务器宕机，就将服务切换到其他可用的服务器上；如果磁盘损坏，则从备份的磁盘读取数据。</p>
<h2 id="3-高可用的应用"><a class="markdownIt-Anchor" href="#3-高可用的应用"></a> 3. 高可用的应用</h2>
<blockquote>
<p>应用层主要处理网站应用的业务逻辑，一个显著的特点是应用的 <strong>无状态</strong> 性。</p>
<p>所谓的 <strong>无状态</strong> 的应用是指应用服务器不保存业务的上下文信息，而仅根据每次请求提交的数据进行相应的业务逻辑处理，多个服务实例之间完全对等，请求提交到任意服务器，处理结果都是完全一样的。</p>
</blockquote>
<h3 id="31-通过负载均衡进行无状态服务的失效转移"><a class="markdownIt-Anchor" href="#31-通过负载均衡进行无状态服务的失效转移"></a> 3.1. 通过负载均衡进行无状态服务的失效转移</h3>
<p>无状态的应用实现高可用架构十分简单，由于服务器不保存请求状态，那么所有服务器完全对等，在任意节点执行同样的请求，结果总是一致的。这种情况下，最简单的高可用方案就是使用负载均衡。</p>
<p>负载均衡，顾名思义，主要使用在业务量和数据量较高的情况下，当单台服务器不足以承担所有的负载压力时，通过负载均衡手段，将流量和数据分摊到一个集群组成的多台服务器上，以提高整体的负载处理能力。</p>
<h3 id="32-应用服务器集群的-session-管理"><a class="markdownIt-Anchor" href="#32-应用服务器集群的-session-管理"></a> 3.2. 应用服务器集群的 Session 管理</h3>
<p>应用服务器的高可用架构设计主要基于服务无状态这一特性。事实上，业务总是有状态的，如购物车记录用户的购买信息；用户的登录状态；最新发布的消息等等。</p>
<p>Web 应用中将这些多次请求修改使用的上下文对象称作会话。单机情况下，Session 可由部署在服务器上的 Web 容器管理。</p>
<p>而在集群环境下，Session 管理有以下手段：</p>
<h4 id="321-session-复制"><a class="markdownIt-Anchor" href="#321-session-复制"></a> 3.2.1. Session 复制</h4>
<p>Session 复制是指应用服务器开启 Web 容器的 Session 复制功能，在集群中的几台服务器之间同步 Session 对象，使得每台服务器上都保存所有用户的 Session 信息。</p>
<p>这种方案很简单但不可取。因为当集群规模较大时，集群服务间需要大量的通信来进行 Session 复制，占用服务器和网络的大量资源。</p>
<h4 id="322-session-绑定"><a class="markdownIt-Anchor" href="#322-session-绑定"></a> 3.2.2. Session 绑定</h4>
<p>Session 绑定可以利用负载均衡的源地址 Hash 算法实现，负载均衡服务器总是将来源于同一 IP 的请求分发到同一台服务器上。这样在整个会话期间，用户所有的请求都在同一台服务器上处理，即 Session 绑定到某台特定服务器上。这种方法又被称作会话黏滞。</p>
<p>但是这种策略不符合系统高可用的需求，因为一旦某台服务器宕机，那么该机器上的 Session 也就不复存在了。</p>
<h4 id="323-利用-cookie-记录-session"><a class="markdownIt-Anchor" href="#323-利用-cookie-记录-session"></a> 3.2.3. 利用 Cookie 记录 Session</h4>
<p>可以将 Session 记录在客户端（浏览器 Cookie），每次请求服务器时，将 Session 放在请求中发送给服务器，服务器处理完请求后再将修改过的 Session 响应给客户端。</p>
<p>这种策略的缺点是：</p>
<ul>
<li>Cookie 有大小限制，能记录的信息有限；</li>
<li>每次请求响应都需要传输 Cookie，影响性能；</li>
<li>如果用户关闭 Cookie，访问就不能工作。</li>
</ul>
<h4 id="324-session-服务器"><a class="markdownIt-Anchor" href="#324-session-服务器"></a> 3.2.4. Session 服务器</h4>
<p>利用独立部署的 Session 服务器（集群）统一管理 Session，应用服务器每次读写 Session 时，都访问 Session 服务器。</p>
<p>实现 Session 服务器的一种简单方法时：利用分布式缓存、数据库等，在此基础上进行包装，使其符合 Session 的存储和访问要求。如果业务对 Session 管理有较高要求，如利用 Session 服务集成单点登录（SSO）、用户服务等功能，则需要开发独立的 Session 服务管理平台。</p>
<h2 id="4-高可用的服务"><a class="markdownIt-Anchor" href="#4-高可用的服务"></a> 4. 高可用的服务</h2>
<p>高可用的服务策略：</p>
<ul>
<li><strong>分级管理</strong>
<ul>
<li>将服务根据业务重要性进行分级管理，核心应用和服务优先使用更好的硬件，在运维响应速度上也格外迅速。</li>
<li>在服务部署上进行必要的隔离，避免故障的连锁反应。低优先级的服务通过启动不同的线程或部署在不同的虚拟机上进行隔离，而高优先级的服务则需要部署在不同的物理机上，核心服务和数据甚至要部署在不同地域的数据中心。</li>
</ul>
</li>
<li><strong>超时设置</strong> - 由于服务器宕机、线程死锁等原因，可能导致应用程序对服务端的调用失去响应。所以有必要引入超时机制，一旦调用超时，服务化框架抛出异常，应用程序根据服务调度策略，选择重试或请求转移到其他机器上。</li>
<li><strong>异步调用</strong> - 对于需要即时响应的业务，应用在调用服务时可以通过消息队列等异步方式完成，避免一个服务失败导致整个应用请求失败的情况。当然不是所有服务调用都可以异步调用，对于获取用户信息这类调用，采用异步方式会延长响应时间，得不偿失；此外，对于那些必须确认服务调用才能继续下一步操作的应用也不适宜食用异步调用。</li>
<li><strong>服务降级</strong> - 网站访问高峰期，服务可能因为大量并发调用而性能下降，严重时可能会导致宕机。为了保证核心功能的正常运行，需要对服务进行降级。降级有两种手段：
<ul>
<li><strong>拒绝服务</strong> - 拒绝低优先级应用的调用，减少服务调用并发数，确保核心应用正常使用。或者随机拒绝部分调用，节约资源，避免要死大家一起死的惨剧。</li>
<li><strong>关闭服务</strong> - 关闭部分不重要的服务，或者服务内部关闭部分不重要的功能，以节约资源。</li>
</ul>
</li>
<li><strong>幂等性设计</strong> - 为了避免服务重复调用，可以通过设置编号的方式进行服务调用有效性校验，有效的操作才能继续执行。</li>
</ul>
<h2 id="5-高可用的数据"><a class="markdownIt-Anchor" href="#5-高可用的数据"></a> 5. 高可用的数据</h2>
<h3 id="51-cap-原理"><a class="markdownIt-Anchor" href="#51-cap-原理"></a> 5.1. CAP 原理</h3>
<p>分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容忍性（P：Partition Tolerance），最多只能同时满足其中两项。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/分布式理论-CAP.jpg!zp" width="450"/>
</div>
<h4 id="511-可用性"><a class="markdownIt-Anchor" href="#511-可用性"></a> 5.1.1. 可用性</h4>
<p><strong>可用性指分布式系统在面对各种异常时可以提供正常服务的能力</strong>。可以用系统可用时间占总时间的比值来衡量，4 个 9 的可用性表示系统 99.99% 的时间是可用的。</p>
<p>在可用性条件下，系统提供的服务一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。</p>
<h4 id="512-分区容忍性"><a class="markdownIt-Anchor" href="#512-分区容忍性"></a> 5.1.2. 分区容忍性</h4>
<p>网络分区指分布式系统中的节点被划分为多个区域，每个区域内部可以通信，但是区域之间无法通信。</p>
<p>在分区容忍性条件下，<strong>分布式系统在遇到任何网络分区故障的时候，仍然需要能对外提供一致性和可用性的服务，除非是整个网络环境都发生了故障</strong>。</p>
<h4 id="513-一致性"><a class="markdownIt-Anchor" href="#513-一致性"></a> 5.1.3. 一致性</h4>
<p><strong>一致性指的是多个数据副本是否能保持一致的特性</strong>。</p>
<p>在一致性的条件下，系统在执行数据更新操作之后能够从一致性状态转移到另一个一致性状态。</p>
<p>数据一致性又可以分为以下几点：</p>
<ul>
<li><strong>强一致性</strong> - 数据更新操作结果和操作响应总是一致的，即操作响应通知更新失败，那么数据一定没有被更新，而不是处于不确定状态。</li>
<li><strong>最终一致性</strong> - 即物理存储的数据可能是不一致的，终端用户访问到的数据可能也是不一致的，但系统经过一段时间的自我修复和修正，数据最终会达到一致。</li>
</ul>
<h4 id="514-权衡"><a class="markdownIt-Anchor" href="#514-权衡"></a> 5.1.4. 权衡</h4>
<p>在分布式系统中，分区容忍性必不可少，因为需要总是假设网络是不可靠的。因此，CAP 理论实际在是要在可用性和一致性之间做权衡。</p>
<p>可用性和一致性往往是冲突的，很难都使它们同时满足。在多个节点之间进行数据同步时，</p>
<ul>
<li>为了保证一致性（CP），就需要让所有节点下线成为不可用的状态，等待同步完成；</li>
<li>为了保证可用性（AP），在同步过程中允许读取所有节点的数据，但是数据可能不一致。</li>
</ul>
<h3 id="52-数据备份"><a class="markdownIt-Anchor" href="#52-数据备份"></a> 5.2. 数据备份</h3>
<ul>
<li><strong>冷备份</strong> - 定期将数据复制到某种存储介质。</li>
<li><strong>热备份</strong>
<ul>
<li><strong>异步热备方式</strong> - 异步热备方式是指多份数据副本的写入操作异步完成，应用程序收到数据服务系统的写操作成功响应时，只写成功了一份，存储系统将会异步地写其他副本。</li>
<li><strong>同步热备方式</strong> - 同步热备方式是指多份数据副本的写入操作同步完成，即应用程序收到数据服务系统的写成功响应时，多份数据都已经写操作成功。但是当应用程序收到数据写操作失败的响应式，可能有部分副本或者全部副本都已经写入成功了（因为网络或者系统故障，无法返回操作成功的响应）。</li>
</ul>
</li>
</ul>
<h3 id="53-失效转移"><a class="markdownIt-Anchor" href="#53-失效转移"></a> 5.3. 失效转移</h3>
<h4 id="531-失效确认"><a class="markdownIt-Anchor" href="#531-失效确认"></a> 5.3.1. 失效确认</h4>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/architecture/check-fail.png!zp" width="500" />
</div>
<p>判断服务器宕机的手段有两种：<strong>心跳检测</strong>和<strong>访问失败报告</strong>。</p>
<p>对于应用程序的访问失败报告，控制中心还需要再一次发送心跳检测进行确认，以免错误判断服务器宕机。因为一旦进行数据访问的失效转移，意味着数据存储多份副本不一致，需要进行后续一系列的复杂动作。</p>
<h4 id="532-访问转移"><a class="markdownIt-Anchor" href="#532-访问转移"></a> 5.3.2. 访问转移</h4>
<p>确认某台数据服务器宕机后，就需要将数据读写访问重新路由到其他服务器上。对于完全对等存储的服务器，当其中一台宕机后，应用程序根据配置直接切换到对等服务器上。如果存储不对等，就需要重新计算路由，选择存储服务器。</p>
<h4 id="533-数据恢复"><a class="markdownIt-Anchor" href="#533-数据恢复"></a> 5.3.3. 数据恢复</h4>
<p>因为某台服务器宕机，所以数据存储的副本数目会减少，必须将副本的数目恢复到系统设定的值，否则，再有服务器宕机时，就可能出现无法访问转移，数据永久丢失的情况。因此系统需要从健康的服务器复制数据，将数据副本数目恢复到设定值。</p>
<h2 id="6-高可用的软件质量保证"><a class="markdownIt-Anchor" href="#6-高可用的软件质量保证"></a> 6. 高可用的软件质量保证</h2>
<p>高可用的软件质量保证的手段：</p>
<ul>
<li>自动化发布</li>
<li>自动化测试</li>
<li>预发布验证</li>
<li>代码控制</li>
<li>灰度发布</li>
</ul>
<h2 id="7-系统监控"><a class="markdownIt-Anchor" href="#7-系统监控"></a> 7. 系统监控</h2>
<blockquote>
<p>不允许没有监控的系统上线。</p>
</blockquote>
<ul>
<li><strong>监控数据采集</strong>
<ul>
<li><strong>用户行为日志收集</strong>
<ul>
<li>服务端日志收集 - Apache、Nginx 等几乎所有 Web 服务器都具备日志记录功能，只要开启日志记录即可。如果是服务器比较多，需要集中采集日志，通常会使用 Elastic 来进行收集。</li>
<li>客户端日志收集 - 利用页面嵌入专门的 JavaScript 脚本可以收集用户真实的操作行为。</li>
<li>日志分析 - 可以利用 ElasticSearch 做语义分析及搜索；利用实时计算框架 Storm、Flink 等开发日志统计与分析工具。</li>
</ul>
</li>
<li><strong>服务器性能监控</strong> - 收集服务器性能指标，如系统负载、内存占用、CPU 占用、磁盘 IO、网络 IO 等。常用的监控工具有：<a href="https://github.com/apache/skywalking" target="_blank" rel="noopener">Apache SkyWalking</a> 、<a href="https://github.com/naver/pinpoint" target="_blank" rel="noopener">Pinpoint</a> 等。</li>
<li><strong>运行数据报告</strong> - 应该监控一些与具体业务场景相关的技术和业务指标，如：缓存命中率、平均响应时延、TPS、QPS 等。</li>
</ul>
</li>
<li><strong>监控管理</strong>
<ul>
<li><strong>系统报警</strong> - 设置阈值。当达到阈值，及时触发告警（短信、邮件、通信工具均可），通过及时判断状况，防患于未然。</li>
<li><strong>失效转移</strong> - 监控系统可以在发现故障的情况下主动通知应用进行失效转移。</li>
<li><strong>自动优雅降级</strong>
<ul>
<li>优雅降级是为了应付突然爆发的访问高峰，主动关闭部分功能，释放部分资源，以保证核心功能的优先访问。</li>
<li>系统在监控管理基础之上实现自动优雅降级，是柔性架构的理想状态。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="8-资料"><a class="markdownIt-Anchor" href="#8-资料"></a> 8. 资料</h2>
<ul>
<li><a href="https://item.jd.com/11322972.html" target="_blank" rel="noopener">大型网站技术架构：核心原理与案例分析</a></li>
</ul>
]]></content>
      <categories>
        <category>设计</category>
        <category>架构</category>
      </categories>
      <tags>
        <tag>设计</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>系统架构概述</title>
    <url>/blog/design/architecture/system-architecture-overview/</url>
    <content><![CDATA[<h1 id="系统架构概述"><a class="markdownIt-Anchor" href="#系统架构概述"></a> 系统架构概述</h1>
<blockquote>
<p><strong>架构</strong> 的一种通俗说法是：<strong>最高层次的规划，难以改变的决定。</strong></p>
<p><strong>软件架构</strong>是有关软件整体结构与组件的抽象描述，用于指导大型软件系统各个方面的设计。 ——维基百科</p>
</blockquote>
<h2 id="1-大型系统架构的问题和目标"><a class="markdownIt-Anchor" href="#1-大型系统架构的问题和目标"></a> 1. 大型系统架构的问题和目标</h2>
<p>大型系统面临的问题：</p>
<ul>
<li>用户体量大且分布广泛</li>
<li>海量数据</li>
<li>高并发、高吞吐</li>
<li>网络环境复杂</li>
<li>安全环境恶劣，易受网络攻击</li>
<li>产品需要快速迭代</li>
<li>从小到大，渐进发展</li>
<li>以用户为中心</li>
<li>免费服务，付费体验</li>
</ul>
<p>大型系统架构的目标：</p>
<ul>
<li><strong>高性能</strong> - 高并发、高吞吐，以应对大量的用户访问以及处理海量的数据。</li>
<li><strong>高可用</strong> - 提供稳定可靠的服务。一般通过备份、分布式等手段来提升系统的可用性。</li>
<li><strong>易伸缩</strong> - 通过增/减服务器节点数，来灵活的提高/降低系统处理能力。</li>
<li><strong>易扩展</strong> - 架构上耦合度低，易于在不影响现有功能的基础上支撑业务快速发展。</li>
<li><strong>安全性</strong> - 通过信息加密，认证、权限管理，风险控制等防护性手段，为系统保驾护航。</li>
<li><strong>易维护</strong> - 利用持续集成、持续部署等自动化手段，使得系统可以快速迭代（构建、部署、运维），缩减系统维护难度和成本。</li>
</ul>
<h2 id="2-大型软件架构演化"><a class="markdownIt-Anchor" href="#2-大型软件架构演化"></a> 2. 大型软件架构演化</h2>
<p>大型软件架构演化比较具有代表性的就是大型网站的演化过程。这里介绍一下大型网站演化的一般规律。</p>
<h3 id="21-初始阶段架构"><a class="markdownIt-Anchor" href="#21-初始阶段架构"></a> 2.1. 初始阶段架构</h3>
<ul>
<li><strong>问题</strong>：网站运营初期，访问用户少，一台服务器绰绰有余。</li>
<li><strong>特征</strong>：<strong>应用程序、数据库、文件等所有的资源都在一台服务器上。</strong></li>
<li><strong>描述</strong>：通常服务器操作系统使用 linux，应用程序使用 PHP 开发，然后部署在 Apache 上，数据库使用 Mysql，通俗称为 LAMP。汇集各种免费开源软件以及一台廉价服务器就可以开始系统的发展之路了。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/系统架构进化-初始阶段架构.jpg!zp" width="400"/>
</div>
<h3 id="22-应用服务和数据服务分离"><a class="markdownIt-Anchor" href="#22-应用服务和数据服务分离"></a> 2.2. 应用服务和数据服务分离</h3>
<ul>
<li><strong>问题</strong>：越来越多的用户访问导致性能越来越差，越来越多的数据导致存储空间不足，一台服务器已不足以支撑。</li>
<li><strong>特征</strong>：<strong>应用服务器、数据库服务器、文件服务器分别独立部署。</strong></li>
<li><strong>描述</strong>：三台服务器对性能要求各不相同：
<ul>
<li>应用服务器要处理大量业务逻辑，因此需要更快更强大的 CPU；</li>
<li>数据库服务器需要快速磁盘检索和数据缓存，因此需要更快的硬盘和更大的内存；</li>
<li>文件服务器需要存储大量文件，因此需要更大容量的硬盘。</li>
</ul>
</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/系统架构进化-应用服务和数据服务分离.jpg!zp" width="450"/>
</div>
<h3 id="23-使用缓存改善性能"><a class="markdownIt-Anchor" href="#23-使用缓存改善性能"></a> 2.3. 使用缓存改善性能</h3>
<ul>
<li><strong>问题</strong>：随着用户逐渐增多，数据库压力太大导致访问延迟。</li>
<li><strong>特征</strong>：由于网站访问和财富分配一样遵循二八定律：<em>80% 的业务访问集中在 20% 的数据上</em>。<strong>将数据库中访问较集中的少部分数据缓存在内存中，可以减少数据库的访问次数，降低数据库的访问压力。</strong></li>
<li><strong>描述</strong>：缓存分为两种：应用服务器上的本地缓存和分布式缓存服务器上的远程缓存。
<ul>
<li>本地缓存访问速度更快，但缓存数据量有限，同时存在与应用程序争用内存的情况。</li>
<li>分布式缓存可以采用集群方式，理论上可以做到不受内存容量限制的缓存服务。</li>
</ul>
</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/系统架构进化-使用缓存改善性能.jpg!zp" width="450"/>
</div>
<h3 id="24-使用应用服务器集群改善并发处理能力"><a class="markdownIt-Anchor" href="#24-使用应用服务器集群改善并发处理能力"></a> 2.4. 使用应用服务器集群改善并发处理能力</h3>
<ul>
<li><strong>问题</strong>：使用缓存后，数据库访问压力得到有效缓解。但是单一应用服务器能够处理的请求连接有限，在访问高峰期，成为瓶颈。</li>
<li><strong>特征</strong>：<strong>多台服务器通过负载均衡同时向外部提供服务，解决单一服务器处理能力和存储空间不足的问题。</strong></li>
<li><strong>描述</strong>：使用集群是系统解决高并发、海量数据问题的常用手段。通过向集群中追加资源，提升系统的并发处理能力，使得服务器的负载压力不再成为整个系统的瓶颈。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/系统架构进化-使用应用服务器集群.jpg!zp" width="500"/>
</div>
<h3 id="25-数据库读写分离"><a class="markdownIt-Anchor" href="#25-数据库读写分离"></a> 2.5. 数据库读写分离</h3>
<ul>
<li><strong>问题</strong>：网站使用缓存后，使绝大部分数据读操作访问都可以不通过数据库就能完成，但是仍有一部分读操作和全部的写操作需要访问数据库，在网站的用户达到一定规模后，数据库因为负载压力过高而成为网站的瓶颈。</li>
<li><strong>特征</strong>：目前大部分的主流数据库都提供主从热备功能，通过配置两台数据库主从关系，可以将一台数据库服务器的数据更新同步到一台服务器上。<strong>网站利用数据库的主从热备功能，实现数据库读写分离，从而改善数据库负载压力。</strong></li>
<li><strong>描述</strong>：应用服务器在写操作的时候，访问主数据库，主数据库通过主从复制机制将数据更新同步到从数据库。这样当应用服务器在读操作的时候，访问从数据库获得数据。为了便于应用程序访问读写分离后的数据库，通常在应用服务器端使用专门的数据访问模块，使数据库读写分离的对应用透明。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/系统架构进化-数据库读写分离.jpg!zp" width="500"/>
</div>
<h3 id="26-反向代理和-cdn-加速"><a class="markdownIt-Anchor" href="#26-反向代理和-cdn-加速"></a> 2.6. 反向代理和 CDN 加速</h3>
<ul>
<li><strong>问题</strong>：中国网络环境复杂，不同地区的用户访问网站时，速度差别也极大。</li>
<li><strong>特征</strong>：<strong>采用 CDN 和反向代理加快系统的静态资源访问速度。</strong></li>
<li><strong>描述</strong>：CDN 和反向代理的基本原理都是缓存，区别在于：
<ul>
<li>CDN 部署在网络提供商的机房，使用户在请求网站服务时，可以从距离自己最近的网络提供商机房获取数据；</li>
<li>而反向代理则部署在网站的中心机房，当用户请求到达中心机房后，首先访问的服务器时反向代理服务器，如果反向代理服务器中缓存着用户请求的资源，就将其直接返回给用户。</li>
</ul>
</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/系统架构进化-反向代理和CDN加速.jpg!zp" width="500"/>
</div>
<h3 id="27-分布式文件系统和分布式数据库"><a class="markdownIt-Anchor" href="#27-分布式文件系统和分布式数据库"></a> 2.7. 分布式文件系统和分布式数据库</h3>
<ul>
<li><strong>问题</strong>：随着大型网站业务持续增长，数据库经过读写分离，从一台服务器拆分为两台服务器，依然不能满足需求。</li>
<li><strong>特征</strong>：<strong>数据库采用分布式数据库，文件系统采用分布式文件系统。</strong></li>
<li><strong>描述</strong>：分布式数据库是数据库拆分的最后方法，只有在单表数据规模非常庞大的时候才使用。不到不得已时，更常用的数据库拆分手段是业务分库，将不同的业务数据库部署在不同的物理服务器上。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/系统架构进化-分布式文件系统和分布式数据库.jpg!zp" />
</div>
<h3 id="28-使用-nosql-和搜索引擎"><a class="markdownIt-Anchor" href="#28-使用-nosql-和搜索引擎"></a> 2.8. 使用 NoSQL 和搜索引擎</h3>
<ul>
<li><strong>问题</strong>：随着网站业务越来越复杂，对数据存储和检索的需求也越来越复杂。</li>
<li><strong>特征</strong>：<strong>系统引入 NoSQL 数据库及搜索引擎。</strong></li>
<li><strong>描述</strong>：NoSQL 数据库及搜索引擎对可伸缩的分布式特性具有更好的支持。应用服务器通过统一数据访问模块访问各种数据，减轻应用程序管理诸多数据源的麻烦。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/系统架构进化-使用NoSQL和搜索引擎.jpg!zp" />
</div>
<h3 id="29-业务拆分"><a class="markdownIt-Anchor" href="#29-业务拆分"></a> 2.9. 业务拆分</h3>
<ul>
<li><strong>问题</strong>：大型网站的业务场景日益复杂，分为多个产品线。</li>
<li><strong>特征</strong>：采用分而治之的手段将整个网站业务分成不同的产品线。<strong>系统上按照业务进行拆分改造，应用服务器按照业务区分进行分别部署。</strong></li>
<li><strong>描述</strong>：应用之间可以通过超链接建立关系，也可以通过消息队列进行数据分发，当然更多的还是通过访问同一个数据存储系统来构成一个关联的完整系统。
<ul>
<li><strong>纵向拆分</strong>：<strong>将一个大应用拆分为多个小应用</strong>，如果新业务较为独立，那么就直接将其设计部署为一个独立的 Web 应用系统。纵向拆分相对较为简单，通过梳理业务，将较少相关的业务剥离即可。</li>
<li><strong>横向拆分</strong>：<strong>将复用的业务拆分出来，独立部署为分布式服务</strong>，新增业务只需要调用这些分布式服务横向拆分需要识别可复用的业务，设计服务接口，规范服务依赖关系。</li>
</ul>
</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/系统架构进化-业务拆分.jpg!zp" />
</div>
<h3 id="210-分布式服务"><a class="markdownIt-Anchor" href="#210-分布式服务"></a> 2.10. 分布式服务</h3>
<ul>
<li><strong>问题</strong>：随着业务越拆越小，存储系统越来越庞大，应用系统整体复杂程度呈指数级上升，部署维护越来越困难。由于所有应用要和所有数据库系统连接，最终导致数据库连接资源不足，拒绝服务。</li>
<li><strong>特征</strong>：<strong>公共业务提取出来，独立部署。由这些可复用的业务连接数据库，通过分布式服务提供共用业务服务。</strong></li>
<li>描述：大型网站的架构演化到这里，基本上大多数的技术问题都得以解决，诸如跨数据中心的实时数据同步和具体网站业务相关的问题也都可以组合改进现有技术架构来解决。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/系统架构进化-分布式服务.jpg!zp" />
</div>
<h2 id="3-大型软件架构的考量"><a class="markdownIt-Anchor" href="#3-大型软件架构的考量"></a> 3. 大型软件架构的考量</h2>
<blockquote>
<p><strong>每一个模式描述了一个不但重复发生的问题及该问题解决方案的核心。这样，就可以不断复用该方案而减少重复工作</strong>。</p>
</blockquote>
<h3 id="31-原则"><a class="markdownIt-Anchor" href="#31-原则"></a> 3.1. 原则</h3>
<ul>
<li>架构设计应该<strong>按需设计</strong>。任何网站都是随着业务逐步发展，不断演化而成，不要指望一劳永逸。</li>
<li>驱动技术发展的主要力量是业务发展。</li>
<li>不要盲目跟风大公司的解决方案。</li>
<li>不要盲目追求流行技术，而脱离了业务发展的实际情况。</li>
<li>不要把所有问题都丢给技术。现实中，有很多案例告诉我们，很多问题不一定需要通过技术来解决。归根结底，技术始终都是业务的辅助，业务问题究竟是通过技术来解决还是直接通过业务来解决，需要根据实际情况去分析判断。这就需要对业务领域有比较深入的理解和思考。</li>
</ul>
<h3 id="32-性能"><a class="markdownIt-Anchor" href="#32-性能"></a> 3.2. 性能</h3>
<p>性能是软件系统的重要衡量标准。很多扩展性、伸缩性、可用性的问题，是为了解决性能问题而引入的。</p>
<p>常见的性能提升手段有：</p>
<ul>
<li>前端
<ul>
<li>浏览器缓存</li>
<li>静态资源压缩</li>
<li>合理布局页面</li>
<li>减少 cookie 传输</li>
<li>CDN</li>
</ul>
</li>
<li>应用服务
<ul>
<li>负载均衡和反向代理</li>
<li>本地缓存</li>
<li>分布式缓存</li>
<li>异步消息队列</li>
<li>集群</li>
<li>代码层面：使用多线程、改善内存管理</li>
</ul>
</li>
<li>数据库
<ul>
<li>索引</li>
<li>数据库缓存</li>
<li>SQL 优化</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：缓存是改善软件性能的第一手段。缓存除了可以加快数据访问速度以外，还可以减轻后端应用和数据存储的负载压力。所以，如果要提升系统性能，应该第一时间想到缓存。</p>
<p>使用缓存有两个前提：</p>
<ul>
<li>数据访问热点不均匀，频繁访问的数据应该放在缓存中</li>
<li>数据在某个时间段有效，不过很快过期，否则缓存数据会因已经失效而产生脏读</li>
</ul>
</blockquote>
<h3 id="33-扩展性"><a class="markdownIt-Anchor" href="#33-扩展性"></a> 3.3. 扩展性</h3>
<blockquote>
<p>衡量扩展性的标准就是增加新的业务产品时，是否可以实现对现有产品透明无影响，不需要任何改动或很少改动，既有功能就可以上线新产品。</p>
<p>软件发展的一个重要目标和驱动力是降低软件耦合性。事物之间直接关系越少，彼此影响就越小，也就更容易独立发展，即扩展性好。</p>
</blockquote>
<p>主要手段有：</p>
<ul>
<li>
<p><strong>分层</strong> - 分层是扩展性设计的最基本手段。通过分层，可以将一个的软件系统切分为不同的部分，便于分工合作开发和维护；各层间具有一定的独立性。</p>
<ul>
<li>分层架构的约束：<strong>禁止跨层次的调用及逆向调用</strong>。</li>
<li>即使系统规模很小，也应该考虑采用分层的架构，这样便于以后扩展。</li>
</ul>
</li>
<li>
<p><strong>分割</strong> - 将不同的功能和服务分割开来，包装成高内聚、低耦合的模块单元。这有助于软件的开发和维护，便于不同模块的分布式部署，提高系统的并发处理能力和功能扩展能力。</p>
</li>
<li>
<p><strong>异步</strong> - 业务间的消息传递不是同步调用，而是将一个业务操作拆分成多阶段，每个阶段间通过共享数据的方式异步执行进行协作。</p>
<ul>
<li><strong>在单一服务器内部可通过多线程共享内存队列的方式实现异步</strong>，处在业务操作前面的线程将操作输出到队列，后面的线程从队列中读取数据进行处理；</li>
<li>在分布式系统中，<strong>多个服务器集群通过分布式消息队列实现异步</strong>。</li>
</ul>
</li>
<li>
<p><strong>分布式</strong> - 将业务和可复用服务分离，通过分布式服务框架调用。分布式是指多台服务器部署相同应用构成一个集群，通过负载均衡设备共同对外提供服务。着意味着服务可以用更多的机器工作，即扩展 CPU、内存、IO 等资源，从而提高系统整体的吞吐量和并发处理能力。</p>
<ul>
<li>常用的分布式方案：
<ul>
<li>分布式应用和服务</li>
<li>分布式静态资源</li>
<li>分布式数据和存储</li>
<li>分布式计算</li>
</ul>
</li>
<li>分布式也引入了一些问题：
<ul>
<li>服务调用必须通过网络，网络延迟会影响性能。</li>
<li>服务器越多，宕机概率也越大，导致可用性降低。</li>
<li>数据一致性非常困难，分布式事务也难以保证。</li>
<li>网站依赖错综复杂，开发管理维护困难。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="34-伸缩性"><a class="markdownIt-Anchor" href="#34-伸缩性"></a> 3.4. 伸缩性</h3>
<blockquote>
<p>衡量伸缩的标准就是是否可以用多台服务器构建集群，是否容易向集群中增删服务器节点。增删服务器节点后是否可以提供和之前无差别的服务。集群中可容纳的总服务器数是否有限制。</p>
</blockquote>
<p>主要手段有:</p>
<ul>
<li><strong>应用服务器集群</strong> - 只要服务器上保存数据，则所有服务器都是对等的，通过负载均衡设备向集群中不断加入服务器即可</li>
<li><strong>缓存服务器集群</strong> - 加入新的服务器可能会导致缓存路由失效，进而导致集群中的大部分缓存数据都无法访问。虽然缓存数据可以通过数据库重新加载，但是如果应用严重依赖缓存，可能会导致网站崩溃。需要改进缓存路由算法保证缓存数据的可访问性。</li>
<li><strong>关系型数据库集群</strong> - 关系型数据库虽然支持数据复制，主从热备等机制，但是很难做到大规模集群的可伸缩性，因此关系型数据库的集群伸缩性方案必须在数据库之外实现，通过路由分区等手段将部署有多个数据库的服务器组成一个集群。</li>
<li><strong>Nosql 数据库集群</strong> - 由于先天就是为了应对海量数据而产生，因此对伸缩性的支持通常都非常好。</li>
</ul>
<h3 id="35-可用性"><a class="markdownIt-Anchor" href="#35-可用性"></a> 3.5. 可用性</h3>
<p>对于大型软件系统，出现服务器宕机是必然事件。要保证部分服务器宕机的情况下，系统依然可以继续对外提供服务，不丢失数据，就需要一定程度上的服务器冗余运行，数据冗余备份。这样当某台服务器宕机时，可以将其上的服务和数据访问转移到其他机器上。</p>
<p>一般的做法是：</p>
<ul>
<li><strong>负载均衡</strong> - 通过负载均衡设备建立集群共同对外提供服务。</li>
<li><strong>备份</strong> - 数据存储在多台服务器，互相备份。即使访问和负载很小的服务也必须部署至少两台服务器，构成一个集群，目的就是通过冗余实现服务的高可用。
<ul>
<li><strong>冷备份</strong> - 数据应该定期备份；</li>
<li><strong>热备份</strong> - 为了保证在线业务高可用，还需要对数据库进行主从分离，实时同步 。</li>
<li><strong>灾备</strong> - 为了抵御地震、海啸等不可抗因素导致的网站完全瘫痪，某些大型网站会对整个数据中心进行备份，全球范围内部署 <strong>灾备数据中心</strong>。网站程序和数据实时同步到多个灾备数据中心。</li>
</ul>
</li>
<li><strong>自动化</strong> - 自动化是指，大型系统有必要通过预发布验证、自动化测试、自动化发布、灰度发布等手段，减少将故障引入线上环境的可能。常见自动化手段有：
<ul>
<li>发布过程自动化
<ul>
<li>自动化代码管理</li>
<li>自动化测试</li>
<li>自动化安全监测</li>
<li>自动化部署</li>
</ul>
</li>
<li>运维自动化
<ul>
<li>自动化监控</li>
<li>自动化报警</li>
<li>自动化失效转移</li>
<li>自动化失效恢复</li>
<li>自动化降级</li>
<li>自动化分配资源</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="36-安全"><a class="markdownIt-Anchor" href="#36-安全"></a> 3.6. 安全</h3>
<p>安全是指系统应该对恶意攻击有一定的抵抗能力，保护重要数据不被窃取。</p>
<ul>
<li><strong>密码</strong> 和 <strong>手机校验码</strong> 进行身份认证</li>
<li>登录、交易等重要操作需要对网络通信进行 <strong>加密</strong>，存储的敏感数据如用户信息等也进行加密处理</li>
<li>防止机器人程序攻击网站，使用 <strong>验证码</strong> 进行识别</li>
<li>对常见用于 <strong>攻击</strong> 网站的 XSS 攻击、SQL 注入、进行编码转换等相应处理</li>
<li>对垃圾信息、敏感信息进行 <strong>过滤</strong></li>
<li>对交易转账等重要操作根据交易模式和交易信息进行 <strong>风险控制</strong></li>
</ul>
<h2 id="4-常见架构模型"><a class="markdownIt-Anchor" href="#4-常见架构模型"></a> 4. 常见架构模型</h2>
<h3 id="41-分层架构"><a class="markdownIt-Anchor" href="#41-分层架构"></a> 4.1. 分层架构</h3>
<p>分层架构（layered architecture）是最常见的软件架构，也是事实上的标准架构。</p>
<p>这种架构将软件分成若干个水平层，每一层都有清晰的角色和分工，不需要知道其他层的细节。层与层之间通过接口通信。</p>
<p>四层的结构最常见。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/layered-architecture.png" width="500"/>
</div>
<ul>
<li>表现层（presentation）：用户界面，负责视觉和用户互动</li>
<li>业务层（business）：实现业务逻辑</li>
<li>持久层（persistence）：提供数据，SQL 语句就放在这一层</li>
<li>数据库（database） ：保存数据</li>
</ul>
<p>优点</p>
<ul>
<li>结构简单，容易理解和开发</li>
<li>不同技能的程序员可以分工，负责不同的层，天然适合大多数软件公司的组织架构</li>
<li>每一层都可以独立测试，其他层的接口通过模拟解决</li>
</ul>
<p>缺点</p>
<ul>
<li>一旦环境变化，需要代码调整或增加功能时，通常比较麻烦和费时</li>
<li>部署比较麻烦，即使只修改一个小地方，往往需要整个软件重新部署，不容易做持续发布</li>
<li>软件升级时，可能需要整个服务暂停</li>
<li>扩展性差。用户请求大量增加时，必须依次扩展每一层，由于每一层内部是耦合的，扩展会很困难</li>
</ul>
<h3 id="42-事件驱动架构"><a class="markdownIt-Anchor" href="#42-事件驱动架构"></a> 4.2. 事件驱动架构</h3>
<p>事件（event）是状态发生变化时，软件发出的通知。</p>
<p>事件驱动架构（event-driven architecture）就是通过事件进行通信的软件架构。它分成四个部分。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/event-driven-architecture.png" width="500"/>
</div>
<ul>
<li>事件队列（event queue）：接收事件的入口</li>
<li>分发器（event mediator）：将不同的事件分发到不同的业务逻辑单元</li>
<li>事件通道（event channel）：分发器与处理器之间的联系渠道</li>
<li>事件处理器（event processor）：实现业务逻辑，处理完成后会发出事件，触发下一步操作</li>
</ul>
<p>对于简单的项目，事件队列、分发器和事件通道，可以合为一体，整个软件就分成事件代理和事件处理器两部分。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/simple-event-driven-architecture.png" width="500"/>
</div>
<p>优点</p>
<ul>
<li>分布式的异步架构，事件处理器之间高度解耦，软件的扩展性好</li>
<li>适用性广，各种类型的项目都可以用</li>
<li>性能较好，因为事件的异步本质，软件不易产生堵塞</li>
<li>事件处理器可以独立地加载和卸载，容易部署</li>
</ul>
<p>缺点</p>
<ul>
<li>涉及异步编程（要考虑远程通信、失去响应等情况），开发相对复杂</li>
<li>难以支持原子性操作，因为事件通过会涉及多个处理器，很难回滚</li>
<li>分布式和异步特性导致这个架构较难测试</li>
</ul>
<h3 id="43-微核架构"><a class="markdownIt-Anchor" href="#43-微核架构"></a> 4.3. 微核架构</h3>
<p>微核架构（microkernel architecture）又称为&quot;插件架构&quot;（plug-in architecture），指的是软件的内核相对较小，主要功能和业务逻辑都通过插件实现。</p>
<p>内核（core）通常只包含系统运行的最小功能。插件则是互相独立的，插件之间的通信，应该减少到最低，避免出现互相依赖的问题。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/plug-in-architecture.png" width="500"/>
</div>
<p>优点</p>
<ul>
<li>良好的功能延伸性（extensibility），需要什么功能，开发一个插件即可</li>
<li>功能之间是隔离的，插件可以独立的加载和卸载，使得它比较容易部署，</li>
<li>可定制性高，适应不同的开发需要</li>
<li>可以渐进式地开发，逐步增加功能</li>
</ul>
<p>缺点</p>
<ul>
<li>扩展性（scalability）差，内核通常是一个独立单元，不容易做成分布式</li>
<li>开发难度相对较高，因为涉及到插件与内核的通信，以及内部的插件登记机制</li>
</ul>
<h3 id="44-微服务架构"><a class="markdownIt-Anchor" href="#44-微服务架构"></a> 4.4. 微服务架构</h3>
<p>微服务架构（microservices architecture）是服务导向架构（service-oriented architecture，缩写 SOA）的升级。</p>
<p>每一个服务就是一个独立的部署单元（separately deployed unit）。这些单元都是分布式的，互相解耦，通过远程通信协议（比如 REST、SOAP）联系。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/microservices-architecture.png" width="500"/>
</div>
<p>微服务架构分成三种实现模式。</p>
<ul>
<li>RESTful API 模式：服务通过 API 提供，云服务就属于这一类</li>
<li>RESTful 应用模式：服务通过传统的网络协议或者应用协议提供，背后通常是一个多功能的应用程序，常见于企业内部</li>
<li>集中消息模式：采用消息代理（message broker），可以实现消息队列、负载均衡、统一日志和异常处理，缺点是会出现单点失败，消息代理可能要做成集群</li>
</ul>
<p>优点</p>
<ul>
<li>扩展性好，各个服务之间低耦合</li>
<li>容易部署，软件从单一可部署单元，被拆成了多个服务，每个服务都是可部署单元</li>
<li>容易开发，每个组件都可以进行持续集成式的开发，可以做到实时部署，不间断地升级</li>
<li>易于测试，可以单独测试每一个服务</li>
</ul>
<p>缺点</p>
<ul>
<li>由于强调互相独立和低耦合，服务可能会拆分得很细。这导致系统依赖大量的微服务，变得很凌乱和笨重，性能也会不佳。</li>
<li>一旦服务之间需要通信（即一个服务要用到另一个服务），整个架构就会变得复杂。典型的例子就是一些通用的 Utility 类，一种解决方案是把它们拷贝到每一个服务中去，用冗余换取架构的简单性。</li>
<li>分布式的本质使得这种架构很难实现原子性操作，交易回滚会比较困难。</li>
</ul>
<h3 id="45-云架构"><a class="markdownIt-Anchor" href="#45-云架构"></a> 4.5. 云架构</h3>
<p>云结构（cloud architecture）主要解决扩展性和并发的问题，是最容易扩展的架构。</p>
<p>它的高扩展性，主要原因是没使用中央数据库，而是把数据都复制到内存中，变成可复制的内存数据单元。然后，业务处理能力封装成一个个处理单元（prcessing unit）。访问量增加，就新建处理单元；访问量减少，就关闭处理单元。由于没有中央数据库，所以扩展性的最大瓶颈消失了。由于每个处理单元的数据都在内存里，最好要进行数据持久化。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/cloud-architecture.png" width="500"/>
</div>
<p>这个模式主要分成两部分：处理单元（processing unit）和虚拟中间件（virtualized middleware）。</p>
<ul>
<li>处理单元：实现业务逻辑</li>
<li>虚拟中间件：负责通信、保持 sessions、数据复制、分布式处理、处理单元的部署。</li>
</ul>
<p>虚拟中间件又包含四个组件。</p>
<blockquote>
<ul>
<li><strong>消息中间件</strong>（Messaging Grid）：管理用户请求和 session，当一个请求进来以后，决定分配给哪一个处理单元。</li>
<li><strong>数据中间件</strong>（Data Grid）：将数据复制到每一个处理单元，即数据同步。保证某个处理单元都得到同样的数据。</li>
<li><strong>处理中间件</strong>（Processing Grid）：可选，如果一个请求涉及不同类型的处理单元，该中间件负责协调处理单元</li>
<li><strong>部署中间件</strong>（Deployment Manager）：负责处理单元的启动和关闭，监控负载和响应时间，当负载增加，就新启动处理单元，负载减少，就关闭处理单元。</li>
</ul>
</blockquote>
<p>优点</p>
<ul>
<li>高负载，高扩展性</li>
<li>动态部署</li>
</ul>
<p>缺点</p>
<ul>
<li>实现复杂，成本较高</li>
<li>主要适合网站类应用，不合适大量数据吞吐的大型数据库应用</li>
<li>较难测试</li>
</ul>
<h2 id="5-参考资料"><a class="markdownIt-Anchor" href="#5-参考资料"></a> 5. 参考资料</h2>
<ul>
<li><a href="https://item.jd.com/11322972.html" target="_blank" rel="noopener">大型网站技术架构：核心原理与案例分析</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2016/09/software-architecture.html" target="_blank" rel="noopener">软件架构入门- 阮一峰的网络日志</a></li>
</ul>
]]></content>
      <categories>
        <category>设计</category>
        <category>架构</category>
      </categories>
      <tags>
        <tag>设计</tag>
        <tag>架构</tag>
        <tag>网站</tag>
      </tags>
  </entry>
  <entry>
    <title>扩展性架构</title>
    <url>/blog/design/architecture/extensible-architecture/</url>
    <content><![CDATA[<h1 id="扩展性架构"><a class="markdownIt-Anchor" href="#扩展性架构"></a> 扩展性架构</h1>
<blockquote>
<p>扩展性和伸缩性是不同的概念：</p>
<ul>
<li><strong>扩展性（Extensibility）</strong> - 指对现有系统影响最小的情况下，系统功能可持续扩展或提升的能力。表现在系统基础设施稳定不需要经常变更，应用之间较少依赖和耦合，对需求变更可以敏捷响应。它是系统架构设计层面的开闭原则（对扩展开放、对修改关闭），架构设计考虑未来功能扩展，当系统增加新功能时，不需要对现有系统的结构和代码进行修改。</li>
<li><strong>伸缩性（Scalability）</strong> - 指系统能够通过增加减少自身资源规模的方式增减自己计算处理事务的能力。如果这种增减是成比例的，就被称作线性伸缩性。在网站架构中 ，通常指利用集群的方式增加服务器数量、提高系统的整体事务吞吐能力。</li>
</ul>
</blockquote>
<h2 id="1-易扩展的系统架构"><a class="markdownIt-Anchor" href="#1-易扩展的系统架构"></a> 1. 易扩展的系统架构</h2>
<blockquote>
<p><strong>低耦合的系统更容易扩展、复用</strong>。</p>
</blockquote>
<p><strong>可扩展架构的核心思想是模块化，并在此基础上，降低模块间的耦合性，提高模块的复用性</strong>。</p>
<p>分层和分割不仅可以进行架构伸缩，也是模块化设计的重要手段，利用分层和分割的方式将软件分割为若干个低耦合的独立的组件模块，这些组件模块以消息传递及依赖调用的方式聚合成一个完整的系统。</p>
<p>在大型网站中，这些模块通过分布式部署的方式，独立的模块部署在独立的服务器上，从物理上分离模块间的耦合关系，进一步降低耦合性提高复用性。</p>
<h2 id="2-利用分布式消息队列降低系统耦合性"><a class="markdownIt-Anchor" href="#2-利用分布式消息队列降低系统耦合性"></a> 2. 利用分布式消息队列降低系统耦合性</h2>
<h3 id="21-事件驱动架构"><a class="markdownIt-Anchor" href="#21-事件驱动架构"></a> 2.1. 事件驱动架构</h3>
<p><strong>事件驱动架构通过在低耦合的模块间传输事件消息，以保持模块的松散耦合，并借助事件消息的通信完成模块间合作</strong>。典型的事件驱动架构就是操作系统中常见的生产者消费者模式。在大型网站中，最常见的实现手段就是分布式消息队列。</p>
<h3 id="22-分布式消息队列"><a class="markdownIt-Anchor" href="#22-分布式消息队列"></a> 2.2. 分布式消息队列</h3>
<p>消息生产者应用程序通过远程访问接口将消息推送给消息队列服务器，消息队列服务器将消息写入本地内存队列后立即返回成功响应给消息生产者。消息队列服务器根据消息订阅列表查找订阅该消息的消息消费者应用程序，将消息队列中的消息按照先进先出（FIFO）的原则将消息通过远程通信接口发送给消息消费者程序。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/architecture/分布式消息队列架构原理.png!zp" />
</div>
<p>在伸缩性方面，由于消息队列服务器上的数据可以看作是即时处理的，因此类似于无状态的服务器，伸缩性设计比较简单。将新服务器加入分布式消息队列集群中，通知生产者服务器更改消息队列服务器列表即可。</p>
<p>在可用性方面，为了避免消费者进程处理缓慢，分布式消息队列服务器内存空间不足造成的问题，如果内存队列已满，会将消息写入磁盘，消息推送模块在将内存队列消息处理完成以后，将磁盘内容加载到内存队列继续处理。</p>
<h2 id="3-利用分布式服务打造可复用的业务平台"><a class="markdownIt-Anchor" href="#3-利用分布式服务打造可复用的业务平台"></a> 3. 利用分布式服务打造可复用的业务平台</h2>
<p>巨无霸系统的问题：</p>
<ul>
<li>构建、部署困难</li>
<li>代码分支管理困难</li>
<li>数据库连接耗尽</li>
<li>扩展业务困难</li>
</ul>
<p>而解决巨无霸系统问题的方案就是拆分：</p>
<ul>
<li>通过纵向拆分将业务拆分多个应用或模块；</li>
<li>通过横向拆分将可复用业务作为独立应用。</li>
</ul>
<p>然后，需要通过一个分布式服务管理框架将这些应用或服务组织管理起来：通过接口分解系统耦合性，不同子系统通过相同的接口描述进行服务调用。常见的分布式服务管理框架如：Spring Cloud、Dubbo 等。</p>
<p>大型网站分布式服务的需求与特点：</p>
<ul>
<li>负载均衡</li>
<li>失效转移</li>
<li>高效的远程通信</li>
<li>整合异构系统</li>
<li>对应用最少侵入</li>
<li>版本管理</li>
<li>实时监控</li>
</ul>
<h2 id="4-可扩展的数据结构"><a class="markdownIt-Anchor" href="#4-可扩展的数据结构"></a> 4. 可扩展的数据结构</h2>
<p>传统的关系型数据库为了保证关系运算的正确性，在设计数据库表结构的时候，就需要指定表的 schema ——字段名称，数据类型等，并要遵循特定的设计范式。这些规范带来一个问题：难以面对需求变更带来的挑战，所以有人通过预先设计一些冗余字段来应对。</p>
<p>许多 NoSql 数据库使用 ColumnFamily 设计来设计可扩展的数据结构。</p>
<h2 id="5-开放平台"><a class="markdownIt-Anchor" href="#5-开放平台"></a> 5. 开放平台</h2>
<p>很多大公司会利用开放平台提供大量开放性 API 使得企业和个人可以方便的接入业务。通过开放平台，可以构建生态圈，提升品牌价值以及竞争力。</p>
<p>开放平台不是一朝一夕完成的，这需要大量 OPEN API 的沉淀。系统架构在设计之初，应该有意识的将未来可能被复用的接口好好设计，以便于需要开放 OPEN API 时，可以便捷的暴露服务接口。</p>
<h2 id="6-参考资料"><a class="markdownIt-Anchor" href="#6-参考资料"></a> 6. 参考资料</h2>
<ul>
<li><a href="https://item.jd.com/11322972.html" target="_blank" rel="noopener">大型网站技术架构：核心原理与案例分析</a></li>
</ul>
]]></content>
      <categories>
        <category>设计</category>
        <category>架构</category>
      </categories>
      <tags>
        <tag>设计</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>高性能架构</title>
    <url>/blog/design/architecture/high-performance-architecture/</url>
    <content><![CDATA[<h1 id="高性能架构"><a class="markdownIt-Anchor" href="#高性能架构"></a> 高性能架构</h1>
<h2 id="1-性能测试"><a class="markdownIt-Anchor" href="#1-性能测试"></a> 1. 性能测试</h2>
<blockquote>
<p>性能测试是性能优化的前提和基础，也是性能优化结果的检查和度量标准。不同视角下的性能有不同标准，也有不同的优化手段。</p>
</blockquote>
<h3 id="11-性能指标"><a class="markdownIt-Anchor" href="#11-性能指标"></a> 1.1. 性能指标</h3>
<p>性能测试的主要指标有：</p>
<ul>
<li><strong>响应时间</strong> - 响应时间(RT)是指从客户端发一个请求开始计时，到客户端接收到从服务器端返回的响应结果结束所经历的时间，响应时间由请求发送时间、网络传输时间和服务器处理时间三部分组成。</li>
<li><strong>并发数</strong> - 系统能同时处理的请求、事务数。</li>
<li><strong>吞吐量</strong> - <strong><code>TPS(每秒事务数)</code></strong>、<strong><code>HPS(每秒 HTTP 请求数)</code></strong>、<strong><code>QPS(每秒查询数)</code></strong>。</li>
<li><strong>性能计数器</strong> - 系统负载、对象与线程数、内存使用、CPU 使用、磁盘与网络 IO 等。这些指标也是系统监控的重要参数。</li>
</ul>
<h3 id="12-性能测试方法"><a class="markdownIt-Anchor" href="#12-性能测试方法"></a> 1.2. 性能测试方法</h3>
<ul>
<li>性能测试</li>
<li>负载测试</li>
<li>压力测试</li>
<li>稳定性测试</li>
</ul>
<h3 id="13-性能测试报告"><a class="markdownIt-Anchor" href="#13-性能测试报告"></a> 1.3. 性能测试报告</h3>
<p>性能测试报告示例：</p>
<div align="center">
<img src="https://upload-images.jianshu.io/upload_images/3101171-3d533a36f42608a1.png" />
</div>
<h3 id="14-性能优化策略"><a class="markdownIt-Anchor" href="#14-性能优化策略"></a> 1.4. 性能优化策略</h3>
<ol>
<li><strong>性能分析</strong> - 如果请求响应慢，存在性能问题。需要对请求经历的各个环节逐一分析，排查可能出现性能瓶颈的地方，定位问题。检查监控数据，分析影响性能的主要因素：内存、磁盘、网络、CPU，可能是代码或架构设计不合理，又或者是系统资源确实不足。</li>
<li><strong>性能优化</strong> - 性能优化根据网站分层架构，大致可分为前端性能优化、应用服务性能优化、存储服务性能优化。</li>
</ol>
<h2 id="2-前端性能优化"><a class="markdownIt-Anchor" href="#2-前端性能优化"></a> 2. 前端性能优化</h2>
<h3 id="21-浏览器访问优化"><a class="markdownIt-Anchor" href="#21-浏览器访问优化"></a> 2.1. 浏览器访问优化</h3>
<ol>
<li><strong>减少 HTTP 请求</strong> - HTTP 请求需要建立通信链路，进行数据传输，开销高昂，所以减少 HTTP 请求数可以有效提高访问性能。减少 HTTP 的主要手段是合并 Css、JavaScript、图片。</li>
<li><strong>使用浏览器缓存</strong> - 因为静态资源文件更新频率低，可以缓存浏览器中以提高性能。设置 HTTP 头中的 <code>Cache-Control</code> 和 <code>Expires</code> 属性，可设定浏览器缓存。</li>
<li><strong>启用压缩</strong> - 在服务器端压缩静态资源文件，在浏览器端解压缩，可以有效减少传输的数据量。由于文本文件压缩率可达 80% 以上，所以可以对静态资源，如 Html、Css、JavaScrip 进行压缩。</li>
<li><strong>CSS 放在页面最上面，JavaScript 放在页面最下面</strong> - 浏览器会在下载完全部的 Css 后才对整个页面进行渲染，所以最好的做法是将 Css 放在页面最上面，让浏览器尽快下载 Css；JavaScript 则相反，浏览器加载 JavaScript 后立即执行，可能会阻塞整个页面，造成页面显示缓慢，因此 JavaScript 最好放在页面最下面。</li>
<li><strong>减少 Cookie 传输</strong> - Cookie 包含在 HTTP 每次的请求和响应中，太大的 Cookie 会严重影响数据传输。</li>
</ol>
<h3 id="22-cdn"><a class="markdownIt-Anchor" href="#22-cdn"></a> 2.2. CDN</h3>
<p>CDN 一般缓存的是静态资源。</p>
<p>CDN 的本质仍然是一个缓存，而且将数据缓存在离用户最近的地方，使用户已最快速度获取数据，即所谓网络访问第一跳。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/architecture/cdn.png!zp" width="640" />
</div>
<h3 id="23-反向代理"><a class="markdownIt-Anchor" href="#23-反向代理"></a> 2.3. 反向代理</h3>
<p>传统代理服务器位于浏览器一侧，代理浏览器将 HTTP 请求发送到互联网上，而反向代理服务器位于网站机房一侧，代理网站服务器接收 HTTP 请求。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/architecture/reverse-proxy.jpg!zp" width="640" />
</div>
<p>反向代理服务器可以配置缓存功能加速 Web 请求，当用户第一次访问静态内容时，静态内容就会被缓存在反向代理服务器上。</p>
<p>反向代理还可以实现负载均衡，通过负载均衡构建的集群可以提高系统总体处理能力。</p>
<p>因为所有请求都必须先经过反向代理服务器，所以可以屏蔽一些攻击 IP，达到保护网站安全的作用。</p>
<h2 id="3-应用服务性能优化"><a class="markdownIt-Anchor" href="#3-应用服务性能优化"></a> 3. 应用服务性能优化</h2>
<h3 id="31-分布式缓存"><a class="markdownIt-Anchor" href="#31-分布式缓存"></a> 3.1. 分布式缓存</h3>
<blockquote>
<p>网站性能优化第一定律：优先考虑使用缓存优化性能。</p>
</blockquote>
<h4 id="311-缓存原理"><a class="markdownIt-Anchor" href="#311-缓存原理"></a> 3.1.1. 缓存原理</h4>
<p>缓存指将数据存储在相对较高访问速度的存储介质中，以供系统处理。一方面缓存访问速度快，可以减少数据访问的时间，另一方面如果缓存的数据是经过计算处理得到的，那么被缓存的数据无需重复计算即可直接使用，因此缓存还起到减少计算时间的作用。</p>
<p>缓存的本质是一个内存 HASH 表。</p>
<p>缓存主要用来存放那些读写比很高、很少变化的数据，如商品的类目信息，热门词的搜索列表信息、热门商品信息等。</p>
<h4 id="312-合理使用缓存"><a class="markdownIt-Anchor" href="#312-合理使用缓存"></a> 3.1.2. 合理使用缓存</h4>
<p>缓存数据的选择：</p>
<ul>
<li>不要存储频繁修改的数据</li>
<li>不要存储非热点数据</li>
<li>数据不一致与脏读：缓存有有效期，所以存在一定时间的数据不一致和脏读问题。如果不能接受，可以考虑使用数据更新立即更新缓存策略</li>
</ul>
<p>需要考虑的缓存问题：</p>
<ul>
<li><strong>缓存雪崩</strong> - 当缓存服务崩溃时，数据库会因为不能承受过大的压力而宕机。</li>
<li><strong>缓存预热</strong> - 对于一些明确的热点数据、元数据，如地名、类目信息等，可以在启动时加载到缓存进行预热。</li>
<li><strong>缓存穿透</strong> - 如果因不恰当的业务或恶意攻击持续高并发地请求某个不存在的数据，由于缓存中没有该数据，就会导致请求都落在数据库上，导致数据库最终崩溃。一个简单的策略是将不存在的数据也缓存起来（即缓存 null 值）。</li>
</ul>
<h3 id="32-异步操作"><a class="markdownIt-Anchor" href="#32-异步操作"></a> 3.2. 异步操作</h3>
<p>异步处理不仅可以减少系统服务间的耦合度，提高扩展性，事实上，它还可以提高系统的性能。异步处理可以有效减少响应等待时间，从而提高响应速度。</p>
<p>异步处理一般是通过分布式消息队列的方式。</p>
<p>异步处理可以解决以下问题：</p>
<ul>
<li>异步处理</li>
<li>应用解耦</li>
<li>流量削锋</li>
<li>日志处理</li>
<li>消息通讯</li>
</ul>
<h3 id="33-使用集群"><a class="markdownIt-Anchor" href="#33-使用集群"></a> 3.3. 使用集群</h3>
<p>在高并发场景下，使用负载均衡技术为一个应用构建一个由多台服务器组成的服务器集群，将并发访问请求分发到多台服务器上处理，避免单一服务器因负载压力过大而响应缓慢，使用户请求具有更好的响应延迟特性。</p>
<h3 id="34-代码优化"><a class="markdownIt-Anchor" href="#34-代码优化"></a> 3.4. 代码优化</h3>
<h4 id="341-多线程"><a class="markdownIt-Anchor" href="#341-多线程"></a> 3.4.1. 多线程</h4>
<p>从资源利用的角度看，使用多线程的原因主要有两个：IO 阻塞和多 CPU。</p>
<p>线程数并非越多越好，那么启动多少线程合适呢？</p>
<p>有个参考公式：</p>
<figure class="highlight fix"><table><tr><td class="code"><pre><span class="line"><span class="attr">启动线程数 </span>=<span class="string"> (任务执行时间 / (任务执行时间 - IO 等待时间)) * CPU 内核数</span></span><br></pre></td></tr></table></figure>
<p>最佳启动线程数和 CPU 内核数成正比，和 IO 阻塞时间成反比。</p>
<ul>
<li>如果任务都是 CPU 计算型任务，那么线程数最多不要超过 CPU 内核数，因为启动再多线程，CPU 也来不及调度；</li>
<li>相反，如果是任务需要等待磁盘操作，网络响应，那么多启动线程有助于任务并罚赌，提高系统吞吐量。</li>
</ul>
<h5 id="线程安全问题"><a class="markdownIt-Anchor" href="#线程安全问题"></a> 线程安全问题</h5>
<p>线程安全问题时指多个线程并发访问某个资源，导致数据混乱。</p>
<p>解决手段有：</p>
<ul>
<li><strong>将对象设计为无状态对象</strong> - 典型应用：Servlet 就是无状态对象，可以被服务器多线程并发调用处理用户请求。</li>
<li><strong>使用局部对象</strong></li>
<li><strong>并发访问资源时使用锁</strong> - 但是引入锁会产生性能开销，应尽量使用轻量级的锁。</li>
</ul>
<h4 id="342-资源复用"><a class="markdownIt-Anchor" href="#342-资源复用"></a> 3.4.2. 资源复用</h4>
<p>应该尽量减少那些开销很大的系统资源的创建和销毁，如数据库连接、网络通信连接、线程、复杂对象等。从编程角度，资源复用主要有两种模式：单例模式和对象池。</p>
<h4 id="343-数据结构"><a class="markdownIt-Anchor" href="#343-数据结构"></a> 3.4.3. 数据结构</h4>
<p>根据具体场景，选择合适的数据结构。</p>
<h4 id="344-垃圾回收"><a class="markdownIt-Anchor" href="#344-垃圾回收"></a> 3.4.4. 垃圾回收</h4>
<p>如果 Web 应用运行在 JVM 等具有垃圾回收功能的环境中，那么垃圾回收可能会对系统的性能特性产生巨大影响。立即垃圾回收机制有助于程序优化和参数调优，以及编写内存安全的代码。</p>
<h2 id="4-存储性能优化"><a class="markdownIt-Anchor" href="#4-存储性能优化"></a> 4. 存储性能优化</h2>
<h3 id="41-机械键盘和固态硬盘"><a class="markdownIt-Anchor" href="#41-机械键盘和固态硬盘"></a> 4.1. 机械键盘和固态硬盘</h3>
<p>考虑使用固态硬盘替代机械键盘，因为它的读写速度更快。</p>
<h3 id="42-b数和-lsm-树"><a class="markdownIt-Anchor" href="#42-b数和-lsm-树"></a> 4.2. B+数和 LSM 树</h3>
<p>传统关系数据库的数据库索引一般都使用两级索引的 <strong>B+ 树</strong> 结构，树的层次最多三层。因此可能需要 5 次磁盘访问才能更新一条记录（三次磁盘访问获得数据索引及行 ID，然后再进行一次数据文件读操作及一次数据文件写操作）。</p>
<p>由于磁盘访问是随机的，传统机械键盘在数据随机访问时性能较差，每次数据访问都需要多次访问磁盘影响数据访问性能。</p>
<p>许多 Nosql 数据库中的索引采用 <strong>LSM 树</strong> 作为主要数据结构。LSM 树可视为一个 N 阶合并树。数据写操作都在内存中进行。在 <strong>LSM 树上进行一次数据更新不需要磁盘访问，速度远快于 B+ 树</strong>。</p>
<h3 id="43-raid-和-hdfs"><a class="markdownIt-Anchor" href="#43-raid-和-hdfs"></a> 4.3. RAID 和 HDFS</h3>
<p>RAID 是 Redundant Array of Independent Disks 的缩写，中文简称为独立冗余磁盘阵列。</p>
<p>RAID 是一种把多块独立的硬盘（物理硬盘）按不同的方式组合起来形成一个硬盘组（逻辑硬盘），从而提供比单个硬盘更高的存储性能和提供数据备份技术。</p>
<p>HDFS(分布式文件系统) 更被大型网站所青睐。它可以配合 <code>MapReduce</code> 并发计算任务框架进行大数据处理，可以在整个集群上并发访问所有磁盘，无需 RAID 支持。</p>
<p>HDFS 对数据存储空间的管理以数据块（Block）为单位，默认为 64 MB。所以，HDFS 更适合存储较大的文件。</p>
<h2 id="5-参考资料"><a class="markdownIt-Anchor" href="#5-参考资料"></a> 5. 参考资料</h2>
<ul>
<li><a href="https://item.jd.com/11322972.html" target="_blank" rel="noopener">大型网站技术架构：核心原理与案例分析</a></li>
</ul>
]]></content>
      <categories>
        <category>设计</category>
        <category>架构</category>
      </categories>
      <tags>
        <tag>设计</tag>
        <tag>架构</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>系统安全性架构</title>
    <url>/blog/design/architecture/security-architecture/</url>
    <content><![CDATA[<h1 id="系统安全性架构"><a class="markdownIt-Anchor" href="#系统安全性架构"></a> 系统安全性架构</h1>
<blockquote>
<p>关键词：XSS、CSRF、SQL 注入、DoS、消息摘要、加密算法、证书</p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#%E4%B8%80%E8%AE%A4%E8%AF%81">一、认证</a>
<ul>
<li><a href="#sso">SSO</a></li>
<li><a href="#oauth-20">Oauth 2.0</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E9%89%B4%E6%9D%83">二、鉴权</a>
<ul>
<li><a href="#rbac">RBAC</a></li>
<li><a href="#%E8%A7%92%E8%89%B2%E7%BB%A7%E6%89%BF">角色继承</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89%E5%AE%A1%E8%AE%A1">三、审计</a></li>
<li><a href="#%E5%9B%9B%E7%BD%91%E7%AB%99%E6%94%BB%E5%87%BB">四、网站攻击</a>
<ul>
<li><a href="#xss">XSS</a></li>
<li><a href="#csrf">CSRF</a></li>
<li><a href="#sql-%E6%B3%A8%E5%85%A5">SQL 注入</a></li>
<li><a href="#dos">DoS</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF">五、加密技术</a>
<ul>
<li><a href="#%E6%B6%88%E6%81%AF%E6%91%98%E8%A6%81">消息摘要</a></li>
<li><a href="#%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95">加密算法</a></li>
<li><a href="#%E8%AF%81%E4%B9%A6">证书</a></li>
</ul>
</li>
<li><a href="#%E5%85%AD%E4%BF%A1%E6%81%AF%E8%BF%87%E6%BB%A4">六、信息过滤</a>
<ul>
<li><a href="#%E6%96%87%E6%9C%AC%E5%8C%B9%E9%85%8D">文本匹配</a></li>
<li><a href="#%E9%BB%91%E5%90%8D%E5%8D%95">黑名单</a></li>
<li><a href="#%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95">分类算法</a></li>
</ul>
</li>
<li><a href="#%E4%B8%83%E9%A3%8E%E9%99%A9%E6%8E%A7%E5%88%B6">七、风险控制</a>
<ul>
<li><a href="#%E9%A3%8E%E9%99%A9%E7%A7%8D%E7%B1%BB">风险种类</a></li>
<li><a href="#%E9%A3%8E%E9%99%A9%E6%8E%A7%E5%88%B6%E6%89%8B%E6%AE%B5">风险控制手段</a></li>
<li><a href="#%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E">规则引擎</a></li>
<li><a href="#%E7%BB%9F%E8%AE%A1%E6%A8%A1%E5%9E%8B">统计模型</a></li>
</ul>
</li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="一-认证"><a class="markdownIt-Anchor" href="#一-认证"></a> 一、认证</h2>
<h3 id="sso"><a class="markdownIt-Anchor" href="#sso"></a> SSO</h3>
<p><strong>SSO(Single Sign On)，即单点登录</strong>。所谓单点登录，就是同平台的诸多应用登陆一次，下一次就免登陆的功能。</p>
<p>SSO 需要解决多个异构系统之间的问题：</p>
<ul>
<li>Session 共享问题</li>
<li>跨域问题</li>
</ul>
<h4 id="session-共享问题"><a class="markdownIt-Anchor" href="#session-共享问题"></a> Session 共享问题</h4>
<p>分布式 Session 的几种实现策略：</p>
<ul>
<li>粘性 Session - 缺点：当<strong>服务器节点宕机时，将丢失该服务器节点上的所有 Session</strong>。</li>
<li>应用服务器间的 Session 复制共享 - 缺点：<strong>占用过多内存</strong>；<strong>同步过程占用网络带宽以及服务器处理器时间</strong>。</li>
<li>基于缓存的 Session 共享 ✅ （推荐方案） - 不过需要程序自身控制 Session 读写，可以考虑基于 spring-session + redis 这种成熟的方案来处理。</li>
</ul>
<blockquote>
<p>详情请参考：<a href="../theory/distributed-session-theory.md">Session 原理</a></p>
</blockquote>
<h4 id="cookie-跨域"><a class="markdownIt-Anchor" href="#cookie-跨域"></a> Cookie 跨域</h4>
<p><strong>Cookie 不能跨域</strong>！比如：浏览器不会把 <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> 的 cookie 传给 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a>。</p>
<p>这就存在一个问题：由于域名不同，用户在系统 A 登录后，浏览器记录系统 A 的 Cookie，但是访问系统 B 的时候不会携带这个 Cookie。</p>
<p>针对 <strong>Cookie 不能跨域</strong> 的问题，有几种解决方案：</p>
<ul>
<li>服务端生成 Cookie 后，返回给客户端，客户端解析 Cookie ，提取 Token （比如 JWT），此后每次请求都携带这个 Token。</li>
<li>多个域名共享 Cookie，在返回 Cookie 给客户端的时候，在 Cookie 中设置 domain 白名单。</li>
<li>将 Token 保存在 <strong><code>SessionStroage</code></strong> 中（不依赖 Cookie 就没有跨域的问题了）。</li>
</ul>
<h4 id="cas"><a class="markdownIt-Anchor" href="#cas"></a> CAS</h4>
<p>CAS 是实现 SSO 的主流方式。</p>
<p>CAS 分为两部分，CAS Server 和 CAS Client</p>
<ul>
<li><strong><code>CAS Server</code></strong> - 负责用户的认证工作，就像是把第一次登录用户的一个标识存在这里，以便此用户在其他系统登录时验证其需不需要再次登录。</li>
<li><strong><code>CAS Client</code></strong> - 业务应用，需要接入 CAS Server。当用户访问我们的应用时，首先需要重定向到 CAS Server 端进行验证，要是原来登陆过，就免去登录，重定向到下游系统，否则进行用户名密码登陆操作。</li>
</ul>
<p>术语：</p>
<ul>
<li><strong><code>Ticket Granting Ticket (TGT)</code></strong> - 可以认为是 CAS Server 根据用户名、密码生成的一张票，存在 Server 端。</li>
<li><strong><code>Ticket Granting Cookie (TGC)</code></strong> - 其实就是一个 Cookie，存放用户身份信息，由 Server 发给 Client 端。</li>
<li><strong><code>Service Ticket (ST)</code></strong> - 由 TGT 生成的一次性票据，用于验证，只能用一次。</li>
</ul>
<p>CAS 工作流程：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200119195646.png" alt="" /></p>
<ol>
<li>用户访问 CAS Client A（业务系统），第一次访问，重定向到认证服务中心（CAS Server）。CAS Server 发现当前请求中没有 Cookie，再重定向到 CAS Server 的登录页面。重定向请求的 URL 中包含访问地址，以便认证成功后直接跳转到访问页面。</li>
<li>用户在登录页面输入用户名、密码等认证信息，认证成功后，CAS Server 生成 TGT，再用 TGT 生成一个 ST。然后返回 ST 和 TGC（Cookie）给浏览器。</li>
<li>浏览器携带 ST 再度访问之前想访问的 CAS Client A 页面。</li>
<li>CAS Client A 收到 ST 后，向 CAS Server 验证 ST 的有效性。验证通过则允许用户访问页面。</li>
<li>此时，如果登录另一个 CAS Client B，会先重定向到 CAS Server，CAS Server 可以判断这个 CAS Client B 是第一次访问，但是本地有 TGC，所以无需再次登录。用 TGC 创建一个 ST，返回给浏览器。</li>
<li>重复类似 3、4 步骤。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200119202448.png" alt="" /></p>
<p>以上了归纳总结如下：</p>
<ol>
<li>
<p><strong>访问服务</strong> - 用户访问 SSO Client 资源。</p>
</li>
<li>
<p><strong>定向认证</strong> - SSO Client 重定向用户请求到 SSO Server。</p>
</li>
<li>
<p><strong>用户认证</strong> - 用户身份认证。</p>
</li>
<li>
<p><strong>发放票据</strong> - SSO Server 会产生一个 Service Ticket (ST) 并返回给浏览器。</p>
</li>
<li>
<p><strong>验证票据</strong> - 浏览器每次访问 SSO Client 时，携带 ST，SSO Client 向 SSO Server 验证票据。只有验证通过，才允许访问。</p>
</li>
<li>
<p><strong>传输用户信息</strong> - SSO Server 验证票据通过后，传输用户认证结果信息给 SSO Client。</p>
</li>
</ol>
<h3 id="oauth-20"><a class="markdownIt-Anchor" href="#oauth-20"></a> Oauth 2.0</h3>
<h4 id="基本原理"><a class="markdownIt-Anchor" href="#基本原理"></a> 基本原理</h4>
<p>OAuth 在&quot;客户端&quot;与&quot;服务提供商&quot;之间，设置了一个授权层（authorization layer）。“客户端&quot;不能直接登录&quot;服务提供商”，只能登录授权层，以此将用户与客户端区分开来。&quot;客户端&quot;登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。</p>
<p>&quot;客户端&quot;登录授权层以后，&quot;服务提供商&quot;根据令牌的权限范围和有效期，向&quot;客户端&quot;开放用户储存的资料。</p>
<p>OAuth 2.0 的运行流程如下图，摘自 RFC 6749。</p>
<div align="center"><img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014051203.png"/></div>
（A）用户打开客户端以后，客户端要求用户给予授权。
<p>（B）用户同意给予客户端授权。</p>
<p>（C）客户端使用上一步获得的授权，向认证服务器申请令牌。</p>
<p>（D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。</p>
<p>（E）客户端使用令牌，向资源服务器申请获取资源。</p>
<p>（F）资源服务器确认令牌无误，同意向客户端开放资源。</p>
<p>不难看出来，上面六个步骤之中，B 是关键，即用户怎样才能给于客户端授权。有了这个授权以后，客户端就可以获取令牌，进而凭令牌获取资源。</p>
<h4 id="授权模式"><a class="markdownIt-Anchor" href="#授权模式"></a> 授权模式</h4>
<p>客户端必须得到用户的授权（authorization grant），才能获得令牌（access token）。OAuth 2.0 定义了四种授权方式。</p>
<ul>
<li>授权码模式（authorization code）</li>
<li>简化模式（implicit）</li>
<li>密码模式（resource owner password credentials）</li>
<li>客户端模式（client credentials）</li>
</ul>
<h4 id="授权码模式"><a class="markdownIt-Anchor" href="#授权码模式"></a> 授权码模式</h4>
<p>授权码模式（authorization code）是功能最完整、流程最严密的授权模式。它的特点就是通过客户端的后台服务器，与&quot;服务提供商&quot;的认证服务器进行互动。</p>
<div align="center"><img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014051204.png"/></div>
它的步骤如下：
<p>（A）用户访问客户端，后者将前者导向认证服务器。</p>
<p>（B）用户选择是否给予客户端授权。</p>
<p>（C）假设用户给予授权，认证服务器将用户导向客户端事先指定的&quot;重定向 URI&quot;（redirection URI），同时附上一个授权码。</p>
<p>（D）客户端收到授权码，附上早先的&quot;重定向 URI&quot;，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见。</p>
<p>（E）认证服务器核对了授权码和重定向 URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）。</p>
<p>下面是上面这些步骤所需要的参数。</p>
<p>A 步骤中，客户端申请认证的 URI，包含以下参数：</p>
<ul>
<li>response_type：表示授权类型，必选项，此处的值固定为&quot;code&quot;</li>
<li>client_id：表示客户端的 ID，必选项</li>
<li>redirect_uri：表示重定向 URI，可选项</li>
<li>scope：表示申请的权限范围，可选项</li>
<li>state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET /authorize?response_type=code&amp;client_id=s6BhdRkqt3&amp;state=xyz</span><br><span class="line">  &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br></pre></td></tr></table></figure>
<p>C 步骤中，服务器回应客户端的 URI，包含以下参数：</p>
<ul>
<li>code：表示授权码，必选项。该码的有效期应该很短，通常设为 10 分钟，客户端只能使用该码一次，否则会被授权服务器拒绝。该码与客户端 ID 和重定向 URI，是一一对应关系。</li>
<li>state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">302</span> Found</span><br><span class="line"><span class="attribute">Location</span>: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA</span><br><span class="line">    &amp;state=xyz</span><br></pre></td></tr></table></figure>
<p>D 步骤中，客户端向认证服务器申请令牌的 HTTP 请求，包含以下参数：</p>
<ul>
<li>grant_type：表示使用的授权模式，必选项，此处的值固定为&quot;authorization_code&quot;。</li>
<li>code：表示上一步获得的授权码，必选项。</li>
<li>redirect_uri：表示重定向 URI，必选项，且必须与 A 步骤中的该参数值保持一致。</li>
<li>client_id：表示客户端 ID，必选项。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/token</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br><span class="line"><span class="attribute">Authorization</span>: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=authorization_code&amp;code=SplxlOBeZQQYbYS6WxSbIA</span><br><span class="line">&amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb</span><br></pre></td></tr></table></figure>
<p>E 步骤中，认证服务器发送的 HTTP 回复，包含以下参数：</p>
<ul>
<li>access_token：表示访问令牌，必选项。</li>
<li>token_type：表示令牌类型，该值大小写不敏感，必选项，可以是 bearer 类型或 mac 类型。</li>
<li>expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</li>
<li>refresh_token：表示更新令牌，用来获取下一次的访问令牌，可选项。</li>
<li>scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json;charset=UTF-8</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-store</span><br><span class="line"><span class="attribute">Pragma</span>: no-cache</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"> "access_token":"2YotnFZFEjr1zCsicMWpAA",</span><br><span class="line"> "token_type":"example",</span><br><span class="line"> "expires_in":3600,</span><br><span class="line"> "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",</span><br><span class="line"> "example_parameter":"example_value"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面代码可以看到，相关参数使用 JSON 格式发送（Content-Type: application/json）。此外，HTTP 头信息中明确指定不得缓存。</p>
<h4 id="简化模式"><a class="markdownIt-Anchor" href="#简化模式"></a> 简化模式</h4>
<p>简化模式（implicit grant type）不通过第三方应用程序的服务器，直接在浏览器中向认证服务器申请令牌，跳过了&quot;授权码&quot;这个步骤，因此得名。所有步骤在浏览器中完成，令牌对访问者是可见的，且客户端不需要认证。</p>
<div align="center"><img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014051205.png"/></div>
它的步骤如下：
<p>（A）客户端将用户导向认证服务器。</p>
<p>（B）用户决定是否给于客户端授权。</p>
<p>（C）假设用户给予授权，认证服务器将用户导向客户端指定的&quot;重定向 URI&quot;，并在 URI 的 Hash 部分包含了访问令牌。</p>
<p>（D）浏览器向资源服务器发出请求，其中不包括上一步收到的 Hash 值。</p>
<p>（E）资源服务器返回一个网页，其中包含的代码可以获取 Hash 值中的令牌。</p>
<p>（F）浏览器执行上一步获得的脚本，提取出令牌。</p>
<p>（G）浏览器将令牌发给客户端。</p>
<p>下面是上面这些步骤所需要的参数。</p>
<p>A 步骤中，客户端发出的 HTTP 请求，包含以下参数：</p>
<ul>
<li>response_type：表示授权类型，此处的值固定为&quot;token&quot;，必选项。</li>
<li>client_id：表示客户端的 ID，必选项。</li>
<li>redirect_uri：表示重定向的 URI，可选项。</li>
<li>scope：表示权限范围，可选项。</li>
<li>state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET /authorize?response_type=token&amp;client_id=s6BhdRkqt3&amp;state=xyz</span><br><span class="line">  &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br></pre></td></tr></table></figure>
<p>C 步骤中，认证服务器回应客户端的 URI，包含以下参数：</p>
<ul>
<li>access_token：表示访问令牌，必选项。</li>
<li>token_type：表示令牌类型，该值大小写不敏感，必选项。</li>
<li>expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</li>
<li>scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。</li>
<li>state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">302</span> Found</span><br><span class="line"><span class="attribute">Location</span>: http://example.com/cb#access_token=2YotnFZFEjr1zCsicMWpAA</span><br><span class="line">         &amp;state=xyz&amp;token_type=example&amp;expires_in=3600</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，认证服务器用 HTTP 头信息的 Location 栏，指定浏览器重定向的网址。注意，在这个网址的 Hash 部分包含了令牌。</p>
<p>根据上面的 D 步骤，下一步浏览器会访问 Location 指定的网址，但是 Hash 部分不会发送。接下来的 E 步骤，服务提供商的资源服务器发送过来的代码，会提取出 Hash 中的令牌。</p>
<p>密码模式</p>
<p>密码模式（Resource Owner Password Credentials Grant）中，用户向客户端提供自己的用户名和密码。客户端使用这些信息，向&quot;服务商提供商&quot;索要授权。</p>
<p>在这种模式中，用户必须把自己的密码给客户端，但是客户端不得储存密码。这通常用在用户对客户端高度信任的情况下，比如客户端是操作系统的一部分，或者由一个著名公司出品。而认证服务器只有在其他授权模式无法执行的情况下，才能考虑使用这种模式。</p>
<div align="center"><img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014051206.png"/></div>
它的步骤如下：
<p>（A）用户向客户端提供用户名和密码。</p>
<p>（B）客户端将用户名和密码发给认证服务器，向后者请求令牌。</p>
<p>（C）认证服务器确认无误后，向客户端提供访问令牌。</p>
<p>B 步骤中，客户端发出的 HTTP 请求，包含以下参数：</p>
<ul>
<li>grant_type：表示授权类型，此处的值固定为&quot;password&quot;，必选项。</li>
<li>username：表示用户名，必选项。</li>
<li>password：表示用户的密码，必选项。</li>
<li>scope：表示权限范围，可选项。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/token</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br><span class="line"><span class="attribute">Authorization</span>: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=password&amp;username=johndoe&amp;password=A3ddj3w</span><br></pre></td></tr></table></figure>
<p>C 步骤中，认证服务器向客户端发送访问令牌，下面是一个例子。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json;charset=UTF-8</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-store</span><br><span class="line"><span class="attribute">Pragma</span>: no-cache</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"> "access_token":"2YotnFZFEjr1zCsicMWpAA",</span><br><span class="line"> "token_type":"example",</span><br><span class="line"> "expires_in":3600,</span><br><span class="line"> "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",</span><br><span class="line"> "example_parameter":"example_value"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，各个参数的含义参见《授权码模式》一节。</p>
<p>整个过程中，客户端不得保存用户的密码。</p>
<p>客户端模式</p>
<p>客户端模式（Client Credentials Grant）指客户端以自己的名义，而不是以用户的名义，向&quot;服务提供商&quot;进行认证。严格地说，客户端模式并不属于 OAuth 框架所要解决的问题。在这种模式中，用户直接向客户端注册，客户端以自己的名义要求&quot;服务提供商&quot;提供服务，其实不存在授权问题。</p>
<div align="center"><img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014051207.png"/></div>
它的步骤如下：
<p>（A）客户端向认证服务器进行身份认证，并要求一个访问令牌。</p>
<p>（B）认证服务器确认无误后，向客户端提供访问令牌。</p>
<p>A 步骤中，客户端发出的 HTTP 请求，包含以下参数：</p>
<ul>
<li>grant<em>type：表示授权类型，此处的值固定为&quot;client</em>credentials&quot;，必选项。</li>
<li>scope：表示权限范围，可选项。</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/token</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br><span class="line"><span class="attribute">Authorization</span>: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=client_credentials</span><br></pre></td></tr></table></figure>
<p>认证服务器必须以某种方式，验证客户端身份。</p>
<p>B 步骤中，认证服务器向客户端发送访问令牌，下面是一个例子。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json;charset=UTF-8</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-store</span><br><span class="line"><span class="attribute">Pragma</span>: no-cache</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"> "access_token":"2YotnFZFEjr1zCsicMWpAA",</span><br><span class="line"> "token_type":"example",</span><br><span class="line"> "expires_in":3600,</span><br><span class="line"> "example_parameter":"example_value"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，各个参数的含义参见《授权码模式》一节。</p>
<h4 id="更新令牌"><a class="markdownIt-Anchor" href="#更新令牌"></a> 更新令牌</h4>
<p>如果用户访问的时候，客户端的&quot;访问令牌&quot;已经过期，则需要使用&quot;更新令牌&quot;申请一个新的访问令牌。</p>
<p>客户端发出更新令牌的 HTTP 请求，包含以下参数：</p>
<ul>
<li>grant<em>type：表示使用的授权模式，此处的值固定为&quot;refresh</em>token&quot;，必选项。</li>
<li>refresh_token：表示早前收到的更新令牌，必选项。</li>
<li>scope：表示申请的授权范围，不可以超出上一次申请的范围，如果省略该参数，则表示与上一次一致。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/token</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br><span class="line"><span class="attribute">Authorization</span>: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=refresh_token&amp;refresh_token=tGzv3JOkF0XG5Qx2TlKWIA</span><br></pre></td></tr></table></figure>
<h2 id="二-鉴权"><a class="markdownIt-Anchor" href="#二-鉴权"></a> 二、鉴权</h2>
<h3 id="rbac"><a class="markdownIt-Anchor" href="#rbac"></a> RBAC</h3>
<p>基于角色的访问控制（RBAC: Role-Based Access Control)</p>
<p>每个用户关联一个或多个角色，每个角色关联一个或多个权限，从而可以实现了非常灵活的权限管理。角色可以根据实际业务需求灵活创建，这样就省去了每新增一个用户就要关联一遍所有权限的麻烦。简单来说 RBAC 就是：用户关联角色，角色关联权限。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200119210359.png" alt="" /></p>
<h3 id="角色继承"><a class="markdownIt-Anchor" href="#角色继承"></a> 角色继承</h3>
<p>角色继承(Hierarchical Role) 就是指角色可以继承于其他角色，在拥有其他角色权限的同时，自己还可以关联额外的权限。这种设计可以给角色分组和分层，一定程度简化了权限管理工作。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200119210528.png" alt="" /></p>
<h4 id="职责分离separation-of-duty"><a class="markdownIt-Anchor" href="#职责分离separation-of-duty"></a> 职责分离(Separation of Duty)</h4>
<p>为了避免用户拥有过多权限而产生利益冲突，例如一个篮球运动员同时拥有裁判的权限（看一眼就给你判犯规狠不狠？），另一种职责分离扩展版的 RBAC 被提出。</p>
<p>职责分离有两种模式：</p>
<p>静态职责分离(Static Separation of Duty)：用户无法同时被赋予有冲突的角色。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/594774-feb7c1074d151113.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/509/format/webp" alt="img" /></p>
<p>动态职责分离(Dynamic Separation of Duty)：用户在一次会话（Session）中不能同时激活自身所拥有的、互相有冲突的角色，只能选择其一。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/594774-059b93e4209e8fa6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/397/format/webp" alt="img" /></p>
<p>讲了这么多 RBAC，都还只是在用户和权限之间进行设计，并没有涉及到用户和对象之间的权限判断，而在实际业务系统中限制用户能够使用的对象是很常见的需求。</p>
<h2 id="三-审计"><a class="markdownIt-Anchor" href="#三-审计"></a> 三、审计</h2>
<p>TODO</p>
<h2 id="四-网站攻击"><a class="markdownIt-Anchor" href="#四-网站攻击"></a> 四、网站攻击</h2>
<p>互联网环境鱼龙混杂，网站被攻击是常见现象，所以了解一些常见的网站攻击手段十分必要。下面列举比较常见的 4 种攻击手段：</p>
<h3 id="xss"><a class="markdownIt-Anchor" href="#xss"></a> XSS</h3>
<h4 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h4>
<p><strong><code>跨站脚本（Cross-site scripting，通常简称为XSS）</code></strong> 是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了 HTML 以及用户端脚本语言。</p>
<p>XSS 攻击示例：</p>
<p>假如有下面一个 textbox</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"address1"</span> <span class="attr">value</span>=<span class="string">"value1from"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>value1from 是来自用户的输入，如果用户不是输入 value1from,而是输入 <code>&quot;/&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&lt;!-</code> 那么就会变成：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"address1"</span> <span class="attr">value</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">	alert(<span class="built_in">document</span>.cookie)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">!-</span> "&gt;</span></span><br></pre></td></tr></table></figure>
<p>嵌入的 JavaScript 代码将会被执行。攻击的威力，取决于用户输入了什么样的脚本。</p>
<h4 id="攻击手段和目的"><a class="markdownIt-Anchor" href="#攻击手段和目的"></a> 攻击手段和目的</h4>
<p>常用的 XSS 攻击手段和目的有：</p>
<ul>
<li>盗用 cookie，获取敏感信息。</li>
<li>利用植入 Flash，通过 <code>crossdomain</code> 权限设置进一步获取更高权限；或者利用 Java 等得到类似的操作。</li>
<li>利用 <code>iframe</code>、<code>frame</code>、<code>XMLHttpRequest</code> 或上述 Flash 等方式，以（被攻击）用户的身份执行一些管理动作，或执行一些一般的如发微博、加好友、发私信等操作。</li>
<li>利用可被攻击的域受到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动。</li>
<li>在访问量极大的一些页面上的 XSS 可以攻击一些小型网站，实现 DDoS 攻击的效果。</li>
</ul>
<h4 id="应对手段"><a class="markdownIt-Anchor" href="#应对手段"></a> 应对手段</h4>
<ul>
<li><strong>过滤特殊字符</strong> - 将用户所提供的内容进行过滤，从而避免 HTML 和 Jascript 代码的运行。如 <code>&gt;</code> 转义为 <code>&amp;gt</code>、<code>&lt;</code> 转义为 <code>&amp;lt</code> 等，就可以防止大部分攻击。为了避免对不必要的内容错误转移，如 <code>3&lt;5</code> 中的 <code>&lt;</code> 需要进行文本匹配后再转移，如：<code>&lt;img src=</code> 这样的上下文中的 <code>&lt;</code> 才转义。</li>
<li><strong>设置 Cookie 为 HttpOnly</strong> - 设置了 HttpOnly 的 Cookie 可以防止 JavaScript 脚本调用，就无法通过 document.cookie 获取用户 Cookie 信息。</li>
</ul>
<blockquote>
<p>👉 参考阅读：</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%B6%B2%E7%AB%99%E6%8C%87%E4%BB%A4%E7%A2%BC" target="_blank" rel="noopener">Wiki 词条 - 跨站脚本</a></li>
<li><a href="https://www.cnblogs.com/TankXiao/archive/2012/03/21/2337194.html" target="_blank" rel="noopener">Web 安全测试之 XSS</a></li>
</ul>
</blockquote>
<h3 id="csrf"><a class="markdownIt-Anchor" href="#csrf"></a> CSRF</h3>
<h4 id="概念-2"><a class="markdownIt-Anchor" href="#概念-2"></a> 概念</h4>
<p><strong><code>跨站请求伪造（Cross-site request forgery，CSRF）</code></strong>，也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF。它是一种挟持用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。和跨站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。</p>
<h4 id="攻击手段和目的-2"><a class="markdownIt-Anchor" href="#攻击手段和目的-2"></a> 攻击手段和目的</h4>
<p>可以如此理解 CSRF：攻击者盗用了你的身份，以你的名义发送恶意请求。</p>
<p>CSRF 能做的事太多：</p>
<ul>
<li>以你名义发送邮件，发消息</li>
<li>用你的账号购买商品</li>
<li>用你的名义完成虚拟货币转账</li>
<li>泄露个人隐私</li>
<li>…</li>
</ul>
<h4 id="应对手段-2"><a class="markdownIt-Anchor" href="#应对手段-2"></a> 应对手段</h4>
<ul>
<li><strong>表单 Token</strong> - CSRF 是一个伪造用户请求的操作，所以需要构造用户请求的所有参数才可以。表单 Token 通过在请求参数中添加随机数的办法来阻止攻击者获得所有请求参数。</li>
<li><strong>验证码</strong> - 请求提交时，需要用户输入验证码，以避免用户在不知情的情况下被攻击者伪造请求。</li>
<li><strong>Referer check</strong> - HTTP 请求头的 Referer 域中记录着请求资源，可通过检查请求来源，验证其是否合法。</li>
</ul>
<blockquote>
<p>👉 参考阅读：</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0" target="_blank" rel="noopener">Wiki 词条 - 跨站请求伪造</a></li>
<li><a href="http://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html" target="_blank" rel="noopener">浅谈 CSRF 攻击方式</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/22521378" target="_blank" rel="noopener">「每日一题」CSRF 是什么？</a><a href="https://zhuanlan.zhihu.com/p/22521378" target="_blank" rel="noopener">「每日一题」CSRF 是什么？</a></li>
<li><a href="https://www.jianshu.com/p/855395f9603b" target="_blank" rel="noopener">WEB 安全之-CSRF（跨站请求伪造）</a></li>
</ul>
</blockquote>
<h3 id="sql-注入"><a class="markdownIt-Anchor" href="#sql-注入"></a> SQL 注入</h3>
<h4 id="概念-3"><a class="markdownIt-Anchor" href="#概念-3"></a> 概念</h4>
<p><strong><code>SQL 注入攻击（SQL injection）</code></strong>，是发生于应用程序之数据层的安全漏洞。简而言之，是在输入的字符串之中注入 SQL 指令，在设计不良的程序当中忽略了检查，那么这些注入进去的指令就会被数据库服务器误认为是正常的 SQL 指令而运行，因此遭到破坏或是入侵。</p>
<p>攻击示例：</p>
<p>考虑以下简单的登录表单：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/login"</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span>Username: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span>Password: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"登陆"</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们的处理里面的 SQL 可能是这样的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">username:=r.Form.Get("username")</span><br><span class="line">password:=r.Form.Get("password")</span><br><span class="line">sql:="<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> username=<span class="string">'"+username+"'</span> <span class="keyword">AND</span> <span class="keyword">password</span>=<span class="string">'"+password+"'</span><span class="string">"</span></span><br></pre></td></tr></table></figure>
<p>如果用户的输入的用户名如下，密码任意</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">myuser' or 'foo' = 'foo' <span class="comment">--</span></span><br></pre></td></tr></table></figure>
<p>那么我们的 SQL 变成了如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> username=<span class="string">'myuser'</span> <span class="keyword">or</span> <span class="string">'foo'</span> = <span class="string">'foo'</span> <span class="comment">--'' AND password='xxx'</span></span><br></pre></td></tr></table></figure>
<p>在 SQL 里面 <code>--</code> 是注释标记，所以查询语句会在此中断。这就让攻击者在不知道任何合法用户名和密码的情况下成功登录了。</p>
<p>对于 MSSQL 还有更加危险的一种 SQL 注入，就是控制系统，下面这个可怕的例子将演示如何在某些版本的 MSSQL 数据库上执行系统命令。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sql:="<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">LIKE</span> <span class="string">'%"+prod+"%'</span><span class="string">"</span></span><br><span class="line"><span class="string">Db.Exec(sql)</span></span><br></pre></td></tr></table></figure>
<p>如果攻击提交 <code>a%' exec master..xp_cmdshell 'net user test testpass /ADD' --</code> 作为变量 prod 的值，那么 sql 将会变成</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sql:="<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">LIKE</span> <span class="string">'%a%'</span> exec master..xp_cmdshell <span class="string">'net user test testpass /ADD'</span><span class="comment">--%'"</span></span><br></pre></td></tr></table></figure>
<p>MSSQL 服务器会执行这条 SQL 语句，包括它后面那个用于向系统添加新用户的命令。如果这个程序是以 sa 运行而 MSSQLSERVER 服务又有足够的权限的话，攻击者就可以获得一个系统帐号来访问主机了。</p>
<p>虽然以上的例子是针对某一特定的数据库系统的，但是这并不代表不能对其它数据库系统实施类似的攻击。针对这种安全漏洞，只要使用不同方法，各种数据库都有可能遭殃。</p>
<h4 id="攻击手段和目的-3"><a class="markdownIt-Anchor" href="#攻击手段和目的-3"></a> 攻击手段和目的</h4>
<ul>
<li>数据表中的数据外泄，例如个人机密数据，账户数据，密码等。</li>
<li>数据结构被黑客探知，得以做进一步攻击（例如 <code>SELECT * FROM sys.tables</code>）。</li>
<li>数据库服务器被攻击，系统管理员账户被窜改（例如 <code>ALTER LOGIN sa WITH PASSWORD='xxxxxx'</code>）。</li>
<li>获取系统较高权限后，有可能得以在网页加入恶意链接、恶意代码以及 XSS 等。</li>
<li>经由数据库服务器提供的操作系统支持，让黑客得以修改或控制操作系统（例如 xp_cmdshell &quot;net stop iisadmin&quot;可停止服务器的 IIS 服务）。</li>
<li>破坏硬盘数据，瘫痪全系统（例如 xp_cmdshell “FORMAT C:”）。</li>
</ul>
<h4 id="应对手段-3"><a class="markdownIt-Anchor" href="#应对手段-3"></a> 应对手段</h4>
<ul>
<li><strong>使用参数化查询</strong> - 建议使用数据库提供的参数化查询接口，参数化的语句使用参数而不是将用户输入变量嵌入到 SQL 语句中，即不要直接拼接 SQL 语句。例如使用 database/sql 里面的查询函数 <code>Prepare</code> 和 <code>Query</code> ，或者 <code>Exec(query string, args ...interface{})</code>。</li>
<li><strong>单引号转换</strong> - 在组合 SQL 字符串时，先针对所传入的参数进行字符替换（将单引号字符替换为连续 2 个单引号字符）。</li>
</ul>
<blockquote>
<p>👉 参考阅读：</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/SQL%E8%B3%87%E6%96%99%E9%9A%B1%E7%A2%BC%E6%94%BB%E6%93%8A" target="_blank" rel="noopener">Wiki 词条 - SQL 注入攻击</a></li>
<li><a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/09.4.md" target="_blank" rel="noopener">避免 SQL 注入</a></li>
<li><a href="http://blog.jobbole.com/83092/" target="_blank" rel="noopener">实例讲解 SQL 注入攻击</a></li>
</ul>
</blockquote>
<h3 id="dos"><a class="markdownIt-Anchor" href="#dos"></a> DoS</h3>
<p><strong><code>拒绝服务攻击（denial-of-service attack, DoS）亦称洪水攻击</code></strong>，是一种网络攻击手法，其目的在于使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。</p>
<p>当黑客使用网络上两个或以上被攻陷的电脑作为“僵尸”向特定的目标发动“拒绝服务”式攻击时，称为分布式拒绝服务攻击（distributed denial-of-service attack，缩写：DDoS attack、DDoS）。</p>
<h4 id="攻击方式"><a class="markdownIt-Anchor" href="#攻击方式"></a> 攻击方式</h4>
<ul>
<li>带宽消耗型攻击</li>
<li>资源消耗型攻击</li>
</ul>
<h4 id="应对手段-4"><a class="markdownIt-Anchor" href="#应对手段-4"></a> 应对手段</h4>
<ul>
<li><strong>防火墙</strong> - 允许或拒绝特定通讯协议，端口或 IP 地址。当攻击从少数不正常的 IP 地址发出时，可以简单的使用拒绝规则阻止一切从攻击源 IP 发出的通信。</li>
<li><strong>路由器、交换机</strong> - 具有速度限制和访问控制能力。</li>
<li><strong>流量清洗</strong> - 通过采用抗 DDoS 软件处理，将正常流量和恶意流量区分开。</li>
</ul>
<blockquote>
<p>👉 参考阅读：</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E9%98%BB%E6%96%B7%E6%9C%8D%E5%8B%99%E6%94%BB%E6%93%8A" target="_blank" rel="noopener">拒绝服务攻击</a></li>
</ul>
</blockquote>
<h2 id="五-加密技术"><a class="markdownIt-Anchor" href="#五-加密技术"></a> 五、加密技术</h2>
<p>对于网站来说，用户信息、账户等等敏感数据一旦泄漏，后果严重，所以为了保护数据，应对这些信息进行加密处理。</p>
<p>信息加密技术一般分为：</p>
<ul>
<li>消息摘要</li>
<li>加密算法
<ul>
<li>对称加密</li>
<li>非对称加密</li>
</ul>
</li>
<li>证书</li>
</ul>
<h3 id="消息摘要"><a class="markdownIt-Anchor" href="#消息摘要"></a> 消息摘要</h3>
<p>常用数字签名算法：MD5、SHA 等。</p>
<p>应用场景：将用户密码以消息摘要形式保存到数据库中。</p>
<blockquote>
<p>👉 参考阅读：</p>
<ul>
<li><a href="https://github.com/dunwu/javacore/blob/master/docs/advanced/encode/java-message-digest.md" target="_blank" rel="noopener">消息摘要</a></li>
</ul>
</blockquote>
<h3 id="加密算法"><a class="markdownIt-Anchor" href="#加密算法"></a> 加密算法</h3>
<h4 id="对称加密"><a class="markdownIt-Anchor" href="#对称加密"></a> 对称加密</h4>
<p>对称加密指加密和解密所使用的密钥是同一个密钥。</p>
<p>常用对称加密算法：DES、AES 等。</p>
<p>应用场景：Cookie 加密、通信机密等。</p>
<h4 id="非对称加密"><a class="markdownIt-Anchor" href="#非对称加密"></a> 非对称加密</h4>
<p>非对称加密指加密和解密所使用的不是同一个密钥，而是一个公私钥对。用公钥加密的信息必须用私钥才能解开；反之，用私钥加密的信息只有用公钥才能解开。</p>
<p>常用非对称加密算法：RSA 等。</p>
<p>应用场景：HTTPS 传输中浏览器使用的数字证书实质上是经过权威机构认证的非对称加密公钥。</p>
<blockquote>
<p>👉 参考阅读：</p>
<ul>
<li><a href="https://github.com/dunwu/javacore/blob/master/docs/advanced/encode/java-encryption.md" target="_blank" rel="noopener">加密</a></li>
</ul>
</blockquote>
<h4 id="密钥安全管理"><a class="markdownIt-Anchor" href="#密钥安全管理"></a> 密钥安全管理</h4>
<p>保证密钥安全的方法：</p>
<ol>
<li>把密钥和算法放在一个独立的服务器上，对外提供加密和解密服务，应用系统通过调用这个服务，实现数据的加解密。</li>
<li>把加解密算法放在应用系统中，密钥则放在独立服务器中，为了提高密钥的安全性，实际存储时，密钥被切分成数片，加密后分别保存在不同存储介质中。</li>
</ol>
<h3 id="证书"><a class="markdownIt-Anchor" href="#证书"></a> 证书</h3>
<p><strong>证书可以称为信息安全加密的终极手段</strong>。公开密钥认证（英语：Public key certificate），又称公开密钥证书、公钥证书、数字证书（digital certificate）、数字认证、身份证书（identity certificate）、电子证书或安全证书，是用于公开密钥基础建设的电子文件，用来证明公开密钥拥有者的身份。此文件包含了公钥信息、拥有者身份信息（主体）、以及数字证书认证机构（发行者）对这份文件的数字签名，以保证这个文件的整体内容正确无误。</p>
<p>透过信任权威数字证书认证机构的根证书、及其使用公开密钥加密作数字签名核发的公开密钥认证，形成信任链架构，已在 TLS 实现并在万维网的 HTTP 以 HTTPS、在电子邮件的 SMTP 以 STARTTLS 引入并广泛应用。</p>
<p>众所周知，常见的应用层协议 HTTP、FTP、Telnet 本身不保证信息安全。但是加入了 SSL/TLS 加密数据包机制的 HTTPS、FTPS、Telnets 是信息安全的。传输层安全性协议（Transport Layer Security, TLS），及其前身安全套接层（Secure Sockets Layer, SSL）是一种安全协议，目的是为互联网通信，提供安全及数据完整性保障。</p>
<h4 id="证书原理"><a class="markdownIt-Anchor" href="#证书原理"></a> 证书原理</h4>
<p>SSL/TLS 协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</p>
<p>这里有两个问题：</p>
<p>（1）<strong>如何保证公钥不被篡改？</strong></p>
<p>解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。</p>
<p>（2）<strong>公钥加密计算量太大，如何减少耗用的时间？</strong></p>
<p>解决方法：每一次对话（session），客户端和服务器端都生成一个&quot;对话密钥&quot;（session key），用它来加密信息。由于&quot;对话密钥&quot;是对称加密，所以运算速度非常快，而服务器公钥只用于加密&quot;对话密钥&quot;本身，这样就减少了加密运算的消耗时间。</p>
<p>SSL/TLS 协议的基本过程是这样的：</p>
<ol>
<li>客户端向服务器端索要并验证公钥。</li>
<li>双方协商生成&quot;对话密钥&quot;。</li>
<li>双方采用&quot;对话密钥&quot;进行加密通信。</li>
</ol>
<blockquote>
<p>👉 参考阅读：</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E6%80%A7%E5%8D%94%E5%AE%9A" target="_blank" rel="noopener">传输层安全性协议</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%85%AC%E9%96%8B%E9%87%91%E9%91%B0%E8%AA%8D%E8%AD%89" target="_blank" rel="noopener">公开密钥认证</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">SSL/TLS 协议运行机制的概述</a></li>
</ul>
</blockquote>
<h2 id="六-信息过滤"><a class="markdownIt-Anchor" href="#六-信息过滤"></a> 六、信息过滤</h2>
<p>在网络中，广告和垃圾信息屡见不鲜，泛滥成灾。</p>
<p>常见的信息过滤与反垃圾手段有：</p>
<h3 id="文本匹配"><a class="markdownIt-Anchor" href="#文本匹配"></a> 文本匹配</h3>
<p>解决敏感词过滤。系统维护一份敏感词清单，如果信息中含有敏感词，则自动进行过滤或拒绝信息。</p>
<h3 id="黑名单"><a class="markdownIt-Anchor" href="#黑名单"></a> 黑名单</h3>
<p>黑名单就是将一些已经被识别出有违规行为的 IP、域名、邮箱等加入黑名单，拒绝其请求。</p>
<p>黑名单可以通过 Hash 表来实现，方法简单，复杂度小，适于一般应用场景。</p>
<p>但如果黑名单列表非常大时，Hash 表要占用很大的内存空间，这时就不再使用了。这种情况下，可以使用布隆过滤器来实现，即通过一个二进制列表和一组随机数映射函数来实现。</p>
<h3 id="分类算法"><a class="markdownIt-Anchor" href="#分类算法"></a> 分类算法</h3>
<p>对于海量信息，难以通过人工去审核。对广告贴。</p>
<p>垃圾邮件等内容的识别比较好的自动化方法就是采用分类算法。</p>
<p>简单来说，即将批量已分类的样本输入分类算法进行训练，得到一个分类模型，然后利用分类算法结合分类模型去对信息进行识别。想了解具体做法，需要去理解机器学习相关知识。</p>
<h2 id="七-风险控制"><a class="markdownIt-Anchor" href="#七-风险控制"></a> 七、风险控制</h2>
<p>网络给商务、金融领域带来极大便利的同时，也将风险带给了对网络安全一无所知的人们。由于交易双方信息的不对等，使得交易存在着风险，而当交易发生在网络上时，风险就更加难以控制了。</p>
<h3 id="风险种类"><a class="markdownIt-Anchor" href="#风险种类"></a> 风险种类</h3>
<ul>
<li>账户风险 - 盗用账户、恶意注册账户等</li>
<li>买家风险 - 虚假询盘、恶意拒收、恶意下单、黄牛党抢购热门商品等</li>
<li>卖家风险 - 虚假发货、出售违禁品、侵权等</li>
<li>交易风险 - 信用卡盗刷、交易欺诈、洗钱、套现、电信诈骗等</li>
</ul>
<h3 id="风险控制手段"><a class="markdownIt-Anchor" href="#风险控制手段"></a> 风险控制手段</h3>
<p>大型电商网站系统或金融系统都配备专业的风控团队进行风险控制。风险控制手段既包括人工审核也包括自动审核。</p>
<p>自动风控的技术手段主要有规则引擎和统计模型。</p>
<h3 id="规则引擎"><a class="markdownIt-Anchor" href="#规则引擎"></a> 规则引擎</h3>
<p>在交易中，买家、卖家的某些指标满足一定条件时，就会被认为存在风险。如：交易金额超过某个数值；用户来自黑名单；用户和上次登录的地址距离差距很大；用户在一定时间内频繁交易等等。</p>
<p>如果以上这些条件都通过 if … else … 式样的代码去实现，代码维护、扩展会非常不便。因此，就有了规则引擎来处理这类问题。规则引擎是一种将业务规则和规则处理逻辑相分离的技术，业务规则由运营人员通过管理界面去编辑，实现无需修改代码，即可实时的使用新规则。</p>
<h3 id="统计模型"><a class="markdownIt-Anchor" href="#统计模型"></a> 统计模型</h3>
<p>规则引擎虽然技术简单，但是随着规则不断增加，规模越来越大。可能会出现规则冲突，难以维护的情况，并且规则越多，性能也越差。</p>
<p>为了解决这种问题，就有了统计模型。统计模型会使用分类算法或更复杂的机器学习算法进行智能统计。根据历史交易中的信息训练分类，然后将经过采集加工后的交易信息输入分类算法，得到交易风险值，然后基于此，做出预测。</p>
<p>经过充分训练后的统计模型，准确率不低于规则引擎。但是，需要有领域专家、行业专家介入，建立合理的训练模型，并不断优化。</p>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><a href="https://item.jd.com/11322972.html" target="_blank" rel="noopener">《大型网站技术架构：核心原理与案例分析》</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%B6%B2%E7%AB%99%E6%8C%87%E4%BB%A4%E7%A2%BC" target="_blank" rel="noopener">Wiki 词条 - 跨站脚本</a></li>
<li><a href="https://www.cnblogs.com/TankXiao/archive/2012/03/21/2337194.html" target="_blank" rel="noopener">Web 安全测试之 XSS</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0" target="_blank" rel="noopener">Wiki 词条 - 跨站请求伪造</a></li>
<li><a href="http://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html" target="_blank" rel="noopener">浅谈 CSRF 攻击方式</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/22521378" target="_blank" rel="noopener">「每日一题」CSRF 是什么？</a><a href="https://zhuanlan.zhihu.com/p/22521378" target="_blank" rel="noopener">「每日一题」CSRF 是什么？</a></li>
<li><a href="https://www.jianshu.com/p/855395f9603b" target="_blank" rel="noopener">WEB 安全之-CSRF（跨站请求伪造）</a></li>
<li><a href="https://zh.wikipedia.org/wiki/SQL%E8%B3%87%E6%96%99%E9%9A%B1%E7%A2%BC%E6%94%BB%E6%93%8A" target="_blank" rel="noopener">Wiki 词条 - SQL 注入攻击</a></li>
<li><a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/09.4.md" target="_blank" rel="noopener">避免 SQL 注入</a></li>
<li><a href="http://blog.jobbole.com/83092/" target="_blank" rel="noopener">实例讲解 SQL 注入攻击</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E9%98%BB%E6%96%B7%E6%9C%8D%E5%8B%99%E6%94%BB%E6%93%8A" target="_blank" rel="noopener">拒绝服务攻击</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E6%80%A7%E5%8D%94%E5%AE%9A" target="_blank" rel="noopener">传输层安全性协议</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%85%AC%E9%96%8B%E9%87%91%E9%91%B0%E8%AA%8D%E8%AD%89" target="_blank" rel="noopener">公开密钥认证</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">SSL/TLS 协议运行机制的概述</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html</a></li>
<li><a href="http://www.coin163.com/java/cas/cas.html" target="_blank" rel="noopener">CAS 实现 SSO 单点登录原理</a></li>
<li><a href="https://www.jianshu.com/p/ce0944b4a903" target="_blank" rel="noopener">权限系统设计模型分析（DAC，MAC，RBAC，ABAC）</a></li>
</ul>
]]></content>
      <categories>
        <category>设计</category>
        <category>架构</category>
      </categories>
      <tags>
        <tag>设计</tag>
        <tag>架构</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>一篇文章让你彻底掌握 Python</title>
    <url>/blog/coding/python/</url>
    <content><![CDATA[<blockquote>
<p>📓 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p>
</blockquote>
<h1 id="python-编程"><a class="markdownIt-Anchor" href="#python-编程"></a> Python 编程</h1>
<h2 id="解释器"><a class="markdownIt-Anchor" href="#解释器"></a> 解释器</h2>
<p>Linux/Unix 的系统上，Python 解释器通常被安装在 <code>/usr/local/bin/python3.4</code> 这样的有效路径（目录）里。</p>
<p>我们可以将路径 <code>/usr/local/bin</code> 添加到您的 Linux/Unix 操作系统的环境变量中，这样您就可以通过 shell 终端输入下面的命令来启动 Python 。</p>
<p>在 Linux/Unix 系统中，你可以在脚本顶部添加以下命令让 Python 脚本可以像 SHELL 脚本一样可直接执行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python3.4</span></span><br></pre></td></tr></table></figure>
<h2 id="注释"><a class="markdownIt-Anchor" href="#注释"></a> 注释</h2>
<p>Python 中的注释有三种形式：</p>
<ul>
<li>以 <code>#</code> 开头</li>
<li>以 <code>'''</code> 开始，以 <code>'''</code> 结尾</li>
<li>以 <code>&quot;&quot;&quot;</code> 开始，以 <code>&quot;&quot;&quot;</code> 结尾</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">这是多行注释，用三个单引号</span></span><br><span class="line"><span class="string">这是多行注释，用三个单引号</span></span><br><span class="line"><span class="string">这是多行注释，用三个单引号</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">这是多行注释，用三个双引号</span></span><br><span class="line"><span class="string">这是多行注释，用三个双引号</span></span><br><span class="line"><span class="string">这是多行注释，用三个双引号</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<h2 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h2>
<p>Python3 中有六个标准的数据类型：</p>
<ul>
<li>Numbers（数字）</li>
<li>String（字符串）</li>
<li>List（列表）</li>
<li>Tuple（元组）</li>
<li>Sets（集合）</li>
<li>Dictionaries（字典）</li>
</ul>
<h2 id="操作符"><a class="markdownIt-Anchor" href="#操作符"></a> 操作符</h2>
<p>Python 语言支持以下类型的运算符:</p>
<ul>
<li>
<p>算术运算符</p>
</li>
<li>
<p>比较（关系）运算符</p>
</li>
<li>
<p>赋值运算符</p>
</li>
<li>
<p>逻辑运算符</p>
</li>
<li>
<p>位运算符</p>
</li>
<li>
<p>成员运算符</p>
</li>
<li>
<p>身份运算符</p>
</li>
<li>
<p>运算符优先级</p>
</li>
</ul>
<h3 id="算术运算符"><a class="markdownIt-Anchor" href="#算术运算符"></a> 算术运算符</h3>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>加 - 两个对象相加</td>
<td>a + b 输出结果 31</td>
</tr>
<tr>
<td>-</td>
<td>减 - 得到负数或是一个数减去另一个数</td>
<td>a - b 输出结果 -11</td>
</tr>
<tr>
<td>*</td>
<td>乘 - 两个数相乘或是返回一个被重复若干次的字符串</td>
<td>a * b 输出结果 210</td>
</tr>
<tr>
<td>/</td>
<td>除 - x 除以 y</td>
<td>b / a 输出结果 2.1</td>
</tr>
<tr>
<td>%</td>
<td>取模 - 返回除法的余数</td>
<td>b % a 输出结果 1</td>
</tr>
<tr>
<td>**</td>
<td>幂 - 返回 x 的 y 次幂</td>
<td>a**b 为 10 的 21 次方</td>
</tr>
<tr>
<td>//</td>
<td>取整除 - 返回商的整数部分</td>
<td>9//2 输出结果 4 , 9.0//2.0 输出结果 4.0</td>
</tr>
</tbody>
</table>
<h3 id="比较运算符"><a class="markdownIt-Anchor" href="#比较运算符"></a> 比较运算符</h3>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>==</td>
<td>等于 - 比较对象是否相等</td>
<td>(a == b) 返回 False。</td>
</tr>
<tr>
<td>!=</td>
<td>不等于 - 比较两个对象是否不相等</td>
<td>(a != b) 返回 True.</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于 - 返回 x 是否大于 y</td>
<td>(a &gt; b) 返回 False。</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于 - 返回 x 是否小于 y。所有比较运算符返回 1 表示真，返回 0 表示假。这分别与特殊的变量 True 和 False 等价。注意，这些变量名的大写。</td>
<td>(a &lt; b) 返回 True。</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于 - 返回 x 是否大于等于 y。</td>
<td>(a &gt;= b) 返回 False。</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于 - 返回 x 是否小于等于 y。</td>
<td>(a &lt;= b) 返回 True。</td>
</tr>
</tbody>
</table>
<h3 id="赋值运算符"><a class="markdownIt-Anchor" href="#赋值运算符"></a> 赋值运算符</h3>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td>简单的赋值运算符</td>
<td>c = a + b 将 a + b 的运算结果赋值为 c</td>
</tr>
<tr>
<td>+=</td>
<td>加法赋值运算符</td>
<td>c += a 等效于 c = c + a</td>
</tr>
<tr>
<td>-=</td>
<td>减法赋值运算符</td>
<td>c -= a 等效于 c = c - a</td>
</tr>
<tr>
<td>*=</td>
<td>乘法赋值运算符</td>
<td>c _= a 等效于 c = c _ a</td>
</tr>
<tr>
<td>/=</td>
<td>除法赋值运算符</td>
<td>c /= a 等效于 c = c / a</td>
</tr>
<tr>
<td>%=</td>
<td>取模赋值运算符</td>
<td>c %= a 等效于 c = c % a</td>
</tr>
<tr>
<td>**=</td>
<td>幂赋值运算符</td>
<td>c **= a 等效于 c = c ** a</td>
</tr>
<tr>
<td>//=</td>
<td>取整除赋值运算符</td>
<td>c //= a 等效于 c = c // a</td>
</tr>
</tbody>
</table>
<h3 id="位运算符"><a class="markdownIt-Anchor" href="#位运算符"></a> 位运算符</h3>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;</td>
<td>按位与运算符：参与运算的两个值,如果两个相应位都为 1,则该位的结果为 1,否则为 0</td>
<td>(a &amp; b) 输出结果 12 ，二进制解释： 0000 1100</td>
</tr>
<tr>
<td>|</td>
<td>按位或运算符：只要对应的二个二进位有一个为 1 时，结果位就为 1。</td>
<td>(a | b) 输出结果 61 ，二进制解释： 0011 1101</td>
</tr>
<tr>
<td>^</td>
<td>按位异或运算符：当两对应的二进位相异时，结果为 1</td>
<td>(a ^ b) 输出结果 49 ，二进制解释： 0011 0001</td>
</tr>
<tr>
<td>~</td>
<td>按位取反运算符：对数据的每个二进制位取反,即把 1 变为 0,把 0 变为 1</td>
<td>(~a ) 输出结果 -61 ，二进制解释： 1100 0011， 在一个有符号二进制数的补码形式。</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>左移动运算符：运算数的各二进位全部左移若干位，由&quot;&lt;&lt;&quot;右边的数指定移动的位数，高位丢弃，低位补 0。</td>
<td>a &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右移动运算符：把&quot;&gt;&gt;“左边的运算数的各二进位全部右移若干位，”&gt;&gt;&quot;右边的数指定移动的位数</td>
<td>a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111</td>
</tr>
</tbody>
</table>
<h3 id="逻辑运算符"><a class="markdownIt-Anchor" href="#逻辑运算符"></a> 逻辑运算符</h3>
<table>
<thead>
<tr>
<th>运算符</th>
<th>逻辑表达式</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>and</td>
<td>x and y</td>
<td>布尔&quot;与&quot; - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。</td>
<td>(a and b) 返回 20。</td>
</tr>
<tr>
<td>or</td>
<td>x or y</td>
<td>布尔&quot;或&quot; - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。</td>
<td>(a or b) 返回 10。</td>
</tr>
<tr>
<td>not</td>
<td>not x</td>
<td>布尔&quot;非&quot; - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。</td>
<td>not(a and b) 返回 False</td>
</tr>
</tbody>
</table>
<h3 id="成员运算符"><a class="markdownIt-Anchor" href="#成员运算符"></a> 成员运算符</h3>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>in</td>
<td>如果在指定的序列中找到值返回 True，否则返回 False。</td>
<td>x 在 y 序列中 , 如果 x 在 y 序列中返回 True。</td>
</tr>
<tr>
<td>not in</td>
<td>如果在指定的序列中没有找到值返回 True，否则返回 False。</td>
<td>x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。</td>
</tr>
</tbody>
</table>
<h3 id="身份运算符"><a class="markdownIt-Anchor" href="#身份运算符"></a> 身份运算符</h3>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>is</td>
<td>is 是判断两个标识符是不是引用自一个对象</td>
<td>x is y, 如果 id(x) 等于 id(y) , <strong>is</strong> 返回结果 1</td>
</tr>
<tr>
<td>is not</td>
<td>is not 是判断两个标识符是不是引用自不同对象</td>
<td>x is not y, 如果 id(x) 不等于 id(y). <strong>is not</strong> 返回结果 1</td>
</tr>
</tbody>
</table>
<h3 id="运算符优先级"><a class="markdownIt-Anchor" href="#运算符优先级"></a> 运算符优先级</h3>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>**</td>
<td>指数 (最高优先级)</td>
</tr>
<tr>
<td>~ + -</td>
<td>按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)</td>
</tr>
<tr>
<td>* / % //</td>
<td>乘，除，取模和取整除</td>
</tr>
<tr>
<td>+ -</td>
<td>加法减法</td>
</tr>
<tr>
<td>&gt;&gt; &lt;&lt;</td>
<td>右移，左移运算符</td>
</tr>
<tr>
<td>&amp;</td>
<td>位 ‘AND’</td>
</tr>
<tr>
<td>^ |</td>
<td>位运算符</td>
</tr>
<tr>
<td>&lt;= &lt; &gt; &gt;=</td>
<td>比较运算符</td>
</tr>
<tr>
<td>&lt;&gt; == !=</td>
<td>等于运算符</td>
</tr>
<tr>
<td>= %= /= //= -= += *= **=</td>
<td>赋值运算符</td>
</tr>
<tr>
<td>is is not</td>
<td>身份运算符</td>
</tr>
<tr>
<td>in not in</td>
<td>成员运算符</td>
</tr>
<tr>
<td>not or and</td>
<td>逻辑运算符</td>
</tr>
</tbody>
</table>
<h2 id="控制语句"><a class="markdownIt-Anchor" href="#控制语句"></a> 控制语句</h2>
<h3 id="条件语句"><a class="markdownIt-Anchor" href="#条件语句"></a> 条件语句</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition_1:</span><br><span class="line">    statement_block_1</span><br><span class="line"><span class="keyword">elif</span> condition_2:</span><br><span class="line">    statement_block_2</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    statement_block_3</span><br></pre></td></tr></table></figure>
<h3 id="循环语句"><a class="markdownIt-Anchor" href="#循环语句"></a> 循环语句</h3>
<h4 id="while"><a class="markdownIt-Anchor" href="#while"></a> while</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 判断条件：</span><br><span class="line">    statements</span><br></pre></td></tr></table></figure>
<h4 id="for"><a class="markdownIt-Anchor" href="#for"></a> for</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &lt;variable&gt; <span class="keyword">in</span> &lt;sequence&gt;:</span><br><span class="line">  &lt;statements&gt;</span><br></pre></td></tr></table></figure>
<h4 id="range"><a class="markdownIt-Anchor" href="#range"></a> range()</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">10</span>, <span class="number">3</span>) :</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>
<h4 id="break-和-continue"><a class="markdownIt-Anchor" href="#break-和-continue"></a> break 和 continue</h4>
<ul>
<li>break 语句可以跳出 for 和 while 的循环体。</li>
<li>continue 语句被用来告诉 Python 跳过当前循环块中的剩余语句，然后继续进行下一轮循环。</li>
</ul>
<h4 id="pass"><a class="markdownIt-Anchor" href="#pass"></a> pass</h4>
<p>pass 语句什么都不做。它只在语法上需要一条语句但程序不需要任何操作时使用.例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">pass</span>  <span class="comment"># 等待键盘中断 (Ctrl+C)</span></span><br></pre></td></tr></table></figure>
<h2 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h2>
<p>Python 定义函数使用 def 关键字，一般格式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span>  函数名（参数列表）：</span></span><br><span class="line"><span class="function">    函数体</span></span><br></pre></td></tr></table></figure>
<h3 id="函数变量作用域"><a class="markdownIt-Anchor" href="#函数变量作用域"></a> 函数变量作用域</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line">a = <span class="number">4</span>  <span class="comment"># 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_func1</span><span class="params">()</span>:</span></span><br><span class="line">    a = <span class="number">17</span> <span class="comment"># 局部变量</span></span><br><span class="line">    print(<span class="string">"in print_func a = "</span>, a)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_func2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"in print_func a = "</span>, a)</span><br><span class="line">print_func1()</span><br><span class="line">print_func2()</span><br><span class="line">print(<span class="string">"a = "</span>, a)</span><br></pre></td></tr></table></figure>
<p>以上实例运行结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">in</span> print_func a =  <span class="number">17</span></span><br><span class="line"><span class="keyword">in</span> print_func a =  <span class="number">4</span></span><br><span class="line">a =  <span class="number">4</span></span><br></pre></td></tr></table></figure>
<h3 id="关键字参数"><a class="markdownIt-Anchor" href="#关键字参数"></a> 关键字参数</h3>
<p>函数也可以使用 kwarg=value 的关键字参数形式被调用.例如,以下函数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parrot</span><span class="params">(voltage, state=<span class="string">'a stiff'</span>, action=<span class="string">'voom'</span>, type=<span class="string">'Norwegian Blue'</span>)</span>:</span></span><br><span class="line">    print(<span class="string">"-- This parrot wouldn't"</span>, action, end=<span class="string">' '</span>)</span><br><span class="line">    print(<span class="string">"if you put"</span>, voltage, <span class="string">"volts through it."</span>)</span><br><span class="line">    print(<span class="string">"-- Lovely plumage, the"</span>, type)</span><br><span class="line">    print(<span class="string">"-- It's"</span>, state, <span class="string">"!"</span>)</span><br></pre></td></tr></table></figure>
<p>可以以下几种方式被调用:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">parrot(<span class="number">1000</span>)                                          <span class="comment"># 1 positional argument</span></span><br><span class="line">parrot(voltage=<span class="number">1000</span>)                                  <span class="comment"># 1 keyword argument</span></span><br><span class="line">parrot(voltage=<span class="number">1000000</span>, action=<span class="string">'VOOOOOM'</span>)             <span class="comment"># 2 keyword arguments</span></span><br><span class="line">parrot(action=<span class="string">'VOOOOOM'</span>, voltage=<span class="number">1000000</span>)             <span class="comment"># 2 keyword arguments</span></span><br><span class="line">parrot(<span class="string">'a million'</span>, <span class="string">'bereft of life'</span>, <span class="string">'jump'</span>)         <span class="comment"># 3 positional arguments</span></span><br><span class="line">parrot(<span class="string">'a thousand'</span>, state=<span class="string">'pushing up the daisies'</span>)  <span class="comment"># 1 positional, 1 keyword</span></span><br></pre></td></tr></table></figure>
<p>以下为错误调用方法：</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">parrot<span class="params">()</span>                     <span class="comment"># required argument missing</span></span><br><span class="line">parrot<span class="params">(<span class="attr">voltage</span>=5.0, 'dead')</span>  <span class="comment"># non-keyword argument after a keyword argument</span></span><br><span class="line">parrot<span class="params">(110, <span class="attr">voltage</span>=220)</span>     <span class="comment"># duplicate value for the same argument</span></span><br><span class="line">parrot<span class="params">(<span class="attr">actor</span>='John Cleese')</span>  <span class="comment"># unknown keyword argument</span></span><br></pre></td></tr></table></figure>
<h3 id="可变参数列表"><a class="markdownIt-Anchor" href="#可变参数列表"></a> 可变参数列表</h3>
<p>最后,一个最不常用的选择是可以让函数调用可变个数的参数.这些参数被包装进一个元组(查看元组和序列).在这些可变个数的参数之前,可以有零到多个普通的参数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">arithmetic_mean</span><span class="params">(*args)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> args:</span><br><span class="line">        sum += x</span><br><span class="line">    <span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure>
<h3 id="返回值"><a class="markdownIt-Anchor" href="#返回值"></a> 返回值</h3>
<p>Python 的函数的返回值使用 return 语句，可以将函数作为一个值赋值给指定变量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">return_sum</span><span class="params">(x,y)</span>:</span></span><br><span class="line">    c = x + y</span><br><span class="line">    <span class="keyword">return</span> c</span><br></pre></td></tr></table></figure>
<h2 id="异常"><a class="markdownIt-Anchor" href="#异常"></a> 异常</h2>
<h3 id="异常处理"><a class="markdownIt-Anchor" href="#异常处理"></a> 异常处理</h3>
<p>try 语句按照如下方式工作；</p>
<ul>
<li>首先，执行 try 子句（在关键字 try 和关键字 except 之间的语句）</li>
<li>如果没有异常发生，忽略 except 子句，try 子句执行后结束。</li>
<li>如果在执行 try 子句的过程中发生了异常，那么 try 子句余下的部分将被忽略。如果异常的类型和 except 之后的名称相符，那么对应的 except 子句将被执行。最后执行 try 语句之后的代码。</li>
<li>如果一个异常没有与任何的 except 匹配，那么这个异常将会传递给上层的 try 中。</li>
<li>不管 try 子句里面有没有发生异常，finally 子句都会执行。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = open(<span class="string">'myfile.txt'</span>)</span><br><span class="line">    s = f.readline()</span><br><span class="line">    i = int(s.strip())</span><br><span class="line"><span class="keyword">except</span> OSError <span class="keyword">as</span> err:</span><br><span class="line">    print(<span class="string">"OS error: &#123;0&#125;"</span>.format(err))</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">    print(<span class="string">"Could not convert data to an integer."</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">"Unexpected error:"</span>, sys.exc_info()[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">raise</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="comment"># 清理行为</span></span><br></pre></td></tr></table></figure>
<h3 id="抛出异常"><a class="markdownIt-Anchor" href="#抛出异常"></a> 抛出异常</h3>
<p>Python 使用 raise 语句抛出一个指定的异常。例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">raise</span> NameError(<span class="string">'HiThere'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File "&lt;stdin&gt;", line 1, in ?</span><br><span class="line">NameError: HiThere</span><br></pre></td></tr></table></figure>
<h3 id="自定义异常"><a class="markdownIt-Anchor" href="#自定义异常"></a> 自定义异常</h3>
<p>可以通过创建一个新的 exception 类来拥有自己的异常。异常应该继承自 Exception 类，或者直接继承，或者间接继承。</p>
<p>当创建一个模块有可能抛出多种不同的异常时，一种通常的做法是为这个包建立一个基础异常类，然后基于这个基础类为不同的错误情况创建不同的子类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Error</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="string">"""Base class for exceptions in this module."""</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputError</span><span class="params">(Error)</span>:</span></span><br><span class="line">    <span class="string">"""Exception raised for errors in the input.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Attributes:</span></span><br><span class="line"><span class="string">        expression -- input expression in which the error occurred</span></span><br><span class="line"><span class="string">        message -- explanation of the error</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, expression, message)</span>:</span></span><br><span class="line">        self.expression = expression</span><br><span class="line">        self.message = message</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TransitionError</span><span class="params">(Error)</span>:</span></span><br><span class="line">    <span class="string">"""Raised when an operation attempts a state transition that's not</span></span><br><span class="line"><span class="string">    allowed.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Attributes:</span></span><br><span class="line"><span class="string">        previous -- state at beginning of transition</span></span><br><span class="line"><span class="string">        next -- attempted new state</span></span><br><span class="line"><span class="string">        message -- explanation of why the specific transition is not allowed</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, previous, next, message)</span>:</span></span><br><span class="line">        self.previous = previous</span><br><span class="line">        self.next = next</span><br><span class="line">        self.message = message</span><br></pre></td></tr></table></figure>
<p>大多数的异常的名字都以&quot;Error&quot;结尾，就跟标准的异常命名一样。</p>
<h2 id="面向对象"><a class="markdownIt-Anchor" href="#面向对象"></a> 面向对象</h2>
<h3 id="面向对象技术简介"><a class="markdownIt-Anchor" href="#面向对象技术简介"></a> 面向对象技术简介</h3>
<ul>
<li>
<p><strong>类(Class):</strong> 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。</p>
</li>
<li>
<p>**类变量：**类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。</p>
</li>
<li>
<p>**数据成员：**类变量或者实例变量用于处理类及其实例对象的相关的数据。</p>
</li>
<li>
<p>**方法重写：**如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。</p>
</li>
<li>
<p>**实例变量：**定义在方法中的变量，只作用于当前实例的类。</p>
</li>
<li>
<p>**继承：**即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个 Dog 类型的对象派生自 Animal 类，这是模拟&quot;是一个（is-a）&quot;关系（例图，Dog 是一个 Animal）。</p>
</li>
<li>
<p>**实例化：**创建一个类的实例，类的具体对象。</p>
</li>
<li>
<p>**方法：**类中定义的函数。</p>
</li>
<li>
<p>**对象：**通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。</p>
</li>
</ul>
<h3 id="类定义"><a class="markdownIt-Anchor" href="#类定义"></a> 类定义</h3>
<p>语法格式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span>:</span></span><br><span class="line">    &lt;statement<span class="number">-1</span>&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br></pre></td></tr></table></figure>
<p>类实例化后，可以使用其属性，实际上，创建一个类之后，可以通过类名访问其属性。</p>
<h3 id="类对象"><a class="markdownIt-Anchor" href="#类对象"></a> 类对象</h3>
<p>类对象支持两种操作：属性引用和实例化。</p>
<p>属性引用使用和 Python 中所有的属性引用一样的标准语法：<strong><a href="http://obj.name" target="_blank" rel="noopener">obj.name</a></strong>。</p>
<p>类对象创建后，类命名空间中所有的命名都是有效属性名。所以如果类定义是这样:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></span><br><span class="line">    <span class="string">"""一个简单的类实例"""</span></span><br><span class="line">    i = <span class="number">12345</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'hello world'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化类</span></span><br><span class="line">x = MyClass()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问类的属性和方法</span></span><br><span class="line">print(<span class="string">"MyClass 类的属性 i 为："</span>, x.i)</span><br><span class="line">print(<span class="string">"MyClass 类的方法 f 输出为："</span>, x.f())</span><br></pre></td></tr></table></figure>
<p>实例化类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 实例化类</span></span><br><span class="line">x = MyClass()</span><br><span class="line"><span class="comment"># 访问类的属性和方法</span></span><br></pre></td></tr></table></figure>
<p>以上创建了一个新的类实例并将该对象赋给局部变量 x，x 为空的对象。</p>
<p>执行以上程序输出结果为：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">MyClass</span> <span class="string">类的属性 i 为： 12345</span></span><br><span class="line"><span class="attr">MyClass</span> <span class="string">类的方法 f 输出为： hello world</span></span><br></pre></td></tr></table></figure>
<p>很多类都倾向于将对象创建为有初始状态的。因此类可能会定义一个名为 <strong>init</strong>() 的特殊方法（构造方法），像下面这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.data = []</span><br></pre></td></tr></table></figure>
<p>类定义了 <strong>init</strong>() 方法的话，类的实例化操作会自动调用 <strong>init</strong>() 方法。所以在下例中，可以这样创建一个新的实例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = MyClass()</span><br></pre></td></tr></table></figure>
<p>当然， <strong>init</strong>() 方法可以有参数，参数通过 <strong>init</strong>() 传递到类的实例化操作上。例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, realpart, imagpart)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.r = realpart</span><br><span class="line"><span class="meta">... </span>        self.i = imagpart</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = Complex(<span class="number">3.0</span>, <span class="number">-4.5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.r, x.i</span><br><span class="line">(<span class="number">3.0</span>, <span class="number">-4.5</span>)</span><br></pre></td></tr></table></figure>
<h3 id="类的方法"><a class="markdownIt-Anchor" href="#类的方法"></a> 类的方法</h3>
<p>在类地内部，使用 def 关键字可以为类定义一个方法，与一般函数定义不同，类方法必须包含参数 self,且为第一个参数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>:</span></span><br><span class="line">    <span class="comment">#定义基本属性</span></span><br><span class="line">    name = <span class="string">''</span></span><br><span class="line">    age = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义私有属性,私有属性在类外部无法直接进行访问</span></span><br><span class="line">    __weight = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,n,a,w)</span>:</span></span><br><span class="line">        self.name = n</span><br><span class="line">        self.age = a</span><br><span class="line">        self.__weight = w</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"%s 说: 我 %d 岁。"</span> %(self.name,self.age))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化类</span></span><br><span class="line">p = people(<span class="string">'W3Cschool'</span>,<span class="number">10</span>,<span class="number">30</span>)</span><br><span class="line">p.speak()</span><br></pre></td></tr></table></figure>
<p>执行以上程序输出结果为：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">W3Cschool 说: 我 <span class="number">10</span> 岁。</span><br></pre></td></tr></table></figure>
<h3 id="继承"><a class="markdownIt-Anchor" href="#继承"></a> 继承</h3>
<p>Python 同样支持类的继承，如果一种语言不支持继承就，类就没有什么意义。派生类的定义如下所示:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClassName</span><span class="params">(BaseClassName1)</span>:</span></span><br><span class="line">    &lt;statement<span class="number">-1</span>&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br></pre></td></tr></table></figure>
<p>需要注意圆括号中基类的顺序，若是基类中有相同的方法名，而在子类使用时未指定，python 从左至右搜索 即方法在子类中未找到时，从左到右查找基类中是否包含方法。</p>
<p>BaseClassName（示例中的基类名）必须与派生类定义在一个作用域内。除了类，还可以用表达式，基类定义在另一个模块中时这一点非常有用:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">DerivedClassName</span>(<span class="title">modname</span>.<span class="type">BaseClassName</span>):</span></span><br></pre></td></tr></table></figure>
<p><strong>实例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>:</span></span><br><span class="line">    <span class="comment">#定义基本属性</span></span><br><span class="line">    name = <span class="string">''</span></span><br><span class="line">    age = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义私有属性,私有属性在类外部无法直接进行访问</span></span><br><span class="line">    __weight = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,n,a,w)</span>:</span></span><br><span class="line">        self.name = n</span><br><span class="line">        self.age = a</span><br><span class="line">        self.__weight = w</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"%s 说: 我 %d 岁。"</span> %(self.name,self.age))</span><br><span class="line"></span><br><span class="line"><span class="comment">#单继承示例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span><span class="params">(people)</span>:</span></span><br><span class="line">    grade = <span class="string">''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,n,a,w,g)</span>:</span></span><br><span class="line">        <span class="comment">#调用父类的构函</span></span><br><span class="line">        people.__init__(self,n,a,w)</span><br><span class="line">        self.grade = g</span><br><span class="line">    <span class="comment">#覆写父类的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"%s 说: 我 %d 岁了，我在读 %d 年级"</span>%(self.name,self.age,self.grade))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = student(<span class="string">'ken'</span>,<span class="number">10</span>,<span class="number">60</span>,<span class="number">3</span>)</span><br><span class="line">s.speak()</span><br></pre></td></tr></table></figure>
<p>执行以上程序输出结果为：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">ken 说: 我 <span class="number">10</span> 岁了，我在读 <span class="number">3</span> 年级</span><br></pre></td></tr></table></figure>
<h3 id="多继承"><a class="markdownIt-Anchor" href="#多继承"></a> 多继承</h3>
<p>Python 同样有限的支持多继承形式。多继承的类定义形如下例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClassName</span><span class="params">(Base1, Base2, Base3)</span>:</span></span><br><span class="line">    &lt;statement<span class="number">-1</span>&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br></pre></td></tr></table></figure>
<p>需要注意圆括号中父类的顺序，若是父类中有相同的方法名，而在子类使用时未指定，python 从左至右搜索 即方法在子类中未找到时，从左到右查找父类中是否包含方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>:</span></span><br><span class="line">    <span class="comment">#定义基本属性</span></span><br><span class="line">    name = <span class="string">''</span></span><br><span class="line">    age = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义私有属性,私有属性在类外部无法直接进行访问</span></span><br><span class="line">    __weight = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,n,a,w)</span>:</span></span><br><span class="line">        self.name = n</span><br><span class="line">        self.age = a</span><br><span class="line">        self.__weight = w</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"%s 说: 我 %d 岁。"</span> %(self.name,self.age))</span><br><span class="line"></span><br><span class="line"><span class="comment">#单继承示例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span><span class="params">(people)</span>:</span></span><br><span class="line">    grade = <span class="string">''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,n,a,w,g)</span>:</span></span><br><span class="line">        <span class="comment">#调用父类的构函</span></span><br><span class="line">        people.__init__(self,n,a,w)</span><br><span class="line">        self.grade = g</span><br><span class="line">    <span class="comment">#覆写父类的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"%s 说: 我 %d 岁了，我在读 %d 年级"</span>%(self.name,self.age,self.grade))</span><br><span class="line"></span><br><span class="line"><span class="comment">#另一个类，多重继承之前的准备</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">speaker</span><span class="params">()</span>:</span></span><br><span class="line">    topic = <span class="string">''</span></span><br><span class="line">    name = <span class="string">''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,n,t)</span>:</span></span><br><span class="line">        self.name = n</span><br><span class="line">        self.topic = t</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"我叫 %s，我是一个演说家，我演讲的主题是 %s"</span>%(self.name,self.topic))</span><br><span class="line"></span><br><span class="line"><span class="comment">#多重继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sample</span><span class="params">(speaker,student)</span>:</span></span><br><span class="line">    a =<span class="string">''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,n,a,w,g,t)</span>:</span></span><br><span class="line">        student.__init__(self,n,a,w,g)</span><br><span class="line">        speaker.__init__(self,n,t)</span><br><span class="line"></span><br><span class="line">test = sample(<span class="string">"Tim"</span>,<span class="number">25</span>,<span class="number">80</span>,<span class="number">4</span>,<span class="string">"Python"</span>)</span><br><span class="line">test.speak()   <span class="comment">#方法名同，默认调用的是在括号中排前地父类的方法</span></span><br></pre></td></tr></table></figure>
<p>执行以上程序输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我叫 Tim，我是一个演说家，我演讲的主题是 Python</span><br></pre></td></tr></table></figure>
<h3 id="方法重写"><a class="markdownIt-Anchor" href="#方法重写"></a> 方法重写</h3>
<p>如果你的父类方法的功能不能满足你的需求，你可以在子类重写你父类的方法，实例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>:</span>        <span class="comment"># 定义父类</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">myMethod</span><span class="params">(self)</span>:</span></span><br><span class="line">      <span class="keyword">print</span> (<span class="string">'调用父类方法'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span><span class="params">(Parent)</span>:</span> <span class="comment"># 定义子类</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">myMethod</span><span class="params">(self)</span>:</span></span><br><span class="line">      <span class="keyword">print</span> (<span class="string">'调用子类方法'</span>)</span><br><span class="line"></span><br><span class="line">c = Child()          <span class="comment"># 子类实例</span></span><br><span class="line">c.myMethod()         <span class="comment"># 子类调用重写方法</span></span><br></pre></td></tr></table></figure>
<p>执行以上程序输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">调用子类方法</span><br></pre></td></tr></table></figure>
<h3 id="类属性与方法"><a class="markdownIt-Anchor" href="#类属性与方法"></a> 类属性与方法</h3>
<h4 id="类的私有属性"><a class="markdownIt-Anchor" href="#类的私有属性"></a> 类的私有属性</h4>
<p><strong>__private_attrs</strong>：两个下划线开头，声明该属性为私有，不能在类地外部被使用或直接访问。在类内部的方法中使用时<strong>self.__private_attrs</strong>。</p>
<h4 id="类的方法-2"><a class="markdownIt-Anchor" href="#类的方法-2"></a> 类的方法</h4>
<p>在类地内部，使用 def 关键字可以为类定义一个方法，与一般函数定义不同，类方法必须包含参数 self,且为第一个参数</p>
<h4 id="类的私有方法"><a class="markdownIt-Anchor" href="#类的私有方法"></a> 类的私有方法</h4>
<p><strong>__private_method</strong>：两个下划线开头，声明该方法为私有方法，不能在类地外部调用。在类的内部调用 <strong>slef.__private_methods</strong>。</p>
<p>实例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JustCounter</span>:</span></span><br><span class="line">    __secretCount = <span class="number">0</span>  <span class="comment"># 私有变量</span></span><br><span class="line">    publicCount = <span class="number">0</span>    <span class="comment"># 公开变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__secretCount += <span class="number">1</span></span><br><span class="line">        self.publicCount += <span class="number">1</span></span><br><span class="line">        <span class="keyword">print</span> (self.__secretCount)</span><br><span class="line"></span><br><span class="line">counter = JustCounter()</span><br><span class="line">counter.count()</span><br><span class="line">counter.count()</span><br><span class="line"><span class="keyword">print</span> (counter.publicCount)</span><br><span class="line"><span class="keyword">print</span> (counter.__secretCount)  <span class="comment"># 报错，实例不能访问私有变量</span></span><br></pre></td></tr></table></figure>
<p>执行以上程序输出结果为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">Traceback (most recent <span class="keyword">call</span> <span class="keyword">last</span>):</span><br><span class="line">  <span class="keyword">File</span> <span class="string">"test.py"</span>, line <span class="number">16</span>, <span class="keyword">in</span> &lt;<span class="keyword">module</span>&gt;</span><br><span class="line">    print (counter.__secretCount)  <span class="comment"># 报错，实例不能访问私有变量</span></span><br><span class="line">AttributeError: <span class="string">'JustCounter'</span> <span class="keyword">object</span> has <span class="keyword">no</span> <span class="keyword">attribute</span> <span class="string">'__secretCount'</span></span><br></pre></td></tr></table></figure>
<h4 id="类的专有方法"><a class="markdownIt-Anchor" href="#类的专有方法"></a> 类的专有方法：</h4>
<ul>
<li>*<strong>*init</strong> 😗* 构造函数，在生成对象时调用</li>
<li>*<strong>*del</strong> 😗* 析构函数，释放对象时使用</li>
<li>*<strong>*repr</strong> 😗* 打印，转换</li>
<li>*<strong>*setitem</strong> 😗* 按照索引赋值</li>
<li>*<strong>*getitem</strong>😗* 按照索引获取值</li>
<li>*<strong>*len</strong>😗* 获得长度</li>
<li>*<strong>*cmp</strong>😗* 比较运算</li>
<li>*<strong>*call</strong>😗* 函数调用</li>
<li>*<strong>*add</strong>😗* 加运算</li>
<li>*<strong>*sub</strong>😗* 减运算</li>
<li>*<strong>*mul</strong>😗* 乘运算</li>
<li>*<strong>*div</strong>😗* 除运算</li>
<li>*<strong>*mod</strong>😗* 求余运算</li>
<li>*<strong>*pow</strong>😗* 乘方</li>
</ul>
<h4 id="运算符重载"><a class="markdownIt-Anchor" href="#运算符重载"></a> 运算符重载</h4>
<p>Python 同样支持运算符重载，我么可以对类的专有方法进行重载，实例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">      self.a = a</span><br><span class="line">      self.b = b</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">'Vector (%d, %d)'</span> % (self.a, self.b)</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self,other)</span>:</span></span><br><span class="line">      <span class="keyword">return</span> Vector(self.a + other.a, self.b + other.b)</span><br><span class="line"></span><br><span class="line">v1 = Vector(<span class="number">2</span>,<span class="number">10</span>)</span><br><span class="line">v2 = Vector(<span class="number">5</span>,<span class="number">-2</span>)</span><br><span class="line"><span class="keyword">print</span> (v1 + v2)</span><br></pre></td></tr></table></figure>
<p>以上代码执行结果如下所示:</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">Vector</span><span class="params">(<span class="number">7</span>,<span class="number">8</span>)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="标准库概览"><a class="markdownIt-Anchor" href="#标准库概览"></a> 标准库概览</h2>
<h3 id="操作系统接口"><a class="markdownIt-Anchor" href="#操作系统接口"></a> 操作系统接口</h3>
<p>os 模块提供了不少与操作系统相关联的函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.getcwd()      <span class="comment"># 返回当前的工作目录</span></span><br><span class="line"><span class="string">'C:\\Python34'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.chdir(<span class="string">'/server/accesslogs'</span>)   <span class="comment"># 修改当前的工作目录</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.system(<span class="string">'mkdir today'</span>)   <span class="comment"># 执行系统命令 mkdir</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="文件通配符"><a class="markdownIt-Anchor" href="#文件通配符"></a> 文件通配符</h3>
<p>glob 模块提供了一个函数用于从目录通配符搜索中生成文件列表:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> glob</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>glob.glob(<span class="string">'*.py'</span>)</span><br><span class="line">[<span class="string">'primes.py'</span>, <span class="string">'random.py'</span>, <span class="string">'quote.py'</span>]</span><br></pre></td></tr></table></figure>
<h3 id="命令行参数"><a class="markdownIt-Anchor" href="#命令行参数"></a> 命令行参数</h3>
<p>通用工具脚本经常调用命令行参数。这些命令行参数以链表形式存储于 sys 模块的 argv 变量。例如在命令行中执行 <code>python demo.py one two three</code> 后可以得到以下输出结果:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(sys.argv)</span><br><span class="line">[<span class="string">'demo.py'</span>, <span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>]</span><br></pre></td></tr></table></figure>
<h3 id="错误输出重定向和程序终止"><a class="markdownIt-Anchor" href="#错误输出重定向和程序终止"></a> 错误输出重定向和程序终止</h3>
<p>sys 还有 stdin，stdout 和 stderr 属性，即使在 stdout 被重定向时，后者也可以用于显示警告和错误信息。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.stderr.write(<span class="string">'Warning, log file not found starting a new one\n'</span>)</span><br><span class="line">Warning, log file <span class="keyword">not</span> found starting a new one</span><br></pre></td></tr></table></figure>
<h3 id="字符串正则匹配"><a class="markdownIt-Anchor" href="#字符串正则匹配"></a> 字符串正则匹配</h3>
<p>re 模块为高级字符串处理提供了正则表达式工具。对于复杂的匹配和处理，正则表达式提供了简洁、优化的解决方案:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(<span class="string">r'\bf[a-z]*'</span>, <span class="string">'which foot or hand fell fastest'</span>)</span><br><span class="line">[<span class="string">'foot'</span>, <span class="string">'fell'</span>, <span class="string">'fastest'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.sub(<span class="string">r'(\b[a-z]+) \1'</span>, <span class="string">r'\1'</span>, <span class="string">'cat in the the hat'</span>)</span><br><span class="line"><span class="string">'cat in the hat'</span></span><br></pre></td></tr></table></figure>
<h3 id="数学"><a class="markdownIt-Anchor" href="#数学"></a> 数学</h3>
<p>math 模块为浮点运算提供了对底层 C 函数库的访问:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>math.cos(math.pi / <span class="number">4</span>)</span><br><span class="line"><span class="number">0.70710678118654757</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>math.log(<span class="number">1024</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">10.0</span></span><br></pre></td></tr></table></figure>
<h1 id="资料"><a class="markdownIt-Anchor" href="#资料"></a> 资料</h1>
<ul>
<li><a href="https://github.com/vinta/awesome-python" target="_blank" rel="noopener">https://github.com/vinta/awesome-python</a> - 资源大全</li>
<li><a href="https://github.com/jobbole/awesome-python-cn" target="_blank" rel="noopener">https://github.com/jobbole/awesome-python-cn</a> - 资源大全</li>
<li><a href="https://github.com/scrapy/scrapy" target="_blank" rel="noopener">https://github.com/scrapy/scrapy</a> - python 爬虫框架</li>
<li><a href="https://github.com/faif/python-patterns" target="_blank" rel="noopener">https://github.com/faif/python-patterns</a> - python 设计模式</li>
<li><a href="https://github.com/kennethreitz/python-guide" target="_blank" rel="noopener">https://github.com/kennethreitz/python-guide</a> - python 最佳实践</li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>如何学习一门编程语言</title>
    <url>/blog/coding/programming-guide/</url>
    <content><![CDATA[<blockquote>
<p>📓 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p>
</blockquote>
<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<p>很多人喜欢争论什么什么编程语言好，我认为这个话题如果不限定应用范围，就毫无意义。</p>
<p>每种编程语言必然有其优点和缺点，这也决定了它有适合的应用场景和不适合的应用场景。现代软件行业，想一门编程语言包打天下是不现实的。这中现状也造成了一种现象，一个程序员往往要掌握多种编程语言。</p>
<p>学习任何一门编程语言，都会面临的第一个问题都是：如何学习 XX 语言？</p>
<p>我不想说什么多看、多学、多写、多练之类的废话。世上事有难易乎？无他，唯手熟尔。谁不知道熟能生巧的道理？</p>
<p>我觉得有必要谈谈的是：如何由浅入深的学习一门编程语言？学习所有编程语言有没有一个相对统一的学习方法？</p>
<p>曾几何时，当我还是一名小菜鸟时，总是叹服那些大神掌握多门编程语言。后来，在多年编程工作和学习中，我陆陆续续也接触过不少编程语言：C、C++、Java、C#、Javascript、shell 等等。每次学习一门新的编程语言，掌握程度或深或浅，但是学习的曲线却大抵相似。</p>
<p>下面，我按照个人的学习经验总结一下，学习编程语言的基本步骤。</p>
<h2 id="学习编程语言的步骤"><a class="markdownIt-Anchor" href="#学习编程语言的步骤"></a> 学习编程语言的步骤</h2>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/programming/learn-programming-language.png"/></div>
<h3 id="基本语法"><a class="markdownIt-Anchor" href="#基本语法"></a> 基本语法</h3>
<p>首先当然是了解语言的最基本语法。</p>
<p>控制台输出，如 C 的 printf，Java 的 System.out.println 等。</p>
<p>普通程序员的第一行代码一般都是输出 “Hello World” 吧。</p>
<ul>
<li>
<p>基本数据类型</p>
<p>不同编程语言的基本数据类型不同。基本数据类型是的申请内存空间变得方便、规范化。</p>
</li>
<li>
<p>变量</p>
<p>不同编程语言的声明变量方式有很大不同。有的如 Java 、C++ 需要明确指定变量数据类型，这种叫强类型定义语言。有的语言（主要是脚本语言），如 Javascript、Shell 等，不需要明确指定数据类型，这种叫弱类型定义语言。</p>
<p>还需要注意的一点是变量的作用域范围和生命周期。不同语言变量的作用域范围和生命周期不一定一样，这个需要在代码中细细体会，有时会为此埋雷。</p>
</li>
<li>
<p>逻辑控制语句</p>
<p>编程语言都会有逻辑控制语句，哪怕是汇编语言。</p>
<p>掌握条件语句、循环语句、中断循环语句（break、continue）、选择语句。一般区别仅仅在于关键字、语法格式略有不同。</p>
</li>
<li>
<p>运算符</p>
<p>掌握基本运算符，如算术运算符、关系运算符、逻辑运算符、赋值运算符等。</p>
<p>有些语言还提供位运算符、特殊运算符，视情节掌握。</p>
</li>
<li>
<p>注释（没啥好说的）</p>
</li>
<li>
<p>函数</p>
<p>编程语言基本都有函数。注意语法格式：是否支持出参；支持哪些数据作为入参，有些语言允许将函数作为参数传入另一个参数（即回调）；返回值；如何退出函数（如 Java、C++的 return，）。</p>
</li>
</ul>
<h3 id="数组-枚举-集合"><a class="markdownIt-Anchor" href="#数组-枚举-集合"></a> 数组、枚举、集合</h3>
<p>枚举只有部分编程语言有，如 Java、C++、C#。</p>
<p>但是数组和集合（有些语言叫容器）一般编程语言都有，只是有的编程语言提供的集合比较丰富。使用方法基本类似。</p>
<h3 id="常用类"><a class="markdownIt-Anchor" href="#常用类"></a> 常用类</h3>
<p>比较常用的类（当然有些语言中不叫类，叫对象或者其他什么，这个不重要，领会精神）请了解其 API 用法，如：字符串、日期、数学计算等等。</p>
<h3 id="语言特性"><a class="markdownIt-Anchor" href="#语言特性"></a> 语言特性</h3>
<p>语言特性这个特字反映的就是各个编程语言自身的&quot;独特个性&quot;，这涉及的点比较多，简单列举一些。</p>
<p><strong>编程模式</strong></p>
<p>比较流行的编程模式大概有：</p>
<p>面向对象编程，主要是封装、继承、多态；函数式编程，主要是应用 Lambda；过程式编程，可以理解为实现需求功能的特定步骤。</p>
<p>每种编程模式都有一定的道理，我从不认为只有面向对象编程才是王道。</p>
<p>Java 是面向对象语言，从 Java8 开始也支持函数编程（引入 Lambda 表达式）；C++ 可以算是半面向对象，半面向过程式语言。</p>
<p><strong>语言自身特性</strong></p>
<p>每个语言自身都有一些重要特性需要了解。例如，学习 C、C++，你必须了解内存的申请和释放，了解指针、引用。而学习 Java，你需要了解 JVM，垃圾回收机制。学习 Javascript，你需要了解 DOM 操作等。</p>
<h3 id="代码组织-模块加载-库管理"><a class="markdownIt-Anchor" href="#代码组织-模块加载-库管理"></a> 代码组织、模块加载、库管理</h3>
<p>一个程序一般都有很多个源代码文件。这就会引入这些问题：如何将代码文件组织起来？如何根据业务需要，选择将部分模块启动时进行加载，部分模块使用懒加载（或者热加载）？</p>
<p>最基本的引用文件就不提了，如 C、C++的#include，Java 的 import 等。</p>
<p>针对代码组织、模块加载、库管理这些问题，不同语言会有不同的解决方案。</p>
<p>如 Java 可以用 maven、gradle 管理项目依赖、组织代码结构；Javascript （包括 Nodejs、jquery、react 等等库）可以用 npm、yarn 管理依赖，用 webpack 等工具管理模块加载。</p>
<h3 id="容错处理"><a class="markdownIt-Anchor" href="#容错处理"></a> 容错处理</h3>
<p>程序总难免会有 bug。</p>
<p>所以为了代码健壮性也好，为了方便定位问题也好，代码中需要有容错处理。常见的手段有：</p>
<ul>
<li>异常</li>
<li>断言</li>
<li>日志</li>
<li>调试</li>
<li>单元测试</li>
</ul>
<h3 id="输入输出和文件处理"><a class="markdownIt-Anchor" href="#输入输出和文件处理"></a> 输入输出和文件处理</h3>
<p>这块知识比较繁杂。建议提纲挈领的学习一下，理解基本概念，比如输入输出流、管道等等。至于 API，用到的时候再查一下即可。</p>
<h3 id="回调机制"><a class="markdownIt-Anchor" href="#回调机制"></a> 回调机制</h3>
<p>每种语言实现回调的方式有所不同，如 .Net 的 delegate （大量被用于 WinForm 程序）；Javascript 中函数天然支持回调：Javascript 函数允许传入另一个函数作为入参，然后在方法中调用它。其它语言的回调方式不一一列举。</p>
<h3 id="序列化和反序列化"><a class="markdownIt-Anchor" href="#序列化和反序列化"></a> 序列化和反序列化</h3>
<p>首先需要了解的是，序列化和反序列化的作用是为了在不同平台之间传输对象。</p>
<p>其次，要知道序列化存在多种方式，不同编程语言可能有多种方案。根据应用的序列化方式，选择性了解即可。</p>
<h3 id="进阶特性"><a class="markdownIt-Anchor" href="#进阶特性"></a> 进阶特性</h3>
<p>以下学习内容属于进阶性内容。可以根据开发需要去学习、掌握。需要注意的是，学习这些特性的态度应该是不学则已，学则死磕。因为半懂半不懂，特别容易引入问题。</p>
<p><em>对于半桶水的同学，我想说：放过自己，也放过别人，活着不好吗？</em></p>
<ul>
<li>
<p>**并发编程：**好处多多，十分重要，但是并发代码容易出错，且出错难以定位。要学习还是要花很大力气的，需要了解大量知识，如：进程、线程、同步、异步、读写锁等等。</p>
</li>
<li>
<p><strong>反射</strong> - 让你可以动态编程（慎用）。</p>
</li>
<li>
<p><strong>泛型</strong> - 集合（或者叫容器）的基石。精通泛型，能大大提高你的代码效率。</p>
</li>
<li>
<p><strong>元数据</strong> - 描述数据的数据。Java 中叫做注解。</p>
</li>
</ul>
<h3 id="库和框架"><a class="markdownIt-Anchor" href="#库和框架"></a> 库和框架</h3>
<p>学习一门编程语言，难免需要用到围绕它构建的技术生态圈——库和框架。这方面知识范围太庞大，根据实际应用领域去学习吧。比如搞 JavaWeb，你多多少少肯定要用到 Spring、Mybatis、Hibernate、Shiro 等大量开发框架；如果做 Javascript 前端，你可能会用到 React、Vue、Angular 、jQuery 等库或框架。</p>
<h2 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h2>
<p>总结以上，编程语言学习的道路是任重而道远的，未来是光明的。</p>
<p>最后一句话与君共勉：路漫漫兮其修远，吾将上下而求索。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 从入门到精通</title>
    <url>/blog/tools/git/</url>
    <content><![CDATA[<blockquote>
<p>📓 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p>
</blockquote>
<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<h3 id="git-是什么"><a class="markdownIt-Anchor" href="#git-是什么"></a> Git 是什么</h3>
<p>Git 是一个开源的分布式版本控制系统。</p>
<h3 id="什么是版本控制"><a class="markdownIt-Anchor" href="#什么是版本控制"></a> 什么是版本控制</h3>
<p>版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。</p>
<h3 id="什么是分布式版本控制系统"><a class="markdownIt-Anchor" href="#什么是分布式版本控制系统"></a> 什么是分布式版本控制系统</h3>
<p>介绍分布式版本控制系统前，有必要先了解一下传统的集中式版本控制系统。</p>
<p><strong>集中化的版本控制系统</strong>，诸如 CVS，Subversion 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。</p>
<p>这么做最显而易见的缺点是中央服务器的单点故障。如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。要是中央服务器的磁盘发生故障，碰巧没做备份，或者备份不够及时，就会有丢失数据的风险。最坏的情况是彻底丢失整个项目的所有历史更改记录。</p>
<div align="center"><img src="https://git-scm.com/figures/18333fig0102-tn.png"/></div>
<p><strong>分布式版本控制系统</strong>的客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。因为每一次的提取操作，实际上都是一次对代码仓库的完整备份。</p>
<div align="center"><img src="https://git-scm.com/figures/18333fig0103-tn.png"/></div>
<h3 id="为什么使用-git"><a class="markdownIt-Anchor" href="#为什么使用-git"></a> 为什么使用 Git</h3>
<p>Git 是分布式的。这是 Git 和其它非分布式的版本控制系统，例如 svn，cvs 等，最核心的区别。分布式带来以下好处：</p>
<p><strong>工作时不需要联网</strong></p>
<p>首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件 A，你的同事也在他的电脑上改了文件 A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p>
<p><strong>更加安全</strong></p>
<p>集中式版本控制系统，一旦中央服务器出了问题，所有人都无法工作。</p>
<p>分布式版本控制系统，每个人电脑中都有完整的版本库，所以某人的机器挂了，并不影响其它人。</p>
<h2 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h2>
<p><strong>Debian/Ubuntu 环境安装</strong></p>
<p>如果你使用的系统是 Debian/Ubuntu ， 安装命令为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \</span><br><span class="line">&gt; libz-dev libssl-dev</span><br><span class="line">$ apt-get install git-core</span><br><span class="line">$ git --version</span><br><span class="line">git version 1.8.1.2</span><br></pre></td></tr></table></figure>
<p><strong>Centos/RedHat 环境安装</strong></p>
<p>如果你使用的系统是 Centos/RedHat ，安装命令为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum install curl-devel expat-devel gettext-devel \</span><br><span class="line">&gt; openssl-devel zlib-devel</span><br><span class="line">$ yum -y install git-core</span><br><span class="line">$ git --version</span><br><span class="line">git version 1.7.1</span><br></pre></td></tr></table></figure>
<p><strong>Windows 环境安装</strong></p>
<p>在<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git 官方下载地址</a>下载 exe 安装包。按照安装向导安装即可。</p>
<p>建议安装 Git Bash 这个 git 的命令行工具。</p>
<p><strong>Mac 环境安装</strong></p>
<p>在<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git 官方下载地址</a>下载 mac 安装包。按照安装向导安装即可。</p>
<h2 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h2>
<p>Git 自带一个 <code>git config</code> 的工具来帮助设置控制 Git 外观和行为的配置变量。 这些变量存储在三个不同的位置：</p>
<ol>
<li><code>/etc/gitconfig</code> 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果使用带有 <code>--system</code> 选项的 <code>git config</code> 时，它会从此文件读写配置变量。</li>
<li><code>\~/.gitconfig</code> 或 <code>\~/.config/git/config</code> 文件：只针对当前用户。 可以传递 <code>--global</code> 选项让 Git 读写此文件。</li>
<li>当前使用仓库的 Git 目录中的 <code>config</code> 文件（就是 <code>.git/config</code>）：针对该仓库。</li>
</ol>
<p>每一个级别覆盖上一级别的配置，所以 <code>.git/config</code> 的配置变量会覆盖 <code>/etc/gitconfig</code> 中的配置变量。</p>
<p>在 Windows 系统中，Git 会查找 <code>$HOME</code> 目录下（一般情况下是 <code>C:\Users\$USER</code>）的 <code>.gitconfig</code> 文件。 Git 同样也会寻找 <code>/etc/gitconfig</code> 文件，但只限于 MSys 的根目录下，即安装 Git 时所选的目标位置。</p>
<h3 id="用户信息"><a class="markdownIt-Anchor" href="#用户信息"></a> 用户信息</h3>
<p>当安装完 Git 应该做的第一件事就是设置你的用户名称与邮件地址。 这样做很重要，因为每一个 Git 的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"John Doe"</span></span><br><span class="line">$ git config --global user.email johndoe@example.com</span><br></pre></td></tr></table></figure>
<p>再次强调，如果使用了 <code>--global</code> 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 <code>--global</code> 选项的命令来配置。</p>
<p>很多 GUI 工具都会在第一次运行时帮助你配置这些信息。</p>
<h3 id="gitignore"><a class="markdownIt-Anchor" href="#gitignore"></a> .gitignore</h3>
<p><code>.gitignore</code> 文件可能从字面含义也不难猜出：这个文件里配置的文件或目录，会自动被 git 所忽略，不纳入版本控制。</p>
<p>在日常开发中，我们的项目经常会产生一些临时文件，如编译 Java 产生的 <code>*.class</code> 文件，又或是 IDE 自动生成的隐藏目录（Intellij 的 <code>.idea</code> 目录、Eclipse 的 <code>.settings</code> 目录等）等等。这些文件或目录实在没必要纳入版本管理。在这种场景下，你就需要用到 <code>.gitignore</code> 配置来过滤这些文件或目录。</p>
<p>配置的规则很简单，也没什么可说的，看几个例子，自然就明白了。</p>
<p>这里推荐一下 Github 的开源项目：<a href="https://github.com/github/gitignore" target="_blank" rel="noopener">https://github.com/github/gitignore</a></p>
<p>在这里，你可以找到很多常用的模板，如：Java、Nodejs、C++ 的 <code>.gitignore</code> 模板等等。</p>
<h2 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h2>
<p>个人认为，对于 Git 这个版本工具，再不了解原理的情况下，直接去学习命令行，可能会一头雾水。所以，本文特意将原理放在命令使用章节之前讲解。</p>
<h3 id="版本库"><a class="markdownIt-Anchor" href="#版本库"></a> 版本库</h3>
<p>当你一个项目到本地或创建一个 git 项目，项目目录下会有一个隐藏的 <code>.git</code> 子目录。这个目录是 git 用来跟踪管理版本库的，千万不要手动修改。</p>
<h3 id="哈希值"><a class="markdownIt-Anchor" href="#哈希值"></a> 哈希值</h3>
<p>Git 中所有数据在存储前都计算校验和，然后以校验和来引用。 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。 这个功能建构在 Git 底层，是构成 Git 哲学不可或缺的部分。 若你在传送过程中丢失信息或损坏文件，Git 就能发现。</p>
<p>Git 用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）。 这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git 中文件的内容或目录结构计算出来。 SHA-1 哈希看起来是这样：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">24</span>b9da6552252987aa493b52f8696cd6d3b00373</span><br></pre></td></tr></table></figure>
<p>Git 中使用这种哈希值的情况很多，你将经常看到这种哈希值。 实际上，Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。</p>
<h3 id="文件状态"><a class="markdownIt-Anchor" href="#文件状态"></a> 文件状态</h3>
<p>在 GIt 中，你的文件可能会处于三种状态之一：</p>
<ul>
<li><strong>已修改（modified）</strong> - 已修改表示修改了文件，但还没保存到数据库中。</li>
<li><strong>已暂存（staged）</strong> - 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</li>
<li><strong>已提交（committed）</strong> - 已提交表示数据已经安全的保存在本地数据库中。</li>
</ul>
<h3 id="工作区域"><a class="markdownIt-Anchor" href="#工作区域"></a> 工作区域</h3>
<p>与文件状态对应的，不同状态的文件在 Git 中处于不同的工作区域。</p>
<ul>
<li><strong>工作区（working）</strong> - 当你 <code>git clone</code> 一个项目到本地，相当于在本地克隆了项目的一个副本。工作区是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。</li>
<li><strong>暂存区（staging）</strong> - 暂存区是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。 有时候也被称作`‘索引’’，不过一般说法还是叫暂存区。</li>
<li><strong>本地仓库（local）</strong> - 提交更新，找到暂存区域的文件，将快照永久性存储到 Git 本地仓库。</li>
<li><strong>远程仓库（remote）</strong> - 以上几个工作区都是在本地。为了让别人可以看到你的修改，你需要将你的更新推送到远程仓库。同理，如果你想同步别人的修改，你需要从远程仓库拉取更新。</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/web/git/git-theory.png"/></div>
<h2 id="命令"><a class="markdownIt-Anchor" href="#命令"></a> 命令</h2>
<p>国外网友制作了一张 Git Cheat Sheet，总结很精炼，各位不妨收藏一下。</p>
<p>本节选择性介绍 git 中比较常用的命令行场景。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/web/git/git-cheat-sheet.png"/></div>
<h3 id="创建仓库"><a class="markdownIt-Anchor" href="#创建仓库"></a> 创建仓库</h3>
<p>克隆一个已创建的仓库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过 SSH</span></span><br><span class="line">$ git <span class="built_in">clone</span> ssh://user@domain.com/repo.git</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过 HTTP</span></span><br><span class="line">$ git <span class="built_in">clone</span> http://domain.com/user/repo.git</span><br></pre></td></tr></table></figure>
<p>创建一个新的本地仓库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure>
<h3 id="添加修改"><a class="markdownIt-Anchor" href="#添加修改"></a> 添加修改</h3>
<p>添加修改到暂存区：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 把指定文件添加到暂存区</span></span><br><span class="line">$ git add xxx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把当前所有修改添加到暂存区</span></span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把所有修改添加到暂存区</span></span><br><span class="line">$ git add -A</span><br></pre></td></tr></table></figure>
<p>提交修改到本地仓库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 提交本地的所有修改</span></span><br><span class="line">$ git commit -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交之前已标记的变化</span></span><br><span class="line">$ git commit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 附加消息提交</span></span><br><span class="line">$ git commit -m <span class="string">'commit message'</span></span><br></pre></td></tr></table></figure>
<h4 id="储藏"><a class="markdownIt-Anchor" href="#储藏"></a> 储藏</h4>
<p>有时，我们需要在同一个项目的不同分支上工作。当需要切换分支时，偏偏本地的工作还没有完成，此时，提交修改显得不严谨，但是不提交代码又无法切换分支。这时，你可以使用 <code>git stash</code> 将本地的修改内容作为草稿储藏起来。</p>
<p>官方称之为储藏，但我个人更喜欢称之为存草稿。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 将修改作为当前分支的草稿保存</span></span><br><span class="line">$ git stash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 查看草稿列表</span></span><br><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on master: 6fae349 :memo: Writing docs.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.1 删除草稿</span></span><br><span class="line">$ git stash drop stash@&#123;0&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.2 读取草稿</span></span><br><span class="line">$ git stash apply stash@&#123;0&#125;</span><br></pre></td></tr></table></figure>
<h3 id="撤销修改"><a class="markdownIt-Anchor" href="#撤销修改"></a> 撤销修改</h3>
<p>撤销本地修改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 移除缓存区的所有文件（i.e. 撤销上次git add）</span></span><br><span class="line">$ git reset HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将HEAD重置到上一次提交的版本，并将之后的修改标记为未添加到缓存区的修改</span></span><br><span class="line">$ git reset &lt;commit&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将HEAD重置到上一次提交的版本，并保留未提交的本地修改</span></span><br><span class="line">$ git reset --keep &lt;commit&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 放弃工作目录下的所有修改</span></span><br><span class="line">$ git reset --hard HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将HEAD重置到指定的版本，并抛弃该版本之后的所有修改</span></span><br><span class="line">$ git reset --hard &lt;commit-hash&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用远端分支强制覆盖本地分支</span></span><br><span class="line">$ git reset --hard &lt;remote/branch&gt; e.g., upstream/master, origin/my-feature</span><br><span class="line"></span><br><span class="line"><span class="comment"># 放弃某个文件的所有本地修改</span></span><br><span class="line">$ git checkout HEAD &lt;file&gt;</span><br></pre></td></tr></table></figure>
<p>删除添加<code>.gitignore</code>文件前错误提交的文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git rm -r --cached .</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">"remove xyz file"</span></span><br></pre></td></tr></table></figure>
<p>撤销远程修改（创建一个新的提交，并回滚到指定版本）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git revert &lt;commit-hash&gt;</span><br></pre></td></tr></table></figure>
<p>彻底删除指定版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行下面命令后，commit-hash 提交后的记录都会被彻底删除，使用需谨慎</span></span><br><span class="line">$ git reset --hard &lt;commit-hash&gt;</span><br><span class="line">$ git push -f</span><br></pre></td></tr></table></figure>
<h3 id="更新与推送"><a class="markdownIt-Anchor" href="#更新与推送"></a> 更新与推送</h3>
<p>更新：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载远程端版本，但不合并到HEAD中</span></span><br><span class="line">$ git fetch &lt;remote&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将远程端版本合并到本地版本中</span></span><br><span class="line">$ git pull origin master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以rebase方式将远端分支与本地合并</span></span><br><span class="line">$ git pull --rebase &lt;remote&gt; &lt;branch&gt;</span><br></pre></td></tr></table></figure>
<p>推送：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将本地版本推送到远程端</span></span><br><span class="line">$ git push remote &lt;remote&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程端分支</span></span><br><span class="line">$ git push &lt;remote&gt; :&lt;branch&gt; (since Git v1.5.0)</span><br><span class="line">$ git push &lt;remote&gt; --delete &lt;branch&gt; (since Git v1.7.0)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发布标签</span></span><br><span class="line">$ git push --tags</span><br></pre></td></tr></table></figure>
<h3 id="查看信息"><a class="markdownIt-Anchor" href="#查看信息"></a> 查看信息</h3>
<p>显示工作路径下已修改的文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status</span><br></pre></td></tr></table></figure>
<p>显示与上次提交版本文件的不同：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git diff</span><br></pre></td></tr></table></figure>
<p>显示提交历史：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从最新提交开始，显示所有的提交记录（显示hash， 作者信息，提交的标题和时间）</span></span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个用户的所有提交</span></span><br><span class="line">$ git <span class="built_in">log</span> --author=<span class="string">"username"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个文件的所有修改</span></span><br><span class="line">$ git <span class="built_in">log</span> -p &lt;file&gt;</span><br></pre></td></tr></table></figure>
<p>显示搜索内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从当前目录的所有文件中查找文本内容</span></span><br><span class="line">$ git grep <span class="string">"Hello"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在某一版本中搜索文本</span></span><br><span class="line">$ git grep <span class="string">"Hello"</span> v2.5</span><br></pre></td></tr></table></figure>
<h3 id="分支"><a class="markdownIt-Anchor" href="#分支"></a> 分支</h3>
<p>增删查分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出所有的分支</span></span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有的远端分支</span></span><br><span class="line">$ git branch -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于当前分支创建新分支</span></span><br><span class="line">$ git branch &lt;new-branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于远程分支创建新的可追溯的分支</span></span><br><span class="line">$ git branch --track &lt;new-branch&gt; &lt;remote-branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除本地分支</span></span><br><span class="line">$ git branch -d &lt;branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制删除本地分支，将会丢失未合并的修改</span></span><br><span class="line">$ git branch -D &lt;branch&gt;</span><br></pre></td></tr></table></figure>
<p>切换分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切换分支</span></span><br><span class="line">$ git checkout &lt;branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建并切换到新分支</span></span><br><span class="line">$ git checkout -b &lt;branch&gt;</span><br></pre></td></tr></table></figure>
<h3 id="标签"><a class="markdownIt-Anchor" href="#标签"></a> 标签</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 给当前版本打标签</span></span><br><span class="line">$ git tag &lt;tag-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给当前版本打标签并附加消息</span></span><br><span class="line">$ git tag -a &lt;tag-name&gt;</span><br></pre></td></tr></table></figure>
<h3 id="合并与重置"><a class="markdownIt-Anchor" href="#合并与重置"></a> 合并与重置</h3>
<blockquote>
<p>merge 与 rebase 虽然是 git 常用功能，但是强烈建议不要使用 git 命令来完成这项工作。</p>
<p>因为如果出现代码冲突，在没有代码比对工具的情况下，实在太艰难了。</p>
<p>你可以考虑使用各种 Git GUI 工具。</p>
</blockquote>
<p>合并：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将分支合并到当前HEAD中</span></span><br><span class="line">$ git merge &lt;branch&gt;</span><br></pre></td></tr></table></figure>
<p>重置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将当前HEAD版本重置到分支中，请勿重置已发布的提交</span></span><br><span class="line">$ git rebase &lt;branch&gt;</span><br></pre></td></tr></table></figure>
<h3 id="github"><a class="markdownIt-Anchor" href="#github"></a> Github</h3>
<p>Github 作为最著名的代码开源协作社区，在程序员圈想必无人不知，无人不晓。</p>
<p>这里不赘述 Github 的用法，确实有不会用的新手同学，可以参考官方教程：<a href="https://guides.github.com/" target="_blank" rel="noopener">https://guides.github.com/</a></p>
<h4 id="clone-方式"><a class="markdownIt-Anchor" href="#clone-方式"></a> clone 方式</h4>
<p>Git 支持三种协议：HTTPS / SSH / GIT</p>
<p>而 Github 上支持 HTTPS 和 SSH。</p>
<p>HTTPS 这种方式要求你每次 push 时都要输入用户名、密码，有些繁琐。</p>
<p>而 SSH 要求你本地生成证书，然后在你的 Github 账户中注册。第一次配置麻烦是麻烦了点，但是以后就免去了每次 push 需要输入用户名、密码的繁琐。</p>
<div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-66f60822aeb2c21c.png"/></div>
<p>以下介绍以下，如何生成证书，以及在 Github 中注册。</p>
<h4 id="生成-ssh-公钥"><a class="markdownIt-Anchor" href="#生成-ssh-公钥"></a> 生成 SSH 公钥</h4>
<p>如前所述，许多 Git 服务器都使用 SSH 公钥进行认证。 为了向 Git 服务器提供 SSH 公钥，如果某系统用户尚未拥有密钥，必须事先为其生成一份。 这个过程在所有操作系统上都是相似的。 首先，你需要确认自己是否已经拥有密钥。 默认情况下，用户的 SSH 密钥存储在其 <code>\~/.ssh</code> 目录下。 进入该目录并列出其中内容，你便可以快速确认自己是否已拥有密钥：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/.ssh</span><br><span class="line">$ ls</span><br><span class="line">authorized_keys2  id_dsa       known_hosts</span><br><span class="line">config            id_dsa.pub</span><br></pre></td></tr></table></figure>
<p>我们需要寻找一对以 <code>id_dsa</code> 或 <code>id_rsa</code> 命名的文件，其中一个带有 <code>.pub</code> 扩展名。 <code>.pub</code> 文件是你的公钥，另一个则是私钥。 如果找不到这样的文件（或者根本没有 <code>.ssh</code> 目录），你可以通过运行 <code>ssh-keygen</code> 程序来创建它们。在 Linux/Mac 系统中，<code>ssh-keygen</code> 随 SSH 软件包提供；在 Windows 上，该程序包含于 MSysGit 软件包中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/home/schacon/.ssh/id_rsa):</span><br><span class="line">Created directory <span class="string">'/home/schacon/.ssh'</span>.</span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved <span class="keyword">in</span> /home/schacon/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> /home/schacon/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">d0:82:24:8e:d7:f1:bb:9b:33:53:96:93:49:da:9b:e3 schacon@mylaptop.local</span><br></pre></td></tr></table></figure>
<p>首先 <code>ssh-keygen</code> 会确认密钥的存储位置（默认是 <code>.ssh/id_rsa</code>），然后它会要求你输入两次密钥口令。如果你不想在使用密钥时输入口令，将其留空即可。</p>
<p>现在，进行了上述操作的用户需要将各自的公钥发送给任意一个 Git 服务器管理员（假设服务器正在使用基于公钥的 SSH 验证设置）。 他们所要做的就是复制各自的 <code>.pub</code> 文件内容，并将其通过邮件发送。 公钥看起来是这样的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat ~/.ssh/id_rsa.pub</span><br><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSU</span><br><span class="line">GPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3</span><br><span class="line">Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XA</span><br><span class="line">t3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/En</span><br><span class="line">mZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbx</span><br><span class="line">NrRFi9wrf+M7Q== schacon@mylaptop.local</span><br></pre></td></tr></table></figure>
<p>在你的 Github 账户中，依次点击 <strong>Settings</strong> &gt; <strong>SSH and GPG keys</strong> &gt; <strong>New SSH key</strong></p>
<p>然后，将上面生成的公钥内容粘贴到 <code>Key</code> 编辑框并保存。至此大功告成。</p>
<p>后面，你在克隆你的 Github 项目时使用 SSH 方式即可。</p>
<p>如果觉得我的讲解还不够细致，可以参考：<a href="https://help.github.com/articles/adding-a-new-ssh-key-to-your-github-account/" target="_blank" rel="noopener">https://help.github.com/articles/adding-a-new-ssh-key-to-your-github-account/</a></p>
<h2 id="最佳实践-git-flow"><a class="markdownIt-Anchor" href="#最佳实践-git-flow"></a> 最佳实践 Git Flow</h2>
<blockquote>
<p>详细内容，可以参考这篇文章：<a href="http://www.cnblogs.com/cnblogsfans/p/5075073.html" target="_blank" rel="noopener">Git 在团队中的最佳实践–如何正确使用 Git Flow</a></p>
</blockquote>
<p>Git 在实际开发中的最佳实践策略 Git Flow 可以归纳为以下：</p>
<ul>
<li><strong><code>master</code> 分支</strong> - 也就是我们经常使用的主线分支，这个分支是最近发布到生产环境的代码，这个分支只能从其他分支合并，不能在这个分支直接修改。</li>
<li><strong><code>develop</code> 分支</strong> - 这个分支是我们的主开发分支，包含所有要发布到下一个 release 的代码，这个分支主要是从其他分支合并代码过来，比如 feature 分支。</li>
<li><strong><code>feature</code> 分支</strong> - 这个分支主要是用来开发一个新的功能，一旦开发完成，我们合并回 develop 分支进入下一个 release。</li>
<li><strong><code>release</code> 分支</strong> - 当你需要一个发布一个新 release 的时候，我们基于 Develop 分支创建一个 release 分支，完成 release 后，我们合并到 master 和 develop 分支。</li>
<li><strong><code>hotfix</code> 分支</strong> - 当我们在 master 发现新的 Bug 时候，我们需要创建一个 hotfix, 完成 hotfix 后，我们合并回 master 和 develop 分支，所以 hotfix 的改动会进入下一个 release。</li>
</ul>
<h2 id="常见问题"><a class="markdownIt-Anchor" href="#常见问题"></a> 常见问题</h2>
<h3 id="编辑提交editting-commits"><a class="markdownIt-Anchor" href="#编辑提交editting-commits"></a> 编辑提交(editting commits)</h3>
<h4 id="我刚才提交了什么"><a class="markdownIt-Anchor" href="#我刚才提交了什么"></a> 我刚才提交了什么</h4>
<p>如果你用 <code>git commit -a</code> 提交了一次变化(changes)，而你又不确定到底这次提交了哪些内容。 你就可以用下面的命令显示当前<code>HEAD</code>上的最近一次的提交(commit):</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git show</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -n1 -p</span><br></pre></td></tr></table></figure>
<h4 id="我的提交信息commit-message写错了"><a class="markdownIt-Anchor" href="#我的提交信息commit-message写错了"></a> 我的提交信息(commit message)写错了</h4>
<p>如果你的提交信息(commit message)写错了且这次提交(commit)还没有推(push), 你可以通过下面的方法来修改提交信息(commit message):</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure>
<p>这会打开你的默认编辑器, 在这里你可以编辑信息. 另一方面, 你也可以用一条命令一次完成:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git commit --amend -m <span class="string">'xxxxxxx'</span></span><br></pre></td></tr></table></figure>
<p>如果你已经推(push)了这次提交(commit), 你可以修改这次提交(commit)然后强推(force push), 但是不推荐这么做。</p>
<h4 id="我提交commit里的用户名和邮箱不对"><a class="markdownIt-Anchor" href="#我提交commit里的用户名和邮箱不对"></a> 我提交(commit)里的用户名和邮箱不对</h4>
<p>如果这只是单个提交(commit)，修改它：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git commit --amend --author <span class="string">"New Authorname &lt;authoremail@mydomain.com&gt;"</span></span><br></pre></td></tr></table></figure>
<p>如果你需要修改所有历史, 参考 'git filter-branch’的指南页.</p>
<h4 id="我想从一个提交commit里移除一个文件"><a class="markdownIt-Anchor" href="#我想从一个提交commit里移除一个文件"></a> 我想从一个提交(commit)里移除一个文件</h4>
<p>通过下面的方法，从一个提交(commit)里移除一个文件:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git checkout HEAD^ myfile</span><br><span class="line">$ git add -A</span><br><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure>
<p>这将非常有用，当你有一个开放的补丁(open patch)，你往上面提交了一个不必要的文件，你需要强推(force push)去更新这个远程补丁。</p>
<h4 id="我想删除我的的最后一次提交commit"><a class="markdownIt-Anchor" href="#我想删除我的的最后一次提交commit"></a> 我想删除我的的最后一次提交(commit)</h4>
<p>如果你需要删除推了的提交(pushed commits)，你可以使用下面的方法。可是，这会不可逆的改变你的历史，也会搞乱那些已经从该仓库拉取(pulled)了的人的历史。简而言之，如果你不是很确定，千万不要这么做。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git reset HEAD^ --hard</span><br><span class="line">$ git push -f [remote] [branch]</span><br></pre></td></tr></table></figure>
<p>如果你还没有推到远程, 把 Git 重置(reset)到你最后一次提交前的状态就可以了(同时保存暂存的变化):</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">my</span>-branch*)$ git <span class="keyword">reset</span> --soft HEAD@&#123;1&#125;</span><br></pre></td></tr></table></figure>
<p>这只能在没有推送之前有用. 如果你已经推了, 唯一安全能做的是 <code>git revert SHAofBadCommit</code>， 那会创建一个新的提交(commit)用于撤消前一个提交的所有变化(changes)； 或者, 如果你推的这个分支是 rebase-safe 的 (例如： 其它开发者不会从这个分支拉), 只需要使用 <code>git push -f</code>； 更多, 请参考 <a href="#deleteremove-last-pushed-commit">the above section</a>。</p>
<h4 id="删除任意提交commit"><a class="markdownIt-Anchor" href="#删除任意提交commit"></a> 删除任意提交(commit)</h4>
<p>同样的警告：不到万不得已的时候不要这么做.</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git rebase --onto SHA1_OF_BAD_COMMIT^ SHA1_OF_BAD_COMMIT</span><br><span class="line">$ git push -f [remote] [branch]</span><br></pre></td></tr></table></figure>
<p>或者做一个 <a href="#interactive-rebase">交互式 rebase</a> 删除那些你想要删除的提交(commit)里所对应的行。</p>
<h4 id="我尝试推一个修正后的提交amended-commit到远程但是报错"><a class="markdownIt-Anchor" href="#我尝试推一个修正后的提交amended-commit到远程但是报错"></a> 我尝试推一个修正后的提交(amended commit)到远程，但是报错：</h4>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">To https://github.com/yourusername/repo.git</span><br><span class="line">! [rejected]        mybranch -&gt; mybranch (non-fast-forward)</span><br><span class="line">error: failed to push some refs to <span class="string">'https://github.com/tanay1337/webmaker.org.git'</span></span><br><span class="line">hint: Updates were rejected because the tip of your current branch is behind</span><br><span class="line">hint: its remote counterpart. Integrate the remote changes (e.g.</span><br><span class="line">hint: <span class="string">'git pull ...'</span>) before pushing again.</span><br><span class="line">hint: See the <span class="string">'Note about fast-forwards'</span> <span class="keyword">in</span> <span class="string">'git push --help'</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure>
<p>注意, rebasing(见下面)和修正(amending)会用一个<strong>新的提交(commit)代替旧的</strong>, 所以如果之前你已经往远程仓库上推过一次修正前的提交(commit)，那你现在就必须强推(force push) (<code>-f</code>)。 注意 – <em>总是</em> 确保你指明一个分支!</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(my-branch)$ git push origin mybranch -f</span><br></pre></td></tr></table></figure>
<p>一般来说, <strong>要避免强推</strong>. 最好是创建和推(push)一个新的提交(commit)，而不是强推一个修正后的提交。后者会使那些与该分支或该分支的子分支工作的开发者，在源历史中产生冲突。</p>
<h4 id="我意外的做了一次硬重置hard-reset我想找回我的内容"><a class="markdownIt-Anchor" href="#我意外的做了一次硬重置hard-reset我想找回我的内容"></a> 我意外的做了一次硬重置(hard reset)，我想找回我的内容</h4>
<p>如果你意外的做了 <code>git reset --hard</code>, 你通常能找回你的提交(commit), 因为 Git 对每件事都会有日志，且都会保存几天。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git reflog</span><br></pre></td></tr></table></figure>
<p>你将会看到一个你过去提交(commit)的列表, 和一个重置的提交。 选择你想要回到的提交(commit)的 SHA，再重置一次:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git reset --hard SHA1234</span><br></pre></td></tr></table></figure>
<p>这样就完成了。</p>
<h3 id="暂存staging"><a class="markdownIt-Anchor" href="#暂存staging"></a> 暂存(Staging)</h3>
<h4 id="我需要把暂存的内容添加到上一次的提交commit"><a class="markdownIt-Anchor" href="#我需要把暂存的内容添加到上一次的提交commit"></a> 我需要把暂存的内容添加到上一次的提交(commit)</h4>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(my-branch*)$ git commit --amend</span><br></pre></td></tr></table></figure>
<h4 id="我想要暂存一个新文件的一部分而不是这个文件的全部"><a class="markdownIt-Anchor" href="#我想要暂存一个新文件的一部分而不是这个文件的全部"></a> 我想要暂存一个新文件的一部分，而不是这个文件的全部</h4>
<p>一般来说, 如果你想暂存一个文件的一部分, 你可这样做:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git add --patch filename.x</span><br></pre></td></tr></table></figure>
<p><code>-p</code> 简写。这会打开交互模式， 你将能够用 <code>s</code> 选项来分隔提交(commit)； 然而, 如果这个文件是新的, 会没有这个选择， 添加一个新文件时, 这样做:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git add -N filename.x</span><br></pre></td></tr></table></figure>
<p>然后, 你需要用 <code>e</code> 选项来手动选择需要添加的行，执行 <code>git diff --cached</code> 将会显示哪些行暂存了哪些行只是保存在本地了。</p>
<h4 id="我想把在一个文件里的变化changes加到两个提交commit里"><a class="markdownIt-Anchor" href="#我想把在一个文件里的变化changes加到两个提交commit里"></a> 我想把在一个文件里的变化(changes)加到两个提交(commit)里</h4>
<p><code>git add</code> 会把整个文件加入到一个提交. <code>git add -p</code> 允许交互式的选择你想要提交的部分.</p>
<h4 id="我想把暂存的内容变成未暂存把未暂存的内容暂存起来"><a class="markdownIt-Anchor" href="#我想把暂存的内容变成未暂存把未暂存的内容暂存起来"></a> 我想把暂存的内容变成未暂存，把未暂存的内容暂存起来</h4>
<p>这个有点困难， 我能想到的最好的方法是先 stash 未暂存的内容， 然后重置(reset)，再 pop 第一步 stashed 的内容, 最后再 add 它们。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git stash -k</span><br><span class="line">$ git reset --hard</span><br><span class="line">$ git stash pop</span><br><span class="line">$ git add -A</span><br></pre></td></tr></table></figure>
<h3 id="未暂存unstaged的内容"><a class="markdownIt-Anchor" href="#未暂存unstaged的内容"></a> 未暂存(Unstaged)的内容</h3>
<h4 id="我想把未暂存的内容移动到一个新分支"><a class="markdownIt-Anchor" href="#我想把未暂存的内容移动到一个新分支"></a> 我想把未暂存的内容移动到一个新分支</h4>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git checkout -b my-branch</span><br></pre></td></tr></table></figure>
<h4 id="我想把未暂存的内容移动到另一个已存在的分支"><a class="markdownIt-Anchor" href="#我想把未暂存的内容移动到另一个已存在的分支"></a> 我想把未暂存的内容移动到另一个已存在的分支</h4>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git stash</span><br><span class="line">$ git checkout my-branch</span><br><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure>
<h4 id="我想丢弃本地未提交的变化uncommitted-changes"><a class="markdownIt-Anchor" href="#我想丢弃本地未提交的变化uncommitted-changes"></a> 我想丢弃本地未提交的变化(uncommitted changes)</h4>
<p>如果你只是想重置源(origin)和你本地(local)之间的一些提交(commit)，你可以：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">## one commit</span></span><br><span class="line">(my-branch)$ git reset --hard HEAD^</span><br><span class="line"><span class="comment">## two commits</span></span><br><span class="line">(my-branch)$ git reset --hard HEAD^^</span><br><span class="line"><span class="comment">## four commits</span></span><br><span class="line">(my-branch)$ git reset --hard HEAD~4</span><br><span class="line"><span class="comment">## or</span></span><br><span class="line">(master)$ git checkout -f</span><br></pre></td></tr></table></figure>
<p>重置某个特殊的文件, 你可以用文件名做为参数:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git reset filename</span><br></pre></td></tr></table></figure>
<h4 id="我想丢弃某些未暂存的内容"><a class="markdownIt-Anchor" href="#我想丢弃某些未暂存的内容"></a> 我想丢弃某些未暂存的内容</h4>
<p>如果你想丢弃工作拷贝中的一部分内容，而不是全部。</p>
<p>签出(checkout)不需要的内容，保留需要的。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git checkout -p</span><br><span class="line"><span class="comment">## Answer y to all of the snippets you want to drop</span></span><br></pre></td></tr></table></figure>
<p>另外一个方法是使用 <code>stash</code>， Stash 所有要保留下的内容, 重置工作拷贝, 重新应用保留的部分。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git stash -p</span><br><span class="line"><span class="comment">## Select all of the snippets you want to save</span></span><br><span class="line">$ git reset --hard</span><br><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure>
<p>或者, stash 你不需要的部分, 然后 stash drop。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git stash -p</span><br><span class="line"><span class="comment">## Select all of the snippets you don't want to save</span></span><br><span class="line">$ git stash drop</span><br></pre></td></tr></table></figure>
<h3 id="分支branches"><a class="markdownIt-Anchor" href="#分支branches"></a> 分支(Branches)</h3>
<h4 id="我从错误的分支拉取了内容或把内容拉取到了错误的分支"><a class="markdownIt-Anchor" href="#我从错误的分支拉取了内容或把内容拉取到了错误的分支"></a> 我从错误的分支拉取了内容，或把内容拉取到了错误的分支</h4>
<p>这是另外一种使用 <code>git reflog</code> 情况，找到在这次错误拉(pull) 之前 HEAD 的指向。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git reflog</span><br><span class="line">ab7555f HEAD@&#123;0&#125;: pull origin wrong-branch: Fast-forward</span><br><span class="line">c5bc55a HEAD@&#123;1&#125;: checkout: checkout message goes here</span><br></pre></td></tr></table></figure>
<p>重置分支到你所需的提交(desired commit):</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git reset --hard c5bc55a</span><br></pre></td></tr></table></figure>
<p>完成。</p>
<h4 id="我想扔掉本地的提交commit以便我的分支与远程的保持一致"><a class="markdownIt-Anchor" href="#我想扔掉本地的提交commit以便我的分支与远程的保持一致"></a> 我想扔掉本地的提交(commit)，以便我的分支与远程的保持一致</h4>
<p>先确认你没有推(push)你的内容到远程。</p>
<p><code>git status</code> 会显示你领先(ahead)源(origin)多少个提交:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(my-branch)$ git status</span><br><span class="line"><span class="comment">## On branch my-branch</span></span><br><span class="line"><span class="comment">## Your branch is ahead of 'origin/my-branch' by 2 commits.</span></span><br><span class="line"><span class="comment">##   (use "git push" to publish your local commits)</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>一种方法是:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git reset --hard origin/my-branch</span><br></pre></td></tr></table></figure>
<h4 id="我需要提交到一个新分支但错误的提交到了-master"><a class="markdownIt-Anchor" href="#我需要提交到一个新分支但错误的提交到了-master"></a> 我需要提交到一个新分支，但错误的提交到了 master</h4>
<p>在 master 下创建一个新分支，不切换到新分支,仍在 master 下:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git branch my-branch</span><br></pre></td></tr></table></figure>
<p>把 master 分支重置到前一个提交:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git reset --hard HEAD^</span><br></pre></td></tr></table></figure>
<p><code>HEAD^</code> 是 <code>HEAD^1</code> 的简写，你可以通过指定要设置的<code>HEAD</code>来进一步重置。</p>
<p>或者, 如果你不想使用 <code>HEAD^</code>, 找到你想重置到的提交(commit)的 hash(<code>git log</code> 能够完成)， 然后重置到这个 hash。 使用<code>git push</code> 同步内容到远程。</p>
<p>例如, master 分支想重置到的提交的 hash 为<code>a13b85e</code>:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git reset --hard a13b85e</span><br><span class="line">HEAD is now at a13b85e</span><br></pre></td></tr></table></figure>
<p>签出(checkout)刚才新建的分支继续工作:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git checkout my-branch</span><br></pre></td></tr></table></figure>
<h4 id="我想保留来自另外一个-ref-ish-的整个文件"><a class="markdownIt-Anchor" href="#我想保留来自另外一个-ref-ish-的整个文件"></a> 我想保留来自另外一个 ref-ish 的整个文件</h4>
<p>假设你正在做一个原型方案(原文为 working spike (see note)), 有成百的内容，每个都工作得很好。现在, 你提交到了一个分支，保存工作内容:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(solution)$ git add -A &amp;&amp; git commit -m <span class="string">"Adding all changes from this spike into one big commit."</span></span><br></pre></td></tr></table></figure>
<p>当你想要把它放到一个分支里 (可能是<code>feature</code>, 或者 <code>develop</code>), 你关心是保持整个文件的完整，你想要一个大的提交分隔成比较小。</p>
<p>假设你有:</p>
<ul>
<li>分支 <code>solution</code>, 拥有原型方案， 领先 <code>develop</code> 分支。</li>
<li>分支 <code>develop</code>, 在这里你应用原型方案的一些内容。</li>
</ul>
<p>我去可以通过把内容拿到你的分支里，来解决这个问题:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(develop)$ git checkout solution -- file1.txt</span><br></pre></td></tr></table></figure>
<p>这会把这个文件内容从分支 <code>solution</code> 拿到分支 <code>develop</code> 里来:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">## On branch develop</span></span><br><span class="line"><span class="comment">## Your branch is up-to-date with 'origin/develop'.</span></span><br><span class="line"><span class="comment">## Changes to be committed:</span></span><br><span class="line"><span class="comment">##  (use "git reset HEAD &lt;file&gt;..." to unstage)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">##        modified:   file1.txt</span></span><br></pre></td></tr></table></figure>
<p>然后, 正常提交。</p>
<p>Note: Spike solutions are made to analyze or solve the problem. These solutions are used for estimation and discarded once everyone gets clear visualization of the problem. ~ <a href="https://en.wikipedia.org/wiki/Extreme_programming_practices" target="_blank" rel="noopener">Wikipedia</a>.</p>
<h4 id="我把几个提交commit提交到了同一个分支而这些提交应该分布在不同的分支里"><a class="markdownIt-Anchor" href="#我把几个提交commit提交到了同一个分支而这些提交应该分布在不同的分支里"></a> 我把几个提交(commit)提交到了同一个分支，而这些提交应该分布在不同的分支里</h4>
<p>假设你有一个<code>master</code>分支， 执行<code>git log</code>, 你看到你做过两次提交:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line">commit e3851e817c451cc36f2e6f3049db528415e3c114</span><br><span class="line">Author: Alex Lee &lt;alexlee@example.com&gt;</span><br><span class="line">Date:   Tue Jul 22 15:39:27 2014 -0400</span><br><span class="line"></span><br><span class="line">    Bug <span class="comment">#21 - Added CSRF protection</span></span><br><span class="line"></span><br><span class="line">commit 5ea51731d150f7ddc4a365437931cd8be3bf3131</span><br><span class="line">Author: Alex Lee &lt;alexlee@example.com&gt;</span><br><span class="line">Date:   Tue Jul 22 15:39:12 2014 -0400</span><br><span class="line"></span><br><span class="line">    Bug <span class="comment">#14 - Fixed spacing on title</span></span><br><span class="line"></span><br><span class="line">commit a13b85e984171c6e2a1729bb061994525f626d14</span><br><span class="line">Author: Aki Rose &lt;akirose@example.com&gt;</span><br><span class="line">Date:   Tue Jul 21 01:12:48 2014 -0400</span><br><span class="line"></span><br><span class="line">    First commit</span><br></pre></td></tr></table></figure>
<p>让我们用提交 hash(commit hash)标记 bug (<code>e3851e8</code> for #21, <code>5ea5173</code> for #14).</p>
<p>首先, 我们把<code>master</code>分支重置到正确的提交(<code>a13b85e</code>):</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git reset --hard a13b85e</span><br><span class="line">HEAD is now at a13b85e</span><br></pre></td></tr></table></figure>
<p>现在, 我们对 bug #21 创建一个新的分支:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git checkout -b 21</span><br><span class="line">(21)$</span><br></pre></td></tr></table></figure>
<p>接着, 我们用 <em>cherry-pick</em> 把对 bug #21 的提交放入当前分支。 这意味着我们将应用(apply)这个提交(commit)，仅仅这一个提交(commit)，直接在 HEAD 上面。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(21)$ git cherry-pick e3851e8</span><br></pre></td></tr></table></figure>
<p>这时候, 这里可能会产生冲突， 参见<a href="#interactive-rebase">交互式 rebasing 章</a> <a href="#merge-conflict"><strong>冲突节</strong></a> 解决冲突.</p>
<p>再者， 我们为 bug #14 创建一个新的分支, 也基于<code>master</code>分支</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(21)$ git checkout master</span><br><span class="line">(master)$ git checkout -b 14</span><br><span class="line">(14)$</span><br></pre></td></tr></table></figure>
<p>最后, 为 bug #14 执行 <code>cherry-pick</code>:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(14)$ git cherry-pick 5ea5173</span><br></pre></td></tr></table></figure>
<h4 id="我想删除上游upstream分支被删除了的本地分支"><a class="markdownIt-Anchor" href="#我想删除上游upstream分支被删除了的本地分支"></a> 我想删除上游(upstream)分支被删除了的本地分支</h4>
<p>一旦你在 github 上面合并(merge)了一个 pull request, 你就可以删除你 fork 里被合并的分支。 如果你不准备继续在这个分支里工作, 删除这个分支的本地拷贝会更干净，使你不会陷入工作分支和一堆陈旧分支的混乱之中。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git fetch -p</span><br></pre></td></tr></table></figure>
<h4 id="我不小心删除了我的分支"><a class="markdownIt-Anchor" href="#我不小心删除了我的分支"></a> 我不小心删除了我的分支</h4>
<p>如果你定期推送到远程, 多数情况下应该是安全的，但有些时候还是可能删除了还没有推到远程的分支。 让我们先创建一个分支和一个新的文件:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git checkout -b my-branch</span><br><span class="line">(my-branch)$ git branch</span><br><span class="line">(my-branch)$ touch foo.txt</span><br><span class="line">(my-branch)$ ls</span><br><span class="line">README.md foo.txt</span><br></pre></td></tr></table></figure>
<p>添加文件并做一次提交</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(my-branch)$ git add .</span><br><span class="line">(my-branch)$ git commit -m <span class="string">'foo.txt added'</span></span><br><span class="line">(my-branch)$ foo.txt added</span><br><span class="line"> 1 files changed, 1 insertions(+)</span><br><span class="line"> create mode 100644 foo.txt</span><br><span class="line">(my-branch)$ git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line">commit 4e3cd85a670ced7cc17a2b5d8d3d809ac88d5012</span><br><span class="line">Author: siemiatj &lt;siemiatj@example.com&gt;</span><br><span class="line">Date:   Wed Jul 30 00:34:10 2014 +0200</span><br><span class="line"></span><br><span class="line">    foo.txt added</span><br><span class="line"></span><br><span class="line">commit 69204cdf0acbab201619d95ad8295928e7f411d5</span><br><span class="line">Author: Kate Hudson &lt;katehudson@example.com&gt;</span><br><span class="line">Date:   Tue Jul 29 13:14:46 2014 -0400</span><br><span class="line"></span><br><span class="line">    Fixes <span class="comment">#6: Force pushing after amending commits</span></span><br></pre></td></tr></table></figure>
<p>现在我们切回到主(master)分支，‘不小心的’删除<code>my-branch</code>分支</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(my-branch)$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line">(master)$ git branch -D my-branch</span><br><span class="line">Deleted branch my-branch (was 4e3cd85).</span><br><span class="line">(master)$ <span class="built_in">echo</span> oh noes, deleted my branch!</span><br><span class="line">oh noes, deleted my branch!</span><br></pre></td></tr></table></figure>
<p>在这时候你应该想起了<code>reflog</code>, 一个升级版的日志，它存储了仓库(repo)里面所有动作的历史。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">(master)$ git <span class="built_in">ref</span>log</span><br><span class="line"><span class="number">69204</span>cd <span class="symbol">HEAD@</span>&#123;<span class="number">0</span>&#125;: checkout: moving <span class="keyword">from</span> my-branch to master</span><br><span class="line"><span class="number">4e3</span>cd85 <span class="symbol">HEAD@</span>&#123;<span class="number">1</span>&#125;: commit: foo.txt added</span><br><span class="line"><span class="number">69204</span>cd <span class="symbol">HEAD@</span>&#123;<span class="number">2</span>&#125;: checkout: moving <span class="keyword">from</span> master to my-branch</span><br></pre></td></tr></table></figure>
<p>正如你所见，我们有一个来自删除分支的提交 hash(commit hash)，接下来看看是否能恢复删除了的分支。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git checkout -b my-branch-help</span><br><span class="line">Switched to a new branch <span class="string">'my-branch-help'</span></span><br><span class="line">(my-branch-help)$ git reset --hard 4e3cd85</span><br><span class="line">HEAD is now at 4e3cd85 foo.txt added</span><br><span class="line">(my-branch-help)$ ls</span><br><span class="line">README.md foo.txt</span><br></pre></td></tr></table></figure>
<p>看! 我们把删除的文件找回来了。 Git 的 <code>reflog</code> 在 rebasing 出错的时候也是同样有用的。</p>
<h4 id="我想删除一个分支"><a class="markdownIt-Anchor" href="#我想删除一个分支"></a> 我想删除一个分支</h4>
<p>删除一个远程分支:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git push origin --delete my-branch</span><br></pre></td></tr></table></figure>
<p>你也可以:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git push origin :my-branch</span><br></pre></td></tr></table></figure>
<p>删除一个本地分支:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git branch -D my-branch</span><br></pre></td></tr></table></figure>
<h4 id="我想从别人正在工作的远程分支签出checkout一个分支"><a class="markdownIt-Anchor" href="#我想从别人正在工作的远程分支签出checkout一个分支"></a> 我想从别人正在工作的远程分支签出(checkout)一个分支</h4>
<p>首先, 从远程拉取(fetch) 所有分支:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git fetch --all</span><br></pre></td></tr></table></figure>
<p>假设你想要从远程的<code>daves</code>分支签出到本地的<code>daves</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git checkout --track origin/daves</span><br><span class="line">Branch daves <span class="built_in">set</span> up to track remote branch daves from origin.</span><br><span class="line">Switched to a new branch <span class="string">'daves'</span></span><br></pre></td></tr></table></figure>
<p>(<code>--track</code> 是 <code>git checkout -b [branch] [remotename]/[branch]</code> 的简写)</p>
<p>这样就得到了一个<code>daves</code>分支的本地拷贝, 任何推过(pushed)的更新，远程都能看到.</p>
<h3 id="rebasing-和合并merging"><a class="markdownIt-Anchor" href="#rebasing-和合并merging"></a> Rebasing 和合并(Merging)</h3>
<h4 id="我想撤销-rebasemerge"><a class="markdownIt-Anchor" href="#我想撤销-rebasemerge"></a> 我想撤销 rebase/merge</h4>
<p>你可以合并(merge)或 rebase 了一个错误的分支, 或者完成不了一个进行中的 rebase/merge。 Git 在进行危险操作的时候会把原始的 HEAD 保存在一个叫 ORIG_HEAD 的变量里, 所以要把分支恢复到 rebase/merge 前的状态是很容易的。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(my-branch)$ git reset --hard ORIG_HEAD</span><br></pre></td></tr></table></figure>
<h4 id="我已经-rebase-过-但是我不想强推force-push"><a class="markdownIt-Anchor" href="#我已经-rebase-过-但是我不想强推force-push"></a> 我已经 rebase 过, 但是我不想强推(force push)</h4>
<p>不幸的是，如果你想把这些变化(changes)反应到远程分支上，你就必须得强推(force push)。 是因你快进(Fast forward)了提交，改变了 Git 历史, 远程分支不会接受变化(changes)，除非强推(force push)。这就是许多人使用 merge 工作流, 而不是 rebasing 工作流的主要原因之一， 开发者的强推(force push)会使大的团队陷入麻烦。使用时需要注意，一种安全使用 rebase 的方法是，不要把你的变化(changes)反映到远程分支上, 而是按下面的做:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git checkout my-branch</span><br><span class="line">(my-branch)$ git rebase -i master</span><br><span class="line">(my-branch)$ git checkout master</span><br><span class="line">(master)$ git merge --ff-only my-branch</span><br></pre></td></tr></table></figure>
<p>更多, 参见 <a href="http://stackoverflow.com/questions/11058312/how-can-i-use-git-rebase-without-requiring-a-forced-push" target="_blank" rel="noopener">this SO thread</a>.</p>
<h4 id="我需要组合combine几个提交commit"><a class="markdownIt-Anchor" href="#我需要组合combine几个提交commit"></a> 我需要组合(combine)几个提交(commit)</h4>
<p>假设你的工作分支将会做对于 <code>master</code> 的 pull-request。 一般情况下你不关心提交(commit)的时间戳，只想组合 <em>所有</em> 提交(commit) 到一个单独的里面, 然后重置(reset)重提交(recommit)。 确保主(master)分支是最新的和你的变化都已经提交了, 然后:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(my-branch)$ git reset --soft master</span><br><span class="line">(my-branch)$ git commit -am <span class="string">"New awesome feature"</span></span><br></pre></td></tr></table></figure>
<p>如果你想要更多的控制, 想要保留时间戳, 你需要做交互式 rebase (interactive rebase):</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(my-branch)$ git rebase -i master</span><br></pre></td></tr></table></figure>
<p>如果没有相对的其它分支， 你将不得不相对自己的<code>HEAD</code> 进行 rebase。 例如：你想组合最近的两次提交(commit), 你将相对于<code>HEAD\~2</code> 进行 rebase， 组合最近 3 次提交(commit), 相对于<code>HEAD\~3</code>, 等等。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git rebase -i HEAD~2</span><br></pre></td></tr></table></figure>
<p>在你执行了交互式 rebase 的命令(interactive rebase command)后, 你将在你的编辑器里看到类似下面的内容:</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">pick a9c8a1d Some refactoring</span><br><span class="line">pick <span class="number">01</span>b2fd8 New awesome feature</span><br><span class="line">pick b729ad5 fixup</span><br><span class="line">pick e3851e8 another <span class="keyword">fix</span></span><br><span class="line"></span><br><span class="line">## Rebase <span class="number">8074</span>d12..b729ad5 onto <span class="number">8074</span>d12</span><br><span class="line">#</span><br><span class="line">## Command<span class="variable">s:</span></span><br><span class="line">##  <span class="keyword">p</span>, pick = use commit</span><br><span class="line">##  r, reword = use commit, but <span class="keyword">edit</span> the commit message</span><br><span class="line">##  <span class="keyword">e</span>, <span class="keyword">edit</span> = use commit, but <span class="keyword">stop</span> <span class="keyword">for</span> amending</span><br><span class="line">##  s, squash = use commit, but meld into <span class="keyword">previous</span> commit</span><br><span class="line">##  <span class="keyword">f</span>, fixup = like <span class="string">"squash"</span>, but discard this commit<span class="string">'s log message</span></span><br><span class="line"><span class="string">##  x, exec = run command (the rest of the line) using shell</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string">## These lines can be re-ordered; they are executed from top to bottom.</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string">## If you remove a line here THAT COMMIT WILL BE LOST.</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string">## However, if you remove everything, the rebase will be aborted.</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string">## Note that empty commits are commented out</span></span><br></pre></td></tr></table></figure>
<p>所有以 <code>#</code> 开头的行都是注释, 不会影响 rebase.</p>
<p>然后，你可以用任何上面命令列表的命令替换 <code>pick</code>, 你也可以通过删除对应的行来删除一个提交(commit)。</p>
<p>例如, 如果你想 <strong>单独保留最旧(first)的提交(commit),组合所有剩下的到第二个里面</strong>, 你就应该编辑第二个提交(commit)后面的每个提交(commit) 前的单词为 <code>f</code>:</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">pick a9c8a1d Some refactoring</span><br><span class="line">pick <span class="number">01</span>b2fd8 New awesome feature</span><br><span class="line"><span class="keyword">f</span> b729ad5 fixup</span><br><span class="line"><span class="keyword">f</span> e3851e8 another <span class="keyword">fix</span></span><br></pre></td></tr></table></figure>
<p>如果你想组合这些提交(commit) <strong>并重命名这个提交(commit)</strong>, 你应该在第二个提交(commit)旁边添加一个<code>r</code>，或者更简单的用<code>s</code> 替代 <code>f</code>:</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">pick a9c8a1d Some refactoring</span><br><span class="line">pick <span class="number">01</span>b2fd8 New awesome feature</span><br><span class="line">s b729ad5 fixup</span><br><span class="line">s e3851e8 another <span class="keyword">fix</span></span><br></pre></td></tr></table></figure>
<p>你可以在接下来弹出的文本提示框里重命名提交(commit)。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Newer, awesomer features</span><br><span class="line"></span><br><span class="line">## Please enter the commit message <span class="keyword">for</span> your <span class="keyword">changes</span>. Lines starting</span><br><span class="line">## with <span class="string">'#'</span> will <span class="keyword">be</span> ignored, <span class="built_in">and</span> <span class="keyword">an</span> <span class="built_in">empty</span> message aborts the commit.</span><br><span class="line">## rebase in progress; onto 8074d12</span><br><span class="line">## You are currently editing <span class="keyword">a</span> commit <span class="keyword">while</span> rebasing branch <span class="string">'master'</span> <span class="keyword">on</span> <span class="string">'8074d12'</span>.</span><br><span class="line">#</span><br><span class="line">## Changes <span class="keyword">to</span> <span class="keyword">be</span> committed:</span><br><span class="line">#	modified:   README.md</span><br><span class="line">#</span><br></pre></td></tr></table></figure>
<p>如果成功了, 你应该看到类似下面的内容:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ Successfully rebased and updated refs/heads/master.</span><br></pre></td></tr></table></figure>
<h5 id="安全合并merging策略"><a class="markdownIt-Anchor" href="#安全合并merging策略"></a> 安全合并(merging)策略</h5>
<p><code>--no-commit</code> 执行合并(merge)但不自动提交, 给用户在做提交前检查和修改的机会。 <code>no-ff</code> 会为特性分支(feature branch)的存在过留下证据, 保持项目历史一致。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git merge --no-ff --no-commit my-branch</span><br></pre></td></tr></table></figure>
<h5 id="我需要将一个分支合并成一个提交commit"><a class="markdownIt-Anchor" href="#我需要将一个分支合并成一个提交commit"></a> 我需要将一个分支合并成一个提交(commit)</h5>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git merge --squash my-branch</span><br></pre></td></tr></table></figure>
<h5 id="我只想组合combine未推的提交unpushed-commit"><a class="markdownIt-Anchor" href="#我只想组合combine未推的提交unpushed-commit"></a> 我只想组合(combine)未推的提交(unpushed commit)</h5>
<p>有时候，在将数据推向上游之前，你有几个正在进行的工作提交(commit)。这时候不希望把已经推(push)过的组合进来，因为其他人可能已经有提交(commit)引用它们了。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git rebase -i @&#123;u&#125;</span><br></pre></td></tr></table></figure>
<p>这会产生一次交互式的 rebase(interactive rebase), 只会列出没有推(push)的提交(commit)， 在这个列表时进行 reorder/fix/squash 都是安全的。</p>
<h4 id="检查是否分支上的所有提交commit都合并merge过了"><a class="markdownIt-Anchor" href="#检查是否分支上的所有提交commit都合并merge过了"></a> 检查是否分支上的所有提交(commit)都合并(merge)过了</h4>
<p>检查一个分支上的所有提交(commit)是否都已经合并(merge)到了其它分支, 你应该在这些分支的 head(或任何 commits)之间做一次 diff:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git <span class="built_in">log</span> --graph --left-right --cherry-pick --oneline HEAD...feature/120-on-scroll</span><br></pre></td></tr></table></figure>
<p>这会告诉你在一个分支里有而另一个分支没有的所有提交(commit), 和分支之间不共享的提交(commit)的列表。 另一个做法可以是:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git <span class="built_in">log</span> master ^feature/120-on-scroll --no-merges</span><br></pre></td></tr></table></figure>
<h4 id="交互式-rebaseinteractive-rebase可能出现的问题"><a class="markdownIt-Anchor" href="#交互式-rebaseinteractive-rebase可能出现的问题"></a> 交互式 rebase(interactive rebase)可能出现的问题</h4>
<h5 id="这个-rebase-编辑屏幕出现noop"><a class="markdownIt-Anchor" href="#这个-rebase-编辑屏幕出现noop"></a> 这个 rebase 编辑屏幕出现’noop’</h5>
<p>如果你看到的是这样:</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">noop</span></span><br></pre></td></tr></table></figure>
<p>这意味着你 rebase 的分支和当前分支在同一个提交(commit)上, 或者 <em>领先(ahead)</em> 当前分支。 你可以尝试:</p>
<ul>
<li>检查确保主(master)分支没有问题</li>
<li>rebase <code>HEAD\~2</code> 或者更早</li>
</ul>
<h5 id="有冲突的情况"><a class="markdownIt-Anchor" href="#有冲突的情况"></a> 有冲突的情况</h5>
<p>如果你不能成功的完成 rebase, 你可能必须要解决冲突。</p>
<p>首先执行 <code>git status</code> 找出哪些文件有冲突:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(my-branch)$ git status</span><br><span class="line">On branch my-branch</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">	modified:   README.md</span><br></pre></td></tr></table></figure>
<p>在这个例子里面, <code>README.md</code> 有冲突。 打开这个文件找到类似下面的内容:</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">some code</span><br><span class="line">=========</span><br><span class="line">some code</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; <span class="keyword">new</span>-commit</span><br></pre></td></tr></table></figure>
<p>你需要解决新提交的代码(示例里, 从中间<code>==</code>线到<code>new-commit</code>的地方)与<code>HEAD</code> 之间不一样的地方.</p>
<p>有时候这些合并非常复杂，你应该使用可视化的差异编辑器(visual diff editor):</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master*)$ git mergetool -t opendiff</span><br></pre></td></tr></table></figure>
<p>在你解决完所有冲突和测试过后, <code>git add</code> 变化了的(changed)文件, 然后用<code>git rebase --continue</code> 继续 rebase。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(my-branch)$ git add README.md</span><br><span class="line">(my-branch)$ git rebase --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure>
<p>如果在解决完所有的冲突过后，得到了与提交前一样的结果, 可以执行<code>git rebase --skip</code>。</p>
<p>任何时候你想结束整个 rebase 过程，回来 rebase 前的分支状态, 你可以做:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(my-branch)$ git rebase --abort</span><br></pre></td></tr></table></figure>
<h3 id="杂项miscellaneous-objects"><a class="markdownIt-Anchor" href="#杂项miscellaneous-objects"></a> 杂项(Miscellaneous Objects)</h3>
<h4 id="克隆所有子模块"><a class="markdownIt-Anchor" href="#克隆所有子模块"></a> 克隆所有子模块</h4>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> --recursive git://github.com/foo/bar.git</span><br></pre></td></tr></table></figure>
<p>如果已经克隆了:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git submodule update --init --recursive</span><br></pre></td></tr></table></figure>
<h4 id="删除标签tag"><a class="markdownIt-Anchor" href="#删除标签tag"></a> 删除标签(tag)</h4>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git tag -d &lt;tag_name&gt;</span><br><span class="line">$ git push &lt;remote&gt; :refs/tags/&lt;tag_name&gt;</span><br></pre></td></tr></table></figure>
<h4 id="恢复已删除标签tag"><a class="markdownIt-Anchor" href="#恢复已删除标签tag"></a> 恢复已删除标签(tag)</h4>
<p>如果你想恢复一个已删除标签(tag), 可以按照下面的步骤: 首先, 需要找到无法访问的标签(unreachable tag):</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git fsck --unreachable | grep tag</span><br></pre></td></tr></table></figure>
<p>记下这个标签(tag)的 hash，然后用 Git 的 <a href="http://git-scm.com/docs/git-update-ref" target="_blank" rel="noopener">update-ref</a>:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git update-ref refs/tags/&lt;tag_name&gt; &lt;<span class="built_in">hash</span>&gt;</span><br></pre></td></tr></table></figure>
<p>这时你的标签(tag)应该已经恢复了。</p>
<h4 id="已删除补丁patch"><a class="markdownIt-Anchor" href="#已删除补丁patch"></a> 已删除补丁(patch)</h4>
<p>如果某人在 GitHub 上给你发了一个 pull request, 但是然后他删除了他自己的原始 fork, 你将没法克隆他们的提交(commit)或使用 <code>git am</code>。在这种情况下, 最好手动的查看他们的提交(commit)，并把它们拷贝到一个本地新分支，然后做提交。</p>
<p>做完提交后, 再修改作者，参见<a href="#commit-wrong-author">变更作者</a>。 然后, 应用变化, 再发起一个新的 pull request。</p>
<h3 id="跟踪文件tracking-files"><a class="markdownIt-Anchor" href="#跟踪文件tracking-files"></a> 跟踪文件(Tracking Files)</h3>
<h4 id="我只想改变一个文件名字的大小写而不修改内容"><a class="markdownIt-Anchor" href="#我只想改变一个文件名字的大小写而不修改内容"></a> 我只想改变一个文件名字的大小写，而不修改内容</h4>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git mv --force myfile MyFile</span><br></pre></td></tr></table></figure>
<h4 id="我想从-git-删除一个文件但保留该文件"><a class="markdownIt-Anchor" href="#我想从-git-删除一个文件但保留该文件"></a> 我想从 Git 删除一个文件，但保留该文件</h4>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git rm --cached log.txt</span><br></pre></td></tr></table></figure>
<h3 id="配置configuration"><a class="markdownIt-Anchor" href="#配置configuration"></a> 配置(Configuration)</h3>
<h4 id="我想给一些-git-命令添加别名alias"><a class="markdownIt-Anchor" href="#我想给一些-git-命令添加别名alias"></a> 我想给一些 Git 命令添加别名(alias)</h4>
<p>在 OS X 和 Linux 下, 你的 Git 的配置文件储存在 <code>\~/.gitconfig</code>。我在<code>[alias]</code> 部分添加了一些快捷别名(和一些我容易拼写错误的)，如下:</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">[alias]</span><br><span class="line">    <span class="keyword">a</span> = <span class="built_in">add</span></span><br><span class="line">    amend = commit --amend</span><br><span class="line">    <span class="keyword">c</span> = commit</span><br><span class="line">    <span class="keyword">ca</span> = commit --amend</span><br><span class="line">    ci = commit -<span class="keyword">a</span></span><br><span class="line">    <span class="keyword">co</span> = checkout</span><br><span class="line">    d = diff</span><br><span class="line">    dc = diff --changed</span><br><span class="line">    <span class="keyword">ds</span> = diff --staged</span><br><span class="line">    <span class="keyword">f</span> = fetch</span><br><span class="line">    loll = <span class="built_in">log</span> --graph --decorate --pretty=oneline --abbrev-commit</span><br><span class="line">    <span class="keyword">m</span> = merge</span><br><span class="line">    one = <span class="built_in">log</span> --pretty=oneline</span><br><span class="line">    outstanding = rebase -i @&#123;<span class="keyword">u</span>&#125;</span><br><span class="line">    s = status</span><br><span class="line">    unpushed = <span class="built_in">log</span> @&#123;<span class="keyword">u</span>&#125;</span><br><span class="line">    wc = whatchanged</span><br><span class="line">    wip = rebase -i @&#123;<span class="keyword">u</span>&#125;</span><br><span class="line">    zap = fetch -<span class="keyword">p</span></span><br></pre></td></tr></table></figure>
<h4 id="我想缓存一个仓库repository的用户名和密码"><a class="markdownIt-Anchor" href="#我想缓存一个仓库repository的用户名和密码"></a> 我想缓存一个仓库(repository)的用户名和密码</h4>
<p>你可能有一个仓库需要授权，这时你可以缓存用户名和密码，而不用每次推/拉(push/pull)的时候都输入，Credential helper 能帮你。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git config --global credential.helper cache</span><br><span class="line"><span class="comment">## Set git to use the credential memory cache</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git config --global credential.helper <span class="string">'cache --timeout=3600'</span></span><br><span class="line"><span class="comment">## Set the cache to timeout after 1 hour (setting is in seconds)</span></span><br></pre></td></tr></table></figure>
<h3 id="我不知道我做错了些什么"><a class="markdownIt-Anchor" href="#我不知道我做错了些什么"></a> 我不知道我做错了些什么</h3>
<p>你把事情搞砸了：你 <code>重置(reset)</code> 了一些东西, 或者你合并了错误的分支, 亦或你强推了后找不到你自己的提交(commit)了。有些时候, 你一直都做得很好, 但你想回到以前的某个状态。</p>
<p>这就是 <code>git reflog</code> 的目的， <code>reflog</code> 记录对分支顶端(the tip of a branch)的任何改变, 即使那个顶端没有被任何分支或标签引用。基本上, 每次 HEAD 的改变, 一条新的记录就会增加到<code>reflog</code>。遗憾的是，这只对本地分支起作用，且它只跟踪动作 (例如，不会跟踪一个没有被记录的文件的任何改变)。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git reflog</span><br><span class="line">0a2e358 HEAD@&#123;0&#125;: reset: moving to HEAD\~2</span><br><span class="line">0254ea7 HEAD@&#123;1&#125;: checkout: moving from 2.2 to master</span><br><span class="line">c10f740 HEAD@&#123;2&#125;: checkout: moving from master to 2.2</span><br></pre></td></tr></table></figure>
<p>上面的 reflog 展示了从 master 分支签出(checkout)到 2.2 分支，然后再签回。 那里，还有一个硬重置(hard reset)到一个较旧的提交。最新的动作出现在最上面以 <code>HEAD@{0}</code>标识.</p>
<p>如果事实证明你不小心回移(move back)了提交(commit), reflog 会包含你不小心回移前 master 上指向的提交(0254ea7)。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git reset --hard 0254ea7</span><br></pre></td></tr></table></figure>
<p>然后使用 git reset 就可以把 master 改回到之前的 commit，这提供了一个在历史被意外更改情况下的安全网。</p>
<h2 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h2>
<p>最后，放一张我总结的脑图总结一下以上的知识点。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/web/git/git-summary.png"/></div>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li>官方资源
<ul>
<li><a href="https://git-scm.com/" target="_blank" rel="noopener">Git 官网</a></li>
<li><a href="https://github.com/git/git" target="_blank" rel="noopener">Git Github</a></li>
</ul>
</li>
<li>模板
<ul>
<li><a href="https://github.com/github/gitignore" target="_blank" rel="noopener">gitignore 模板</a> - .gitignore 文件模板</li>
<li><a href="https://github.com/alexkaratarakis/gitattributes" target="_blank" rel="noopener">gitattributes 模板</a> - .gitattributes 文件模板</li>
<li><a href="https://github.com/tiimgreen/github-cheat-sheet" target="_blank" rel="noopener">github-cheat-sheet</a> - git 命令简略图表</li>
</ul>
</li>
<li>Git 书
<ul>
<li><a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">Git 官方推荐教程</a> - Scott Chacon 的 Git 书。</li>
</ul>
</li>
<li>Git 教程
<ul>
<li><a href="https://github.com/geeeeeeeeek/git-recipes" target="_blank" rel="noopener">Git 中文教程</a></li>
<li><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰的 Git 教程</a></li>
<li><a href="https://github.com/xirong/my-git" target="_blank" rel="noopener">有关 git 的学习资源</a></li>
</ul>
</li>
<li>文章
<ul>
<li><a href="https://github.com/k88hudson/git-flight-rules/blob/master/README_zh-CN.md" target="_blank" rel="noopener">Git Cookbook</a></li>
<li><a href="https://github.com/521xueweihan/git-tips" target="_blank" rel="noopener">Git 奇技淫巧</a></li>
<li><a href="https://github.com/aseaday/git-style-guide" target="_blank" rel="noopener">Git 风格指南</a></li>
<li><a href="http://www.cnblogs.com/cnblogsfans/p/5075073.html" target="_blank" rel="noopener">Git 在团队中的最佳实践–如何正确使用 Git Flow</a></li>
</ul>
</li>
<li>Git 工具
<ul>
<li><a href="https://git-scm.com/downloads/guis" target="_blank" rel="noopener">guis</a> - Git 官网展示的客户端工具列表。</li>
<li><a href="https://github.com/gogits/gogs" target="_blank" rel="noopener">gogs</a> - 极易搭建的自助 Git 服务。</li>
<li><a href="https://github.com/nvie/gitflow" target="_blank" rel="noopener">gitflow</a> - 应用 <a href="http://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener">fit-flow</a> 模型的工具。</li>
<li><a href="http://firstaidgit.io/" target="_blank" rel="noopener">firstaidgit.io</a> 一个可搜索的最常被问到的 Git 的问题</li>
<li><a href="https://github.com/unixorn/git-extra-commands" target="_blank" rel="noopener">git-extra-commands</a> - 一堆有用的额外的 Git 脚本</li>
<li><a href="https://github.com/tj/git-extras" target="_blank" rel="noopener">git-extras</a> - GIT 工具集 – repo summary, repl, changelog population, author commit percentages and more</li>
<li><a href="https://github.com/qw3rtman/git-fire" target="_blank" rel="noopener">git-fire</a> - git-fire 是一个 Git 插件，用于帮助在紧急情况下添加所有当前文件, 做提交(committing), 和推(push)到一个新分支(阻止合并冲突)。</li>
<li><a href="https://github.com/git-tips/tips" target="_blank" rel="noopener">git-tips</a> - Git 小提示</li>
<li><a href="https://github.com/Originate/git-town" target="_blank" rel="noopener">git-town</a> - 通用，高级 Git 工作流支持！ <a href="http://www.git-town.com" target="_blank" rel="noopener">http://www.git-town.com</a></li>
</ul>
</li>
<li>GUI 客户端(GUI Clients)
<ul>
<li><a href="https://www.gitkraken.com/" target="_blank" rel="noopener">GitKraken</a> - 豪华的 Git 客户端 Windows, Mac &amp; Linux</li>
<li><a href="https://git-cola.github.io/" target="_blank" rel="noopener">git-cola</a> - 另外一个 Git 客户端 Windows &amp; OS X</li>
<li><a href="https://github.com/git-up/GitUp" target="_blank" rel="noopener">GitUp</a> - 一个新的 Git 客户端，在处理 Git 的复杂性上有自己的特点</li>
<li><a href="https://rowanj.github.io/gitx/" target="_blank" rel="noopener">gitx-dev</a> - 图形化的 Git 客户端 OS X</li>
<li><a href="https://www.sourcetreeapp.com/" target="_blank" rel="noopener">Source Tree</a> - 免费的图形化 Git 客户端 Windows &amp; OS X</li>
<li><a href="http://www.git-tower.com/" target="_blank" rel="noopener">Tower</a> - 图形化 Git 客户端 OS X(付费)</li>
</ul>
</li>
<li>git cheat sheet
<ul>
<li><a href="https://services.github.com/on-demand/downloads/github-git-cheat-sheet.pdf" target="_blank" rel="noopener">github-git-cheat-sheet</a></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title>软件工程与项目管理</title>
    <url>/blog/efficiency/software-engineering/</url>
    <content><![CDATA[<blockquote>
<p>📓 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p>
<p>软件工程是一门研究用工程化方法构建和维护有效的、实用的和高质量的软件的学科。它涉及程序设计语言、数据库、软件开发工具、系统平台、标准、设计模式等方面。</p>
</blockquote>
<h2 id="软件工程的目标"><a class="markdownIt-Anchor" href="#软件工程的目标"></a> 软件工程的目标</h2>
<p>软件工程的目标是：在给定成本、进度的前提下，开发出具有适用性、有效性、可修改性、可靠性、可理解性、可维护性、可重用性、可移植性、可追踪性、可互操作性和满足用户需求的软件产品。</p>
<ol>
<li><strong>适用性</strong> - 软件在不同的系统约束条件下，使用户需求得到满足的难易程度。</li>
<li><strong>有效性</strong> - 软件系统能最有效的利用计算机的时间和空间资源。各种软件无不把系统的时/空开销作为衡量软件质量的一项重要技术指标。很多场合，在追求时间有效性和空间有效性时会发生矛盾，这时不得不牺牲时间有效性换取空间有效性或牺牲空间有效性换取时间有效性。时/空折衷是经常采用的技巧。</li>
<li><strong>可修改性</strong> - 允许对系统进行修改而不增加原系统的复杂性。它支持软件的调试和维护，是一个难以达到的目标。</li>
<li><strong>可靠性</strong> - 能防止因概念、设计和结构等方面的不完善造成的软件系统失效，具有挽回因操作不当造成软件系统失效的能力。</li>
<li><strong>可理解性</strong> - 系统具有清晰的结构，能直接反映问题的需求。可理解性有助于控制系统软件复杂性，并支持软件的维护、移植或重用。</li>
<li><strong>可维护性</strong> - 软件交付使用后，能够对它进行修改，以改正潜伏的错误，改进性能和其它属性，使软件产品适应环境的变化等。软件维护费用在软件开发费用中占有很大的比重。可维护性是软件工程中一项十分重要的目标。</li>
<li><strong>可重用性</strong> - 把概念或功能相对独立的一个或一组相关模块定义为一个软部件。可组装在系统的任何位置，降低工作量。</li>
<li><strong>可移植性</strong> - 软件从一个计算机系统或环境搬到另一个计算机系统或环境的难易程度。</li>
<li><strong>可追踪性</strong> - 根据软件需求对软件设计、程序进行正向追踪，或根据软件设计、程序对软件需求的逆向追踪的能力。</li>
<li><strong>可互操作性</strong> - 多个软件元素相互通信并协同完成任务的能力。</li>
</ol>
<h2 id="软件工程的原理"><a class="markdownIt-Anchor" href="#软件工程的原理"></a> 软件工程的原理</h2>
<p>软件工程的七条基本原理：</p>
<ol>
<li>用分阶段的生存周期计划进行严格的管理。</li>
<li>坚持进行阶段评审。</li>
<li>实行严格的产品控制。</li>
<li>采用现代程序设计技术。</li>
<li>软件工程结果应能清楚地审查。</li>
<li>开发小组的人员应该少而精。</li>
<li>承认不断改进软件工程实践的必要性。</li>
</ol>
<h2 id="软件工程的方法"><a class="markdownIt-Anchor" href="#软件工程的方法"></a> 软件工程的方法</h2>
<p>著名的重量级开发方法：</p>
<ul>
<li><a href="https://zh.wikipedia.org/zh-cn/ISO_9000" target="_blank" rel="noopener">ISO9000</a> - ISO 9000 系列标准是国际标准化组织设立的标准，与品质管理系统有关。</li>
<li><a href="https://zh.wikipedia.org/wiki/%E8%83%BD%E5%8A%9B%E6%88%90%E7%86%9F%E5%BA%A6%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener">能力成熟度模型（CMM）</a> - CMM 涵盖一个成熟的软件发展组织所应具备的重要功能与项目，它描述了软件发展的演进过程，从毫无章法、不成熟的软件开发阶段到成熟软件开发阶段的过程。</li>
<li><a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B" target="_blank" rel="noopener">统一软件开发过程（RUP）</a> - RUP 是一种软件工程方法，为迭代式软件开发流程。</li>
</ul>
<p>著名的轻量级开发方法：</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E6%95%8F%E6%8D%B7%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91" target="_blank" rel="noopener">敏捷开发（Agile Development）</a> - 是一种应对快速变化的需求的一种软件开发能力。它们的具体名称、理念、过程、术语都不尽相同，相对于“非敏捷”，更强调程序员团队与业务专家之间的紧密协作、面对面的沟通（认为比书面的文档更有效）、频繁交付新的软件版本、紧凑而自我组织型的团队、能够很好地适应需求变化的代码编写和团队组织方法，也更注重软件开发过程中人的作用。</li>
<li><a href="https://zh.wikipedia.org/wiki/%E6%9E%81%E9%99%90%E7%BC%96%E7%A8%8B" target="_blank" rel="noopener">极限编程（XP）</a> - 极限编程是敏捷软件开发中最有成效的方法学之一。极限编程技术以沟通（Communication）、简单（Simplicity）、反馈（Feedback）、勇气（Courage）和尊重（Respect）为价值标准。</li>
</ul>
<h2 id="软件需求"><a class="markdownIt-Anchor" href="#软件需求"></a> 软件需求</h2>
<p>软件需求包括三个不同的层次：业务需求、用户需求和功能需求。</p>
<ul>
<li>
<p>**业务需求（Business requirement）**表示组织或客户高层次的目标。业务需求通常来自项目投资人、购买产品的客户、实际用户的管理者、市场营销部门或产品策划部门。业务需求描述了组织为什么要开发一个系统，即组织希望达到的目标。使用前景和范围（ vision and scope ）文档来记录业务需求，这份文档有时也被称作项目轮廓图或市场需求（ project charter 或 market requirement ）文档。</p>
</li>
<li>
<p>**用户需求（user requirement）**描述的是用户的目标，或用户要求系统必须能完成的任务。用例、场景描述和事件――响应表都是表达用户需求的有效途径。也就是说用户需求描述了用户能使用系统来做些什么。</p>
</li>
<li>
<p>**功能需求（functional requirement）**规定开发人员必须在产品中实现的软件功能，用户利用这些功能来完成任务，满足业务需求。功能需求有时也被称作行为需求（ behavioral requirement ），因为习惯上总是用“应该”对其进行描述：“系统应该发送电子邮件来通知用户已接受其预定”。功能需求描述是开发人员需要实现什么。</p>
</li>
<li>
<p>**系统需求（system requirement）**用于描述包含多个子系统的产品（即系统）的顶级需求。系统可以只包含软件系统，也可以既包含软件又包含硬件子系统。人也可以是系统的一部分，因此某些系统功能可能要由人来承担。</p>
</li>
</ul>
<h3 id="软件需求说明书-srs"><a class="markdownIt-Anchor" href="#软件需求说明书-srs"></a> 软件需求说明书（ SRS ）</h3>
<p>软件需求说明书（ SRS ）完整地描述了软件系统的预期特性。开发、测试、质量保证、项目管理和其他相关的项目功能都要用到 SRS 。</p>
<p>除了功能需求外， SRS 中还包含非功能需求，包括性能指标和对质量属性的描述。</p>
<ul>
<li>**质量属性（quality attribute）**对产品的功能描述作了补充，它从不同方面描述了产品的各种特性。这些特性包括可用性、可移植性、完整性、效率和健壮性，它们对用户或开发人员都很重要。其他的非功能需求包括系统与外部世界的外部界面，以及对设计与实现的约束。</li>
<li>**约束（constraint）**限制了开发人员设计和构建系统时的选择范围。</li>
</ul>
<h2 id="软件生命周期"><a class="markdownIt-Anchor" href="#软件生命周期"></a> 软件生命周期</h2>
<blockquote>
<p><strong>软件生命周期（Software Life Cycle,SLC）是软件的产生直到报废或停止使用的生命周期。</strong></p>
</blockquote>
<ul>
<li>问题定义 - 要求系统分析员与用户进行交流，弄清“用户需要计算机解决什么问题”然后提出关于“系统目标与范围的说明”，提交用户审查和确认。</li>
<li>可行性研究 - 一方面在于把待开发的系统的目标以明确的语言描述出来；另一方面从经济、技术、法律等多方面进行可行性分析。</li>
<li>需求分析 - 弄清用户对软件系统的全部需求，编写需求规格说明书和初步的用户手册，提交评审。</li>
<li>开发阶段
<ul>
<li>概要设计</li>
<li>详细设计</li>
<li>编码实现</li>
<li>软件测试 - 测试的过程分单元测试、组装测试以及系统测试三个阶段进行。测试的方法主要有白盒测试和黑盒测试两种。</li>
</ul>
</li>
<li>维护</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/software-engineering/软件生命周期.gif"/></div>
<h2 id="软件生命周期模型"><a class="markdownIt-Anchor" href="#软件生命周期模型"></a> 软件生命周期模型</h2>
<h3 id="瀑布模型"><a class="markdownIt-Anchor" href="#瀑布模型"></a> 瀑布模型</h3>
<blockquote>
<p>瀑布模型（Waterfall Model）强调系统开发应有完整的周期，且必须完整的经历周期的每一开发阶段，并系统化的考量分析与设计的技术、时间与资源之投入等。</p>
</blockquote>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/software-engineering/瀑布模型.jpg"/></div>
<h4 id="核心思想"><a class="markdownIt-Anchor" href="#核心思想"></a> 核心思想</h4>
<p>瀑布模型核心思想是按工序将问题拆分，将功能的实现与设计分开，便于分工协作，即采用结构化的分析与设计方法将逻辑实现与物理实现分开。将软件生命周期划分为制定计划、需求分析、软件设计、程序编写、软件测试和运行维护等六个基本活动，并且规定了它们自上而下、相互衔接的固定次序，如同瀑布流水，逐级下落。</p>
<h4 id="优缺点"><a class="markdownIt-Anchor" href="#优缺点"></a> 优缺点</h4>
<p><strong>优点</strong></p>
<ul>
<li>为项目提供了按阶段划分的检查点。</li>
<li>当前一阶段完成后，您只需要去关注后续阶段。</li>
<li>可在迭代模型中应用瀑布模型。</li>
<li>它提供了一个模板，这个模板使得分析、设计、编码、测试和支持的方法可以在该模板下有一个共同的指导。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>各个阶段的划分完全固定，阶段之间产生大量的文档，极大地增加了工作量。</li>
<li>由于开发模型是线性的，用户只有等到整个过程的末期才能见到开发成果，从而增加了开发风险。</li>
<li>通过过多的强制完成日期和里程碑来跟踪各个项目阶段。</li>
<li>瀑布模型的突出缺点是不适应用户需求的变化。</li>
</ul>
<p><strong>适用场景</strong></p>
<p>是否使用这一模型主要取决于是否能理解客户的需求以及在项目的进程中这些需求的变化程度。对于需求经常变化的项目，不要适用瀑布模型。</p>
<h3 id="螺旋模型"><a class="markdownIt-Anchor" href="#螺旋模型"></a> 螺旋模型</h3>
<blockquote>
<p>螺旋模型基本做法是在“瀑布模型”的每一个开发阶段前引入一个非常严格的风险识别、风险分析和风险控制，它把软件项目分解成一个个小项目。每个小项目都标识一个或多个主要风险，直到所有的主要风险因素都被确定。</p>
</blockquote>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/software-engineering/螺旋模型.png"/></div>
<h4 id="核心思想-2"><a class="markdownIt-Anchor" href="#核心思想-2"></a> 核心思想</h4>
<p>螺旋模型沿着螺线进行若干次迭代，图中的四个象限代表了以下活动：</p>
<ol>
<li>制定计划 - 确定软件目标，选定实施方案，弄清项目开发的限制条件；</li>
<li>风险分析 - 分析评估所选方案，考虑如何识别和消除风险；</li>
<li>实施工程 - 实施软件开发和验证；</li>
<li>客户评估 - 评价开发工作，提出修正建议，制定下一步计划。</li>
</ol>
<p>螺旋模型由风险驱动，强调可选方案和约束条件从而支持软件的重用，有助于将软件质量作为特殊目标融入产品开发之中。</p>
<h4 id="优缺点-2"><a class="markdownIt-Anchor" href="#优缺点-2"></a> 优缺点</h4>
<p><strong>优点</strong></p>
<ul>
<li>设计上的灵活性,可以在项目的各个阶段进行变更。</li>
<li>以小的分段来构建大型系统,使成本计算变得简单容易。</li>
<li>客户始终参与每个阶段的开发,保证了项目不偏离正确方向以及项目的可控性。</li>
<li>随着项目推进,客户始终掌握项目的最新信息, 从而他或她能够和管理层有效地交互。</li>
<li>客户认可这种公司内部的开发方式带来的良好的沟通和高质量的产品。</li>
</ul>
<p><strong>缺点</strong></p>
<p>很难让用户确信这种演化方法的结果是可以控制的。建设周期长，而软件技术发展比较快，所以经常出现软件开发完毕后，和当前的技术水平有了较大的差距，无法满足当前用户需求。</p>
<p><strong>适用场景</strong></p>
<p>对于新项目，需求不明确的情况下，适合用螺旋模型进行开发，便于风险控制和需求变更。</p>
<h2 id="软件工程术语"><a class="markdownIt-Anchor" href="#软件工程术语"></a> 软件工程术语</h2>
<ul>
<li><strong>里程碑（Milestone）</strong> - 在制定项目进度计划时，在进度时间表上设立一些重要的时间检查点，这样一来，就可以在项目执行过程中利用这些重要的时间检查点来对项目的进程进行检查和控制。这些重要的时间检查点被称作项目的里程碑。</li>
<li><strong>人月</strong> - 软件开发的工作量单位。如 200 人月，10 个人开发，那算来就是花 20 个月就可完工。</li>
<li><strong>基线</strong> - 基线是项目储存库中每个工件版本在特定时期的一个“快照”。它提供一个正式标准，随后的工作基于此标准，并且只有经过授权后才能变更这个标准。建立一个初始基线后，以后每次对其进行的变更都将记录为一个差值，直到建成下一个基线。</li>
</ul>
<h2 id="资源"><a class="markdownIt-Anchor" href="#资源"></a> 资源</h2>
<ul>
<li><strong>书籍</strong>
<ul>
<li><a href="https://book.douban.com/subject/2230248/" target="_blank" rel="noopener">人月神话</a></li>
<li><a href="https://book.douban.com/subject/1477390/" target="_blank" rel="noopener">代码大全</a></li>
</ul>
</li>
<li><strong>文章</strong>
<ul>
<li><a href="https://juejin.im/post/5a4991e151882574d23cafbf" target="_blank" rel="noopener">使用甘特图做项目管理</a></li>
<li><a href="https://juejin.im/post/5c1f6a1e6fb9a04a03793573" target="_blank" rel="noopener">使用燃尽图监控项目整体进度</a></li>
</ul>
</li>
<li><strong>工具</strong>
<ul>
<li><a href="https://my.oschina.net/editorial-story/blog/1559395" target="_blank" rel="noopener">10 大开源免费的项目管理软件推荐</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2017/08/issue.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2017/08/issue.html</a></li>
</ul>
</li>
<li><strong>文档模板</strong>
<ul>
<li><a href="https://pan.baidu.com/s/1sXTOs1PSDyw9P2zWtzbsmw" target="_blank" rel="noopener">软件工程文档标准模板百度网盘下载</a> - 下载密码：uu1f</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>效率提升</category>
      </categories>
      <tags>
        <tag>效率提升</tag>
        <tag>软件工程</tag>
        <tag>管理</tag>
      </tags>
  </entry>
  <entry>
    <title>一篇文章让你彻底掌握 Shell</title>
    <url>/blog/coding/shell/</url>
    <content><![CDATA[<blockquote>
<p>由于 bash 是 Linux 标准默认的 shell 解释器，可以说 bash 是 shell 编程的基础。</p>
<p>本文主要介绍 bash 的语法，对于 linux 指令不做任何介绍。</p>
<p>📓 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」<br />
🔁 本文的源码已归档到 <a href="https://github.com/dunwu/linux-tutorial/tree/master/codes/shell/demos" target="_blank" rel="noopener">linux-tutorial</a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">███████╗██╗  ██╗███████╗██╗     ██╗</span><br><span class="line">██╔════╝██║  ██║██╔════╝██║     ██║</span><br><span class="line">███████╗███████║█████╗  ██║     ██║</span><br><span class="line">╚════██║██╔══██║██╔══╝  ██║     ██║</span><br><span class="line">███████║██║  ██║███████╗███████╗███████╗</span><br></pre></td></tr></table></figure>
<h2 id="1-简介"><a class="markdownIt-Anchor" href="#1-简介"></a> 1. 简介</h2>
<h3 id="11-什么是-shell"><a class="markdownIt-Anchor" href="#11-什么是-shell"></a> 1.1. 什么是 shell</h3>
<ul>
<li>Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。</li>
<li>Shell 既是一种命令语言，又是一种程序设计语言。</li>
<li>Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问 Linux 内核的服务。</li>
</ul>
<p>Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。</p>
<h3 id="12-什么是-shell-脚本"><a class="markdownIt-Anchor" href="#12-什么是-shell-脚本"></a> 1.2. 什么是 shell 脚本</h3>
<p>Shell 脚本（shell script），是一种为 shell 编写的脚本程序，一般文件后缀为 <code>.sh</code>。</p>
<p>业界所说的 shell 通常都是指 shell 脚本，但 shell 和 shell script 是两个不同的概念。</p>
<h3 id="13-shell-环境"><a class="markdownIt-Anchor" href="#13-shell-环境"></a> 1.3. Shell 环境</h3>
<p>Shell 编程跟 java、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。</p>
<p>Shell 的解释器种类众多，常见的有：</p>
<ul>
<li><a href="https://www.gnu.org/software/bash/" target="_blank" rel="noopener">sh</a> - 即 Bourne Shell。sh 是 Unix 标准默认的 shell。</li>
<li><a href="https://www.gnu.org/software/bash/" target="_blank" rel="noopener">bash</a> - 即 Bourne Again Shell。bash 是 Linux 标准默认的 shell。</li>
<li><a href="https://fishshell.com/" target="_blank" rel="noopener">fish</a> - 智能和用户友好的命令行 shell。</li>
<li><a href="http://xiki.org/" target="_blank" rel="noopener">xiki</a> - 使 shell 控制台更友好，更强大。</li>
<li><a href="http://www.zsh.org/" target="_blank" rel="noopener">zsh</a> - 功能强大的 shell 与脚本语言。</li>
</ul>
<h4 id="指定脚本解释器"><a class="markdownIt-Anchor" href="#指定脚本解释器"></a> 指定脚本解释器</h4>
<p>在 shell 脚本，<code>#!</code> 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 解释器。<code>#!</code> 被称作<a href="https://zh.wikipedia.org/wiki/Shebang" target="_blank" rel="noopener">shebang（也称为 Hashbang ）</a>。</p>
<p>所以，你应该会在 shell 中，见到诸如以下的注释：</p>
<ul>
<li>指定 sh 解释器</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br></pre></td></tr></table></figure>
<ul>
<li>指定 bash 解释器</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong></p>
<p>上面的指定解释器的方式是比较常见的，但有时候，你可能也会看到下面的方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br></pre></td></tr></table></figure>
<p>这样做的好处是，系统会自动在 <code>PATH</code> 环境变量中查找你指定的程序（本例中的<code>bash</code>）。相比第一种写法，你应该尽量用这种写法，因为程序的路径是不确定的。这样写还有一个好处，操作系统的<code>PATH</code>变量有可能被配置为指向程序的另一个版本。比如，安装完新版本的<code>bash</code>，我们可能将其路径添加到<code>PATH</code>中，来“隐藏”老版本。如果直接用<code>#!/bin/bash</code>，那么系统会选择老版本的<code>bash</code>来执行脚本，如果用<code>#!/usr/bin/env bash</code>，则会使用新版本。</p>
</blockquote>
<h3 id="14-模式"><a class="markdownIt-Anchor" href="#14-模式"></a> 1.4. 模式</h3>
<p>shell 有交互和非交互两种模式。</p>
<h4 id="交互模式"><a class="markdownIt-Anchor" href="#交互模式"></a> 交互模式</h4>
<blockquote>
<p>简单来说，你可以将 shell 的交互模式理解为执行命令行。</p>
</blockquote>
<p>看到形如下面的东西，说明 shell 处于交互模式下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">user@host:~$</span><br></pre></td></tr></table></figure>
<p>接着，便可以输入一系列 Linux 命令，比如 <code>ls</code>，<code>grep</code>，<code>cd</code>，<code>mkdir</code>，<code>rm</code> 等等。</p>
<h4 id="非交互模式"><a class="markdownIt-Anchor" href="#非交互模式"></a> 非交互模式</h4>
<blockquote>
<p>简单来说，你可以将 shell 的非交互模式理解为执行 shell 脚本。</p>
</blockquote>
<p>在非交互模式下，shell 从文件或者管道中读取命令并执行。</p>
<p>当 shell 解释器执行完文件中的最后一个命令，shell 进程终止，并回到父进程。</p>
<p>可以使用下面的命令让 shell 以非交互模式运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sh /path/to/script.sh</span><br><span class="line">bash /path/to/script.sh</span><br><span class="line"><span class="built_in">source</span> /path/to/script.sh</span><br><span class="line">./path/to/script.sh</span><br></pre></td></tr></table></figure>
<p>上面的例子中，<code>script.sh</code>是一个包含 shell 解释器可以识别并执行的命令的普通文本文件，<code>sh</code>和<code>bash</code>是 shell 解释器程序。你可以使用任何喜欢的编辑器创建<code>script.sh</code>（vim，nano，Sublime Text, Atom 等等）。</p>
<p>其中，<code>source /path/to/script.sh</code> 和 <code>./path/to/script.sh</code> 是等价的。</p>
<p>除此之外，你还可以通过<code>chmod</code>命令给文件添加可执行的权限，来直接执行脚本文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod +x /path/to/script.sh <span class="comment">#使脚本具有执行权限</span></span><br><span class="line">/path/to/test.sh</span><br></pre></td></tr></table></figure>
<p>这种方式要求脚本文件的第一行必须指明运行该脚本的程序，比如：</p>
<p><strong>⌨️ 『示例源码』</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Hello, world!"</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中，我们使用了一个很有用的命令<code>echo</code>来输出字符串到屏幕上。</p>
<h2 id="2-基本语法"><a class="markdownIt-Anchor" href="#2-基本语法"></a> 2. 基本语法</h2>
<h3 id="21-解释器"><a class="markdownIt-Anchor" href="#21-解释器"></a> 2.1. 解释器</h3>
<p>前面虽然两次提到了<code>#!</code> ，但是本着重要的事情说三遍的精神，这里再强调一遍：</p>
<p>在 shell 脚本，<code>#!</code> 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 解释器。<code>#!</code> 被称作<a href="https://zh.wikipedia.org/wiki/Shebang" target="_blank" rel="noopener">shebang（也称为 Hashbang ）</a>。</p>
<p><code>#!</code> 决定了脚本可以像一个独立的可执行文件一样执行，而不用在终端之前输入<code>sh</code>, <code>bash</code>, <code>python</code>, <code>php</code>等。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以下两种方式都可以指定 shell 解释器为 bash，第二种方式更好</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br></pre></td></tr></table></figure>
<h3 id="22-注释"><a class="markdownIt-Anchor" href="#22-注释"></a> 2.2. 注释</h3>
<p>注释可以说明你的代码是什么作用，以及为什么这样写。</p>
<p>shell 语法中，注释是特殊的语句，会被 shell 解释器忽略。</p>
<ul>
<li>单行注释 - 以 <code>#</code> 开头，到行尾结束。</li>
<li>多行注释 - 以 <code>:&lt;&lt;EOF</code> 开头，到 <code>EOF</code> 结束。</li>
</ul>
<p><strong>⌨️ 『示例源码』</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#--------------------------------------------</span></span><br><span class="line"><span class="comment"># shell 注释示例</span></span><br><span class="line"><span class="comment"># author：zp</span></span><br><span class="line"><span class="comment">#--------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># echo '这是单行注释'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">########## 这是分割线 ##########</span></span><br><span class="line"></span><br><span class="line">:&lt;&lt;EOF</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'这是多行注释'</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'这是多行注释'</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'这是多行注释'</span></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<h3 id="23-echo"><a class="markdownIt-Anchor" href="#23-echo"></a> 2.3. echo</h3>
<p>echo 用于字符串的输出。</p>
<p>输出普通字符串：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"hello, world"</span></span><br><span class="line"><span class="comment"># Output: hello, world</span></span><br></pre></td></tr></table></figure>
<p>输出含变量的字符串：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"hello, \"zp\""</span></span><br><span class="line"><span class="comment"># Output: hello, "zp"</span></span><br></pre></td></tr></table></figure>
<p>输出含变量的字符串：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">name=zp</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"hello, \"<span class="variable">$&#123;name&#125;</span>\""</span></span><br><span class="line"><span class="comment"># Output: hello, "zp"</span></span><br></pre></td></tr></table></figure>
<p>输出含换行符的字符串：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输出含换行符的字符串</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"YES\nNO"</span></span><br><span class="line"><span class="comment">#  Output: YES\nNO</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"YES\nNO"</span> <span class="comment"># -e 开启转义</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  YES</span></span><br><span class="line"><span class="comment">#  NO</span></span><br></pre></td></tr></table></figure>
<p>输出含不换行符的字符串：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"YES"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"NO"</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  YES</span></span><br><span class="line"><span class="comment">#  NO</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"YES\c"</span> <span class="comment"># -e 开启转义 \c 不换行</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"NO"</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  YESNO</span></span><br></pre></td></tr></table></figure>
<p>输出重定向至文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"test"</span> &gt; test.txt</span><br></pre></td></tr></table></figure>
<p>输出执行结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> `<span class="built_in">pwd</span>`</span><br><span class="line"><span class="comment">#  Output:(当前目录路径)</span></span><br></pre></td></tr></table></figure>
<p><strong>⌨️ 『示例源码』</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出普通字符串</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"hello, world"</span></span><br><span class="line"><span class="comment">#  Output: hello, world</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出含变量的字符串</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"hello, \"zp\""</span></span><br><span class="line"><span class="comment">#  Output: hello, "zp"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出含变量的字符串</span></span><br><span class="line">name=zp</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"hello, \"<span class="variable">$&#123;name&#125;</span>\""</span></span><br><span class="line"><span class="comment">#  Output: hello, "zp"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出含换行符的字符串</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"YES\nNO"</span></span><br><span class="line"><span class="comment">#  Output: YES\nNO</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"YES\nNO"</span> <span class="comment"># -e 开启转义</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  YES</span></span><br><span class="line"><span class="comment">#  NO</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出含不换行符的字符串</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"YES"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"NO"</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  YES</span></span><br><span class="line"><span class="comment">#  NO</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"YES\c"</span> <span class="comment"># -e 开启转义 \c 不换行</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"NO"</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  YESNO</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出内容定向至文件</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"test"</span> &gt; test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出执行结果</span></span><br><span class="line"><span class="built_in">echo</span> `<span class="built_in">pwd</span>`</span><br><span class="line"><span class="comment">#  Output:(当前目录路径)</span></span><br></pre></td></tr></table></figure>
<h3 id="24-printf"><a class="markdownIt-Anchor" href="#24-printf"></a> 2.4. printf</h3>
<p>printf 用于格式化输出字符串。</p>
<p>默认，printf 不会像 echo 一样自动添加换行符，如果需要换行可以手动添加 <code>\n</code>。</p>
<p><strong>⌨️ 『示例源码』</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 单引号</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">'%d %s\n'</span> 1 <span class="string">"abc"</span></span><br><span class="line"><span class="comment">#  Output:1 abc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 双引号</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%d %s\n"</span> 1 <span class="string">"abc"</span></span><br><span class="line"><span class="comment">#  Output:1 abc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 无引号</span></span><br><span class="line"><span class="built_in">printf</span> %s abcdef</span><br><span class="line"><span class="comment">#  Output: abcdef(并不会换行)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式只指定了一个参数，但多出的参数仍然会按照该格式输出</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%s\n"</span> abc def</span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  abc</span></span><br><span class="line"><span class="comment">#  def</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%s %s %s\n"</span> a b c d e f g h i j</span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  a b c</span></span><br><span class="line"><span class="comment">#  d e f</span></span><br><span class="line"><span class="comment">#  g h i</span></span><br><span class="line"><span class="comment">#  j</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果没有参数，那么 %s 用 NULL 代替，%d 用 0 代替</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%s and %d \n"</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#   and 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式化输出</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%-10s %-8s %-4s\n"</span> 姓名 性别 体重kg</span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%-10s %-8s %-4.2f\n"</span> 郭靖 男 66.1234</span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%-10s %-8s %-4.2f\n"</span> 杨过 男 48.6543</span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%-10s %-8s %-4.2f\n"</span> 郭芙 女 47.9876</span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  姓名     性别   体重kg</span></span><br><span class="line"><span class="comment">#  郭靖     男      66.12</span></span><br><span class="line"><span class="comment">#  杨过     男      48.65</span></span><br><span class="line"><span class="comment">#  郭芙     女      47.99</span></span><br></pre></td></tr></table></figure>
<h4 id="printf-的转义符"><a class="markdownIt-Anchor" href="#printf-的转义符"></a> printf 的转义符</h4>
<table>
<thead>
<tr>
<th>序列</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\a</code></td>
<td>警告字符，通常为 ASCII 的 BEL 字符</td>
</tr>
<tr>
<td><code>\b</code></td>
<td>后退</td>
</tr>
<tr>
<td><code>\c</code></td>
<td>抑制（不显示）输出结果中任何结尾的换行字符（只在%b 格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略</td>
</tr>
<tr>
<td><code>\f</code></td>
<td>换页（formfeed）</td>
</tr>
<tr>
<td><code>\n</code></td>
<td>换行</td>
</tr>
<tr>
<td><code>\r</code></td>
<td>回车（Carriage return）</td>
</tr>
<tr>
<td><code>\t</code></td>
<td>水平制表符</td>
</tr>
<tr>
<td><code>\v</code></td>
<td>垂直制表符</td>
</tr>
<tr>
<td><code>\\</code></td>
<td>一个字面上的反斜杠字符</td>
</tr>
<tr>
<td><code>\ddd</code></td>
<td>表示 1 到 3 位数八进制值的字符。仅在格式字符串中有效</td>
</tr>
<tr>
<td><code>\0ddd</code></td>
<td>表示 1 到 3 位的八进制值字符</td>
</tr>
</tbody>
</table>
<h2 id="3-变量"><a class="markdownIt-Anchor" href="#3-变量"></a> 3. 变量</h2>
<p>跟许多程序设计语言一样，你可以在 bash 中创建变量。</p>
<p>Bash 中没有数据类型，bash 中的变量可以保存一个数字、一个字符、一个字符串等等。同时无需提前声明变量，给变量赋值会直接创建变量。</p>
<h3 id="31-变量命名原则"><a class="markdownIt-Anchor" href="#31-变量命名原则"></a> 3.1. 变量命名原则</h3>
<ul>
<li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。</li>
<li>中间不能有空格，可以使用下划线（_）。</li>
<li>不能使用标点符号。</li>
<li>不能使用 bash 里的关键字（可用 help 命令查看保留关键字）。</li>
</ul>
<h3 id="32-声明变量"><a class="markdownIt-Anchor" href="#32-声明变量"></a> 3.2. 声明变量</h3>
<p>访问变量的语法形式为：<code>${var}</code> 和 <code>$var</code> 。</p>
<p>变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，所以推荐加花括号。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">word=<span class="string">"hello"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;word&#125;</span></span><br><span class="line"><span class="comment"># Output: hello</span></span><br></pre></td></tr></table></figure>
<h3 id="33-只读变量"><a class="markdownIt-Anchor" href="#33-只读变量"></a> 3.3. 只读变量</h3>
<p>使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rword=<span class="string">"hello"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;rword&#125;</span></span><br><span class="line"><span class="built_in">readonly</span> rword</span><br><span class="line"><span class="comment"># rword="bye"  # 如果放开注释，执行时会报错</span></span><br></pre></td></tr></table></figure>
<h3 id="34-删除变量"><a class="markdownIt-Anchor" href="#34-删除变量"></a> 3.4. 删除变量</h3>
<p>使用 unset 命令可以删除变量。变量被删除后不能再次使用。unset 命令不能删除只读变量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dword=<span class="string">"hello"</span>  <span class="comment"># 声明变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;dword&#125;</span>  <span class="comment"># 输出变量值</span></span><br><span class="line"><span class="comment"># Output: hello</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">unset</span> dword    <span class="comment"># 删除变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;dword&#125;</span></span><br><span class="line"><span class="comment"># Output: （空）</span></span><br></pre></td></tr></table></figure>
<h3 id="35-变量类型"><a class="markdownIt-Anchor" href="#35-变量类型"></a> 3.5. 变量类型</h3>
<ul>
<li><strong>局部变量</strong> - 局部变量是仅在某个脚本内部有效的变量。它们不能被其他的程序和脚本访问。</li>
<li><strong>环境变量</strong> - 环境变量是对当前 shell 会话内所有的程序或脚本都可见的变量。创建它们跟创建局部变量类似，但使用的是 <code>export</code> 关键字，shell 脚本也可以定义环境变量。</li>
</ul>
<p>常见的环境变量：</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$HOME</code></td>
<td>当前用户的用户目录</td>
</tr>
<tr>
<td><code>$PATH</code></td>
<td>用分号分隔的目录列表，shell 会到这些目录中查找命令</td>
</tr>
<tr>
<td><code>$PWD</code></td>
<td>当前工作目录</td>
</tr>
<tr>
<td><code>$RANDOM</code></td>
<td>0 到 32767 之间的整数</td>
</tr>
<tr>
<td><code>$UID</code></td>
<td>数值类型，当前用户的用户 ID</td>
</tr>
<tr>
<td><code>$PS1</code></td>
<td>主要系统输入提示符</td>
</tr>
<tr>
<td><code>$PS2</code></td>
<td>次要系统输入提示符</td>
</tr>
</tbody>
</table>
<p><a href="http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_03_02.html###sect_03_02_04" target="_blank" rel="noopener">这里</a> 有一张更全面的 Bash 环境变量列表。</p>
<p><strong>⌨️ 『示例源码』</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################### 声明变量 ###################</span></span><br><span class="line">name=<span class="string">"world"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"hello <span class="variable">$&#123;name&#125;</span>"</span></span><br><span class="line"><span class="comment"># Output: hello world</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################### 输出变量 ###################</span></span><br><span class="line">folder=$(<span class="built_in">pwd</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"current path: <span class="variable">$&#123;folder&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################### 只读变量 ###################</span></span><br><span class="line">rword=<span class="string">"hello"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;rword&#125;</span></span><br><span class="line"><span class="comment"># Output: hello</span></span><br><span class="line"><span class="built_in">readonly</span> rword</span><br><span class="line"><span class="comment"># rword="bye"  # 如果放开注释，执行时会报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################### 删除变量 ###################</span></span><br><span class="line">dword=<span class="string">"hello"</span> <span class="comment"># 声明变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;dword&#125;</span> <span class="comment"># 输出变量值</span></span><br><span class="line"><span class="comment"># Output: hello</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">unset</span> dword <span class="comment"># 删除变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;dword&#125;</span></span><br><span class="line"><span class="comment"># Output: （空）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################### 系统变量 ###################</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"UID:<span class="variable">$UID</span>"</span></span><br><span class="line"><span class="built_in">echo</span> LOGNAME:<span class="variable">$LOGNAME</span></span><br><span class="line"><span class="built_in">echo</span> User:<span class="variable">$USER</span></span><br><span class="line"><span class="built_in">echo</span> HOME:<span class="variable">$HOME</span></span><br><span class="line"><span class="built_in">echo</span> PATH:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">echo</span> HOSTNAME:<span class="variable">$HOSTNAME</span></span><br><span class="line"><span class="built_in">echo</span> SHELL:<span class="variable">$SHELL</span></span><br><span class="line"><span class="built_in">echo</span> LANG:<span class="variable">$LANG</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################### 自定义变量 ###################</span></span><br><span class="line">days=10</span><br><span class="line">user=<span class="string">"admin"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$user</span> logged in <span class="variable">$days</span> days age"</span></span><br><span class="line">days=5</span><br><span class="line">user=<span class="string">"root"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$user</span> logged in <span class="variable">$days</span> days age"</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># admin logged in 10 days age</span></span><br><span class="line"><span class="comment"># root logged in 5 days age</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################### 从变量读取列表 ###################</span></span><br><span class="line">colors=<span class="string">"Red Yellow Blue"</span></span><br><span class="line">colors=<span class="variable">$colors</span><span class="string">" White Black"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> color <span class="keyword">in</span> <span class="variable">$colors</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">" <span class="variable">$color</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<h2 id="4-字符串"><a class="markdownIt-Anchor" href="#4-字符串"></a> 4. 字符串</h2>
<h3 id="41-单引号和双引号"><a class="markdownIt-Anchor" href="#41-单引号和双引号"></a> 4.1. 单引号和双引号</h3>
<p>shell 字符串可以用单引号 <code>''</code>，也可以用双引号 <code>“”</code>，也可以不用引号。</p>
<ul>
<li>单引号的特点
<ul>
<li>单引号里不识别变量</li>
<li>单引号里不能出现单独的单引号（使用转义符也不行），但可成对出现，作为字符串拼接使用。</li>
</ul>
</li>
<li>双引号的特点
<ul>
<li>双引号里识别变量</li>
<li>双引号里可以出现转义字符</li>
</ul>
</li>
</ul>
<p>综上，推荐使用双引号。</p>
<h3 id="42-拼接字符串"><a class="markdownIt-Anchor" href="#42-拼接字符串"></a> 4.2. 拼接字符串</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用单引号拼接</span></span><br><span class="line">name1=<span class="string">'white'</span></span><br><span class="line">str1=<span class="string">'hello, '</span><span class="variable">$&#123;name1&#125;</span><span class="string">''</span></span><br><span class="line">str2=<span class="string">'hello, $&#123;name1&#125;'</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str1&#125;</span>_<span class="variable">$&#123;str2&#125;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># hello, white_hello, $&#123;name1&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用双引号拼接</span></span><br><span class="line">name2=<span class="string">"black"</span></span><br><span class="line">str3=<span class="string">"hello, "</span><span class="variable">$&#123;name2&#125;</span><span class="string">""</span></span><br><span class="line">str4=<span class="string">"hello, <span class="variable">$&#123;name2&#125;</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str3&#125;</span>_<span class="variable">$&#123;str4&#125;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># hello, black_hello, black</span></span><br></pre></td></tr></table></figure>
<h3 id="43-获取字符串长度"><a class="markdownIt-Anchor" href="#43-获取字符串长度"></a> 4.3. 获取字符串长度</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">text=<span class="string">"12345"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#text&#125;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># 5</span></span><br></pre></td></tr></table></figure>
<h3 id="44-截取子字符串"><a class="markdownIt-Anchor" href="#44-截取子字符串"></a> 4.4. 截取子字符串</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">text=<span class="string">"12345"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;text:2:2&#125;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># 34</span></span><br></pre></td></tr></table></figure>
<p>从第 3 个字符开始，截取 2 个字符</p>
<h3 id="45-查找子字符串"><a class="markdownIt-Anchor" href="#45-查找子字符串"></a> 4.5. 查找子字符串</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line">text=<span class="string">"hello"</span></span><br><span class="line"><span class="built_in">echo</span> `expr index <span class="string">"<span class="variable">$&#123;text&#125;</span>"</span> ll`</span><br><span class="line"></span><br><span class="line"><span class="comment"># Execute: ./str-demo5.sh</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure>
<p>查找 <code>ll</code> 子字符在 <code>hello</code> 字符串中的起始位置。</p>
<p><strong>⌨️ 『示例源码』</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################### 使用单引号拼接字符串 ###################</span></span><br><span class="line">name1=<span class="string">'white'</span></span><br><span class="line">str1=<span class="string">'hello, '</span><span class="variable">$&#123;name1&#125;</span><span class="string">''</span></span><br><span class="line">str2=<span class="string">'hello, $&#123;name1&#125;'</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str1&#125;</span>_<span class="variable">$&#123;str2&#125;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># hello, white_hello, $&#123;name1&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################### 使用双引号拼接字符串 ###################</span></span><br><span class="line">name2=<span class="string">"black"</span></span><br><span class="line">str3=<span class="string">"hello, "</span><span class="variable">$&#123;name2&#125;</span><span class="string">""</span></span><br><span class="line">str4=<span class="string">"hello, <span class="variable">$&#123;name2&#125;</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str3&#125;</span>_<span class="variable">$&#123;str4&#125;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># hello, black_hello, black</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################### 获取字符串长度 ###################</span></span><br><span class="line">text=<span class="string">"12345"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;text&#125;</span> length is: <span class="variable">$&#123;#text&#125;</span>"</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># 12345 length is: 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取子字符串</span></span><br><span class="line">text=<span class="string">"12345"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;text:2:2&#125;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># 34</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################### 查找子字符串 ###################</span></span><br><span class="line">text=<span class="string">"hello"</span></span><br><span class="line"><span class="built_in">echo</span> `expr index <span class="string">"<span class="variable">$&#123;text&#125;</span>"</span> ll`</span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################### 判断字符串中是否包含子字符串 ###################</span></span><br><span class="line">result=$(<span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;str&#125;</span>"</span> | grep <span class="string">"feature/"</span>)</span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">"<span class="variable">$result</span>"</span> != <span class="string">""</span> ]]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">"feature/ 是 <span class="variable">$&#123;str&#125;</span> 的子字符串"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">"feature/ 不是 <span class="variable">$&#123;str&#125;</span> 的子字符串"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################### 截取关键字左边内容 ###################</span></span><br><span class="line">full_branch=<span class="string">"feature/1.0.0"</span></span><br><span class="line">branch=`<span class="built_in">echo</span> <span class="variable">$&#123;full_branch#feature/&#125;</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"branch is <span class="variable">$&#123;branch&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################### 截取关键字右边内容 ###################</span></span><br><span class="line">full_version=<span class="string">"0.0.1-SNAPSHOT"</span></span><br><span class="line">version=`<span class="built_in">echo</span> <span class="variable">$&#123;full_version%-SNAPSHOT&#125;</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"version is <span class="variable">$&#123;version&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################### 字符串分割成数组 ###################</span></span><br><span class="line">str=<span class="string">"0.0.0.1"</span></span><br><span class="line">OLD_IFS=<span class="string">"<span class="variable">$IFS</span>"</span></span><br><span class="line">IFS=<span class="string">"."</span></span><br><span class="line">array=( <span class="variable">$&#123;str&#125;</span> )</span><br><span class="line">IFS=<span class="string">"<span class="variable">$OLD_IFS</span>"</span></span><br><span class="line">size=<span class="variable">$&#123;#array[*]&#125;</span></span><br><span class="line">lastIndex=`expr <span class="variable">$&#123;size&#125;</span> - 1`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"数组长度：<span class="variable">$&#123;size&#125;</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"最后一个数组元素：<span class="variable">$&#123;array[$&#123;lastIndex&#125;</span>]&#125;"</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="variable">$&#123;array[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">"<span class="variable">$item</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################### 判断字符串是否为空 ###################</span></span><br><span class="line"><span class="comment">#-n 判断长度是否非零</span></span><br><span class="line"><span class="comment">#-z 判断长度是否为零</span></span><br><span class="line"></span><br><span class="line">str=testing</span><br><span class="line">str2=<span class="string">''</span></span><br><span class="line"><span class="keyword">if</span> [[ -n <span class="string">"<span class="variable">$str</span>"</span> ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">"The string <span class="variable">$str</span> is not empty"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">"The string <span class="variable">$str</span> is empty"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ -n <span class="string">"<span class="variable">$str2</span>"</span> ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">"The string <span class="variable">$str2</span> is not empty"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">"The string <span class="variable">$str2</span> is empty"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#	Output:</span></span><br><span class="line"><span class="comment">#	The string testing is not empty</span></span><br><span class="line"><span class="comment">#	The string  is empty</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################### 字符串比较 ###################</span></span><br><span class="line">str=hello</span><br><span class="line">str2=world</span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$str</span> = <span class="string">"hello"</span> ]]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">"str equals hello"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">"str not equals hello"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$str2</span> = <span class="string">"hello"</span> ]]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">"str2 equals hello"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">"str2 not equals hello"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<h2 id="5-数组"><a class="markdownIt-Anchor" href="#5-数组"></a> 5. 数组</h2>
<p>bash 只支持一维数组。</p>
<p>数组下标从 0 开始，下标可以是整数或算术表达式，其值应大于或等于 0。</p>
<h3 id="51-创建数组"><a class="markdownIt-Anchor" href="#51-创建数组"></a> 5.1. 创建数组</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建数组的不同方式</span></span><br><span class="line">nums=([2]=2 [0]=0 [1]=1)</span><br><span class="line">colors=(red yellow <span class="string">"dark blue"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="52-访问数组元素"><a class="markdownIt-Anchor" href="#52-访问数组元素"></a> 5.2. 访问数组元素</h3>
<ul>
<li><strong>访问数组的单个元素：</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;nums[1]&#125;</span></span><br><span class="line"><span class="comment"># Output: 1</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>访问数组的所有元素：</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;colors[*]&#125;</span></span><br><span class="line"><span class="comment"># Output: red yellow dark blue</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;colors[@]&#125;</span></span><br><span class="line"><span class="comment"># Output: red yellow dark blue</span></span><br></pre></td></tr></table></figure>
<p>上面两行有很重要（也很微妙）的区别：</p>
<p>为了将数组中每个元素单独一行输出，我们用 <code>printf</code> 命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">"+ %s\n"</span> <span class="variable">$&#123;colors[*]&#125;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># + red</span></span><br><span class="line"><span class="comment"># + yellow</span></span><br><span class="line"><span class="comment"># + dark</span></span><br><span class="line"><span class="comment"># + blue</span></span><br></pre></td></tr></table></figure>
<p>为什么<code>dark</code>和<code>blue</code>各占了一行？尝试用引号包起来：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">"+ %s\n"</span> <span class="string">"<span class="variable">$&#123;colors[*]&#125;</span>"</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># + red yellow dark blue</span></span><br></pre></td></tr></table></figure>
<p>现在所有的元素都在一行输出 —— 这不是我们想要的！让我们试试<code>${colors[@]}</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">"+ %s\n"</span> <span class="string">"<span class="variable">$&#123;colors[@]&#125;</span>"</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># + red</span></span><br><span class="line"><span class="comment"># + yellow</span></span><br><span class="line"><span class="comment"># + dark blue</span></span><br></pre></td></tr></table></figure>
<p>在引号内，<code>${colors[@]}</code>将数组中的每个元素扩展为一个单独的参数；数组元素中的空格得以保留。</p>
<ul>
<li><strong>访问数组的部分元素：</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;nums[@]:0:2&#125;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># 0 1</span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，<code>${array[@]}</code> 扩展为整个数组，<code>:0:2</code>取出了数组中从 0 开始，长度为 2 的元素。</p>
<h3 id="53-访问数组长度"><a class="markdownIt-Anchor" href="#53-访问数组长度"></a> 5.3. 访问数组长度</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#nums[*]&#125;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure>
<h3 id="54-向数组中添加元素"><a class="markdownIt-Anchor" href="#54-向数组中添加元素"></a> 5.4. 向数组中添加元素</h3>
<p>向数组中添加元素也非常简单：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">colors=(white <span class="string">"<span class="variable">$&#123;colors[@]&#125;</span>"</span> green black)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;colors[@]&#125;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># white red yellow dark blue green black</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中，<code>${colors[@]}</code> 扩展为整个数组，并被置换到复合赋值语句中，接着，对数组<code>colors</code>的赋值覆盖了它原来的值。</p>
<h3 id="55-从数组中删除元素"><a class="markdownIt-Anchor" href="#55-从数组中删除元素"></a> 5.5. 从数组中删除元素</h3>
<p>用<code>unset</code>命令来从数组中删除一个元素：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unset</span> nums[0]</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;nums[@]&#125;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># 1 2</span></span><br></pre></td></tr></table></figure>
<p><strong>⌨️ 『示例源码』</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################### 创建数组 ###################</span></span><br><span class="line">nums=( [ 2 ] = 2 [ 0 ] = 0 [ 1 ] = 1 )</span><br><span class="line">colors=( red yellow <span class="string">"dark blue"</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment">################### 访问数组的单个元素 ###################</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;nums[1]&#125;</span></span><br><span class="line"><span class="comment"># Output: 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################### 访问数组的所有元素 ###################</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;colors[*]&#125;</span></span><br><span class="line"><span class="comment"># Output: red yellow dark blue</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;colors[@]&#125;</span></span><br><span class="line"><span class="comment"># Output: red yellow dark blue</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"+ %s\n"</span> <span class="variable">$&#123;colors[*]&#125;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># + red</span></span><br><span class="line"><span class="comment"># + yellow</span></span><br><span class="line"><span class="comment"># + dark</span></span><br><span class="line"><span class="comment"># + blue</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"+ %s\n"</span> <span class="string">"<span class="variable">$&#123;colors[*]&#125;</span>"</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># + red yellow dark blue</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"+ %s\n"</span> <span class="string">"<span class="variable">$&#123;colors[@]&#125;</span>"</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># + red</span></span><br><span class="line"><span class="comment"># + yellow</span></span><br><span class="line"><span class="comment"># + dark blue</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################### 访问数组的部分元素 ###################</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;nums[@]:0:2&#125;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># 0 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################### 获取数组长度 ###################</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#nums[*]&#125;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################### 向数组中添加元素 ###################</span></span><br><span class="line">colors=( white <span class="string">"<span class="variable">$&#123;colors[@]&#125;</span>"</span> green black )</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;colors[@]&#125;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># white red yellow dark blue green black</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################### 从数组中删除元素 ###################</span></span><br><span class="line"><span class="built_in">unset</span> nums[ 0 ]</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;nums[@]&#125;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># 1 2</span></span><br></pre></td></tr></table></figure>
<h2 id="6-运算符"><a class="markdownIt-Anchor" href="#6-运算符"></a> 6. 运算符</h2>
<h3 id="61-算术运算符"><a class="markdownIt-Anchor" href="#61-算术运算符"></a> 6.1. 算术运算符</h3>
<p>下表列出了常用的算术运算符，假定变量 x 为 10，变量 y 为 20：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>加法</td>
<td><code>expr $x + $y</code> 结果为 30。</td>
</tr>
<tr>
<td>-</td>
<td>减法</td>
<td><code>expr $x - $y</code> 结果为 -10。</td>
</tr>
<tr>
<td>*</td>
<td>乘法</td>
<td><code>expr $x * $y</code> 结果为 200。</td>
</tr>
<tr>
<td>/</td>
<td>除法</td>
<td><code>expr $y / $x</code> 结果为 2。</td>
</tr>
<tr>
<td>%</td>
<td>取余</td>
<td><code>expr $y % $x</code> 结果为 0。</td>
</tr>
<tr>
<td>=</td>
<td>赋值</td>
<td><code>x=$y</code> 将把变量 y 的值赋给 x。</td>
</tr>
<tr>
<td>==</td>
<td>相等。用于比较两个数字，相同则返回 true。</td>
<td><code>[ $x == $y ]</code> 返回 false。</td>
</tr>
<tr>
<td>!=</td>
<td>不相等。用于比较两个数字，不相同则返回 true。</td>
<td><code>[ $x != $y ]</code> 返回 true。</td>
</tr>
</tbody>
</table>
<p>**注意：**条件表达式要放在方括号之间，并且要有空格，例如: <code>[$x==$y]</code> 是错误的，必须写成 <code>[ $x == $y ]</code>。</p>
<p><strong>⌨️ 『示例源码』</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">x=10</span><br><span class="line">y=20</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"x=<span class="variable">$&#123;x&#125;</span>, y=<span class="variable">$&#123;y&#125;</span>"</span></span><br><span class="line"></span><br><span class="line">val=`expr <span class="variable">$&#123;x&#125;</span> + <span class="variable">$&#123;y&#125;</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> + <span class="variable">$&#123;y&#125;</span> = <span class="variable">$val</span>"</span></span><br><span class="line"></span><br><span class="line">val=`expr <span class="variable">$&#123;x&#125;</span> - <span class="variable">$&#123;y&#125;</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> - <span class="variable">$&#123;y&#125;</span> = <span class="variable">$val</span>"</span></span><br><span class="line"></span><br><span class="line">val=`expr <span class="variable">$&#123;x&#125;</span> \* <span class="variable">$&#123;y&#125;</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> * <span class="variable">$&#123;y&#125;</span> = <span class="variable">$val</span>"</span></span><br><span class="line"></span><br><span class="line">val=`expr <span class="variable">$&#123;y&#125;</span> / <span class="variable">$&#123;x&#125;</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;y&#125;</span> / <span class="variable">$&#123;x&#125;</span> = <span class="variable">$val</span>"</span></span><br><span class="line"></span><br><span class="line">val=`expr <span class="variable">$&#123;y&#125;</span> % <span class="variable">$&#123;x&#125;</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;y&#125;</span> % <span class="variable">$&#123;x&#125;</span> = <span class="variable">$val</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> == <span class="variable">$&#123;y&#125;</span> ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> = <span class="variable">$&#123;y&#125;</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> != <span class="variable">$&#123;y&#125;</span> ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> != <span class="variable">$&#123;y&#125;</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  x=10, y=20</span></span><br><span class="line"><span class="comment">#  10 + 20 = 30</span></span><br><span class="line"><span class="comment">#  10 - 20 = -10</span></span><br><span class="line"><span class="comment">#  10 * 20 = 200</span></span><br><span class="line"><span class="comment">#  20 / 10 = 2</span></span><br><span class="line"><span class="comment">#  20 % 10 = 0</span></span><br><span class="line"><span class="comment">#  10 != 20</span></span><br></pre></td></tr></table></figure>
<h3 id="62-关系运算符"><a class="markdownIt-Anchor" href="#62-关系运算符"></a> 6.2. 关系运算符</h3>
<p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字。</p>
<p>下表列出了常用的关系运算符，假定变量 x 为 10，变量 y 为 20：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-eq</code></td>
<td>检测两个数是否相等，相等返回 true。</td>
<td><code>[ $a -eq $b ]</code>返回 false。</td>
</tr>
<tr>
<td><code>-ne</code></td>
<td>检测两个数是否相等，不相等返回 true。</td>
<td><code>[ $a -ne $b ]</code> 返回 true。</td>
</tr>
<tr>
<td><code>-gt</code></td>
<td>检测左边的数是否大于右边的，如果是，则返回 true。</td>
<td><code>[ $a -gt $b ]</code> 返回 false。</td>
</tr>
<tr>
<td><code>-lt</code></td>
<td>检测左边的数是否小于右边的，如果是，则返回 true。</td>
<td><code>[ $a -lt $b ]</code> 返回 true。</td>
</tr>
<tr>
<td><code>-ge</code></td>
<td>检测左边的数是否大于等于右边的，如果是，则返回 true。</td>
<td><code>[ $a -ge $b ]</code> 返回 false。</td>
</tr>
<tr>
<td><code>-le</code></td>
<td>检测左边的数是否小于等于右边的，如果是，则返回 true。</td>
<td><code>[ $a -le $b ]</code>返回 true。</td>
</tr>
</tbody>
</table>
<p><strong>⌨️ 『示例源码』</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">x=10</span><br><span class="line">y=20</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"x=<span class="variable">$&#123;x&#125;</span>, y=<span class="variable">$&#123;y&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> -eq <span class="variable">$&#123;y&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -eq <span class="variable">$&#123;y&#125;</span> : x 等于 y"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -eq <span class="variable">$&#123;y&#125;</span>: x 不等于 y"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> -ne <span class="variable">$&#123;y&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -ne <span class="variable">$&#123;y&#125;</span>: x 不等于 y"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -ne <span class="variable">$&#123;y&#125;</span>: x 等于 y"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> -gt <span class="variable">$&#123;y&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -gt <span class="variable">$&#123;y&#125;</span>: x 大于 y"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -gt <span class="variable">$&#123;y&#125;</span>: x 不大于 y"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> -lt <span class="variable">$&#123;y&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -lt <span class="variable">$&#123;y&#125;</span>: x 小于 y"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -lt <span class="variable">$&#123;y&#125;</span>: x 不小于 y"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> -ge <span class="variable">$&#123;y&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -ge <span class="variable">$&#123;y&#125;</span>: x 大于或等于 y"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -ge <span class="variable">$&#123;y&#125;</span>: x 小于 y"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> -le <span class="variable">$&#123;y&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -le <span class="variable">$&#123;y&#125;</span>: x 小于或等于 y"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -le <span class="variable">$&#123;y&#125;</span>: x 大于 y"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  x=10, y=20</span></span><br><span class="line"><span class="comment">#  10 -eq 20: x 不等于 y</span></span><br><span class="line"><span class="comment">#  10 -ne 20: x 不等于 y</span></span><br><span class="line"><span class="comment">#  10 -gt 20: x 不大于 y</span></span><br><span class="line"><span class="comment">#  10 -lt 20: x 小于 y</span></span><br><span class="line"><span class="comment">#  10 -ge 20: x 小于 y</span></span><br><span class="line"><span class="comment">#  10 -le 20: x 小于或等于 y</span></span><br></pre></td></tr></table></figure>
<h3 id="63-布尔运算符"><a class="markdownIt-Anchor" href="#63-布尔运算符"></a> 6.3. 布尔运算符</h3>
<p>下表列出了常用的布尔运算符，假定变量 x 为 10，变量 y 为 20：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>!</code></td>
<td>非运算，表达式为 true 则返回 false，否则返回 true。</td>
<td><code>[ ! false ]</code> 返回 true。</td>
</tr>
<tr>
<td><code>-o</code></td>
<td>或运算，有一个表达式为 true 则返回 true。</td>
<td><code>[ $a -lt 20 -o $b -gt 100 ]</code> 返回 true。</td>
</tr>
<tr>
<td><code>-a</code></td>
<td>与运算，两个表达式都为 true 才返回 true。</td>
<td><code>[ $a -lt 20 -a $b -gt 100 ]</code> 返回 false。</td>
</tr>
</tbody>
</table>
<p><strong>⌨️ 『示例源码』</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">x=10</span><br><span class="line">y=20</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"x=<span class="variable">$&#123;x&#125;</span>, y=<span class="variable">$&#123;y&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> != <span class="variable">$&#123;y&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> != <span class="variable">$&#123;y&#125;</span> : x 不等于 y"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> != <span class="variable">$&#123;y&#125;</span>: x 等于 y"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> -lt 100 &amp;&amp; <span class="variable">$&#123;y&#125;</span> -gt 15 ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> 小于 100 且 <span class="variable">$&#123;y&#125;</span> 大于 15 : 返回 true"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> 小于 100 且 <span class="variable">$&#123;y&#125;</span> 大于 15 : 返回 false"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> -lt 100 || <span class="variable">$&#123;y&#125;</span> -gt 100 ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> 小于 100 或 <span class="variable">$&#123;y&#125;</span> 大于 100 : 返回 true"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> 小于 100 或 <span class="variable">$&#123;y&#125;</span> 大于 100 : 返回 false"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> -lt 5 || <span class="variable">$&#123;y&#125;</span> -gt 100 ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> 小于 5 或 <span class="variable">$&#123;y&#125;</span> 大于 100 : 返回 true"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> 小于 5 或 <span class="variable">$&#123;y&#125;</span> 大于 100 : 返回 false"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  x=10, y=20</span></span><br><span class="line"><span class="comment">#  10 != 20 : x 不等于 y</span></span><br><span class="line"><span class="comment">#  10 小于 100 且 20 大于 15 : 返回 true</span></span><br><span class="line"><span class="comment">#  10 小于 100 或 20 大于 100 : 返回 true</span></span><br><span class="line"><span class="comment">#  10 小于 5 或 20 大于 100 : 返回 false</span></span><br></pre></td></tr></table></figure>
<h3 id="64-逻辑运算符"><a class="markdownIt-Anchor" href="#64-逻辑运算符"></a> 6.4. 逻辑运算符</h3>
<p>以下介绍 Shell 的逻辑运算符，假定变量 x 为 10，变量 y 为 20:</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&amp;&amp;</code></td>
<td>逻辑的 AND</td>
<td><code>[[ ${x} -lt 100 &amp;&amp; ${y} -gt 100 ]]</code> 返回 false</td>
</tr>
<tr>
<td><code>||</code></td>
<td>逻辑的 OR</td>
<td><code>[[ ${x} -lt 100 || ${y} -gt 100 ]]</code> 返回 true</td>
</tr>
</tbody>
</table>
<p><strong>⌨️ 『示例源码』</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">x=10</span><br><span class="line">y=20</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"x=<span class="variable">$&#123;x&#125;</span>, y=<span class="variable">$&#123;y&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> -lt 100 &amp;&amp; <span class="variable">$&#123;y&#125;</span> -gt 100 ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -lt 100 &amp;&amp; <span class="variable">$&#123;y&#125;</span> -gt 100 返回 true"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -lt 100 &amp;&amp; <span class="variable">$&#123;y&#125;</span> -gt 100 返回 false"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> -lt 100 || <span class="variable">$&#123;y&#125;</span> -gt 100 ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -lt 100 || <span class="variable">$&#123;y&#125;</span> -gt 100 返回 true"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -lt 100 || <span class="variable">$&#123;y&#125;</span> -gt 100 返回 false"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  x=10, y=20</span></span><br><span class="line"><span class="comment">#  10 -lt 100 &amp;&amp; 20 -gt 100 返回 false</span></span><br><span class="line"><span class="comment">#  10 -lt 100 || 20 -gt 100 返回 true</span></span><br></pre></td></tr></table></figure>
<h3 id="65-字符串运算符"><a class="markdownIt-Anchor" href="#65-字符串运算符"></a> 6.5. 字符串运算符</h3>
<p>下表列出了常用的字符串运算符，假定变量 a 为 “abc”，变量 b 为 “efg”：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>=</code></td>
<td>检测两个字符串是否相等，相等返回 true。</td>
<td><code>[ $a = $b ]</code> 返回 false。</td>
</tr>
<tr>
<td><code>!=</code></td>
<td>检测两个字符串是否相等，不相等返回 true。</td>
<td><code>[ $a != $b ]</code> 返回 true。</td>
</tr>
<tr>
<td><code>-z</code></td>
<td>检测字符串长度是否为 0，为 0 返回 true。</td>
<td><code>[ -z $a ]</code> 返回 false。</td>
</tr>
<tr>
<td><code>-n</code></td>
<td>检测字符串长度是否为 0，不为 0 返回 true。</td>
<td><code>[ -n $a ]</code> 返回 true。</td>
</tr>
<tr>
<td><code>str</code></td>
<td>检测字符串是否为空，不为空返回 true。</td>
<td><code>[ $a ]</code> 返回 true。</td>
</tr>
</tbody>
</table>
<p><strong>⌨️ 『示例源码』</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">x=<span class="string">"abc"</span></span><br><span class="line">y=<span class="string">"xyz"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"x=<span class="variable">$&#123;x&#125;</span>, y=<span class="variable">$&#123;y&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> = <span class="variable">$&#123;y&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> = <span class="variable">$&#123;y&#125;</span> : x 等于 y"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> = <span class="variable">$&#123;y&#125;</span>: x 不等于 y"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> != <span class="variable">$&#123;y&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> != <span class="variable">$&#123;y&#125;</span> : x 不等于 y"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> != <span class="variable">$&#123;y&#125;</span>: x 等于 y"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ -z <span class="variable">$&#123;x&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"-z <span class="variable">$&#123;x&#125;</span> : 字符串长度为 0"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"-z <span class="variable">$&#123;x&#125;</span> : 字符串长度不为 0"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ -n <span class="string">"<span class="variable">$&#123;x&#125;</span>"</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"-n <span class="variable">$&#123;x&#125;</span> : 字符串长度不为 0"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"-n <span class="variable">$&#123;x&#125;</span> : 字符串长度为 0"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> : 字符串不为空"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> : 字符串为空"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  x=abc, y=xyz</span></span><br><span class="line"><span class="comment">#  abc = xyz: x 不等于 y</span></span><br><span class="line"><span class="comment">#  abc != xyz : x 不等于 y</span></span><br><span class="line"><span class="comment">#  -z abc : 字符串长度不为 0</span></span><br><span class="line"><span class="comment">#  -n abc : 字符串长度不为 0</span></span><br><span class="line"><span class="comment">#  abc : 字符串不为空</span></span><br></pre></td></tr></table></figure>
<h3 id="66-文件测试运算符"><a class="markdownIt-Anchor" href="#66-文件测试运算符"></a> 6.6. 文件测试运算符</h3>
<p>文件测试运算符用于检测 Unix 文件的各种属性。</p>
<p>属性检测描述如下：</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>-b file</td>
<td>检测文件是否是块设备文件，如果是，则返回 true。</td>
<td><code>[ -b $file ]</code> 返回 false。</td>
</tr>
<tr>
<td>-c file</td>
<td>检测文件是否是字符设备文件，如果是，则返回 true。</td>
<td><code>[ -c $file ]</code> 返回 false。</td>
</tr>
<tr>
<td>-d file</td>
<td>检测文件是否是目录，如果是，则返回 true。</td>
<td><code>[ -d $file ]</code> 返回 false。</td>
</tr>
<tr>
<td>-f file</td>
<td>检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。</td>
<td><code>[ -f $file ]</code> 返回 true。</td>
</tr>
<tr>
<td>-g file</td>
<td>检测文件是否设置了 SGID 位，如果是，则返回 true。</td>
<td><code>[ -g $file ]</code> 返回 false。</td>
</tr>
<tr>
<td>-k file</td>
<td>检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。</td>
<td><code>[ -k $file ]</code>返回 false。</td>
</tr>
<tr>
<td>-p file</td>
<td>检测文件是否是有名管道，如果是，则返回 true。</td>
<td><code>[ -p $file ]</code> 返回 false。</td>
</tr>
<tr>
<td>-u file</td>
<td>检测文件是否设置了 SUID 位，如果是，则返回 true。</td>
<td><code>[ -u $file ]</code> 返回 false。</td>
</tr>
<tr>
<td>-r file</td>
<td>检测文件是否可读，如果是，则返回 true。</td>
<td><code>[ -r $file ]</code> 返回 true。</td>
</tr>
<tr>
<td>-w file</td>
<td>检测文件是否可写，如果是，则返回 true。</td>
<td><code>[ -w $file ]</code> 返回 true。</td>
</tr>
<tr>
<td>-x file</td>
<td>检测文件是否可执行，如果是，则返回 true。</td>
<td><code>[ -x $file ]</code> 返回 true。</td>
</tr>
<tr>
<td>-s file</td>
<td>检测文件是否为空（文件大小是否大于 0），不为空返回 true。</td>
<td><code>[ -s $file ]</code> 返回 true。</td>
</tr>
<tr>
<td>-e file</td>
<td>检测文件（包括目录）是否存在，如果是，则返回 true。</td>
<td><code>[ -e $file ]</code> 返回 true。</td>
</tr>
</tbody>
</table>
<p><strong>⌨️ 『示例源码』</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">file=<span class="string">"/etc/hosts"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ -r <span class="variable">$&#123;file&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件可读"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件不可读"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [[ -w <span class="variable">$&#123;file&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件可写"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件不可写"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [[ -x <span class="variable">$&#123;file&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件可执行"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件不可执行"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [[ -f <span class="variable">$&#123;file&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件为普通文件"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件为特殊文件"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [[ -d <span class="variable">$&#123;file&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件是个目录"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件不是个目录"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [[ -s <span class="variable">$&#123;file&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件不为空"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件为空"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [[ -e <span class="variable">$&#123;file&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件存在"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件不存在"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  Output:(根据文件的实际情况，输出结果可能不同)</span></span><br><span class="line"><span class="comment">#  /etc/hosts 文件可读</span></span><br><span class="line"><span class="comment">#  /etc/hosts 文件可写</span></span><br><span class="line"><span class="comment">#  /etc/hosts 文件不可执行</span></span><br><span class="line"><span class="comment">#  /etc/hosts 文件为普通文件</span></span><br><span class="line"><span class="comment">#  /etc/hosts 文件不是个目录</span></span><br><span class="line"><span class="comment">#  /etc/hosts 文件不为空</span></span><br><span class="line"><span class="comment">#  /etc/hosts 文件存在</span></span><br></pre></td></tr></table></figure>
<h2 id="7-控制语句"><a class="markdownIt-Anchor" href="#7-控制语句"></a> 7. 控制语句</h2>
<h3 id="71-条件语句"><a class="markdownIt-Anchor" href="#71-条件语句"></a> 7.1. 条件语句</h3>
<p>跟其它程序设计语言一样，Bash 中的条件语句让我们可以决定一个操作是否被执行。结果取决于一个包在<code>[[ ]]</code>里的表达式。</p>
<p>由<code>[[ ]]</code>（<code>sh</code>中是<code>[ ]</code>）包起来的表达式被称作 <strong>检测命令</strong> 或 <strong>基元</strong>。这些表达式帮助我们检测一个条件的结果。这里可以找到有关<a href="http://serverfault.com/a/52050" target="_blank" rel="noopener">bash 中单双中括号区别</a>的答案。</p>
<p>共有两个不同的条件表达式：<code>if</code>和<code>case</code>。</p>
<h4 id="if"><a class="markdownIt-Anchor" href="#if"></a> <code>if</code></h4>
<p>（1）<code>if</code> 语句</p>
<p><code>if</code>在使用上跟其它语言相同。如果中括号里的表达式为真，那么<code>then</code>和<code>fi</code>之间的代码会被执行。<code>fi</code>标志着条件代码块的结束。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 写成一行</span></span><br><span class="line"><span class="keyword">if</span> [[ 1 -eq 1 ]]; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">"1 -eq 1 result is: true"</span>; <span class="keyword">fi</span></span><br><span class="line"><span class="comment"># Output: 1 -eq 1 result is: true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 写成多行</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">"abc"</span> -eq <span class="string">"abc"</span> ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">""</span>abc<span class="string">" -eq "</span>abc<span class="string">" result is: true"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># Output: abc -eq abc result is: true</span></span><br></pre></td></tr></table></figure>
<p>（2）<code>if else</code> 语句</p>
<p>同样，我们可以使用<code>if..else</code>语句，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [[ 2 -ne 1 ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"true"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"false"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># Output: true</span></span><br></pre></td></tr></table></figure>
<p>（3）<code>if elif else</code> 语句</p>
<p>有些时候，<code>if..else</code>不能满足我们的要求。别忘了<code>if..elif..else</code>，使用起来也很方便。</p>
<p><strong>⌨️ 『示例源码』</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">x=10</span><br><span class="line">y=20</span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> &gt; <span class="variable">$&#123;y&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> &gt; <span class="variable">$&#123;y&#125;</span>"</span></span><br><span class="line"><span class="keyword">elif</span> [[ <span class="variable">$&#123;x&#125;</span> &lt; <span class="variable">$&#123;y&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> &lt; <span class="variable">$&#123;y&#125;</span>"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> = <span class="variable">$&#123;y&#125;</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># Output: 10 &lt; 20</span></span><br></pre></td></tr></table></figure>
<h4 id="case"><a class="markdownIt-Anchor" href="#case"></a> <code>case</code></h4>
<p>如果你需要面对很多情况，分别要采取不同的措施，那么使用<code>case</code>会比嵌套的<code>if</code>更有用。使用<code>case</code>来解决复杂的条件判断，看起来像下面这样：</p>
<p><strong>⌨️ 『示例源码』</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exec</span></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$&#123;oper&#125;</span> <span class="keyword">in</span></span><br><span class="line">  <span class="string">"+"</span>)</span><br><span class="line">    val=`expr <span class="variable">$&#123;x&#125;</span> + <span class="variable">$&#123;y&#125;</span>`</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> + <span class="variable">$&#123;y&#125;</span> = <span class="variable">$&#123;val&#125;</span>"</span></span><br><span class="line">  ;;</span><br><span class="line">  <span class="string">"-"</span>)</span><br><span class="line">    val=`expr <span class="variable">$&#123;x&#125;</span> - <span class="variable">$&#123;y&#125;</span>`</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> - <span class="variable">$&#123;y&#125;</span> = <span class="variable">$&#123;val&#125;</span>"</span></span><br><span class="line">  ;;</span><br><span class="line">  <span class="string">"*"</span>)</span><br><span class="line">    val=`expr <span class="variable">$&#123;x&#125;</span> \* <span class="variable">$&#123;y&#125;</span>`</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> * <span class="variable">$&#123;y&#125;</span> = <span class="variable">$&#123;val&#125;</span>"</span></span><br><span class="line">  ;;</span><br><span class="line">  <span class="string">"/"</span>)</span><br><span class="line">    val=`expr <span class="variable">$&#123;x&#125;</span> / <span class="variable">$&#123;y&#125;</span>`</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> / <span class="variable">$&#123;y&#125;</span> = <span class="variable">$&#123;val&#125;</span>"</span></span><br><span class="line">  ;;</span><br><span class="line">  *)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Unknown oper!"</span></span><br><span class="line">  ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>
<p>每种情况都是匹配了某个模式的表达式。<code>|</code>用来分割多个模式，<code>)</code>用来结束一个模式序列。第一个匹配上的模式对应的命令将会被执行。<code>*</code>代表任何不匹配以上给定模式的模式。命令块儿之间要用<code>;;</code>分隔。</p>
<h3 id="72-循环语句"><a class="markdownIt-Anchor" href="#72-循环语句"></a> 7.2. 循环语句</h3>
<p>循环其实不足为奇。跟其它程序设计语言一样，bash 中的循环也是只要控制条件为真就一直迭代执行的代码块。</p>
<p>Bash 中有四种循环：<code>for</code>，<code>while</code>，<code>until</code>和<code>select</code>。</p>
<h4 id="for循环"><a class="markdownIt-Anchor" href="#for循环"></a> <code>for</code>循环</h4>
<p><code>for</code>与它在 C 语言中的姊妹非常像。看起来是这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> arg <span class="keyword">in</span> elem1 elem2 ... elemN</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="comment">### 语句</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>在每次循环的过程中，<code>arg</code>依次被赋值为从<code>elem1</code>到<code>elemN</code>。这些值还可以是通配符或者<a href="https://github.com/denysdovhan/bash-handbook/blob/master/translations/zh-CN/README.md#%E5%A4%A7%E6%8B%AC%E5%8F%B7%E6%89%A9%E5%B1%95" target="_blank" rel="noopener">大括号扩展</a>。</p>
<p>当然，我们还可以把<code>for</code>循环写在一行，但这要求<code>do</code>之前要有一个分号，就像下面这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..5&#125;; <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span>; <span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>还有，如果你觉得<code>for..in..do</code>对你来说有点奇怪，那么你也可以像 C 语言那样使用<code>for</code>，比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (( i = 0; i &lt; 10; i++ )); <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>当我们想对一个目录下的所有文件做同样的操作时，<code>for</code>就很方便了。举个例子，如果我们想把所有的<code>.bash</code>文件移动到<code>script</code>文件夹中，并给它们可执行权限，我们的脚本可以这样写：</p>
<p><strong>⌨️ 『示例源码』</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">DIR=/home/zp</span><br><span class="line"><span class="keyword">for</span> FILE <span class="keyword">in</span> <span class="variable">$&#123;DIR&#125;</span>/*.sh; <span class="keyword">do</span></span><br><span class="line">  mv <span class="string">"<span class="variable">$FILE</span>"</span> <span class="string">"<span class="variable">$&#123;DIR&#125;</span>/scripts"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment"># 将 /home/zp 目录下所有 sh 文件拷贝到 /home/zp/scripts</span></span><br></pre></td></tr></table></figure>
<h4 id="while循环"><a class="markdownIt-Anchor" href="#while循环"></a> <code>while</code>循环</h4>
<p><code>while</code>循环检测一个条件，只要这个条件为 <em>真</em>，就执行一段命令。被检测的条件跟<code>if..then</code>中使用的<a href="https://github.com/denysdovhan/bash-handbook/blob/master/translations/zh-CN/README.md#%E5%9F%BA%E5%85%83%E5%92%8C%E7%BB%84%E5%90%88%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank" rel="noopener">基元</a>并无二异。因此一个<code>while</code>循环看起来会是这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> [[ condition ]]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="comment">### 语句</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>跟<code>for</code>循环一样，如果我们把<code>do</code>和被检测的条件写到一行，那么必须要在<code>do</code>之前加一个分号。</p>
<p><strong>⌨️ 『示例源码』</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">### 0到9之间每个数的平方</span></span><br><span class="line">x=0</span><br><span class="line"><span class="keyword">while</span> [[ <span class="variable">$&#123;x&#125;</span> -lt 10 ]]; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> $((x * x))</span><br><span class="line">  x=$((x + 1))</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  0</span></span><br><span class="line"><span class="comment">#  1</span></span><br><span class="line"><span class="comment">#  4</span></span><br><span class="line"><span class="comment">#  9</span></span><br><span class="line"><span class="comment">#  16</span></span><br><span class="line"><span class="comment">#  25</span></span><br><span class="line"><span class="comment">#  36</span></span><br><span class="line"><span class="comment">#  49</span></span><br><span class="line"><span class="comment">#  64</span></span><br><span class="line"><span class="comment">#  81</span></span><br></pre></td></tr></table></figure>
<h4 id="until循环"><a class="markdownIt-Anchor" href="#until循环"></a> <code>until</code>循环</h4>
<p><code>until</code>循环跟<code>while</code>循环正好相反。它跟<code>while</code>一样也需要检测一个测试条件，但不同的是，只要该条件为 <em>假</em> 就一直执行循环：</p>
<p><strong>⌨️ 『示例源码』</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">x=0</span><br><span class="line">until [[ <span class="variable">$&#123;x&#125;</span> -ge 5 ]]; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$&#123;x&#125;</span></span><br><span class="line">  x=`expr <span class="variable">$&#123;x&#125;</span> + 1`</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  0</span></span><br><span class="line"><span class="comment">#  1</span></span><br><span class="line"><span class="comment">#  2</span></span><br><span class="line"><span class="comment">#  3</span></span><br><span class="line"><span class="comment">#  4</span></span><br></pre></td></tr></table></figure>
<h4 id="select循环"><a class="markdownIt-Anchor" href="#select循环"></a> <code>select</code>循环</h4>
<p><code>select</code>循环帮助我们组织一个用户菜单。它的语法几乎跟<code>for</code>循环一致：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">select answer <span class="keyword">in</span> elem1 elem2 ... elemN</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="comment">### 语句</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p><code>select</code>会打印<code>elem1..elemN</code>以及它们的序列号到屏幕上，之后会提示用户输入。通常看到的是<code>$?</code>（<code>PS3</code>变量）。用户的选择结果会被保存到<code>answer</code>中。如果<code>answer</code>是一个在<code>1..N</code>之间的数字，那么<code>语句</code>会被执行，紧接着会进行下一次迭代 —— 如果不想这样的话我们可以使用<code>break</code>语句。</p>
<p><strong>⌨️ 『示例源码』</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line">PS3=<span class="string">"Choose the package manager: "</span></span><br><span class="line">select ITEM <span class="keyword">in</span> bower npm gem pip</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">"Enter the package name: "</span> &amp;&amp; <span class="built_in">read</span> PACKAGE</span><br><span class="line"><span class="keyword">case</span> <span class="variable">$&#123;ITEM&#125;</span> <span class="keyword">in</span></span><br><span class="line">  bower) bower install <span class="variable">$&#123;PACKAGE&#125;</span> ;;</span><br><span class="line">  npm) npm install <span class="variable">$&#123;PACKAGE&#125;</span> ;;</span><br><span class="line">  gem) gem install <span class="variable">$&#123;PACKAGE&#125;</span> ;;</span><br><span class="line">  pip) pip install <span class="variable">$&#123;PACKAGE&#125;</span> ;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"><span class="built_in">break</span> <span class="comment"># 避免无限循环</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>这个例子，先询问用户他想使用什么包管理器。接着，又询问了想安装什么包，最后执行安装操作。</p>
<p>运行这个脚本，会得到如下输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./my_script</span><br><span class="line">1) bower</span><br><span class="line">2) npm</span><br><span class="line">3) gem</span><br><span class="line">4) pip</span><br><span class="line">Choose the package manager: 2</span><br><span class="line">Enter the package name: gitbook-cli</span><br></pre></td></tr></table></figure>
<h4 id="break-和-continue"><a class="markdownIt-Anchor" href="#break-和-continue"></a> <code>break</code> 和 <code>continue</code></h4>
<p>如果想提前结束一个循环或跳过某次循环执行，可以使用 shell 的<code>break</code>和<code>continue</code>语句来实现。它们可以在任何循环中使用。</p>
<blockquote>
<p><code>break</code>语句用来提前结束当前循环。</p>
<p><code>continue</code>语句用来跳过某次迭代。</p>
</blockquote>
<p><strong>⌨️ 『示例源码』</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查找 10 以内第一个能整除 2 和 3 的正整数</span></span><br><span class="line">i=1</span><br><span class="line"><span class="keyword">while</span> [[ <span class="variable">$&#123;i&#125;</span> -lt 10 ]]; <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> [[ $((i % 3)) -eq 0 ]] &amp;&amp; [[ $((i % 2)) -eq 0 ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$&#123;i&#125;</span></span><br><span class="line">    <span class="built_in">break</span>;</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  i=`expr <span class="variable">$&#123;i&#125;</span> + 1`</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment"># Output: 6</span></span><br></pre></td></tr></table></figure>
<p><strong>⌨️ 『示例源码』</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打印10以内的奇数</span></span><br><span class="line"><span class="keyword">for</span> (( i = 0; i &lt; 10; i ++ )); <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> [[ $((i % 2)) -eq 0 ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">continue</span>;</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$&#123;i&#125;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  1</span></span><br><span class="line"><span class="comment">#  3</span></span><br><span class="line"><span class="comment">#  5</span></span><br><span class="line"><span class="comment">#  7</span></span><br><span class="line"><span class="comment">#  9</span></span><br></pre></td></tr></table></figure>
<h2 id="8-函数"><a class="markdownIt-Anchor" href="#8-函数"></a> 8. 函数</h2>
<p>bash 函数定义语法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[ <span class="keyword">function</span> ] funname [()] &#123;</span><br><span class="line">    action;</span><br><span class="line">    [<span class="built_in">return</span> int;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>💡 说明：</p>
<ol>
<li>函数定义时，<code>function</code> 关键字可有可无。</li>
<li>函数返回值 - return 返回函数返回值，返回值类型只能为整数（0-255）。如果不加 return 语句，shell 默认将以最后一条命令的运行结果，作为函数返回值。</li>
<li>函数返回值在调用该函数后通过 <code>$?</code> 来获得。</li>
<li>所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至 shell 解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。</li>
</ol>
</blockquote>
<p><strong>⌨️ 『示例源码』</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">calc</span></span>()&#123;</span><br><span class="line">  PS3=<span class="string">"choose the oper: "</span></span><br><span class="line">  select oper <span class="keyword">in</span> + - \* / <span class="comment"># 生成操作符选择菜单</span></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> -n <span class="string">"enter first num: "</span> &amp;&amp; <span class="built_in">read</span> x <span class="comment"># 读取输入参数</span></span><br><span class="line">  <span class="built_in">echo</span> -n <span class="string">"enter second num: "</span> &amp;&amp; <span class="built_in">read</span> y <span class="comment"># 读取输入参数</span></span><br><span class="line">  <span class="built_in">exec</span></span><br><span class="line">  <span class="keyword">case</span> <span class="variable">$&#123;oper&#125;</span> <span class="keyword">in</span></span><br><span class="line">    <span class="string">"+"</span>)</span><br><span class="line">      <span class="built_in">return</span> $((<span class="variable">$&#123;x&#125;</span> + <span class="variable">$&#123;y&#125;</span>))</span><br><span class="line">    ;;</span><br><span class="line">    <span class="string">"-"</span>)</span><br><span class="line">      <span class="built_in">return</span> $((<span class="variable">$&#123;x&#125;</span> - <span class="variable">$&#123;y&#125;</span>))</span><br><span class="line">    ;;</span><br><span class="line">    <span class="string">"*"</span>)</span><br><span class="line">      <span class="built_in">return</span> $((<span class="variable">$&#123;x&#125;</span> * <span class="variable">$&#123;y&#125;</span>))</span><br><span class="line">    ;;</span><br><span class="line">    <span class="string">"/"</span>)</span><br><span class="line">      <span class="built_in">return</span> $((<span class="variable">$&#123;x&#125;</span> / <span class="variable">$&#123;y&#125;</span>))</span><br><span class="line">    ;;</span><br><span class="line">    *)</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;oper&#125;</span> is not support!"</span></span><br><span class="line">      <span class="built_in">return</span> 0</span><br><span class="line">    ;;</span><br><span class="line">  <span class="keyword">esac</span></span><br><span class="line">  <span class="built_in">break</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line">calc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"the result is: $?"</span> <span class="comment"># $? 获取 calc 函数返回值</span></span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./<span class="keyword">function</span>-demo.sh</span><br><span class="line">1) +</span><br><span class="line">2) -</span><br><span class="line">3) *</span><br><span class="line">4) /</span><br><span class="line">choose the oper: 3</span><br><span class="line">enter first num: 10</span><br><span class="line">enter second num: 10</span><br><span class="line">the result is: 100</span><br></pre></td></tr></table></figure>
<h3 id="81-位置参数"><a class="markdownIt-Anchor" href="#81-位置参数"></a> 8.1. 位置参数</h3>
<p><strong>位置参数</strong>是在调用一个函数并传给它参数时创建的变量。</p>
<p>位置参数变量表：</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$0</code></td>
<td>脚本名称</td>
</tr>
<tr>
<td><code>$1 … $9</code></td>
<td>第 1 个到第 9 个参数列表</td>
</tr>
<tr>
<td><code>${10} … ${N}</code></td>
<td>第 10 个到 N 个参数列表</td>
</tr>
<tr>
<td><code>$*</code> or <code>$@</code></td>
<td>除了<code>$0</code>外的所有位置参数</td>
</tr>
<tr>
<td><code>$#</code></td>
<td>不包括<code>$0</code>在内的位置参数的个数</td>
</tr>
<tr>
<td><code>$FUNCNAME</code></td>
<td>函数名称（仅在函数内部有值）</td>
</tr>
</tbody>
</table>
<p><strong>⌨️ 『示例源码』</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line">x=0</span><br><span class="line"><span class="keyword">if</span> [[ -n <span class="variable">$1</span> ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"第一个参数为：<span class="variable">$1</span>"</span></span><br><span class="line">  x=<span class="variable">$1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"第一个参数为空"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">y=0</span><br><span class="line"><span class="keyword">if</span> [[ -n <span class="variable">$2</span> ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"第二个参数为：<span class="variable">$2</span>"</span></span><br><span class="line">  y=<span class="variable">$2</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"第二个参数为空"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">paramsFunction</span></span>()&#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"函数第一个入参：<span class="variable">$1</span>"</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"函数第二个入参：<span class="variable">$2</span>"</span></span><br><span class="line">&#125;</span><br><span class="line">paramsFunction <span class="variable">$&#123;x&#125;</span> <span class="variable">$&#123;y&#125;</span></span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./<span class="keyword">function</span>-demo2.sh</span><br><span class="line">第一个参数为空</span><br><span class="line">第二个参数为空</span><br><span class="line">函数第一个入参：0</span><br><span class="line">函数第二个入参：0</span><br><span class="line"></span><br><span class="line">$ ./<span class="keyword">function</span>-demo2.sh 10 20</span><br><span class="line">第一个参数为：10</span><br><span class="line">第二个参数为：20</span><br><span class="line">函数第一个入参：10</span><br><span class="line">函数第二个入参：20</span><br></pre></td></tr></table></figure>
<p>执行 <code>./variable-demo4.sh hello world</code> ，然后在脚本中通过 <code>$1</code>、<code>$2</code> … 读取第 1 个参数、第 2 个参数。。。</p>
<h3 id="82-函数处理参数"><a class="markdownIt-Anchor" href="#82-函数处理参数"></a> 8.2. 函数处理参数</h3>
<p>另外，还有几个特殊字符用来处理参数：</p>
<table>
<thead>
<tr>
<th>参数处理</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$#</code></td>
<td>返回参数个数</td>
</tr>
<tr>
<td><code>$*</code></td>
<td>返回所有参数</td>
</tr>
<tr>
<td><code>$$</code></td>
<td>脚本运行的当前进程 ID 号</td>
</tr>
<tr>
<td><code>$!</code></td>
<td>后台运行的最后一个进程的 ID 号</td>
</tr>
<tr>
<td><code>$@</code></td>
<td>返回所有参数</td>
</tr>
<tr>
<td><code>$-</code></td>
<td>返回 Shell 使用的当前选项，与 set 命令功能相同。</td>
</tr>
<tr>
<td><code>$?</code></td>
<td>函数返回值</td>
</tr>
</tbody>
</table>
<p><strong>⌨️ 『示例源码』</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">runner</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">name=zp</span><br><span class="line"><span class="function"><span class="title">paramsFunction</span></span>()&#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"函数第一个入参：<span class="variable">$1</span>"</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"函数第二个入参：<span class="variable">$2</span>"</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"传递到脚本的参数个数：<span class="variable">$#</span>"</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"所有参数："</span></span><br><span class="line">  <span class="built_in">printf</span> <span class="string">"+ %s\n"</span> <span class="string">"$*"</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"脚本运行的当前进程 ID 号：$$"</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"后台运行的最后一个进程的 ID 号：$!"</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"所有参数："</span></span><br><span class="line">  <span class="built_in">printf</span> <span class="string">"+ %s\n"</span> <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Shell 使用的当前选项：$-"</span></span><br><span class="line">  runner</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"runner 函数的返回值：$?"</span></span><br><span class="line">&#125;</span><br><span class="line">paramsFunction 1 <span class="string">"abc"</span> <span class="string">"hello, \"zp\""</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  函数第一个入参：1</span></span><br><span class="line"><span class="comment">#  函数第二个入参：abc</span></span><br><span class="line"><span class="comment">#  传递到脚本的参数个数：3</span></span><br><span class="line"><span class="comment">#  所有参数：</span></span><br><span class="line"><span class="comment">#  + 1 abc hello, "zp"</span></span><br><span class="line"><span class="comment">#  脚本运行的当前进程 ID 号：26400</span></span><br><span class="line"><span class="comment">#  后台运行的最后一个进程的 ID 号：</span></span><br><span class="line"><span class="comment">#  所有参数：</span></span><br><span class="line"><span class="comment">#  + 1</span></span><br><span class="line"><span class="comment">#  + abc</span></span><br><span class="line"><span class="comment">#  + hello, "zp"</span></span><br><span class="line"><span class="comment">#  Shell 使用的当前选项：hB</span></span><br><span class="line"><span class="comment">#  runner 函数的返回值：0</span></span><br></pre></td></tr></table></figure>
<h2 id="9-shell-扩展"><a class="markdownIt-Anchor" href="#9-shell-扩展"></a> 9. Shell 扩展</h2>
<p><em>扩展</em> 发生在一行命令被分成一个个的 <em>记号（tokens）</em> 之后。换言之，扩展是一种执行数学运算的机制，还可以用来保存命令的执行结果，等等。</p>
<p>感兴趣的话可以阅读<a href="https://www.gnu.org/software/bash/manual/bash.html###Shell-Expansions" target="_blank" rel="noopener">关于 shell 扩展的更多细节</a>。</p>
<h4 id="大括号扩展"><a class="markdownIt-Anchor" href="#大括号扩展"></a> 大括号扩展</h4>
<p>大括号扩展让生成任意的字符串成为可能。它跟 <em>文件名扩展</em> 很类似，举个例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> beg&#123;i,a,u&#125;n <span class="comment">### begin began begun</span></span><br></pre></td></tr></table></figure>
<p>大括号扩展还可以用来创建一个可被循环迭代的区间。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> &#123;0..5&#125; <span class="comment">### 0 1 2 3 4 5</span></span><br><span class="line"><span class="built_in">echo</span> &#123;00..8..2&#125; <span class="comment">### 00 02 04 06 08</span></span><br></pre></td></tr></table></figure>
<h4 id="命令置换"><a class="markdownIt-Anchor" href="#命令置换"></a> 命令置换</h4>
<p>命令置换允许我们对一个命令求值，并将其值置换到另一个命令或者变量赋值表达式中。当一个命令被``或<code>$()</code>包围时，命令置换将会执行。举个例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">now=`date +%T`</span><br><span class="line"><span class="comment">### or</span></span><br><span class="line">now=$(date +%T)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$now</span> <span class="comment">### 19:08:26</span></span><br></pre></td></tr></table></figure>
<h4 id="算数扩展"><a class="markdownIt-Anchor" href="#算数扩展"></a> 算数扩展</h4>
<p>在 bash 中，执行算数运算是非常方便的。算数表达式必须包在<code>$(( ))</code>中。算数扩展的格式为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">result=$(( ((10 + 5*3) - 7) / 2 ))</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$result</span> <span class="comment">### 9</span></span><br></pre></td></tr></table></figure>
<p>在算数表达式中，使用变量无需带上<code>$</code>前缀：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">x=4</span><br><span class="line">y=7</span><br><span class="line"><span class="built_in">echo</span> $(( x + y ))     <span class="comment">### 11</span></span><br><span class="line"><span class="built_in">echo</span> $(( ++x + y++ )) <span class="comment">### 12</span></span><br><span class="line"><span class="built_in">echo</span> $(( x + y ))     <span class="comment">### 13</span></span><br></pre></td></tr></table></figure>
<h4 id="单引号和双引号"><a class="markdownIt-Anchor" href="#单引号和双引号"></a> 单引号和双引号</h4>
<p>单引号和双引号之间有很重要的区别。在双引号中，变量引用或者命令置换是会被展开的。在单引号中是不会的。举个例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"Your home: <span class="variable">$HOME</span>"</span> <span class="comment">### Your home: /Users/&lt;username&gt;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'Your home: $HOME'</span> <span class="comment">### Your home: $HOME</span></span><br></pre></td></tr></table></figure>
<p>当局部变量和环境变量包含空格时，它们在引号中的扩展要格外注意。随便举个例子，假如我们用<code>echo</code>来输出用户的输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">INPUT=<span class="string">"A string  with   strange    whitespace."</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$INPUT</span>   <span class="comment">### A string with strange whitespace.</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$INPUT</span>"</span> <span class="comment">### A string  with   strange    whitespace.</span></span><br></pre></td></tr></table></figure>
<p>调用第一个<code>echo</code>时给了它 5 个单独的参数 —— <code>$INPUT</code> 被分成了单独的词，<code>echo</code>在每个词之间打印了一个空格。第二种情况，调用<code>echo</code>时只给了它一个参数（整个$INPUT 的值，包括其中的空格）。</p>
<p>来看一个更严肃的例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FILE=<span class="string">"Favorite Things.txt"</span></span><br><span class="line">cat <span class="variable">$FILE</span>   <span class="comment">### 尝试输出两个文件: `Favorite` 和 `Things.txt`</span></span><br><span class="line">cat <span class="string">"<span class="variable">$FILE</span>"</span> <span class="comment">### 输出一个文件: `Favorite Things.txt`</span></span><br></pre></td></tr></table></figure>
<p>尽管这个问题可以通过把 FILE 重命名成<code>Favorite-Things.txt</code>来解决，但是，假如这个值来自某个环境变量，来自一个位置参数，或者来自其它命令（<code>find</code>, <code>cat</code>, 等等）呢。因此，如果输入 <em>可能</em> 包含空格，务必要用引号把表达式包起来。</p>
<h2 id="10-流和重定向"><a class="markdownIt-Anchor" href="#10-流和重定向"></a> 10. 流和重定向</h2>
<p>Bash 有很强大的工具来处理程序之间的协同工作。使用流，我们能将一个程序的输出发送到另一个程序或文件，因此，我们能方便地记录日志或做一些其它我们想做的事。</p>
<p>管道给了我们创建传送带的机会，控制程序的执行成为可能。</p>
<p>学习如何使用这些强大的、高级的工具是非常非常重要的。</p>
<h3 id="101-输入-输出流"><a class="markdownIt-Anchor" href="#101-输入-输出流"></a> 10.1. 输入、输出流</h3>
<p>Bash 接收输入，并以字符序列或 <strong>字符流</strong> 的形式产生输出。这些流能被重定向到文件或另一个流中。</p>
<p>有三个文件描述符：</p>
<table>
<thead>
<tr>
<th>代码</th>
<th>描述符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0</code></td>
<td><code>stdin</code></td>
<td>标准输入</td>
</tr>
<tr>
<td><code>1</code></td>
<td><code>stdout</code></td>
<td>标准输出</td>
</tr>
<tr>
<td><code>2</code></td>
<td><code>stderr</code></td>
<td>标准错误输出</td>
</tr>
</tbody>
</table>
<h3 id="102-重定向"><a class="markdownIt-Anchor" href="#102-重定向"></a> 10.2. 重定向</h3>
<p>重定向让我们可以控制一个命令的输入来自哪里，输出结果到什么地方。这些运算符在控制流的重定向时会被用到：</p>
<table>
<thead>
<tr>
<th>Operator</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&gt;</code></td>
<td>重定向输出</td>
</tr>
<tr>
<td><code>&amp;&gt;</code></td>
<td>重定向输出和错误输出</td>
</tr>
<tr>
<td><code>&amp;&gt;&gt;</code></td>
<td>以附加的形式重定向输出和错误输出</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>重定向输入</td>
</tr>
<tr>
<td><code>&lt;&lt;</code></td>
<td><a href="http://tldp.org/LDP/abs/html/here-docs.html" target="_blank" rel="noopener">Here 文档</a> 语法</td>
</tr>
<tr>
<td><code>&lt;&lt;&lt;</code></td>
<td><a href="http://www.tldp.org/LDP/abs/html/x17837.html" target="_blank" rel="noopener">Here 字符串</a></td>
</tr>
</tbody>
</table>
<p>以下是一些使用重定向的例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">### ls的结果将会被写到list.txt中</span></span><br><span class="line">ls -l &gt; list.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">### 将输出附加到list.txt中</span></span><br><span class="line">ls -a &gt;&gt; list.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">### 所有的错误信息会被写到errors.txt中</span></span><br><span class="line">grep da * 2&gt; errors.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">### 从errors.txt中读取输入</span></span><br><span class="line">less &lt; errors.txt</span><br></pre></td></tr></table></figure>
<h3 id="103-devnull-文件"><a class="markdownIt-Anchor" href="#103-devnull-文件"></a> 10.3. <code>/dev/null</code> 文件</h3>
<p>如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">command</span> &gt; /dev/null</span><br></pre></td></tr></table></figure>
<p>/dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到&quot;禁止输出&quot;的效果。</p>
<p>如果希望屏蔽 stdout 和 stderr，可以这样写：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">command</span> &gt; /dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure>
<h2 id="11-debug"><a class="markdownIt-Anchor" href="#11-debug"></a> 11. Debug</h2>
<p>shell 提供了用于 debug 脚本的工具。</p>
<p>如果想采用 debug 模式运行某脚本，可以在其 shebang 中使用一个特殊的选项：</p>
<figure class="highlight d"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash options</span></span><br></pre></td></tr></table></figure>
<p>options 是一些可以改变 shell 行为的选项。下表是一些可能对你有用的选项：</p>
<table>
<thead>
<tr>
<th>Short</th>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-f</code></td>
<td>noglob</td>
<td>禁止文件名展开（globbing）</td>
</tr>
<tr>
<td><code>-i</code></td>
<td>interactive</td>
<td>让脚本以 <em>交互</em> 模式运行</td>
</tr>
<tr>
<td><code>-n</code></td>
<td>noexec</td>
<td>读取命令，但不执行（语法检查）</td>
</tr>
<tr>
<td><code>-t</code></td>
<td>—</td>
<td>执行完第一条命令后退出</td>
</tr>
<tr>
<td><code>-v</code></td>
<td>verbose</td>
<td>在执行每条命令前，向<code>stderr</code>输出该命令</td>
</tr>
<tr>
<td><code>-x</code></td>
<td>xtrace</td>
<td>在执行每条命令前，向<code>stderr</code>输出该命令以及该命令的扩展参数</td>
</tr>
</tbody>
</table>
<p>举个例子，如果我们在脚本中指定了<code>-x</code>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash -x</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (( i = 0; i &lt; 3; i++ )); <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>这会向<code>stdout</code>打印出变量的值和一些其它有用的信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./my_script</span><br><span class="line">+ (( i = 0 ))</span><br><span class="line">+ (( i &lt; 3 ))</span><br><span class="line">+ <span class="built_in">echo</span> 0</span><br><span class="line">0</span><br><span class="line">+ (( i++  ))</span><br><span class="line">+ (( i &lt; 3 ))</span><br><span class="line">+ <span class="built_in">echo</span> 1</span><br><span class="line">1</span><br><span class="line">+ (( i++  ))</span><br><span class="line">+ (( i &lt; 3 ))</span><br><span class="line">+ <span class="built_in">echo</span> 2</span><br><span class="line">2</span><br><span class="line">+ (( i++  ))</span><br><span class="line">+ (( i &lt; 3 ))</span><br></pre></td></tr></table></figure>
<p>有时我们值需要 debug 脚本的一部分。这种情况下，使用<code>set</code>命令会很方便。这个命令可以启用或禁用选项。使用<code>-</code>启用选项，<code>+</code>禁用选项：</p>
<p><strong>⌨️ 『示例源码』</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启 debug</span></span><br><span class="line"><span class="built_in">set</span> -x</span><br><span class="line"><span class="keyword">for</span> (( i = 0; i &lt; 3; i++ )); <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">printf</span> <span class="variable">$&#123;i&#125;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment"># 关闭 debug</span></span><br><span class="line"><span class="built_in">set</span> +x</span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  + (( i = 0 ))</span></span><br><span class="line"><span class="comment">#  + (( i &lt; 3 ))</span></span><br><span class="line"><span class="comment">#  + printf 0</span></span><br><span class="line"><span class="comment">#  0+ (( i++  ))</span></span><br><span class="line"><span class="comment">#  + (( i &lt; 3 ))</span></span><br><span class="line"><span class="comment">#  + printf 1</span></span><br><span class="line"><span class="comment">#  1+ (( i++  ))</span></span><br><span class="line"><span class="comment">#  + (( i &lt; 3 ))</span></span><br><span class="line"><span class="comment">#  + printf 2</span></span><br><span class="line"><span class="comment">#  2+ (( i++  ))</span></span><br><span class="line"><span class="comment">#  + (( i &lt; 3 ))</span></span><br><span class="line"><span class="comment">#  + set +x</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..5&#125;; <span class="keyword">do</span> <span class="built_in">printf</span> <span class="variable">$&#123;i&#125;</span>; <span class="keyword">done</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"\n"</span></span><br><span class="line"><span class="comment">#  Output: 12345</span></span><br></pre></td></tr></table></figure>
<h2 id="12-更多内容"><a class="markdownIt-Anchor" href="#12-更多内容"></a> 12. 更多内容</h2>
<blockquote>
<p>📓 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p>
</blockquote>
<ul>
<li><a href="https://github.com/alebcay/awesome-shell" target="_blank" rel="noopener">awesome-shell</a>，shell 资源列表</li>
<li><a href="https://github.com/awesome-lists/awesome-bash" target="_blank" rel="noopener">awesome-bash</a>，bash 资源列表</li>
<li><a href="https://github.com/denysdovhan/bash-handbook" target="_blank" rel="noopener">bash-handbook</a></li>
<li><a href="https://github.com/vuuihc/bash-guide" target="_blank" rel="noopener">bash-guide</a> ，bash 基本用法指南</li>
<li><a href="https://github.com/Bash-it/bash-it" target="_blank" rel="noopener">bash-it</a>，为你日常使用，开发以及维护 shell 脚本和自定义命令提供了一个可靠的框架</li>
<li><a href="http://dotfiles.github.io/" target="_blank" rel="noopener">dotfiles.github.io</a>，上面有 bash 和其它 shell 的各种 dotfiles 集合以及 shell 框架的链接</li>
<li><a href="http://www.runoob.com/linux/linux-shell.html" target="_blank" rel="noopener">Runoob Shell 教程</a></li>
<li><a href="https://github.com/koalaman/shellcheck" target="_blank" rel="noopener">shellcheck</a> 一个静态 shell 脚本分析工具，本质上是 bash／sh／zsh 的 lint。</li>
</ul>
<p>最后，Stack Overflow 上 <a href="https://stackoverflow.com/questions/tagged/bash" target="_blank" rel="noopener">bash 标签下</a>有很多你可以学习的问题，当你遇到问题时，也是一个提问的好地方。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/blog/tools/regex/</url>
    <content><![CDATA[<blockquote>
<p>📓 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p>
</blockquote>
<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<p>为了理解下面章节的内容，你需要先了解一些基本概念。</p>
<ul>
<li><strong>正则表达式</strong> - 正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。</li>
<li><strong>元字符</strong> - 元字符(metacharacters)就是正则表达式中具有特殊意义的专用字符。</li>
<li><strong>普通字符</strong> - 普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。</li>
</ul>
<h2 id="基本元字符"><a class="markdownIt-Anchor" href="#基本元字符"></a> 基本元字符</h2>
<p>正则表达式的元字符难以记忆，很大程度上是因为有很多为了简化表达而出现的等价字符。</p>
<p>而实际上最基本的元字符，并没有那么多。对于大部分的场景，基本元字符都可以搞定。</p>
<p>让我们从一个个实例出发，由浅入深的去体会正则的奥妙。</p>
<h3 id="多选-"><a class="markdownIt-Anchor" href="#多选-"></a> 多选 - |</h3>
<p><strong>例 匹配一个确定的字符串</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">checkMatches(<span class="string">"abc"</span>, <span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure>
<p>如果要匹配一个确定的字符串，非常简单，如例 1 所示。</p>
<p>如果你不确定要匹配的字符串，希望有多个选择，怎么办？</p>
<p>答案是：使用元字符<code>|</code> ，它的含义是或。</p>
<p><strong>例 匹配多个可选的字符串</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试正则表达式字符：|</span></span><br><span class="line">Assert.assertTrue(checkMatches(<span class="string">"yes|no"</span>, <span class="string">"yes"</span>));</span><br><span class="line">Assert.assertTrue(checkMatches(<span class="string">"yes|no"</span>, <span class="string">"no"</span>));</span><br><span class="line">Assert.assertFalse(checkMatches(<span class="string">"yes|no"</span>, <span class="string">"right"</span>));</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="literal">yes</span>	<span class="string">matches：</span> <span class="literal">yes</span><span class="string">|no</span></span><br><span class="line"><span class="literal">no</span>	<span class="string">matches：</span> <span class="literal">yes</span><span class="string">|no</span></span><br><span class="line"><span class="string">right</span>	<span class="string">not</span> <span class="string">matches：</span> <span class="literal">yes</span><span class="string">|no</span></span><br></pre></td></tr></table></figure>
<h3 id="分组-"><a class="markdownIt-Anchor" href="#分组-"></a> 分组 - ()</h3>
<p>如果你希望表达式由多个子表达式组成，你可以使用 <code>()</code>。</p>
<p><strong>例 匹配组合字符串</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Assert.assertTrue(checkMatches(<span class="string">"(play|end)(ing|ed)"</span>, <span class="string">"ended"</span>));</span><br><span class="line">Assert.assertTrue(checkMatches(<span class="string">"(play|end)(ing|ed)"</span>, <span class="string">"ending"</span>));</span><br><span class="line">Assert.assertTrue(checkMatches(<span class="string">"(play|end)(ing|ed)"</span>, <span class="string">"playing"</span>));</span><br><span class="line">Assert.assertTrue(checkMatches(<span class="string">"(play|end)(ing|ed)"</span>, <span class="string">"played"</span>));</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong></p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">ended	matches： (play|<span class="type">end</span>)(ing|<span class="type">ed</span>)</span><br><span class="line">ending	matches： (play|<span class="type">end</span>)(ing|<span class="type">ed</span>)</span><br><span class="line">playing	matches： (play|<span class="type">end</span>)(ing|<span class="type">ed</span>)</span><br><span class="line">played	matches： (play|<span class="type">end</span>)(ing|<span class="type">ed</span>)</span><br></pre></td></tr></table></figure>
<h3 id="指定单字符有效范围-"><a class="markdownIt-Anchor" href="#指定单字符有效范围-"></a> 指定单字符有效范围 - []</h3>
<p>前面展示了如何匹配字符串，但是很多时候你需要精确的匹配一个字符，这时可以使用<code>[]</code> 。</p>
<p><strong>例 字符在指定范围</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试正则表达式字符：[]</span></span><br><span class="line">Assert.assertTrue(checkMatches(<span class="string">"[abc]"</span>, <span class="string">"b"</span>));  <span class="comment">// 字符只能是a、b、c</span></span><br><span class="line">Assert.assertTrue(checkMatches(<span class="string">"[a-z]"</span>, <span class="string">"m"</span>)); <span class="comment">// 字符只能是a - z</span></span><br><span class="line">Assert.assertTrue(checkMatches(<span class="string">"[A-Z]"</span>, <span class="string">"O"</span>)); <span class="comment">// 字符只能是A - Z</span></span><br><span class="line">Assert.assertTrue(checkMatches(<span class="string">"[a-zA-Z]"</span>, <span class="string">"K"</span>)); <span class="comment">// 字符只能是a - z和A - Z</span></span><br><span class="line">Assert.assertTrue(checkMatches(<span class="string">"[a-zA-Z]"</span>, <span class="string">"k"</span>));</span><br><span class="line">Assert.assertTrue(checkMatches(<span class="string">"[0-9]"</span>, <span class="string">"5"</span>)); <span class="comment">// 字符只能是0 - 9</span></span><br></pre></td></tr></table></figure>
<p><strong>输出</strong></p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">b</span>	matches：<span class="meta"> [abc]</span></span><br><span class="line"><span class="attribute">m</span>	matches：<span class="meta"> [a-z]</span></span><br><span class="line"><span class="attribute">O</span>	matches：<span class="meta"> [A-Z]</span></span><br><span class="line"><span class="attribute">K</span>	matches：<span class="meta"> [a-zA-Z]</span></span><br><span class="line"><span class="attribute">k</span>	matches：<span class="meta"> [a-zA-Z]</span></span><br><span class="line"><span class="attribute">5</span>	matches：<span class="meta"> [0-9]</span></span><br></pre></td></tr></table></figure>
<h3 id="指定单字符无效范围-"><a class="markdownIt-Anchor" href="#指定单字符无效范围-"></a> 指定单字符无效范围 - [^]</h3>
<p><strong>例 字符不能在指定范围</strong></p>
<p>如果需要匹配一个字符的逆操作，即字符不能在指定范围，可以使用<code>[^]</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试正则表达式字符：[^]</span></span><br><span class="line">Assert.assertFalse(checkMatches(<span class="string">"[^abc]"</span>, <span class="string">"b"</span>)); <span class="comment">// 字符不能是a、b、c</span></span><br><span class="line">Assert.assertFalse(checkMatches(<span class="string">"[^a-z]"</span>, <span class="string">"m"</span>)); <span class="comment">// 字符不能是a - z</span></span><br><span class="line">Assert.assertFalse(checkMatches(<span class="string">"[^A-Z]"</span>, <span class="string">"O"</span>)); <span class="comment">// 字符不能是A - Z</span></span><br><span class="line">Assert.assertFalse(checkMatches(<span class="string">"[^a-zA-Z]"</span>, <span class="string">"K"</span>)); <span class="comment">// 字符不能是a - z和A - Z</span></span><br><span class="line">Assert.assertFalse(checkMatches(<span class="string">"[^a-zA-Z]"</span>, <span class="string">"k"</span>));</span><br><span class="line">Assert.assertFalse(checkMatches(<span class="string">"[^0-9]"</span>, <span class="string">"5"</span>)); <span class="comment">// 字符不能是0 - 9</span></span><br></pre></td></tr></table></figure>
<p><strong>输出</strong></p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">b<span class="built_in">	not</span><span class="built_in"> matches</span>： [^abc]</span><br><span class="line">m<span class="built_in">	not</span><span class="built_in"> matches</span>： [^a-z]</span><br><span class="line">O<span class="built_in">	not</span><span class="built_in"> matches</span>： [^A-Z]</span><br><span class="line">K<span class="built_in">	not</span><span class="built_in"> matches</span>： [^a-zA-Z]</span><br><span class="line">k<span class="built_in">	not</span><span class="built_in"> matches</span>： [^a-zA-Z]</span><br><span class="line"><span class="number">5</span><span class="built_in">	not</span><span class="built_in"> matches</span>： [^<span class="number">0</span>-<span class="number">9</span>]</span><br></pre></td></tr></table></figure>
<h3 id="限制字符数量-"><a class="markdownIt-Anchor" href="#限制字符数量-"></a> 限制字符数量 - {}</h3>
<p>如果想要控制字符出现的次数，可以使用<code>{}</code>。</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>{n}</code></td>
<td>n 是一个非负整数。匹配确定的 n 次。</td>
</tr>
<tr>
<td><code>{n,}</code></td>
<td>n 是一个非负整数。至少匹配 n 次。</td>
</tr>
<tr>
<td><code>{n,m}</code></td>
<td>m 和 n 均为非负整数，其中 n &lt;= m。最少匹配 n 次且最多匹配 m 次。</td>
</tr>
</tbody>
</table>
<p><strong>例 限制字符出现次数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &#123;n&#125;: n 是一个非负整数。匹配确定的 n 次。</span></span><br><span class="line">checkMatches(<span class="string">"ap&#123;1&#125;"</span>, <span class="string">"a"</span>);</span><br><span class="line">checkMatches(<span class="string">"ap&#123;1&#125;"</span>, <span class="string">"ap"</span>);</span><br><span class="line">checkMatches(<span class="string">"ap&#123;1&#125;"</span>, <span class="string">"app"</span>);</span><br><span class="line">checkMatches(<span class="string">"ap&#123;1&#125;"</span>, <span class="string">"apppppppppp"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;n,&#125;: n 是一个非负整数。至少匹配 n 次。</span></span><br><span class="line">checkMatches(<span class="string">"ap&#123;1,&#125;"</span>, <span class="string">"a"</span>);</span><br><span class="line">checkMatches(<span class="string">"ap&#123;1,&#125;"</span>, <span class="string">"ap"</span>);</span><br><span class="line">checkMatches(<span class="string">"ap&#123;1,&#125;"</span>, <span class="string">"app"</span>);</span><br><span class="line">checkMatches(<span class="string">"ap&#123;1,&#125;"</span>, <span class="string">"apppppppppp"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;n,m&#125;: m 和 n 均为非负整数，其中 n &lt;= m。最少匹配 n 次且最多匹配 m 次。</span></span><br><span class="line">checkMatches(<span class="string">"ap&#123;2,5&#125;"</span>, <span class="string">"a"</span>);</span><br><span class="line">checkMatches(<span class="string">"ap&#123;2,5&#125;"</span>, <span class="string">"ap"</span>);</span><br><span class="line">checkMatches(<span class="string">"ap&#123;2,5&#125;"</span>, <span class="string">"app"</span>);</span><br><span class="line">checkMatches(<span class="string">"ap&#123;2,5&#125;"</span>, <span class="string">"apppppppppp"</span>);</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong></p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">a<span class="built_in">	not</span><span class="built_in"> matches</span>： ap&#123;<span class="number">1</span>&#125;</span><br><span class="line">ap<span class="built_in">	matches</span>： ap&#123;<span class="number">1</span>&#125;</span><br><span class="line">app<span class="built_in">	not</span><span class="built_in"> matches</span>： ap&#123;<span class="number">1</span>&#125;</span><br><span class="line">apppppppppp<span class="built_in">	not</span><span class="built_in"> matches</span>： ap&#123;<span class="number">1</span>&#125;</span><br><span class="line">a<span class="built_in">	not</span><span class="built_in"> matches</span>： ap&#123;<span class="number">1</span>,&#125;</span><br><span class="line">ap<span class="built_in">	matches</span>： ap&#123;<span class="number">1</span>,&#125;</span><br><span class="line">app<span class="built_in">	matches</span>： ap&#123;<span class="number">1</span>,&#125;</span><br><span class="line">apppppppppp<span class="built_in">	matches</span>： ap&#123;<span class="number">1</span>,&#125;</span><br><span class="line">a<span class="built_in">	not</span><span class="built_in"> matches</span>： ap&#123;<span class="number">2</span>,<span class="number">5</span>&#125;</span><br><span class="line">ap<span class="built_in">	not</span><span class="built_in"> matches</span>： ap&#123;<span class="number">2</span>,<span class="number">5</span>&#125;</span><br><span class="line">app<span class="built_in">	matches</span>： ap&#123;<span class="number">2</span>,<span class="number">5</span>&#125;</span><br><span class="line">apppppppppp<span class="built_in">	not</span><span class="built_in"> matches</span>： ap&#123;<span class="number">2</span>,<span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="转义字符-"><a class="markdownIt-Anchor" href="#转义字符-"></a> 转义字符 - /</h3>
<p>如果想要查找元字符本身，你需要使用转义符，使得正则引擎将其视作一个普通字符，而不是一个元字符去处理。</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">* 的转义字符：<span class="string">\*</span></span><br><span class="line">+ 的转义字符：<span class="string">\+</span></span><br><span class="line">? 的转义字符：<span class="string">\?</span></span><br><span class="line">^ 的转义字符：<span class="string">\^</span></span><br><span class="line">$ 的转义字符：<span class="string">\$</span></span><br><span class="line">. 的转义字符：<span class="string">\.</span></span><br></pre></td></tr></table></figure>
<p>如果是转义符<code>\</code>本身，你也需要使用<code>\\</code> 。</p>
<h3 id="指定表达式字符串的开始和结尾-"><a class="markdownIt-Anchor" href="#指定表达式字符串的开始和结尾-"></a> 指定表达式字符串的开始和结尾 - ^、$</h3>
<p>如果希望匹配的字符串必须以特定字符串开头，可以使用<code>^</code> 。</p>
<p>注：请特别留意，这里的<code>^</code> 一定要和 <code>[^]</code> 中的 “^” 区分。</p>
<p><strong>例 限制字符串头部</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Assert.assertTrue(checkMatches(<span class="string">"^app[a-z]&#123;0,&#125;"</span>, <span class="string">"apple"</span>)); <span class="comment">// 字符串必须以app开头</span></span><br><span class="line">Assert.assertFalse(checkMatches(<span class="string">"^app[a-z]&#123;0,&#125;"</span>, <span class="string">"aplause"</span>));</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong></p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">apple<span class="built_in">	matches</span>： ^app[a-z]&#123;<span class="number">0</span>,&#125;</span><br><span class="line">aplause<span class="built_in">	not</span><span class="built_in"> matches</span>： ^app[a-z]&#123;<span class="number">0</span>,&#125;</span><br></pre></td></tr></table></figure>
<p>如果希望匹配的字符串必须以特定字符串开头，可以使用<code>$</code> 。</p>
<p><strong>例 限制字符串尾部</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Assert.assertTrue(checkMatches(<span class="string">"[a-z]&#123;0,&#125;ing$"</span>, <span class="string">"playing"</span>)); <span class="comment">// 字符串必须以ing结尾</span></span><br><span class="line">Assert.assertFalse(checkMatches(<span class="string">"[a-z]&#123;0,&#125;ing$"</span>, <span class="string">"long"</span>));</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong></p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">playing<span class="built_in">	matches</span>： [a-z]&#123;<span class="number">0</span>,&#125;ing$</span><br><span class="line">long<span class="built_in">	not</span><span class="built_in"> matches</span>： [a-z]&#123;<span class="number">0</span>,&#125;ing$</span><br></pre></td></tr></table></figure>
<h2 id="等价字符"><a class="markdownIt-Anchor" href="#等价字符"></a> 等价字符</h2>
<p>等价字符，顾名思义，就是对于基本元字符表达的一种简化（等价字符的功能都可以通过基本元字符来实现）。</p>
<p>在没有掌握基本元字符之前，可以先不用理会，因为很容易把人绕晕。</p>
<p>等价字符的好处在于简化了基本元字符的写法。</p>
<h3 id="表示某一类型字符的等价字符"><a class="markdownIt-Anchor" href="#表示某一类型字符的等价字符"></a> 表示某一类型字符的等价字符</h3>
<p>下表中的等价字符都表示某一类型的字符。</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>.</code></strong></td>
<td>匹配除“\n”之外的任何单个字符。</td>
</tr>
<tr>
<td><strong><code>\d</code></strong></td>
<td>匹配一个数字字符。等价于[0-9]。</td>
</tr>
<tr>
<td><strong><code>\D</code></strong></td>
<td>匹配一个非数字字符。等价于[^0-9]。</td>
</tr>
<tr>
<td><strong><code>\w</code></strong></td>
<td>匹配包括下划线的任何单词字符。类似但不等价于“[A-Za-z0-9_]”，这里的单词字符指的是 Unicode 字符集。</td>
</tr>
<tr>
<td><strong><code>\W</code></strong></td>
<td>匹配任何非单词字符。</td>
</tr>
<tr>
<td><strong><code>\s</code></strong></td>
<td>匹配任何不可见字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。</td>
</tr>
<tr>
<td><strong><code>\S</code></strong></td>
<td>匹配任何可见字符。等价于[ \f\n\r\t\v]。</td>
</tr>
</tbody>
</table>
<p><strong>案例 基本等价字符的用法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配除“\n”之外的任何单个字符</span></span><br><span class="line">Assert.assertTrue(checkMatches(<span class="string">".&#123;1,&#125;"</span>, <span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_"</span>));</span><br><span class="line">Assert.assertTrue(checkMatches(<span class="string">".&#123;1,&#125;"</span>, <span class="string">"~!@#$%^&amp;*()+`-=[]&#123;&#125;;:&lt;&gt;,./?|\\"</span>));</span><br><span class="line">Assert.assertFalse(checkMatches(<span class="string">"."</span>, <span class="string">"\n"</span>));</span><br><span class="line">Assert.assertFalse(checkMatches(<span class="string">"[^\n]"</span>, <span class="string">"\n"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配一个数字字符。等价于[0-9]</span></span><br><span class="line">Assert.assertTrue(checkMatches(<span class="string">"\\d&#123;1,&#125;"</span>, <span class="string">"0123456789"</span>));</span><br><span class="line"><span class="comment">// 匹配一个非数字字符。等价于[^0-9]</span></span><br><span class="line">Assert.assertFalse(checkMatches(<span class="string">"\\D&#123;1,&#125;"</span>, <span class="string">"0123456789"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配包括下划线的任何单词字符。类似但不等价于“[A-Za-z0-9_]”，这里的单词字符指的是Unicode字符集</span></span><br><span class="line">Assert.assertTrue(checkMatches(<span class="string">"\\w&#123;1,&#125;"</span>, <span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_"</span>));</span><br><span class="line">Assert.assertFalse(checkMatches(<span class="string">"\\w&#123;1,&#125;"</span>, <span class="string">"~!@#$%^&amp;*()+`-=[]&#123;&#125;;:&lt;&gt;,./?|\\"</span>));</span><br><span class="line"><span class="comment">// 匹配任何非单词字符</span></span><br><span class="line">Assert.assertFalse(checkMatches(<span class="string">"\\W&#123;1,&#125;"</span>, <span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_"</span>));</span><br><span class="line">Assert.assertTrue(checkMatches(<span class="string">"\\W&#123;1,&#125;"</span>, <span class="string">"~!@#$%^&amp;*()+`-=[]&#123;&#125;;:&lt;&gt;,./?|\\"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配任何不可见字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]</span></span><br><span class="line">Assert.assertTrue(checkMatches(<span class="string">"\\s&#123;1,&#125;"</span>, <span class="string">" \f\r\n\t"</span>));</span><br><span class="line"><span class="comment">// 匹配任何可见字符。等价于[^ \f\n\r\t\v]</span></span><br><span class="line">Assert.assertFalse(checkMatches(<span class="string">"\\S&#123;1,&#125;"</span>, <span class="string">" \f\r\n\t"</span>));</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_	matches： .&#123;1,&#125;</span><br><span class="line">~!@#<span class="formula">$%^&amp;*()+`-=[]&#123;&#125;;:&lt;&gt;,./?|<span class="tag">\<span class="name">\</span></span>	matches： .&#123;1,&#125;</span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">n</span></span>	not matches： .</span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">n</span></span>	not matches： [^<span class="tag">\<span class="name">n</span></span>]</span></span><br><span class="line"><span class="formula">0123456789	matches： <span class="tag">\<span class="name">\</span></span>d&#123;1,&#125;</span></span><br><span class="line"><span class="formula">0123456789	not matches： <span class="tag">\<span class="name">\</span></span>D&#123;1,&#125;</span></span><br><span class="line"><span class="formula">ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_	matches： <span class="tag">\<span class="name">\</span></span>w&#123;1,&#125;</span></span><br><span class="line"><span class="formula">~!@#$</span><span class="comment">%^&amp;*()+`-=[]&#123;&#125;;:&lt;&gt;,./?|\\	not matches： \\w&#123;1,&#125;</span></span><br><span class="line">ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_	not matches： <span class="tag">\<span class="name">\</span></span>W&#123;1,&#125;</span><br><span class="line">~!@#<span class="formula">$%^&amp;*()+`-=[]&#123;&#125;;:&lt;&gt;,./?|<span class="tag">\<span class="name">\</span></span>	matches： <span class="tag">\<span class="name">\</span></span>W&#123;1,&#125;</span></span><br><span class="line"><span class="formula"> <span class="tag">\<span class="name">f</span></span><span class="tag">\<span class="name">r</span></span><span class="tag">\<span class="name">n</span></span><span class="tag">\<span class="name">t</span></span>	matches： <span class="tag">\<span class="name">\</span></span>s&#123;1,&#125;</span></span><br><span class="line"><span class="formula"> <span class="tag">\<span class="name">f</span></span><span class="tag">\<span class="name">r</span></span><span class="tag">\<span class="name">n</span></span><span class="tag">\<span class="name">t</span></span>	not matches： <span class="tag">\<span class="name">\</span></span>S&#123;1,&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="限制字符数量的等价字符"><a class="markdownIt-Anchor" href="#限制字符数量的等价字符"></a> 限制字符数量的等价字符</h3>
<p>在基本元字符章节中，已经介绍了限制字符数量的基本元字符 - <code>{}</code> 。</p>
<p>此外，还有 <code>*</code>、<code>+</code>、<code>?</code> 这个三个为了简化写法而出现的等价字符，我们来认识一下。</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>*</code></td>
<td>匹配前面的子表达式零次或多次。等价于{0,}。</td>
</tr>
<tr>
<td><code>+</code></td>
<td>匹配前面的子表达式一次或多次。等价于{1,}。</td>
</tr>
<tr>
<td><code>?</code></td>
<td>匹配前面的子表达式零次或一次。等价于 {0,1}。</td>
</tr>
</tbody>
</table>
<p><strong>案例 限制字符数量的等价字符</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// *: 匹配前面的子表达式零次或多次。* 等价于&#123;0,&#125;。</span></span><br><span class="line">checkMatches(<span class="string">"ap*"</span>, <span class="string">"a"</span>);</span><br><span class="line">checkMatches(<span class="string">"ap*"</span>, <span class="string">"ap"</span>);</span><br><span class="line">checkMatches(<span class="string">"ap*"</span>, <span class="string">"app"</span>);</span><br><span class="line">checkMatches(<span class="string">"ap*"</span>, <span class="string">"apppppppppp"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// +: 匹配前面的子表达式一次或多次。+ 等价于 &#123;1,&#125;。</span></span><br><span class="line">checkMatches(<span class="string">"ap+"</span>, <span class="string">"a"</span>);</span><br><span class="line">checkMatches(<span class="string">"ap+"</span>, <span class="string">"ap"</span>);</span><br><span class="line">checkMatches(<span class="string">"ap+"</span>, <span class="string">"app"</span>);</span><br><span class="line">checkMatches(<span class="string">"ap+"</span>, <span class="string">"apppppppppp"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ?: 匹配前面的子表达式零次或一次。? 等价于 &#123;0,1&#125;。</span></span><br><span class="line">checkMatches(<span class="string">"ap?"</span>, <span class="string">"a"</span>);</span><br><span class="line">checkMatches(<span class="string">"ap?"</span>, <span class="string">"ap"</span>);</span><br><span class="line">checkMatches(<span class="string">"ap?"</span>, <span class="string">"app"</span>);</span><br><span class="line">checkMatches(<span class="string">"ap?"</span>, <span class="string">"apppppppppp"</span>);</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong></p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">a	matches： <span class="keyword">ap</span>*</span><br><span class="line"><span class="keyword">ap</span>	matches： <span class="keyword">ap</span>*</span><br><span class="line"><span class="keyword">app</span>	matches： <span class="keyword">ap</span>*</span><br><span class="line">apppppppppp	matches： <span class="keyword">ap</span>*</span><br><span class="line">a	not matches： <span class="keyword">ap</span>+</span><br><span class="line"><span class="keyword">ap</span>	matches： <span class="keyword">ap</span>+</span><br><span class="line"><span class="keyword">app</span>	matches： <span class="keyword">ap</span>+</span><br><span class="line">apppppppppp	matches： <span class="keyword">ap</span>+</span><br><span class="line">a	matches： <span class="keyword">ap</span>?</span><br><span class="line"><span class="keyword">ap</span>	matches： <span class="keyword">ap</span>?</span><br><span class="line"><span class="keyword">app</span>	not matches： <span class="keyword">ap</span>?</span><br><span class="line">apppppppppp	not matches： <span class="keyword">ap</span>?</span><br></pre></td></tr></table></figure>
<h2 id="元字符优先级顺序"><a class="markdownIt-Anchor" href="#元字符优先级顺序"></a> 元字符优先级顺序</h2>
<p>正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。</p>
<p>下表从最高到最低说明了各种正则表达式运算符的优先级顺序：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>\</td>
<td>转义符</td>
</tr>
<tr>
<td>(), (?😃, (?=), []</td>
<td>括号和中括号</td>
</tr>
<tr>
<td>*, +, ?, {n}, {n,}, {n,m}</td>
<td>限定符</td>
</tr>
<tr>
<td>^, $, *任何元字符、任何字符*</td>
<td>定位点和序列</td>
</tr>
<tr>
<td>|</td>
<td>替换</td>
</tr>
</tbody>
</table>
<p>字符具有高于替换运算符的优先级，使得“m|food”匹配“m”或“food”。若要匹配“mood”或“food”，请使用括号创建子表达式，从而产生“(m|f)ood”。</p>
<h2 id="分组构造"><a class="markdownIt-Anchor" href="#分组构造"></a> 分组构造</h2>
<p>在基本元字符章节，提到了 <code>()</code> 字符可以用来对表达式分组。实际上分组还有更多复杂的用法。</p>
<p>所谓分组构造，是用来描述正则表达式的子表达式，用于捕获字符串中的子字符串。</p>
<h2 id="捕获与非捕获"><a class="markdownIt-Anchor" href="#捕获与非捕获"></a> 捕获与非捕获</h2>
<p>下表为分组构造中的捕获和非捕获分类。</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>描述</th>
<th>捕获或非捕获</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>(exp)</code></td>
<td>匹配的子表达式</td>
<td>捕获</td>
</tr>
<tr>
<td><code>(?&lt;name&gt;exp)</code></td>
<td>命名的反向引用</td>
<td>捕获</td>
</tr>
<tr>
<td><code>(?:exp)</code></td>
<td>非捕获组</td>
<td>非捕获</td>
</tr>
<tr>
<td><code>(?=exp)</code></td>
<td>零宽度正预测先行断言</td>
<td>非捕获</td>
</tr>
<tr>
<td><code>(?!exp)</code></td>
<td>零宽度负预测先行断言</td>
<td>非捕获</td>
</tr>
<tr>
<td><code>(?&lt;=exp)</code></td>
<td>零宽度正回顾后发断言</td>
<td>非捕获</td>
</tr>
<tr>
<td><code>(?&lt;!exp)</code></td>
<td>零宽度负回顾后发断言</td>
<td>非捕获</td>
</tr>
</tbody>
</table>
<p>注：Java 正则引擎不支持平衡组。</p>
<h2 id="反向引用"><a class="markdownIt-Anchor" href="#反向引用"></a> 反向引用</h2>
<h3 id="带编号的反向引用"><a class="markdownIt-Anchor" href="#带编号的反向引用"></a> 带编号的反向引用</h3>
<p>带编号的反向引用使用以下语法：<code>\number</code></p>
<p>其中<em>number</em> 是正则表达式中捕获组的序号位置。 例如，\4 匹配第四个捕获组的内容。 如果正则表达式模式中未定义<em>number</em>，则将发生分析错误</p>
<p><strong>例 匹配重复的单词和紧随每个重复的单词的单词(不命名子表达式)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// (\w+)\s\1\W(\w+) 匹配重复的单词和紧随每个重复的单词的单词</span></span><br><span class="line">Assert.assertTrue(findAll(<span class="string">"(\\w+)\\s\\1\\W(\\w+)"</span>,</span><br><span class="line">		<span class="string">"He said that that was the the correct answer."</span>) &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">regex</span> <span class="string">=</span> <span class="string">(\w+)\s\1\W(\w+),</span> <span class="attr">content:</span> <span class="string">He</span> <span class="string">said</span> <span class="string">that</span> <span class="string">that</span> <span class="string">was</span> <span class="string">the</span> <span class="string">the</span> <span class="string">correct</span> <span class="string">answer.</span></span><br><span class="line"><span class="string">[1th]</span> <span class="attr">start:</span> <span class="number">8</span><span class="string">,</span> <span class="attr">end:</span> <span class="number">21</span><span class="string">,</span> <span class="attr">group:</span> <span class="string">that</span> <span class="string">that</span> <span class="string">was</span></span><br><span class="line"><span class="string">[2th]</span> <span class="attr">start:</span> <span class="number">22</span><span class="string">,</span> <span class="attr">end:</span> <span class="number">37</span><span class="string">,</span> <span class="attr">group:</span> <span class="string">the</span> <span class="string">the</span> <span class="string">correct</span></span><br></pre></td></tr></table></figure>
<p><strong>说明</strong></p>
<p>(\w+): 匹配一个或多个单词字符。<br />
\s: 与空白字符匹配。<br />
\1: 匹配第一个组，即(\w+)。<br />
\W: 匹配包括空格和标点符号的一个非单词字符。 这样可以防止正则表达式模式匹配从第一个捕获组的单词开头的单词。</p>
<h3 id="命名的反向引用"><a class="markdownIt-Anchor" href="#命名的反向引用"></a> 命名的反向引用</h3>
<p>命名后向引用通过使用下面的语法进行定义：<code>\k&lt;name &gt;</code></p>
<p><strong>例 匹配重复的单词和紧随每个重复的单词的单词(命名子表达式)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// (?&lt;duplicateWord&gt;\w+)\s\k&lt;duplicateWord&gt;\W(?&lt;nextWord&gt;\w+) 匹配重复的单词和紧随每个重复的单词的单词</span></span><br><span class="line">Assert.assertTrue(findAll(<span class="string">"(?&lt;duplicateWord&gt;\\w+)\\s\\k&lt;duplicateWord&gt;\\W(?&lt;nextWord&gt;\\w+)"</span>,</span><br><span class="line">		<span class="string">"He said that that was the the correct answer."</span>) &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">regex</span> <span class="string">=</span> <span class="string">(?&lt;duplicateWord&gt;\w+)\s\k&lt;duplicateWord&gt;\W(?&lt;nextWord&gt;\w+),</span> <span class="attr">content:</span> <span class="string">He</span> <span class="string">said</span> <span class="string">that</span> <span class="string">that</span> <span class="string">was</span> <span class="string">the</span> <span class="string">the</span> <span class="string">correct</span> <span class="string">answer.</span></span><br><span class="line"><span class="string">[1th]</span> <span class="attr">start:</span> <span class="number">8</span><span class="string">,</span> <span class="attr">end:</span> <span class="number">21</span><span class="string">,</span> <span class="attr">group:</span> <span class="string">that</span> <span class="string">that</span> <span class="string">was</span></span><br><span class="line"><span class="string">[2th]</span> <span class="attr">start:</span> <span class="number">22</span><span class="string">,</span> <span class="attr">end:</span> <span class="number">37</span><span class="string">,</span> <span class="attr">group:</span> <span class="string">the</span> <span class="string">the</span> <span class="string">correct</span></span><br></pre></td></tr></table></figure>
<p><strong>说明</strong></p>
<p>(?<duplicateWord>\w+): 匹配一个或多个单词字符。 命名此捕获组 duplicateWord。<br />
\s: 与空白字符匹配。<br />
\k<duplicateWord>: 匹配名为 duplicateWord 的捕获的组。<br />
\W: 匹配包括空格和标点符号的一个非单词字符。 这样可以防止正则表达式模式匹配从第一个捕获组的单词开头的单词。<br />
(?<nextWord>\w+): 匹配一个或多个单词字符。 命名此捕获组 nextWord。</p>
<h2 id="非捕获组"><a class="markdownIt-Anchor" href="#非捕获组"></a> 非捕获组</h2>
<p><code>(?:exp)</code> 表示当一个限定符应用到一个组，但组捕获的子字符串并非所需时，通常会使用非捕获组构造。</p>
<p><strong>例 匹配以.结束的语句。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配由句号终止的语句。</span></span><br><span class="line">Assert.assertTrue(findAll(<span class="string">"(?:\\b(?:\\w+)\\W*)+\\."</span>, <span class="string">"This is a short sentence. Never end"</span>) &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">regex = (?:\b(?:\w+)\W*)+\., <span class="string">content:</span> This is a <span class="keyword">short</span> sentence. Never end</span><br><span class="line">[<span class="number">1</span>th] <span class="string">start:</span> <span class="number">0</span>, <span class="string">end:</span> <span class="number">25</span>, <span class="string">group:</span> This is a <span class="keyword">short</span> sentence.</span><br></pre></td></tr></table></figure>
<h2 id="零宽断言"><a class="markdownIt-Anchor" href="#零宽断言"></a> 零宽断言</h2>
<p>用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言。</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>(?=exp)</code></td>
<td>匹配 exp 前面的位置</td>
</tr>
<tr>
<td><code>(?&lt;=exp)</code></td>
<td>匹配 exp 后面的位置</td>
</tr>
<tr>
<td><code>(?!exp)</code></td>
<td>匹配后面跟的不是 exp 的位置</td>
</tr>
<tr>
<td><code>(?&lt;!exp)</code></td>
<td>匹配前面不是 exp 的位置</td>
</tr>
</tbody>
</table>
<h3 id="匹配-exp-前面的位置"><a class="markdownIt-Anchor" href="#匹配-exp-前面的位置"></a> 匹配 exp 前面的位置</h3>
<p><code>(?=exp)</code> 表示输入字符串必须匹配<em>子表达式</em>中的正则表达式模式，尽管匹配的子字符串未包含在匹配结果中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// \b\w+(?=\sis\b) 表示要捕获is之前的单词</span></span><br><span class="line">Assert.assertTrue(findAll(<span class="string">"\\b\\w+(?=\\sis\\b)"</span>, <span class="string">"The dog is a Malamute."</span>) &gt; <span class="number">0</span>);</span><br><span class="line">Assert.assertFalse(findAll(<span class="string">"\\b\\w+(?=\\sis\\b)"</span>, <span class="string">"The island has beautiful birds."</span>) &gt; <span class="number">0</span>);</span><br><span class="line">Assert.assertFalse(findAll(<span class="string">"\\b\\w+(?=\\sis\\b)"</span>, <span class="string">"The pitch missed home plate."</span>) &gt; <span class="number">0</span>);</span><br><span class="line">Assert.assertTrue(findAll(<span class="string">"\\b\\w+(?=\\sis\\b)"</span>, <span class="string">"Sunday is a weekend day."</span>) &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">regex = <span class="symbol">\b</span><span class="symbol">\w</span>+(?=<span class="symbol">\s</span>is<span class="symbol">\b</span>), content: The dog is a Malamute.</span><br><span class="line">[1th] start: 4, end: 7, group: dog</span><br><span class="line">regex = <span class="symbol">\b</span><span class="symbol">\w</span>+(?=<span class="symbol">\s</span>is<span class="symbol">\b</span>), content: The island has beautiful birds.</span><br><span class="line">not found</span><br><span class="line">regex = <span class="symbol">\b</span><span class="symbol">\w</span>+(?=<span class="symbol">\s</span>is<span class="symbol">\b</span>), content: The pitch missed home plate.</span><br><span class="line">not found</span><br><span class="line">regex = <span class="symbol">\b</span><span class="symbol">\w</span>+(?=<span class="symbol">\s</span>is<span class="symbol">\b</span>), content: Sunday is a weekend day.</span><br><span class="line">[1th] start: 0, end: 6, group: Sunday</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong></p>
<p>\b: 在单词边界处开始匹配。</p>
<p>\w+: 匹配一个或多个单词字符。</p>
<p>(?=\sis\b): 确定单词字符是否后接空白字符和字符串“is”，其在单词边界处结束。 如果如此，则匹配成功。</p>
<h3 id="匹配-exp-后面的位置"><a class="markdownIt-Anchor" href="#匹配-exp-后面的位置"></a> 匹配 exp 后面的位置</h3>
<p><code>(?&lt;=exp)</code> 表示子表达式不得在输入字符串当前位置左侧出现，尽管子表达式未包含在匹配结果中。零宽度正回顾后发断言不会回溯。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// (?&lt;=\b20)\d&#123;2&#125;\b 表示要捕获以20开头的数字的后面部分</span></span><br><span class="line">Assert.assertTrue(findAll(<span class="string">"(?&lt;=\\b20)\\d&#123;2&#125;\\b"</span>, <span class="string">"2010 1999 1861 2140 2009"</span>) &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">regex</span> <span class="string">=</span> <span class="string">(?&lt;=\b20)\d&#123;2&#125;\b,</span> <span class="attr">content:</span> <span class="number">2010</span> <span class="number">1999</span> <span class="number">1861</span> <span class="number">2140</span> <span class="number">2009</span></span><br><span class="line"><span class="string">[1th]</span> <span class="attr">start:</span> <span class="number">2</span><span class="string">,</span> <span class="attr">end:</span> <span class="number">4</span><span class="string">,</span> <span class="attr">group:</span> <span class="number">10</span></span><br><span class="line"><span class="string">[2th]</span> <span class="attr">start:</span> <span class="number">22</span><span class="string">,</span> <span class="attr">end:</span> <span class="number">24</span><span class="string">,</span> <span class="attr">group:</span> <span class="number">09</span></span><br></pre></td></tr></table></figure>
<p><strong>说明</strong></p>
<p>\d{2}: 匹配两个十进制数字。</p>
<p>{?&lt;=\b20): 如果两个十进制数字的字边界以小数位数“20”开头，则继续匹配。</p>
<p>\b: 在单词边界处结束匹配。</p>
<h3 id="匹配后面跟的不是-exp-的位置"><a class="markdownIt-Anchor" href="#匹配后面跟的不是-exp-的位置"></a> 匹配后面跟的不是 exp 的位置</h3>
<p><code>(?!exp)</code> 表示输入字符串不得匹配<em>子表达式</em>中的正则表达式模式，尽管匹配的子字符串未包含在匹配结果中。</p>
<p><strong>例 捕获未以“un”开头的单词</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// \b(?!un)\w+\b 表示要捕获未以“un”开头的单词</span></span><br><span class="line">Assert.assertTrue(findAll(<span class="string">"\\b(?!un)\\w+\\b"</span>, <span class="string">"unite one unethical ethics use untie ultimate"</span>) &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">regex</span> <span class="string">=</span> <span class="string">\b(?!un)\w+\b,</span> <span class="attr">content:</span> <span class="string">unite</span> <span class="string">one</span> <span class="string">unethical</span> <span class="string">ethics</span> <span class="string">use</span> <span class="string">untie</span> <span class="string">ultimate</span></span><br><span class="line"><span class="string">[1th]</span> <span class="attr">start:</span> <span class="number">6</span><span class="string">,</span> <span class="attr">end:</span> <span class="number">9</span><span class="string">,</span> <span class="attr">group:</span> <span class="string">one</span></span><br><span class="line"><span class="string">[2th]</span> <span class="attr">start:</span> <span class="number">20</span><span class="string">,</span> <span class="attr">end:</span> <span class="number">26</span><span class="string">,</span> <span class="attr">group:</span> <span class="string">ethics</span></span><br><span class="line"><span class="string">[3th]</span> <span class="attr">start:</span> <span class="number">27</span><span class="string">,</span> <span class="attr">end:</span> <span class="number">30</span><span class="string">,</span> <span class="attr">group:</span> <span class="string">use</span></span><br><span class="line"><span class="string">[4th]</span> <span class="attr">start:</span> <span class="number">37</span><span class="string">,</span> <span class="attr">end:</span> <span class="number">45</span><span class="string">,</span> <span class="attr">group:</span> <span class="string">ultimate</span></span><br></pre></td></tr></table></figure>
<p><strong>说明</strong></p>
<p>\b: 在单词边界处开始匹配。</p>
<p>(?!un): 确定接下来的两个的字符是否为“un”。 如果没有，则可能匹配。</p>
<p>\w+: 匹配一个或多个单词字符。</p>
<p>\b: 在单词边界处结束匹配。</p>
<h3 id="匹配前面不是-exp-的位置"><a class="markdownIt-Anchor" href="#匹配前面不是-exp-的位置"></a> 匹配前面不是 exp 的位置</h3>
<p><code>(?&lt;!exp)</code> 表示子表达式不得在输入字符串当前位置的左侧出现。 但是，任何不匹配子表达式 的子字符串不包含在匹配结果中。</p>
<p><strong>例 捕获任意工作日</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// (?&lt;!(Saturday|Sunday) )\b\w+ \d&#123;1,2&#125;, \d&#123;4&#125;\b 表示要捕获任意工作日（即周一到周五）</span></span><br><span class="line">Assert.assertTrue(findAll(<span class="string">"(?&lt;!(Saturday|Sunday) )\\b\\w+ \\d&#123;1,2&#125;, \\d&#123;4&#125;\\b"</span>, <span class="string">"Monday February 1, 2010"</span>) &gt; <span class="number">0</span>);</span><br><span class="line">Assert.assertTrue(findAll(<span class="string">"(?&lt;!(Saturday|Sunday) )\\b\\w+ \\d&#123;1,2&#125;, \\d&#123;4&#125;\\b"</span>, <span class="string">"Wednesday February 3, 2010"</span>) &gt; <span class="number">0</span>);</span><br><span class="line">Assert.assertFalse(findAll(<span class="string">"(?&lt;!(Saturday|Sunday) )\\b\\w+ \\d&#123;1,2&#125;, \\d&#123;4&#125;\\b"</span>, <span class="string">"Saturday February 6, 2010"</span>) &gt; <span class="number">0</span>);</span><br><span class="line">Assert.assertFalse(findAll(<span class="string">"(?&lt;!(Saturday|Sunday) )\\b\\w+ \\d&#123;1,2&#125;, \\d&#123;4&#125;\\b"</span>, <span class="string">"Sunday February 7, 2010"</span>) &gt; <span class="number">0</span>);</span><br><span class="line">Assert.assertTrue(findAll(<span class="string">"(?&lt;!(Saturday|Sunday) )\\b\\w+ \\d&#123;1,2&#125;, \\d&#123;4&#125;\\b"</span>, <span class="string">"Monday, February 8, 2010"</span>) &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">regex = (?&lt;!(Saturday|Sunday) )\b\w+ \d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;, \d&#123;<span class="number">4</span>&#125;\b, content: Monday February <span class="number">1</span>, <span class="number">2010</span></span><br><span class="line">[<span class="number">1</span>th] start: <span class="number">7</span>, end: <span class="number">23</span>, group: February <span class="number">1</span>, <span class="number">2010</span></span><br><span class="line">regex = (?&lt;!(Saturday|Sunday) )\b\w+ \d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;, \d&#123;<span class="number">4</span>&#125;\b, content: Wednesday February <span class="number">3</span>, <span class="number">2010</span></span><br><span class="line">[<span class="number">1</span>th] start: <span class="number">10</span>, end: <span class="number">26</span>, group: February <span class="number">3</span>, <span class="number">2010</span></span><br><span class="line">regex = (?&lt;!(Saturday|Sunday) )\b\w+ \d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;, \d&#123;<span class="number">4</span>&#125;\b, content: Saturday February <span class="number">6</span>, <span class="number">2010</span></span><br><span class="line"><span class="keyword">not</span> found</span><br><span class="line">regex = (?&lt;!(Saturday|Sunday) )\b\w+ \d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;, \d&#123;<span class="number">4</span>&#125;\b, content: Sunday February <span class="number">7</span>, <span class="number">2010</span></span><br><span class="line"><span class="keyword">not</span> found</span><br><span class="line">regex = (?&lt;!(Saturday|Sunday) )\b\w+ \d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;, \d&#123;<span class="number">4</span>&#125;\b, content: Monday, February <span class="number">8</span>, <span class="number">2010</span></span><br><span class="line">[<span class="number">1</span>th] start: <span class="number">8</span>, end: <span class="number">24</span>, group: February <span class="number">8</span>, <span class="number">2010</span></span><br></pre></td></tr></table></figure>
<h2 id="贪婪与懒惰"><a class="markdownIt-Anchor" href="#贪婪与懒惰"></a> 贪婪与懒惰</h2>
<p>当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配<strong>尽可能多</strong>的字符。以这个表达式为例：a.*b，它将会匹配最长的以 a 开始，以 b 结束的字符串。如果用它来搜索 aabab 的话，它会匹配整个字符串 aabab。这被称为贪婪匹配。</p>
<p>有时，我们更需要懒惰匹配，也就是匹配<strong>尽可能少</strong>的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。这样.*?就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>*?</code></td>
<td>重复任意次，但尽可能少重复</td>
</tr>
<tr>
<td><code>+?</code></td>
<td>重复 1 次或更多次，但尽可能少重复</td>
</tr>
<tr>
<td><code>??</code></td>
<td>重复 0 次或 1 次，但尽可能少重复</td>
</tr>
<tr>
<td><code>{n,m}?</code></td>
<td>重复 n 到 m 次，但尽可能少重复</td>
</tr>
<tr>
<td><code>{n,}?</code></td>
<td>重复 n 次以上，但尽可能少重复</td>
</tr>
</tbody>
</table>
<p><strong>例 Java 正则中贪婪与懒惰的示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 贪婪匹配</span></span><br><span class="line">Assert.assertTrue(findAll(<span class="string">"a\\w*b"</span>, <span class="string">"abaabaaabaaaab"</span>) &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 懒惰匹配</span></span><br><span class="line">Assert.assertTrue(findAll(<span class="string">"a\\w*?b"</span>, <span class="string">"abaabaaabaaaab"</span>) &gt; <span class="number">0</span>);</span><br><span class="line">Assert.assertTrue(findAll(<span class="string">"a\\w+?b"</span>, <span class="string">"abaabaaabaaaab"</span>) &gt; <span class="number">0</span>);</span><br><span class="line">Assert.assertTrue(findAll(<span class="string">"a\\w??b"</span>, <span class="string">"abaabaaabaaaab"</span>) &gt; <span class="number">0</span>);</span><br><span class="line">Assert.assertTrue(findAll(<span class="string">"a\\w&#123;0,4&#125;?b"</span>, <span class="string">"abaabaaabaaaab"</span>) &gt; <span class="number">0</span>);</span><br><span class="line">Assert.assertTrue(findAll(<span class="string">"a\\w&#123;3,&#125;?b"</span>, <span class="string">"abaabaaabaaaab"</span>) &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">regex</span> <span class="string">=</span> <span class="string">a\w*b,</span> <span class="attr">content:</span> <span class="string">abaabaaabaaaab</span></span><br><span class="line"><span class="string">[1th]</span> <span class="attr">start:</span> <span class="number">0</span><span class="string">,</span> <span class="attr">end:</span> <span class="number">14</span><span class="string">,</span> <span class="attr">group:</span> <span class="string">abaabaaabaaaab</span></span><br><span class="line"><span class="string">regex</span> <span class="string">=</span> <span class="string">a\w*?b,</span> <span class="attr">content:</span> <span class="string">abaabaaabaaaab</span></span><br><span class="line"><span class="string">[1th]</span> <span class="attr">start:</span> <span class="number">0</span><span class="string">,</span> <span class="attr">end:</span> <span class="number">2</span><span class="string">,</span> <span class="attr">group:</span> <span class="string">ab</span></span><br><span class="line"><span class="string">[2th]</span> <span class="attr">start:</span> <span class="number">2</span><span class="string">,</span> <span class="attr">end:</span> <span class="number">5</span><span class="string">,</span> <span class="attr">group:</span> <span class="string">aab</span></span><br><span class="line"><span class="string">[3th]</span> <span class="attr">start:</span> <span class="number">5</span><span class="string">,</span> <span class="attr">end:</span> <span class="number">9</span><span class="string">,</span> <span class="attr">group:</span> <span class="string">aaab</span></span><br><span class="line"><span class="string">[4th]</span> <span class="attr">start:</span> <span class="number">9</span><span class="string">,</span> <span class="attr">end:</span> <span class="number">14</span><span class="string">,</span> <span class="attr">group:</span> <span class="string">aaaab</span></span><br><span class="line"><span class="string">regex</span> <span class="string">=</span> <span class="string">a\w+?b,</span> <span class="attr">content:</span> <span class="string">abaabaaabaaaab</span></span><br><span class="line"><span class="string">[1th]</span> <span class="attr">start:</span> <span class="number">0</span><span class="string">,</span> <span class="attr">end:</span> <span class="number">5</span><span class="string">,</span> <span class="attr">group:</span> <span class="string">abaab</span></span><br><span class="line"><span class="string">[2th]</span> <span class="attr">start:</span> <span class="number">5</span><span class="string">,</span> <span class="attr">end:</span> <span class="number">9</span><span class="string">,</span> <span class="attr">group:</span> <span class="string">aaab</span></span><br><span class="line"><span class="string">[3th]</span> <span class="attr">start:</span> <span class="number">9</span><span class="string">,</span> <span class="attr">end:</span> <span class="number">14</span><span class="string">,</span> <span class="attr">group:</span> <span class="string">aaaab</span></span><br><span class="line"><span class="string">regex</span> <span class="string">=</span> <span class="string">a\w??b,</span> <span class="attr">content:</span> <span class="string">abaabaaabaaaab</span></span><br><span class="line"><span class="string">[1th]</span> <span class="attr">start:</span> <span class="number">0</span><span class="string">,</span> <span class="attr">end:</span> <span class="number">2</span><span class="string">,</span> <span class="attr">group:</span> <span class="string">ab</span></span><br><span class="line"><span class="string">[2th]</span> <span class="attr">start:</span> <span class="number">2</span><span class="string">,</span> <span class="attr">end:</span> <span class="number">5</span><span class="string">,</span> <span class="attr">group:</span> <span class="string">aab</span></span><br><span class="line"><span class="string">[3th]</span> <span class="attr">start:</span> <span class="number">6</span><span class="string">,</span> <span class="attr">end:</span> <span class="number">9</span><span class="string">,</span> <span class="attr">group:</span> <span class="string">aab</span></span><br><span class="line"><span class="string">[4th]</span> <span class="attr">start:</span> <span class="number">11</span><span class="string">,</span> <span class="attr">end:</span> <span class="number">14</span><span class="string">,</span> <span class="attr">group:</span> <span class="string">aab</span></span><br><span class="line"><span class="string">regex</span> <span class="string">=</span> <span class="string">a\w&#123;0,4&#125;?b,</span> <span class="attr">content:</span> <span class="string">abaabaaabaaaab</span></span><br><span class="line"><span class="string">[1th]</span> <span class="attr">start:</span> <span class="number">0</span><span class="string">,</span> <span class="attr">end:</span> <span class="number">2</span><span class="string">,</span> <span class="attr">group:</span> <span class="string">ab</span></span><br><span class="line"><span class="string">[2th]</span> <span class="attr">start:</span> <span class="number">2</span><span class="string">,</span> <span class="attr">end:</span> <span class="number">5</span><span class="string">,</span> <span class="attr">group:</span> <span class="string">aab</span></span><br><span class="line"><span class="string">[3th]</span> <span class="attr">start:</span> <span class="number">5</span><span class="string">,</span> <span class="attr">end:</span> <span class="number">9</span><span class="string">,</span> <span class="attr">group:</span> <span class="string">aaab</span></span><br><span class="line"><span class="string">[4th]</span> <span class="attr">start:</span> <span class="number">9</span><span class="string">,</span> <span class="attr">end:</span> <span class="number">14</span><span class="string">,</span> <span class="attr">group:</span> <span class="string">aaaab</span></span><br><span class="line"><span class="string">regex</span> <span class="string">=</span> <span class="string">a\w&#123;3,&#125;?b,</span> <span class="attr">content:</span> <span class="string">abaabaaabaaaab</span></span><br><span class="line"><span class="string">[1th]</span> <span class="attr">start:</span> <span class="number">0</span><span class="string">,</span> <span class="attr">end:</span> <span class="number">5</span><span class="string">,</span> <span class="attr">group:</span> <span class="string">abaab</span></span><br><span class="line"><span class="string">[2th]</span> <span class="attr">start:</span> <span class="number">5</span><span class="string">,</span> <span class="attr">end:</span> <span class="number">14</span><span class="string">,</span> <span class="attr">group:</span> <span class="string">aaabaaaab</span></span><br></pre></td></tr></table></figure>
<p><strong>说明</strong></p>
<p>本例中代码展示的是使用不同贪婪或懒惰策略去查找字符串&quot;abaabaaabaaaab&quot; 中匹配<strong>以&quot;a&quot;开头，以&quot;b&quot;结尾的所有子字符串</strong>。</p>
<p>请从输出结果中，细细体味使用不同的贪婪或懒惰策略，对于匹配子字符串有什么影响。</p>
<h2 id="最实用的正则"><a class="markdownIt-Anchor" href="#最实用的正则"></a> 最实用的正则</h2>
<h3 id="校验中文"><a class="markdownIt-Anchor" href="#校验中文"></a> 校验中文</h3>
<p>**描述：**校验字符串中只能有中文字符（不包括中文标点符号）。中文字符的 Unicode 编码范围是\u4e00 到 \u9fa5。</p>
<p>如有兴趣，可以参考<a href="http://baike.baidu.com/link?url=3xi0vmvCIGKQLJZdn_BYhQ1IDFsoSJMrya6_eOjCBb7A6cRIW-zhZFLC9Yh8wjxU6A_HCfNuP8FBBXU9CN3Wcq" target="_blank" rel="noopener"><strong><em>百度百科-Unicode</em></strong></a> 。</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">^[<span class="symbol">\u</span>4e00-<span class="symbol">\u</span>9fa5]+$</span><br></pre></td></tr></table></figure>
<p><strong>匹配：</strong> 春眠不觉晓</p>
<p>**不匹配：**春眠不觉晓，</p>
<h3 id="校验身份证号码"><a class="markdownIt-Anchor" href="#校验身份证号码"></a> 校验身份证号码</h3>
<p>**描述：**身份证为 15 位或 18 位。15 位是第一代身份证。从 1999 年 10 月 1 日起，全国实行公民身份证号码制度，居民身份证编号由原 15 位升至 18 位。</p>
<p><strong>15 位身份证</strong></p>
<p>**描述：**由 15 位数字组成。排列顺序从左至右依次为：六位数字地区码；六位数字出生日期；三位顺序号，其中 15 位男为单数，女为双数。</p>
<p><strong>18 位身份证</strong></p>
<p>**描述：**由十七位数字本体码和一位数字校验码组成。排列顺序从左至右依次为：六位数字地区码；八位数字出生日期；三位数字顺序码和一位数字校验码（也可能是 X）。</p>
<p>身份证号含义详情请见：<a href="http://baike.baidu.com/link?url=5mYlYNE0RsSe2D4tydajtiaR8hAm4pPZ0FHSPuQ05N4f6H-i7qPuw7sY5KfNuiOVJWVWZvU4gf3IY-vIcKdP1CU4Fv-9pKmFQB50qGv_hZT2dkGbkd9--8_saY7omV80vEw9ixVeEwda37fHswfmtyU4QSiBG5s3K5K-JnYr1dqNlPu0f3t008UcLh5-wyID" target="_blank" rel="noopener"><strong><em>百度百科-居民身份证号码</em></strong></a></p>
<p><strong>地区码（6 位）</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>[<span class="number">1</span><span class="number">-5</span>]|<span class="number">2</span>[<span class="number">1</span><span class="number">-3</span>]|<span class="number">3</span>[<span class="number">1</span><span class="number">-7</span>]|<span class="number">4</span>[<span class="number">1</span><span class="number">-3</span>]|<span class="number">5</span>[<span class="number">0</span><span class="number">-4</span>]|<span class="number">6</span>[<span class="number">1</span><span class="number">-5</span>])\d&#123;<span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure>
<p><strong>出生日期（8 位）</strong></p>
<p>注：下面的是 18 位身份证的有效出生日期，如果是 15 位身份证，只要将第一个\d{4}改为\d{2}即可。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">((\d&#123;4&#125;((0[<span class="string">13578</span>]|1[<span class="string">02</span>])(0[<span class="string">1-9</span>]|[<span class="string">12</span>]\d|3[<span class="string">01</span>])|(0[<span class="string">13456789</span>]|1[<span class="string">012</span>])(0[<span class="string">1-9</span>]|[<span class="string">12</span>]\d|30)|02(0[<span class="string">1-9</span>]|1\d|2[<span class="string">0-8</span>])))|([<span class="string">02468</span>][<span class="symbol">048</span>]|[<span class="string">13579</span>][<span class="symbol">26</span>])0229)</span><br></pre></td></tr></table></figure>
<p><strong>15 位有效身份证</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">^((1[<span class="string">1-5</span>]|2[<span class="string">1-3</span>]|3[<span class="string">1-7</span>]|4[<span class="string">1-3</span>]|5[<span class="string">0-4</span>]|6[<span class="string">1-5</span>])\d&#123;4&#125;)((\d&#123;2&#125;((0[<span class="string">13578</span>]|1[<span class="string">02</span>])(0[<span class="string">1-9</span>]|[<span class="string">12</span>]\d|3[<span class="string">01</span>])|(0[<span class="string">13456789</span>]|1[<span class="string">012</span>])(0[<span class="string">1-9</span>]|[<span class="string">12</span>]\d|30)|02(0[<span class="string">1-9</span>]|1\d|2[<span class="string">0-8</span>])))|([<span class="string">02468</span>][<span class="symbol">048</span>]|[<span class="string">13579</span>][<span class="symbol">26</span>])0229)(\d&#123;3&#125;)$</span><br></pre></td></tr></table></figure>
<p>**匹配：**110001700101031</p>
<p>**不匹配：**110001701501031</p>
<p><strong>18 位有效身份证</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">^((1[<span class="string">1-5</span>]|2[<span class="string">1-3</span>]|3[<span class="string">1-7</span>]|4[<span class="string">1-3</span>]|5[<span class="string">0-4</span>]|6[<span class="string">1-5</span>])\d&#123;4&#125;)((\d&#123;4&#125;((0[<span class="string">13578</span>]|1[<span class="string">02</span>])(0[<span class="string">1-9</span>]|[<span class="string">12</span>]\d|3[<span class="string">01</span>])|(0[<span class="string">13456789</span>]|1[<span class="string">012</span>])(0[<span class="string">1-9</span>]|[<span class="string">12</span>]\d|30)|02(0[<span class="string">1-9</span>]|1\d|2[<span class="string">0-8</span>])))|([<span class="string">02468</span>][<span class="symbol">048</span>]|[<span class="string">13579</span>][<span class="symbol">26</span>])0229)(\d&#123;3&#125;(\d|X))$</span><br></pre></td></tr></table></figure>
<p>**匹配：**110001199001010310 | 11000019900101015X</p>
<p>**不匹配：**990000199001010310 | 110001199013010310</p>
<h3 id="校验有效用户名-密码"><a class="markdownIt-Anchor" href="#校验有效用户名-密码"></a> 校验有效用户名、密码</h3>
<p>**描述：**长度为 6-18 个字符，允许输入字母、数字、下划线，首字符必须为字母。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">^[a-zA-Z]\w&#123;<span class="number">5</span>,<span class="number">17</span>&#125;$</span><br></pre></td></tr></table></figure>
<p>**匹配：**he_llo@worl.d.com | <a href="mailto:hel.l-o@wor-ld.museum" target="_blank" rel="noopener">hel.l-o@wor-ld.museum</a> | <a href="mailto:h1ello@123.com" target="_blank" rel="noopener">h1ello@123.com</a></p>
<p>**不匹配：**hello@worl_d.com | he&amp;llo@world.co1 | .hello@wor#.co.uk</p>
<h3 id="校验邮箱"><a class="markdownIt-Anchor" href="#校验邮箱"></a> 校验邮箱</h3>
<p>**描述：**不允许使用 IP 作为域名，如 : <a href="mailto:hello@154.145.68.12" target="_blank" rel="noopener">hello@154.145.68.12</a></p>
<p><code>@</code>符号前的邮箱用户和<code>.</code>符号前的域名(domain)必须满足以下条件：</p>
<ul>
<li>字符只能是英文字母、数字、下划线<code>_</code>、<code>.</code>、<code>-</code> ；</li>
<li>首字符必须为字母或数字；</li>
<li><code>_</code>、<code>.</code>、<code>-</code> 不能连续出现。</li>
</ul>
<p>域名的根域只能为字母，且至少为两个字符。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">^[<span class="string">A-Za-z0-9</span>](<span class="link">([_\.\-]?[a-zA-Z0-9]+</span>)<span class="emphasis">*)@([A-Za-z0-9]+)(([\.\-]?[a-zA-Z0-9]+)*</span>)\.([A-Za-z]&#123;2,&#125;)$</span><br></pre></td></tr></table></figure>
<p>**匹配：**he_llo@worl.d.com | <a href="mailto:hel.l-o@wor-ld.museum" target="_blank" rel="noopener">hel.l-o@wor-ld.museum</a> | <a href="mailto:h1ello@123.com" target="_blank" rel="noopener">h1ello@123.com</a></p>
<p>**不匹配：**hello@worl_d.com | he&amp;llo@world.co1 | .hello@wor#.co.uk</p>
<h3 id="校验-url"><a class="markdownIt-Anchor" href="#校验-url"></a> 校验 URL</h3>
<p>**描述：**校验 URL。支持 http、https、ftp、ftps。</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">^<span class="comment">(ht|f)</span><span class="comment">(tp|tps)</span>\:<span class="comment">//[a-zA-Z0-9\-\.]+\.([a-zA-Z]&#123;2,3&#125;)?(/\S*)?$</span></span><br></pre></td></tr></table></figure>
<p>**匹配：**<a href="http://google.com/help/me" target="_blank" rel="noopener">http://google.com/help/me</a> | <a href="http://www.google.com/help/me/" target="_blank" rel="noopener">http://www.google.com/help/me/</a> | <a href="https://www.google.com/help.asp" target="_blank" rel="noopener">https://www.google.com/help.asp</a> | <a href="ftp://www.google.com" target="_blank" rel="noopener">ftp://www.google.com</a> | ftps://google.org</p>
<p>**不匹配：**<a href="http://un/www.google.com/index.asp" target="_blank" rel="noopener">http://un/www.google.com/index.asp</a></p>
<h3 id="校验时间"><a class="markdownIt-Anchor" href="#校验时间"></a> 校验时间</h3>
<p>**描述：**校验时间。时、分、秒必须是有效数字，如果数值不是两位数，十位需要补零。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">^([<span class="string">0-1</span>][<span class="symbol">0-9</span>]|[<span class="string">2</span>][<span class="symbol">0-3</span>]):([<span class="string">0-5</span>][<span class="symbol">0-9</span>])$</span><br></pre></td></tr></table></figure>
<p>**匹配：**00:00:00 | 23:59:59 | 17:06:30</p>
<p>**不匹配：**17:6:30 | 24:16:30</p>
<h3 id="校验日期"><a class="markdownIt-Anchor" href="#校验日期"></a> 校验日期</h3>
<p>**描述：**校验日期。日期满足以下条件：</p>
<ul>
<li>格式 yyyy-MM-dd 或 yyyy-M-d</li>
<li>连字符可以没有或是“-”、“/”、“.”之一</li>
<li>闰年的二月可以有 29 日；而平年不可以。</li>
<li>一、三、五、七、八、十、十二月为 31 日。四、六、九、十一月为 30 日。</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">^(?:(?!0000)[<span class="string">0-9</span>]&#123;4&#125;([<span class="string">-/.</span>]?)(?:(?:0?[<span class="string">1-9</span>]|1[<span class="string">0-2</span>])\1(?:0?[<span class="string">1-9</span>]|1[<span class="string">0-9</span>]|2[<span class="string">0-8</span>])|(?:0?[<span class="string">13-9</span>]|1[<span class="string">0-2</span>])\1(?:29|30)|(?:0?[<span class="string">13578</span>]|1[<span class="string">02</span>])\1(?:31))|(?:[<span class="string">0-9</span>]&#123;2&#125;(?:0[<span class="string">48</span>]|[<span class="string">2468</span>][<span class="symbol">048</span>]|[<span class="string">13579</span>][<span class="symbol">26</span>])|(?:0[<span class="string">48</span>]|[<span class="string">2468</span>][<span class="symbol">048</span>]|[<span class="string">13579</span>][<span class="symbol">26</span>])00)([-/.]?)0?2\2(?:29))$</span><br></pre></td></tr></table></figure>
<p>**匹配：**2016/1/1 | 2016/01/01 | 20160101 | 2016-01-01 | 2016.01.01 | 2000-02-29</p>
<p>**不匹配：**2001-02-29 | 2016/12/32 | 2016/6/31 | 2016/13/1 | 2016/0/1</p>
<h3 id="校验中国手机号码"><a class="markdownIt-Anchor" href="#校验中国手机号码"></a> 校验中国手机号码</h3>
<p>**描述：**中国手机号码正确格式：11 位数字。</p>
<p>移动有 16 个号段：134、135、136、137、138、139、147、150、151、152、157、158、159、182、187、188。其中 147、157、188 是 3G 号段，其他都是 2G 号段。联通有 7 种号段：130、131、132、155、156、185、186。其中 186 是 3G（WCDMA）号段，其余为 2G 号段。电信有 4 个号段：133、153、180、189。其中 189 是 3G 号段（CDMA2000），133 号段主要用作无线网卡号。总结：13 开头手机号 0-9；15 开头手机号 0-3、5-9；18 开头手机号 0、2、5-9。</p>
<p>此外，中国在国际上的区号为 86，所以手机号开头有+86、86 也是合法的。</p>
<p>以上信息来源于 <a href="http://baike.baidu.com/link?url=Bia2K_f8rGcakOlP4d9m_-DNSgXU5-0NDP0pPavS0ZbhRHQcUFUTbMERjdO4u7cvkpTJaIDeUXq_EXWnMqXMdSuMQDX3NAbZXAlZYl_V18KATWF7y1EFzUyJ62rf3bAN" target="_blank" rel="noopener"><strong><em>百度百科-手机号</em></strong></a></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">^((\+)?<span class="number">86</span>\s*)?((<span class="number">13</span>[<span class="number">0</span><span class="number">-9</span>])|(<span class="number">15</span>([<span class="number">0</span><span class="number">-3</span>]|[<span class="number">5</span><span class="number">-9</span>]))|(<span class="number">18</span>[<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span><span class="number">-9</span>]))\d&#123;<span class="number">8</span>&#125;$</span><br></pre></td></tr></table></figure>
<p><strong>匹配：</strong>+86 18012345678 | 86 18012345678 | 15812345678</p>
<p>**不匹配：**15412345678 | 12912345678 | 180123456789</p>
<h3 id="校验中国固话号码"><a class="markdownIt-Anchor" href="#校验中国固话号码"></a> 校验中国固话号码</h3>
<p>**描述：**固话号码，必须加区号（以 0 开头）。<br />
3 位有效区号：010、020~029，固话位数为 8 位。<br />
4 位有效区号：03xx 开头到 09xx，固话位数为 7。</p>
<p>如果想了解更详细的信息，请参考 <a href="http://baike.baidu.com/link?url=sX8JoxK1ja5uM5pDYvQe27_QsyqAZ_78DLSeEvwjqtG_uXqU6p5Oh7CPbImNbnwu1ClOmD8udgDIswZfYzQIw0z3BYZO3eTplvVDzieuowTYqt7yHGDAqyT7o4vvGhg4" target="_blank" rel="noopener"><strong><em>百度百科-电话区号</em></strong></a> 。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">^(<span class="number">010</span>|<span class="number">02</span>[<span class="number">0</span><span class="number">-9</span>])(\s|-)\d&#123;<span class="number">8</span>&#125;|(<span class="number">0</span>[<span class="number">3</span><span class="number">-9</span>]\d&#123;<span class="number">2</span>&#125;)(\s|-)\d&#123;<span class="number">7</span>&#125;$</span><br></pre></td></tr></table></figure>
<p>**匹配：**010-12345678 | 010 12345678 | 0512-1234567 | 0512 1234567</p>
<p>**不匹配：**1234567 | 12345678</p>
<h3 id="校验-ipv4-地址"><a class="markdownIt-Anchor" href="#校验-ipv4-地址"></a> 校验 IPv4 地址</h3>
<p>**描述：**IP 地址是一个 32 位的二进制数，通常被分割为 4 个“8 位二进制数”（也就是 4 个字节）。IP 地址通常用“点分十进制”表示成（a.b.c.d）的形式，其中，a,b,c,d 都是 0~255 之间的十进制整数。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">^([<span class="number">01</span>]?\d\d?|<span class="number">2</span>[<span class="number">0</span><span class="number">-4</span>]\d|<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>])\.([<span class="number">01</span>]?\d\d?|<span class="number">2</span>[<span class="number">0</span><span class="number">-4</span>]\d|<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>])\.([<span class="number">01</span>]?\d\d?|<span class="number">2</span>[<span class="number">0</span><span class="number">-4</span>]\d|<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>])\.([<span class="number">01</span>]?\d\d?|<span class="number">2</span>[<span class="number">0</span><span class="number">-4</span>]\d|<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>])$</span><br></pre></td></tr></table></figure>
<p>**匹配：**0.0.0.0 | 255.255.255.255 | 127.0.0.1</p>
<p>**不匹配：**10.10.10 | 10.10.10.256</p>
<h3 id="校验-ipv6-地址"><a class="markdownIt-Anchor" href="#校验-ipv6-地址"></a> 校验 IPv6 地址</h3>
<p>**描述：**IPv6 的 128 位地址通常写成 8 组，每组为四个十六进制数的形式。</p>
<p>IPv6 地址可以表示为以下形式：</p>
<ul>
<li>IPv6 地址</li>
<li>零压缩 IPv6 地址(<a href="https://tools.ietf.org/html/rfc5952#section-2.2" target="_blank" rel="noopener">section 2.2 of rfc5952</a>)</li>
<li>带有本地链接区域索引的 IPv6 地址 (<a href="https://tools.ietf.org/html/rfc4007#section-11" target="_blank" rel="noopener">section 11 of rfc4007</a>)</li>
<li>嵌入 IPv4 的 IPv6 地址(<a href="https://tools.ietf.org/html/rfc6052#section-2" target="_blank" rel="noopener">section 2 of rfc6052</a></li>
<li>映射 IPv4 的 IPv6 地址 (<a href="https://tools.ietf.org/html/rfc2765#section-2.1" target="_blank" rel="noopener">section 2.1 of rfc2765</a>)</li>
<li>翻译 IPv4 的 IPv6 地址 (<a href="https://tools.ietf.org/html/rfc2765#section-2.1" target="_blank" rel="noopener">section 2.1 of rfc2765</a>)</li>
</ul>
<p>显然，IPv6 地址的表示方式很复杂。你也可以参考</p>
<p><a href="http://baike.baidu.com/link?url=D3nmh0q_G_ZVmxXFG79mjjNfT4hs9fwjqUgygh-tvhq43KYqx88HV27WEXmoT4nA4iGzXwXMm5L-j50C2gSL5q" target="_blank" rel="noopener"><strong><em>百度百科-IPv6</em></strong></a></p>
<p><a href="http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses" target="_blank" rel="noopener"><strong><em>Stack overflow 上的 IPv6 正则表达高票答案</em></strong></a></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">(([<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:)&#123;<span class="number">7</span>,<span class="number">7</span>&#125;[<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;|([<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:)&#123;<span class="number">1</span>,<span class="number">7</span>&#125;:|([<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:)&#123;<span class="number">1</span>,<span class="number">6</span>&#125;:[<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;|([<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:)&#123;<span class="number">1</span>,<span class="number">5</span>&#125;(:[<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;)&#123;<span class="number">1</span>,<span class="number">2</span>&#125;|([<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:)&#123;<span class="number">1</span>,<span class="number">4</span>&#125;(:[<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;)&#123;<span class="number">1</span>,<span class="number">3</span>&#125;|([<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:)&#123;<span class="number">1</span>,<span class="number">3</span>&#125;(:[<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;)&#123;<span class="number">1</span>,<span class="number">4</span>&#125;|([<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:)&#123;<span class="number">1</span>,<span class="number">2</span>&#125;(:[<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;)&#123;<span class="number">1</span>,<span class="number">5</span>&#125;|[<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:((:[<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;)&#123;<span class="number">1</span>,<span class="number">6</span>&#125;)|:((:[<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;)&#123;<span class="number">1</span>,<span class="number">7</span>&#125;|:)|fe80:(:[<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">0</span>,<span class="number">4</span>&#125;)&#123;<span class="number">0</span>,<span class="number">4</span>&#125;%[<span class="number">0</span><span class="number">-9</span>a-zA-Z]&#123;<span class="number">1</span>,&#125;|::(ffff(:<span class="number">0</span>&#123;<span class="number">1</span>,<span class="number">4</span>&#125;)&#123;<span class="number">0</span>,<span class="number">1</span>&#125;:)&#123;<span class="number">0</span>,<span class="number">1</span>&#125;((<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>]|(<span class="number">2</span>[<span class="number">0</span><span class="number">-4</span>]|<span class="number">1</span>&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="number">0</span><span class="number">-9</span>])&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="number">0</span><span class="number">-9</span>])\.)&#123;<span class="number">3</span>,<span class="number">3</span>&#125;(<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>]|(<span class="number">2</span>[<span class="number">0</span><span class="number">-4</span>]|<span class="number">1</span>&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="number">0</span><span class="number">-9</span>])&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="number">0</span><span class="number">-9</span>])|([<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:)&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:((<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>]|(<span class="number">2</span>[<span class="number">0</span><span class="number">-4</span>]|<span class="number">1</span>&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="number">0</span><span class="number">-9</span>])&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="number">0</span><span class="number">-9</span>])\.)&#123;<span class="number">3</span>,<span class="number">3</span>&#125;(<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>]|(<span class="number">2</span>[<span class="number">0</span><span class="number">-4</span>]|<span class="number">1</span>&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="number">0</span><span class="number">-9</span>])&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="number">0</span><span class="number">-9</span>]))</span><br></pre></td></tr></table></figure>
<p>**匹配：**1:2:3:4:5:6:7:8 | 1:: | 1::8 | 1::6:7:8 | 1::5:6:7:8 | 1::4:5:6:7:8 | 1::3:4:5:6:7:8 | ::2:3:4:5:6:7:8 | 1:2:3:4:5:6:7:: | 1:2:3:4:5:6::8 | 1:2:3:4:5::8 | 1:2:3:4::8 | 1:2:3::8 | 1:2::8 | 1::8 | ::8 | fe80::7:8%1 | ::255.255.255.255 | 2001:db8:3:4::192.0.2.33 | 64:ff9b::192.0.2.33</p>
<p>**不匹配：**1.2.3.4.5.6.7.8 | 1::2::3</p>
<h3 id="特定字符"><a class="markdownIt-Anchor" href="#特定字符"></a> 特定字符</h3>
<p>匹配长度为 3 的字符串：<code>^.{3}$</code>。</p>
<p>匹配由 26 个英文字母组成的字符串：<code>^[A-Za-z]+$</code>。</p>
<p>匹配由 26 个大写英文字母组成的字符串：<code>^[A-Z]+$</code>。</p>
<p>匹配由 26 个小写英文字母组成的字符串：<code>^[a-z]+$</code>。</p>
<p>匹配由数字和 26 个英文字母组成的字符串：<code>^[A-Za-z0-9]+$</code>。</p>
<p>匹配由数字、26 个英文字母或者下划线组成的字符串：<code>^\w+$</code>。</p>
<h3 id="特定数字"><a class="markdownIt-Anchor" href="#特定数字"></a> 特定数字</h3>
<p>匹配正整数：<code>^[1-9]\d*$</code></p>
<p>匹配负整数：<code>^-[1-9]\d*$</code></p>
<p>匹配整数：<code>^(-?[1-9]\d*)|0$</code></p>
<p>匹配正浮点数：<code>^[1-9]\d*\.\d+|0\.\d+$</code></p>
<p>匹配负浮点数：<code>^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$</code></p>
<p>匹配浮点数：<code>^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$</code></p>
<h2 id="速查元字符字典"><a class="markdownIt-Anchor" href="#速查元字符字典"></a> 速查元字符字典</h2>
<p>为了方便快查正则的元字符含义，在本节根据元字符的功能集中罗列正则的各种元字符。</p>
<h3 id="限定符"><a class="markdownIt-Anchor" href="#限定符"></a> 限定符</h3>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>*</code></td>
<td>匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。</td>
</tr>
<tr>
<td><code>+</code></td>
<td>匹配前面的子表达式一次或多次。例如，‘zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td>
</tr>
<tr>
<td><code>?</code></td>
<td>匹配前面的子表达式零次或一次。例如，“do(es)?” 可以匹配 “do” 或 “does” 中的&quot;do&quot; 。? 等价于 {0,1}。</td>
</tr>
<tr>
<td><code>{n}</code></td>
<td>n 是一个非负整数。匹配确定的 n 次。例如，‘o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td>
</tr>
<tr>
<td><code>{n,}</code></td>
<td>n 是一个非负整数。至少匹配 n 次。例如，‘o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。‘o{1,}’ 等价于 ‘o+’。‘o{0,}’ 则等价于 ‘o*’。</td>
</tr>
<tr>
<td><code>{n,m}</code></td>
<td>m 和 n 均为非负整数，其中 n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，“o{1,3}” 将匹配 “fooooood” 中的前三个 o。‘o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td>
</tr>
</tbody>
</table>
<h3 id="定位符"><a class="markdownIt-Anchor" href="#定位符"></a> 定位符</h3>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>^</code></td>
<td>匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。</td>
</tr>
<tr>
<td><code>$</code></td>
<td>匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。</td>
</tr>
<tr>
<td><code>\b</code></td>
<td>匹配一个字边界，即字与空格间的位置。</td>
</tr>
<tr>
<td><code>\B</code></td>
<td>非字边界匹配。</td>
</tr>
</tbody>
</table>
<h3 id="非打印字符"><a class="markdownIt-Anchor" href="#非打印字符"></a> 非打印字符</h3>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\cx</code></td>
<td>匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td>
</tr>
<tr>
<td><code>\f</code></td>
<td>匹配一个换页符。等价于 \x0c 和 \cL。</td>
</tr>
<tr>
<td><code>\n</code></td>
<td>匹配一个换行符。等价于 \x0a 和 \cJ。</td>
</tr>
<tr>
<td><code>\r</code></td>
<td>匹配一个回车符。等价于 \x0d 和 \cM。</td>
</tr>
<tr>
<td><code>\s</code></td>
<td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。</td>
</tr>
<tr>
<td><code>\S</code></td>
<td>匹配任何非空白字符。等价于 [ \f\n\r\t\v]。</td>
</tr>
<tr>
<td><code>\t</code></td>
<td>匹配一个制表符。等价于 \x09 和 \cI。</td>
</tr>
<tr>
<td><code>\v</code></td>
<td>匹配一个垂直制表符。等价于 \x0b 和 \cK。</td>
</tr>
</tbody>
</table>
<h3 id="分组"><a class="markdownIt-Anchor" href="#分组"></a> 分组</h3>
<table>
<thead>
<tr>
<th>表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>(exp)</code></td>
<td>匹配的子表达式。()中的内容就是子表达式。</td>
</tr>
<tr>
<td><code>(?&lt;name&gt;exp)</code></td>
<td>命名的子表达式（反向引用）。</td>
</tr>
<tr>
<td><code>(?:exp)</code></td>
<td>非捕获组，表示当一个限定符应用到一个组，但组捕获的子字符串并非所需时，通常会使用非捕获组构造。</td>
</tr>
<tr>
<td><code>(?=exp)</code></td>
<td>匹配 exp 前面的位置。</td>
</tr>
<tr>
<td><code>(?&lt;=exp)</code></td>
<td>匹配 exp 后面的位置。</td>
</tr>
<tr>
<td><code>(?!exp)</code></td>
<td>匹配后面跟的不是 exp 的位置。</td>
</tr>
<tr>
<td><code>(?&lt;!exp)</code></td>
<td>匹配前面不是 exp 的位置。</td>
</tr>
</tbody>
</table>
<h3 id="特殊符号"><a class="markdownIt-Anchor" href="#特殊符号"></a> 特殊符号</h3>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\</code></td>
<td>将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\n’ 匹配换行符。序列 ‘\’ 匹配 “”，而 ‘(’ 则匹配 “(”。</td>
</tr>
<tr>
<td><code>\|</code></td>
<td>指明两项之间的一个选择。</td>
</tr>
<tr>
<td><code>[]</code></td>
<td>匹配方括号范围内的任意一个字符。形式如：[xyz]、[<sup>xyz]、[a-z]、[</sup>a-z]、[x,y,z]</td>
</tr>
</tbody>
</table>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><strong>教程</strong>
<ul>
<li><a href="http://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="noopener">正则表达式 30 分钟入门教程</a></li>
<li><a href="https://msdn.microsoft.com/zh-cn/library/d9eze55x(v=vs.80).aspx" target="_blank" rel="noopener">msdn 正则表达式教程</a></li>
<li><a href="http://blog.csdn.net/lxcnn/article/details/4362500" target="_blank" rel="noopener">正则应用之——日期正则表达式</a></li>
<li><a href="https://github.com/ziishaned/learn-regex" target="_blank" rel="noopener">learn-regex</a></li>
<li><a href="http://www.regexlib.com/" target="_blank" rel="noopener">http://www.regexlib.com/</a></li>
</ul>
</li>
<li><strong>文章/常用正则表达式</strong>
<ul>
<li><a href="https://github.com/VincentSit/ChinaMobilePhoneNumberRegex/blob/master/README-CN.md" target="_blank" rel="noopener">ChinaMobilePhoneNumberRegex</a></li>
<li><a href="https://github.com/cdoco/common-regex" target="_blank" rel="noopener">https://github.com/cdoco/common-regex</a></li>
</ul>
</li>
<li><strong>正则测试</strong>
<ul>
<li><a href="https://regex101.com/" target="_blank" rel="noopener">https://regex101.com</a></li>
<li><a href="https://regexr.com/" target="_blank" rel="noopener">https://regexr.com</a></li>
<li><a href="https://www.debuggex.com/" target="_blank" rel="noopener">https://www.debuggex.com</a></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title>网络协议之 HTTP</title>
    <url>/blog/communication/http/</url>
    <content><![CDATA[<h1 id="网络协议之-http"><a class="markdownIt-Anchor" href="#网络协议之-http"></a> 网络协议之 HTTP</h1>
<blockquote>
<p>**超文本传输协议（HTTP）**是一个用于传输超媒体文档（例如 HTML）的<a href="https://en.wikipedia.org/wiki/Application_Layer" target="_blank" rel="noopener">应用层</a>协议。</p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:2 -->
<ul>
<li><a href="#http-%E7%AE%80%E4%BB%8B">HTTP 简介</a></li>
<li><a href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">工作原理</a></li>
<li><a href="#http-%E6%8A%A5%E6%96%87">HTTP 报文</a></li>
<li><a href="#https">HTTPS</a></li>
<li><a href="#cookie-%E5%92%8C-session">Cookie 和 Session</a></li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="http-简介"><a class="markdownIt-Anchor" href="#http-简介"></a> HTTP 简介</h2>
<h3 id="http-是什么"><a class="markdownIt-Anchor" href="#http-是什么"></a> HTTP 是什么</h3>
<p>**超文本传输协议（HTTP）**是一个用于传输超媒体文档（例如 HTML）的<a href="https://en.wikipedia.org/wiki/Application_Layer" target="_blank" rel="noopener">应用层</a>协议。它是为 Web 浏览器与 Web 服务器之间的通信而设计的，但也可以用于其他目的。HTTP 遵循经典的<a href="https://en.wikipedia.org/wiki/Client%E2%80%93server_model" target="_blank" rel="noopener">客户端-服务端模型</a>，客户端打开一个连接以发出请求，然后等待它收到服务器端响应。HTTP 是<a href="http://en.wikipedia.org/wiki/Stateless_protocol" target="_blank" rel="noopener">无状态协议</a>，这意味着服务器不会在两个请求之间保留任何数据（状态）。该协议虽然通常基于 TCP/IP 层，但可以在任何可靠的<a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E5%B1%82" target="_blank" rel="noopener">传输层</a>上使用；也就是说，不像 UDP，它是一个不会静默丢失消息的协议。</p>
<p>HTTP 是由 <strong>IETF</strong>(Internet Engineering Task Force，互联网工程工作小组) 和 <strong>W3C</strong>(World Wide Web Consortium，万维网协会) 共同合作制订的，它们发布了一系列的<strong>RFC</strong>(Request For Comments)，其中最著名的是 RFC 2616，它定义了<strong>HTTP /1.1</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200119131949.png" alt="" /></p>
<h3 id="http-协议特点"><a class="markdownIt-Anchor" href="#http-协议特点"></a> HTTP 协议特点</h3>
<ul>
<li><strong>无连接的</strong> - 无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li>
<li><strong>无状态的</strong> - HTTP 协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li>
<li><strong>媒体独立的</strong> - 这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过 HTTP 发送。客户端以及服务器指定使用适合的 MIME-type 内容类型。</li>
<li><strong>C/S 模型的</strong> - 基于 Client/Server 模型工作。</li>
</ul>
<h3 id="http-版本特性"><a class="markdownIt-Anchor" href="#http-版本特性"></a> HTTP 版本特性</h3>
<h4 id="http-11"><a class="markdownIt-Anchor" href="#http-11"></a> HTTP 1.1</h4>
<p>HTTP1.0 和 HTTP 1.1 主要区别如下：</p>
<ul>
<li><strong>缓存处理</strong>，在 HTTP1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。</li>
<li><strong>带宽优化及网络连接的使用</strong></li>
<li><strong>错误通知的管理</strong> - HTTP1.1 中新增了 24 个错误状态响应码。</li>
<li><strong>Host 头处理</strong>
<ul>
<li>HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。</li>
<li>随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个 IP 地址。HTTP1.1 的请求消息和响应消息都应支持 Host 头域，且请求消息中如果没有 Host 头域会报告一个错误（400 Bad Request）。</li>
</ul>
</li>
<li><strong>长连接</strong>，HTTP 1.1 支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟，在 HTTP1.1 中默认开启 Connection： keep-alive，一定程度上弥补了 HTTP1.0 每次请求都要创建连接的缺点。</li>
</ul>
<h4 id="http-20"><a class="markdownIt-Anchor" href="#http-20"></a> HTTP 2.0</h4>
<p>HTTP/2 在 HTTP/1.1 有几处基本的不同:</p>
<ul>
<li>HTTP/2 是二进制协议而不是文本协议。不再可读，也不可无障碍的手动创建，改善的优化技术现在可被实施。</li>
<li>这是一个复用协议。并行的请求能在同一个链接中处理，移除了 HTTP/1.x 中顺序和阻塞的约束。</li>
<li>压缩了 headers。因为 headers 在一系列请求中常常是相似的，其移除了重复和传输重复数据的成本。</li>
<li>其允许服务器在客户端缓存中填充数据，通过一个叫服务器推送的机制来提前请求。</li>
</ul>
<h2 id="工作原理"><a class="markdownIt-Anchor" href="#工作原理"></a> 工作原理</h2>
<p>HTTP 工作于 <strong>Client/Server</strong> 模型上。</p>
<p>客户端和服务器之间的通信采用 <strong>request/response</strong> 机制。</p>
<p>客户端是终端（可以是浏览器、爬虫程序等），服务器是网站的 Web 服务器。</p>
<p>一次 HTTP 操作称为一个事务，其工作过程大致可分为四步：</p>
<ol>
<li><strong>建立连接</strong> - 首先，客户端和服务器需要建立一个到服务器指定端口（默认端口号为 <strong>80</strong>）的 TCP 连接（注：虽然 HTTP 采用 TCP 连接是最流行的方式，但是 RFC 并没有指定一定要采用这种网络传输方式。）。</li>
<li><strong>发送请求信息</strong> - 客户端向服务器发送请求。请求方式的格式为，统一资源标识符、协议版本号，后边是 MIME 信息包括请求修饰符</li>
<li><strong>发送响应信息</strong> - 服务器监听指定接口是否收到请求，一旦发现请求，处理后，返回响应结果给客户端。其格式为一个状态行包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能的内容。</li>
<li><strong>关闭连接</strong> - 客户端根据响应，显示结果给用户，最后关闭连接。</li>
</ol>
<h3 id="http-优化"><a class="markdownIt-Anchor" href="#http-优化"></a> HTTP 优化</h3>
<p>影响一个 HTTP 网络请求的因素主要有两个：<strong>带宽和延迟。</strong></p>
<ul>
<li>
<p>**带宽：**如果说我们还停留在拨号上网的阶段，带宽可能会成为一个比较严重影响请求的问题，但是现在网络基础建设已经使得带宽得到极大的提升，我们不再会担心由带宽而影响网速，那么就只剩下延迟了。</p>
</li>
<li>
<p><strong>延迟：</strong></p>
</li>
<li>
<ul>
<li>浏览器阻塞（HOL blocking）：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有 4 个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制，后续请求就会被阻塞。</li>
<li>DNS 查询（DNS Lookup）：浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP 的这个系统就是 DNS。这个通常可以利用 DNS 缓存结果来达到减少这个时间的目的。</li>
<li>建立连接（Initial connection）：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。</li>
</ul>
</li>
</ul>
<h2 id="http-报文"><a class="markdownIt-Anchor" href="#http-报文"></a> HTTP 报文</h2>
<p>HTTP 是基于客户端/服务端（C/S）的架构模型，通过一个可靠的链接来交换信息，是一个无状态的请求/响应协议。</p>
<p>一个 HTTP&quot;客户端&quot;是一个应用程序（Web 浏览器或其他任何客户端），通过连接到服务器达到向服务器发送一个或多个 HTTP 的请求的目的。</p>
<p>一个 HTTP&quot;服务器&quot;同样也是一个应用程序（通常是一个 Web 服务，如 Apache Web 服务器或 IIS 服务器等），通过接收客户端的请求并向客户端发送 HTTP 响应数据。</p>
<p>HTTP 使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。</p>
<p>一旦建立连接后，数据消息就通过类似 Internet 邮件所使用的格式[RFC5322]和多用途 Internet 邮件扩展（MIME）[RFC2045]来传送。</p>
<div align="center"><img src="https://images2015.cnblogs.com/blog/318837/201601/318837-20160108221141668-2097587842.png"/></div>
以下是使用 wireshark 抓取的一个实际访问百度首页的 HTTP GET 报文：
<div align="center"><img src="http://images2015.cnblogs.com/blog/318837/201601/318837-20160108221137996-786139964.png"/></div>
可以清楚的看到它的层级结构如下图，经过了层层的包装。
<div align="center"><img src="https://images2015.cnblogs.com/blog/318837/201601/318837-20160108221140731-222242798.png"/></div>
### HTTP 请求报文
<p>客户端发送一个 HTTP 请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成，下图给出了请求报文的一般格式。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200119132129.png" alt="" /></p>
<p>HTTP 请求报文由以下元素组成：</p>
<ul>
<li>一个 HTTP 的<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods" target="_blank" rel="noopener">method</a>，经常是由一个动词像<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET" target="_blank" rel="noopener"><code>GET</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST" target="_blank" rel="noopener"><code>POST</code></a> 或者一个名词像<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/OPTIONS" target="_blank" rel="noopener"><code>OPTIONS</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD" target="_blank" rel="noopener"><code>HEAD</code></a>来定义客户端的动作行为。通常客户端的操作都是获取资源（GET 方法）或者发送<a href="https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms" target="_blank" rel="noopener">HTML form</a>表单值（POST 方法），虽然在一些情况下也会有其他操作。</li>
<li>要获取的资源的路径，通常是上下文中就很明显的元素资源的 URL，它没有<a href="https://developer.mozilla.org/en-US/docs/Glossary/protocol" target="_blank" rel="noopener">protocol</a> （<code>http://</code>），<a href="https://developer.mozilla.org/en-US/docs/Glossary/domain" target="_blank" rel="noopener">domain</a>（<code>developer.mozilla.org</code>），或是 TCP 的<a href="https://developer.mozilla.org/en-US/docs/Glossary/port" target="_blank" rel="noopener">port</a>（HTTP 一般在 80 端口）。</li>
<li>HTTP 协议版本号。</li>
<li>为服务端表达其他信息的可选头部<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers" target="_blank" rel="noopener">headers</a>。</li>
<li>对于一些像 POST 这样的方法，报文的 body 就包含了发送的资源，这与响应报文的 body 类似。</li>
</ul>
<p>根据 HTTP 标准，HTTP 请求可以使用多种请求方法。</p>
<p><strong>HTTP1.0</strong> 定义了三种请求方法： <strong>GET</strong>, <strong>POST</strong> 和 <strong>HEAD</strong>方法。</p>
<p><strong>HTTP1.1</strong> 新增了五种请求方法：<strong>OPTIONS</strong>, <strong>PUT</strong>, <strong>DELETE</strong>, <strong>TRACE</strong> 和 <strong>CONNECT</strong>方法。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>请求指定的页面信息，并返回实体主体。</td>
</tr>
<tr>
<td>HEAD</td>
<td>类似于 get 请求，只不过返回的响应中没有具体的内容，用于获取报头</td>
</tr>
<tr>
<td>POST</td>
<td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。</td>
</tr>
<tr>
<td>PUT</td>
<td>从客户端向服务器传送的数据取代指定的文档的内容。</td>
</tr>
<tr>
<td>DELETE</td>
<td>请求服务器删除指定的页面。</td>
</tr>
<tr>
<td>CONNECT</td>
<td>HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>允许客户端查看服务器的性能。</td>
</tr>
<tr>
<td>TRACE</td>
<td>回显服务器收到的请求，主要用于测试或诊断。</td>
</tr>
</tbody>
</table>
<p><strong>HTTP</strong> <strong>请求消息头</strong></p>
<table>
<thead>
<tr>
<th><strong>请求消息头</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept</td>
<td>浏览器支持的格式</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>支持的编码格式，如（UTF-8，GBK）</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>支持的语言类型</td>
</tr>
<tr>
<td>User-Agent</td>
<td>浏览器信息</td>
</tr>
<tr>
<td>Cookie</td>
<td>记录的是用户当前的状态</td>
</tr>
<tr>
<td>Referer</td>
<td>指从哪个页面单击链接进入的页面</td>
</tr>
<tr>
<td>HOST</td>
<td>目的地址对应的主机名</td>
</tr>
<tr>
<td>Connection</td>
<td>连接类型。如 Keep-Alive 表示长连接，不会断开</td>
</tr>
<tr>
<td>Content-Length</td>
<td>内容长度</td>
</tr>
<tr>
<td>Content-Type</td>
<td>内容类型</td>
</tr>
</tbody>
</table>
<h3 id="http-响应报文"><a class="markdownIt-Anchor" href="#http-响应报文"></a> HTTP 响应报文</h3>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200119132311.png" alt="" /></p>
<p>HTTP 响应报文包含了下面的元素：</p>
<ul>
<li>HTTP 协议版本号。</li>
<li>一个状态码（<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status" target="_blank" rel="noopener">status code</a>），来告知对应请求执行成功或失败，以及失败的原因。</li>
<li>一个状态信息，这个信息是非权威的状态码描述信息，可以由服务端自行设定。</li>
<li>HTTP <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers" target="_blank" rel="noopener">headers</a>，与请求头部类似。</li>
<li>可选项，比起请求报文，响应报文中更常见地包含获取的资源 body。</li>
</ul>
<h4 id="响应消息头"><a class="markdownIt-Anchor" href="#响应消息头"></a> 响应消息头</h4>
<table>
<thead>
<tr>
<th><strong>响应消息头</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Allow</td>
<td>服务器支持哪些请求方法（如 GET、POST 等）。</td>
</tr>
<tr>
<td>Content-Encoding</td>
<td>文档的编码（Encode）方法。只有在解码之后才可以得到 Content-Type 头指定的内容类型。利用 gzip 压缩文档能够显著地减少 HTML 文档的下载时间。Java 的 GZIPOutputStream 可以很方便地进行 gzip 压缩，但只有 Unix 上的 Netscape 和 Windows 上的 IE 4、IE 5 才支持它。因此，Servlet 应该通过查看 Accept-Encoding 头（即 request.getHeader(“Accept-Encoding”)）检查浏览器是否支持 gzip，为支持 gzip 的浏览器返回经 gzip 压缩的 HTML 页面，为其他浏览器返回普通页面。</td>
</tr>
<tr>
<td>Content-Length</td>
<td>表示内容长度。只有当浏览器使用持久 HTTP 连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStram，完成后查看其大小，然后把该值放入 Content-Length 头，最后通过<code>byteArrayStream.writeTo(response.getOutputStream()</code> 发送内容。</td>
</tr>
<tr>
<td>Content-Type</td>
<td>表示后面的文档属于什么 MIME 类型。Servlet 默认为 <code>text/plain</code>，但通常需要显式地指定为 text/html。由于经常要设置 Content-Type，因此 HttpServletResponse 提供了一个专用的方法 setContentType。</td>
</tr>
<tr>
<td>Date</td>
<td>当前的 GMT 时间。你可以用 setDateHeader 来设置这个头以避免转换时间格式的麻烦。</td>
</tr>
<tr>
<td>Expires</td>
<td>应该在什么时候认为文档已经过期，从而不再缓存它？</td>
</tr>
<tr>
<td>Last-Modified</td>
<td>文档的最后改动时间。客户可以通过 If-Modified-Since 请求头提供一个日期，该请求将被视为一个条件 GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个 304（Not Modified）状态。Last-Modified 也可用 setDateHeader 方法来设置。</td>
</tr>
<tr>
<td>Location</td>
<td>表示客户应当到哪里去提取文档。Location 通常不是直接设置的，而是通过 HttpServletResponse 的 sendRedirect 方法，该方法同时设置状态代码为 302。</td>
</tr>
<tr>
<td>Refresh</td>
<td>表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过 <code>response.setHeader(&quot;Refresh&quot;, &quot;5;URL=http://host/path&quot;)</code>让浏览器读取指定的页面。 注意这种功能通常是通过设置 HTML 页面 HEAD 区的 <code>&lt;META HTTP-EQUIV=&quot;Refresh&quot; CONTENT=&quot;5;URL=http://host/path&quot;&gt;</code>实现，这是因为，自动刷新或重定向对于那些不能使用 CGI 或 Servlet 的 HTML 编写者十分重要。但是，对于 Servlet 来说，直接设置 Refresh 头更加方便。 注意 Refresh 的意义是&quot;N 秒之后刷新本页面或访问指定页面&quot;，而不是&quot;每隔 N 秒刷新本页面或访问指定页面&quot;。因此，连续刷新要求每次都发送一个 Refresh 头，而发送 204 状态代码则可以阻止浏览器继续刷新，不管是使用 Refresh 头还是 <code>&lt;META HTTP-EQUIV=&quot;Refresh&quot; ...&gt;</code>。 注意 Refresh 头不属于 HTTP 1.1 正式规范的一部分，而是一个扩展，但 Netscape 和 IE 都支持它。</td>
</tr>
<tr>
<td>Server</td>
<td>服务器名字。Servlet 一般不设置这个值，而是由 Web 服务器自己设置。</td>
</tr>
<tr>
<td>Set-Cookie</td>
<td>设置和页面关联的 Cookie。Servlet 不应使用<code>response.setHeader(&quot;Set-Cookie&quot;, ...)</code>，而是应使用 HttpServletResponse 提供的专用方法 addCookie。参见下文有关 Cookie 设置的讨论。</td>
</tr>
<tr>
<td>WWW-Authenticate</td>
<td>客户应该在 Authorization 头中提供什么类型的授权信息？在包含 401（Unauthorized）状态行的应答中这个头是必需的。例如，<code>response.setHeader(&quot;WWW-Authenticate&quot;, &quot;BASIC realm=＼&quot;executives＼&quot;&quot;)</code>。 注意 Servlet 一般不进行这方面的处理，而是让 Web 服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。</td>
</tr>
</tbody>
</table>
<h4 id="http-响应状态码"><a class="markdownIt-Anchor" href="#http-响应状态码"></a> HTTP 响应状态码</h4>
<p>当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含 HTTP 状态码的信息头（server header）用以响应浏览器的请求。</p>
<p>HTTP 状态码的英文为 <strong><code>HTTP Status Code</code></strong>。</p>
<p>下面是常见的 HTTP 状态码：</p>
<ul>
<li><strong>200</strong> - 请求成功</li>
<li><strong>301</strong> - 资源（网页等）被永久转移到其它 URL</li>
<li><strong>404</strong> - 请求的资源（网页等）不存在</li>
<li><strong>500</strong> - 内部服务器错误</li>
</ul>
<p>HTTP 状态码分类</p>
<p>HTTP 状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP 状态码共分为 5 种类型：</p>
<table>
<thead>
<tr>
<th><strong>分类</strong></th>
<th><strong>分类描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1xx</td>
<td><strong>信息响应</strong>。服务器收到请求，需要请求者继续执行操作</td>
</tr>
<tr>
<td>2xx</td>
<td><strong>成功响应</strong>。操作被成功接收并处理</td>
</tr>
<tr>
<td>3xx</td>
<td><strong>重定向</strong>。需要进一步的操作以完成请求</td>
</tr>
<tr>
<td>4xx</td>
<td><strong>客户端错误</strong>。请求包含语法错误或无法完成请求</td>
</tr>
<tr>
<td>5xx</td>
<td><strong>服务器错误</strong>。服务器在处理请求的过程中发生了错误</td>
</tr>
</tbody>
</table>
<blockquote>
<p>🔔 更详细的 HTTP 状态码可以参考：</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status" target="_blank" rel="noopener">MDN HTTP 响应代码</a></li>
<li><a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes" target="_blank" rel="noopener">Wiki List of HTTP status codes</a></li>
</ul>
</blockquote>
<h2 id="https"><a class="markdownIt-Anchor" href="#https"></a> HTTPS</h2>
<p>HTTP 是明文传输，HTTPS 通过 SSL\TLS 进行了加密</p>
<p>HTTP 的端口号是 80，HTTPS 是 443</p>
<p>HTTPS 需要到 CA 申请证书，一般免费证书很少，需要交费</p>
<p>HTTPS 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。</p>
<h2 id="cookie-和-session"><a class="markdownIt-Anchor" href="#cookie-和-session"></a> Cookie 和 Session</h2>
<blockquote>
<p>由于 Http 是一种无状态的协议，服务器单从网络连接上无从知道客户身份。</p>
<p>会话跟踪是 Web 程序中常用的技术，用来跟踪用户的整个会话。常用会话跟踪技术是 Cookie 与 Session。</p>
</blockquote>
<h3 id="cookie"><a class="markdownIt-Anchor" href="#cookie"></a> Cookie</h3>
<p>HTTP Cookie（也叫 Web Cookie 或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview#HTTP_is_stateless_but_not_sessionless" target="_blank" rel="noopener">无状态</a>的 HTTP 协议记录稳定的状态信息成为了可能。</p>
<p>Cookie 主要用于以下三个方面：</p>
<ul>
<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>
</ul>
<p>Cookie 工作步骤：</p>
<ol>
<li>客户端请求服务器，如果服务器需要记录该用户的状态，就是用 response 向客户端浏览器颁发一个 Cookie。</li>
<li>客户端浏览器会把 Cookie 保存下来。</li>
<li>当浏览器再请求该网站时，浏览器把该请求的网址连同 Cookie 一同提交给服务器。服务器检查该 Cookie，以此来辨认用户状态。</li>
</ol>
<p><strong><em>注：Cookie 功能需要浏览器的支持，如果浏览器不支持 Cookie 或者 Cookie 禁用了，Cookie 功能就会失效。</em></strong></p>
<p>Java 中把 Cookie 封装成了 <code>javax.servlet.http.Cookie</code> 类。</p>
<p>Cookie 和 Http 消息：</p>
<p><code>Cookies</code> 通常设置在 HTTP 头信息中（虽然 JavaScript 也可以直接在浏览器上设置一个 Cookie）。</p>
<p>设置 Cookie 的 Servlet 会发送如下的头信息：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Date: Fri, <span class="number">04</span> Feb <span class="number">2000</span> <span class="number">21</span>:<span class="number">03</span>:<span class="number">38</span> GMT</span><br><span class="line">Server: Apache/<span class="number">1.3</span><span class="number">.9</span> (UNIX) PHP/<span class="number">4.0</span>b3</span><br><span class="line">Set-Cookie: name=xyz; expires=Friday, <span class="number">04</span>-Feb<span class="number">-07</span> <span class="number">22</span>:<span class="number">03</span>:<span class="number">38</span> GMT;</span><br><span class="line">                 path=/; domain=w3cschool.cc</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: text/html</span><br></pre></td></tr></table></figure>
<p>正如您所看到的，<code>Set-Cookie</code> 头包含了一个名称值对、一个 GMT 日期、一个路径和一个域。名称和值会被 URL 编码。<code>expires</code> 字段是一个指令，告诉浏览器在给定的时间和日期之后&quot;忘记&quot;该 Cookie。</p>
<p>如果浏览器被配置为存储 Cookies，它将会保留此信息直到到期日期。如果用户的浏览器指向任何匹配该 Cookie 的路径和域的页面，它会重新发送 Cookie 到服务器。浏览器的头信息可能如下所示：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> HTTP/1.0</span><br><span class="line"><span class="attribute">Connection</span>: Keep-Alive</span><br><span class="line"><span class="attribute">User-Agent</span>: Mozilla/4.6 (X11; I; Linux 2.2.6-15apmac ppc)</span><br><span class="line"><span class="attribute">Host</span>: zink.demon.co.uk:1126</span><br><span class="line"><span class="attribute">Accept</span>: image/gif, */*</span><br><span class="line"><span class="attribute">Accept-Encoding</span>: gzip</span><br><span class="line"><span class="attribute">Accept-Language</span>: en</span><br><span class="line"><span class="attribute">Accept-Charset</span>: iso-8859-1,*,utf-8</span><br><span class="line"><span class="attribute">Cookie</span>: name=xyz</span><br></pre></td></tr></table></figure>
<h3 id="session"><a class="markdownIt-Anchor" href="#session"></a> Session</h3>
<p>不同于 <strong>Cookie 保存在客户端浏览器中</strong>，<strong>Session 保存在服务器上</strong>。</p>
<p>如果说 Cookie 机制是通过检查客户身上的“通行证”来确定客户身份的话，那么 Session 机制就是通过检查服务器上的“客户明细表”来确认客户身份。</p>
<h4 id="session-对浏览器的要求"><a class="markdownIt-Anchor" href="#session-对浏览器的要求"></a> Session 对浏览器的要求</h4>
<p>HTTP 协议是无状态的，<code>Session</code> 不能依据 HTTP 连接来判断是否为同一客户。因此服务器向客户端浏览器发送一个名为 <code>JESSIONID</code> 的 Cookie，他的值为该 Session 的 id（也就是 HttpSession.getId()的返回值）。Session 依据该 Cookie 来识别是否为同一用户。</p>
<p>该 Cookie 为服务器自动生成的，它的<code>maxAge</code>属性一般为-1，表示仅当前浏览器内有效，并且各浏览器窗口间不共享，关闭浏览器就会失效。</p>
<h3 id="cookie-vs-session"><a class="markdownIt-Anchor" href="#cookie-vs-session"></a> Cookie vs. Session</h3>
<p>Cookie vs. Session 对比如下：</p>
<ul>
<li><strong>存储位置</strong>
<ul>
<li>Cookie 存储在浏览器。
<ul>
<li>不占用服务器资源。</li>
<li>一些客户端的程序可能会窥探、复制或修改 Cookie 内容，安全风险更大。</li>
</ul>
</li>
<li>Session 存储在服务器。
<ul>
<li>每个用户都会产生一个 Session，如果并发访问的用户非常多，会产生很多的 Session，消耗大量的内存。</li>
<li>对客户端是透明的，不存在敏感信息泄露的危险。</li>
</ul>
</li>
</ul>
</li>
<li><strong>存取方式</strong>
<ul>
<li>Cookie 只能保存 <code>ASCII</code> 字符串，如果需要存取 <code>Unicode</code> 字符或二进制数据，需要进行<code>UTF-8</code>、<code>GBK</code>或<code>BASE64</code>等方式的编码。</li>
<li>Session 可以存取任何类型的数据，甚至是任何 Java 类。可以将 Session 看成是一个 Java 容器类。</li>
</ul>
</li>
<li><strong>有效期</strong>
<ul>
<li>使用 Cookie 可以保证长时间登录有效，只要设置 Cookie 的 <code>maxAge</code> 属性为一个很大的数字。</li>
<li>而 Session 虽然理论上也可以通过设置很大的数值来保持长时间登录有效，但是，由于 Session 依赖于名为 <code>JESSIONID</code> 的 Cookie，而 Cookie <code>JESSIONID</code>的 <code>maxAge</code> 默认为-1，只要关闭了浏览器该 Session 就会失效，因此，Session 不能实现信息永久有效的效果。使用 URL 地址重写也不能实现。</li>
</ul>
</li>
<li><strong>浏览器的支持</strong>
<ul>
<li>浏览器如果禁用 Cookie，则 Cookie 不能使用。</li>
<li>浏览器如果禁用 Cookie，需要使用 Session 以及 URL 地址重写。需要注意的是：所有的用到 Session 程序的 URL 都要使用<code>response.encodeURL(StringURL)</code> 或<code>response.encodeRediretURL(String URL)</code>进行 URL 地址重写，否则导致 Session 会话跟踪失效。</li>
</ul>
</li>
<li><strong>跨域名</strong>
<ul>
<li>Cookie 支持跨域名。</li>
<li>Session 不支持跨域名。</li>
</ul>
</li>
</ul>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><a href="https://book.douban.com/subject/25863515/" target="_blank" rel="noopener">《图解 HTTP》</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP" target="_blank" rel="noopener">MDN HTTP 教程</a></li>
<li><a href="https://juejin.im/entry/5981c5df518825359a2b9476" target="_blank" rel="noopener">HTTP1.0、HTTP1.1 和 HTTP2.0 的区别</a></li>
<li><a href="http://blog.csdn.net/gueter/article/details/1524447" target="_blank" rel="noopener">http://blog.csdn.net/gueter/article/details/1524447</a></li>
<li><a href="http://www.runoob.com/http/http-intro.html" target="_blank" rel="noopener">http://www.runoob.com/http/http-intro.html</a></li>
<li><a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS</a></li>
</ul>
]]></content>
      <categories>
        <category>通信</category>
      </categories>
      <tags>
        <tag>通信</tag>
        <tag>网络</tag>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title>网络协议之 ICMP</title>
    <url>/blog/communication/icmp/</url>
    <content><![CDATA[<h2 id="icmp-简介"><a class="markdownIt-Anchor" href="#icmp-简介"></a> ICMP 简介</h2>
<p>ICMP 全名为(INTERNET CONTROL MESSAGE PROTOCOL)网络控制消息协议。</p>
<p>ICMP 的协议号为<strong>1</strong>。</p>
<p>ICMP 报文就像是 IP 报文的小弟，总顶着 IP 报文的名头出来混。因为 ICMP 报文是在 IP 报文内部的，如图：</p>
<div align="center"><img src="https://images2015.cnblogs.com/blog/318837/201606/318837-20160617091834260-1410966672.png"/></div>
<h2 id="icmp-类型"><a class="markdownIt-Anchor" href="#icmp-类型"></a> ICMP 类型</h2>
<p>ICMP 报文主要有两大功能：查询报文和差错报文。</p>
<h2 id="目的不可达destination-unreachable-message"><a class="markdownIt-Anchor" href="#目的不可达destination-unreachable-message"></a> 目的不可达(Destination Unreachable Message)</h2>
<p>0 1 2 3</p>
<p>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>| Type | Code | Checksum |</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>| unused |</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>| Internet Header + 64 bits of Original Data Datagram |</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>日常生活中，邮寄包裹会经过多个传递环节，任意一环如果无法传下去，都会返回寄件人，并附上无法邮寄的原因。同理，当路由器收到一个无法传递下去的 IP 报文时，会发送 ICMP<strong>目的不可达报文</strong>（Type 为 3）给 IP 报文的源发送方。报文中的 Code 就表示发送失败的原因。</p>
<p>Code</p>
<p>0 = net unreachable;</p>
<p>1 = host unreachable;</p>
<p>2 = protocol unreachable;</p>
<p>3 = port unreachable;</p>
<p>4 = fragmentation needed and DF set;</p>
<p>5 = source route failed.</p>
<h2 id="超时time-exceeded-message"><a class="markdownIt-Anchor" href="#超时time-exceeded-message"></a> 超时(Time Exceeded Message)</h2>
<p>0 1 2 3</p>
<p>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>| Type | Code | Checksum |</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>| unused |</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>| Internet Header + 64 bits of Original Data Datagram |</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>网络传输 IP 数据报的过程中，如果 IP 数据包的 TTL 值逐渐递减为 0 时，需要丢弃数据报。这时，路由器需要向源发送方发送 <strong>ICMP 超时报文</strong>(Type 为 11)，Code 为 0，表示传输过程中超时了。</p>
<p>一个 IP 数据报可能会因为过大而被分片，然后在目的主机侧把所有的分片重组。如果主机迟迟没有等到所有的分片报文，就会向源发送方发送一个 ICMP 超时报文，Code 为 1，表示分片重组超时了。</p>
<h2 id="参数错误报文parameter-problem-message"><a class="markdownIt-Anchor" href="#参数错误报文parameter-problem-message"></a> 参数错误报文(Parameter Problem Message)</h2>
<p>0 1 2 3</p>
<p>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>| Type | Code | Checksum |</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>| Pointer | unused |</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>| Internet Header + 64 bits of Original Data Datagram |</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>当路由器或主机处理数据报时，发现因为报文头的参数错误而不得不丢弃报文时，需要向源发送方发送<strong>参数错误报文</strong>(Type 为 12)。当 Code 为 0 时，报文中的 Pointer 表示错误的字节位置。</p>
<h2 id="源冷却source-quench-message"><a class="markdownIt-Anchor" href="#源冷却source-quench-message"></a> 源冷却(Source Quench Message)</h2>
<p>0 1 2 3</p>
<p>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>| Type | Code | Checksum |</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>| unused |</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>| Internet Header + 64 bits of Original Data Datagram |</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>路由器在处理报文时会有一个缓存队列。如果超过最大缓存队列，将无法处理，从而丢弃报文。并向源发送方发一个 <strong>ICMP 源冷却报文</strong>(Type 为 4)，告诉对方：“嘿，我这里客满了，你迟点再来。”</p>
<h2 id="重定向redirect-message"><a class="markdownIt-Anchor" href="#重定向redirect-message"></a> 重定向(Redirect Message)</h2>
<p>0 1 2 3</p>
<p>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>| Type | Code | Checksum |</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>| Gateway Internet Address |</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>| Internet Header + 64 bits of Original Data Datagram |</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>想像一下，在公司中，有人来你的项目组问你某某某在哪儿。你一想，我们组没有这人啊。你肯定就会说，我们组没有这号人，你去其他组看看。当路由收到 IP 数据报，发现数据报的目的地址在路由表上没有，它就会发 <strong>ICMP 重定向报文</strong>(Type 为 5)给源发送方，提醒它想要发送的地址不在，去其他地方找找吧。</p>
<h2 id="请求回显或回显应答echo-or-echo-reply-message"><a class="markdownIt-Anchor" href="#请求回显或回显应答echo-or-echo-reply-message"></a> 请求回显或回显应答(Echo or Echo Reply Message)</h2>
<p>0 1 2 3</p>
<p>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>| Type | Code | Checksum |</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>| Identifier | Sequence Number |</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>| Data …</p>
<p>±±±±±</p>
<p><strong>Type(8)<strong>是</strong>请求回显报文(Echo)</strong>；Type(0)是<strong>回显应答报文(Echo Reply)</strong>。</p>
<p>请求回显或回显应答报文属于查询报文。Ping 就是用这种报文进行查询和回应。</p>
<h2 id="时间戳或时间戳请求timestamp-or-timestamp-reply-message"><a class="markdownIt-Anchor" href="#时间戳或时间戳请求timestamp-or-timestamp-reply-message"></a> 时间戳或时间戳请求(Timestamp or Timestamp Reply Message)</h2>
<p>0 1 2 3</p>
<p>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>| Type | Code | Checksum |</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>| Identifier | Sequence Number |</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>| Originate Timestamp |</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>| Receive Timestamp |</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>| Transmit Timestamp |</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>时间戳报文是用来记录收发以及传输时间的报文。Originate Timestamp 记录的是发送方发送报文的时刻；<strong>Receive Timestamp</strong>记录的是接收方收到报文的时刻；<strong>Transmit Timestamp</strong>表示回显这最后发送报文的时刻。</p>
<h2 id="信息请求或信息响应"><a class="markdownIt-Anchor" href="#信息请求或信息响应"></a> 信息请求或信息响应</h2>
<p>0 1 2 3</p>
<p>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>| Type | Code | Checksum |</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>| Identifier | Sequence Number |</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>这种报文是用来找出一个主机所在的网络个数（一个主机可能会在多个网络中）。报文的 IP 消息头的目的地址会填为全 0，表示 this，源地址会填为源 IP 所在的网络 IP。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p><strong>图：ICMP 知识点思维导图</strong></p>
<div align="center"><img src="https://images2015.cnblogs.com/blog/318837/201606/318837-20160617091835838-1982473379.png"/></div>
<h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2>
<ul>
<li><a href="http://www.rfc-editor.org/info/rfc792" target="_blank" rel="noopener">RFC792</a></li>
</ul>
]]></content>
      <categories>
        <category>通信</category>
      </categories>
      <tags>
        <tag>通信</tag>
        <tag>网络</tag>
        <tag>协议</tag>
      </tags>
  </entry>
</search>

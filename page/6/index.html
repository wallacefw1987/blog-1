<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/themes/blue/pace-theme-minimal.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":true},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":true,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="Dunwu&amp;apos;s Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Dunwu">
<meta property="og:url" content="https:&#x2F;&#x2F;dunwu.github.io&#x2F;blog&#x2F;page&#x2F;6&#x2F;index.html">
<meta property="og:site_name" content="Dunwu">
<meta property="og:description" content="Dunwu&amp;apos;s Blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://dunwu.github.io/blog/page/6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Dunwu</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/blog/atom.xml" title="Dunwu" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Dunwu</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">大道至简，知易行难</h1>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/blog/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">42</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">11</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">69</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/dunwu" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/design/theory/system-theory-interview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/design/theory/system-theory-interview/" class="post-title-link" itemprop="url">系统原理面试题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-10 16:02:00" itemprop="dateCreated datePublished" datetime="2018-07-10T16:02:00+08:00">2018-07-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-01-16 17:48:30" itemprop="dateModified" datetime="2020-01-16T17:48:30+08:00">2020-01-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index">
                    <span itemprop="name">设计</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/" itemprop="url" rel="index">
                    <span itemprop="name">系统原理</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/design/theory/system-theory-interview/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="design/theory/system-theory-interview/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="系统原理面试题"><a class="markdownIt-Anchor" href="#系统原理面试题"></a> 系统原理面试题</h1>
<h2 id="1-分布式缓存"><a class="markdownIt-Anchor" href="#1-分布式缓存"></a> 1. 分布式缓存</h2>
<h3 id="11-redis-有什么数据类型分别用于什么场景"><a class="markdownIt-Anchor" href="#11-redis-有什么数据类型分别用于什么场景"></a> 1.1. Redis 有什么数据类型？分别用于什么场景</h3>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>可以存储的值</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>STRING</td>
<td>字符串、整数或者浮点数</td>
<td>对整个字符串或者字符串的其中一部分执行操作</br> 对整数和浮点数执行自增或者自减操作</td>
</tr>
<tr>
<td>LIST</td>
<td>列表</td>
<td>从两端压入或者弹出元素</br> 读取单个或者多个元素</br> 进行修剪，只保留一个范围内的元素</td>
</tr>
<tr>
<td>SET</td>
<td>无序集合</td>
<td>添加、获取、移除单个元素</br> 检查一个元素是否存在于集合中</br> 计算交集、并集、差集</br> 从集合里面随机获取元素</td>
</tr>
<tr>
<td>HASH</td>
<td>包含键值对的无序散列表</td>
<td>添加、获取、移除单个键值对</br> 获取所有键值对</br> 检查某个键是否存在</td>
</tr>
<tr>
<td>ZSET</td>
<td>有序集合</td>
<td>添加、获取、删除元素</br> 根据分值范围或者成员来获取元素</br> 计算一个键的排名</td>
</tr>
</tbody>
</table>
<blockquote>
<p><a href="https://redislabs.com/ebook/part-1-getting-started/chapter-1-getting-to-know-redis/1-2-what-redis-data-structures-look-like/" target="_blank" rel="noopener">What Redis data structures look like</a></p>
</blockquote>
<h3 id="12-redis-的主从复制是如何实现的"><a class="markdownIt-Anchor" href="#12-redis-的主从复制是如何实现的"></a> 1.2. Redis 的主从复制是如何实现的</h3>
<ol>
<li>从服务器连接主服务器，发送 SYNC 命令；</li>
<li>主服务器接收到 SYNC 命名后，开始执行 BGSAVE 命令生成 RDB 文件并使用缓冲区记录此后执行的所有写命令；</li>
<li>主服务器 BGSAVE 执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令；</li>
<li>从服务器收到快照文件后丢弃所有旧数据，载入收到的快照；</li>
<li>主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令；</li>
<li>从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；</li>
</ol>
<h3 id="13-redis-的-key-是如何寻址的"><a class="markdownIt-Anchor" href="#13-redis-的-key-是如何寻址的"></a> 1.3. Redis 的 key 是如何寻址的</h3>
<h4 id="131-背景"><a class="markdownIt-Anchor" href="#131-背景"></a> 1.3.1. 背景</h4>
<p>（1）redis 中的每一个数据库，都由一个 redisDb 的结构存储。其中：</p>
<ul>
<li><a href="http://redisDb.id" target="_blank" rel="noopener">redisDb.id</a> 存储着 redis 数据库以整数表示的号码。</li>
<li>redisDb.dict 存储着该库所有的键值对数据。</li>
<li>redisDb.expires 保存着每一个键的过期时间。</li>
</ul>
<p>（2）当 redis 服务器初始化时，会预先分配 16 个数据库（该数量可以通过配置文件配置），所有数据库保存到结构 redisServer 的一个成员 redisServer.db 数组中。当我们选择数据库 select number 时，程序直接通过 redisServer.db[number] 来切换数据库。有时候当程序需要知道自己是在哪个数据库时，直接读取 <a href="http://redisDb.id" target="_blank" rel="noopener">redisDb.id</a> 即可。</p>
<p>（3）redis 的字典使用哈希表作为其底层实现。dict 类型使用的两个指向哈希表的指针，其中 0 号哈希表（ht[0]）主要用于存储数据库的所有键值，而 1 号哈希表主要用于程序对 0 号哈希表进行 rehash 时使用，rehash 一般是在添加新值时会触发，这里不做过多的赘述。所以 redis 中查找一个 key，其实就是对进行该 dict 结构中的 ht[0] 进行查找操作。</p>
<p>（4）既然是哈希，那么我们知道就会有哈希碰撞，那么当多个键哈希之后为同一个值怎么办呢？redis 采取链表的方式来存储多个哈希碰撞的键。也就是说，当根据 key 的哈希值找到该列表后，如果列表的长度大于 1，那么我们需要遍历该链表来找到我们所查找的 key。当然，一般情况下链表长度都为是 1，所以时间复杂度可看作 o(1)。</p>
<h4 id="132-寻址-key-的步骤"><a class="markdownIt-Anchor" href="#132-寻址-key-的步骤"></a> 1.3.2. 寻址 key 的步骤</h4>
<ol>
<li>当拿到一个 key 后，redis 先判断当前库的 0 号哈希表是否为空，即：if (dict-&gt;ht[0].size == 0)。如果为 true 直接返回 NULL。</li>
<li>判断该 0 号哈希表是否需要 rehash，因为如果在进行 rehash，那么两个表中者有可能存储该 key。如果正在进行 rehash，将调用一次<code>_dictRehashStep</code> 方法，<code>_dictRehashStep</code> 用于对数据库字典、以及哈希键的字典进行被动 rehash，这里不作赘述。</li>
<li>计算哈希表，根据当前字典与 key 进行哈希值的计算。</li>
<li>根据哈希值与当前字典计算哈希表的索引值。</li>
<li>根据索引值在哈希表中取出链表，遍历该链表找到 key 的位置。一般情况，该链表长度为 1。</li>
<li>当 ht[0] 查找完了之后，再进行了次 rehash 判断，如果未在 rehashing，则直接结束，否则对 ht[1]重复 345 步骤。</li>
</ol>
<h3 id="14-redis-的集群模式是如何实现的"><a class="markdownIt-Anchor" href="#14-redis-的集群模式是如何实现的"></a> 1.4. Redis 的集群模式是如何实现的？</h3>
<p>Redis Cluster 是 Redis 的分布式解决方案，在 Redis 3.0 版本正式推出的。</p>
<p>Redis Cluster 去中心化，每个节点保存数据和整个集群状态，每个节点都和其他所有节点连接。</p>
<h4 id="141-redis-cluster-节点分配"><a class="markdownIt-Anchor" href="#141-redis-cluster-节点分配"></a> 1.4.1. Redis Cluster 节点分配</h4>
<p>Redis Cluster 特点：</p>
<ol>
<li>所有的 redis 节点彼此互联(PING-PONG 机制)，内部使用二进制协议优化传输速度和带宽。</li>
<li>节点的 fail 是通过集群中超过半数的节点检测失效时才生效。</li>
<li>客户端与 redis 节点直连,不需要中间 proxy 层。客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可。</li>
<li>redis-cluster 把所有的物理节点映射到[0-16383] 哈希槽 (hash slot)上（不一定是平均分配）,cluster 负责维护 node&lt;-&gt;slot&lt;-&gt;value。</li>
<li>Redis 集群预分好 16384 个桶，当需要在 Redis 集群中放置一个 key-value 时，根据 CRC16(key) mod 16384 的值，决定将一个 key 放到哪个桶中。</li>
</ol>
<h4 id="142-redis-cluster-主从模式"><a class="markdownIt-Anchor" href="#142-redis-cluster-主从模式"></a> 1.4.2. Redis Cluster 主从模式</h4>
<p>Redis Cluster 为了保证数据的高可用性，加入了主从模式。</p>
<p>一个主节点对应一个或多个从节点，主节点提供数据存取，从节点则是从主节点拉取数据备份。当这个主节点挂掉后，就会有这个从节点选取一个来充当主节点，从而保证集群不会挂掉。所以，在集群建立的时候，一定要为每个主节点都添加了从节点。</p>
<h4 id="143-redis-sentinel"><a class="markdownIt-Anchor" href="#143-redis-sentinel"></a> 1.4.3. Redis Sentinel</h4>
<p>Redis Sentinel 用于管理多个 Redis 服务器，它有三个功能：</p>
<ul>
<li><strong>监控（Monitoring）</strong> - Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。</li>
<li><strong>提醒（Notification）</strong> - 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</li>
<li><strong>自动故障迁移（Automatic failover）</strong> - 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。</li>
</ul>
<p>Redis 集群中应该有奇数个节点，所以至少有三个节点。</p>
<p>哨兵监控集群中的主服务器出现故障时，需要根据 quorum 选举出一个哨兵来执行故障转移。选举需要 majority，即大多数哨兵是运行的（2 个哨兵的 majority=2，3 个哨兵的 majority=2，5 个哨兵的 majority=3，4 个哨兵的 majority=2）。</p>
<p>假设集群仅仅部署 2 个节点</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">+----+         +----+</span><br><span class="line">|<span class="string"> M1 </span>|<span class="string">---------</span>|<span class="string"> R1 </span>|</span><br><span class="line">|<span class="string"> S1 </span>|<span class="string">         </span>|<span class="string"> S2 </span>|</span><br><span class="line">+----+         +----+</span><br></pre></td></tr></table></figure>
<p>如果 M1 和 S1 所在服务器宕机，则哨兵只有 1 个，无法满足 majority 来进行选举，就不能执行故障转移。</p>
<h3 id="15-redis-如何实现分布式锁zookeeper-如何实现分布式锁比较二者优劣"><a class="markdownIt-Anchor" href="#15-redis-如何实现分布式锁zookeeper-如何实现分布式锁比较二者优劣"></a> 1.5. Redis 如何实现分布式锁？ZooKeeper 如何实现分布式锁？比较二者优劣？</h3>
<p>分布式锁的三种实现：</p>
<ul>
<li>基于数据库实现分布式锁；</li>
<li>基于缓存（Redis 等）实现分布式锁；</li>
<li>基于 Zookeeper 实现分布式锁；</li>
</ul>
<h4 id="151-数据库实现"><a class="markdownIt-Anchor" href="#151-数据库实现"></a> 1.5.1. 数据库实现</h4>
<h4 id="152-redis-实现"><a class="markdownIt-Anchor" href="#152-redis-实现"></a> 1.5.2. Redis 实现</h4>
<ol>
<li>获取锁的时候，使用 setnx 加锁，并使用 expire 命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的 value 值为一个随机生成的 UUID，通过此在释放锁的时候进行判断。</li>
<li>获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。</li>
<li>释放锁的时候，通过 UUID 判断是不是该锁，若是该锁，则执行 delete 进行锁释放。</li>
</ol>
<h4 id="153-zookeeper-实现"><a class="markdownIt-Anchor" href="#153-zookeeper-实现"></a> 1.5.3. ZooKeeper 实现</h4>
<ol>
<li>创建一个目录 mylock；</li>
<li>线程 A 想获取锁就在 mylock 目录下创建临时顺序节点；</li>
<li>获取 mylock 目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；</li>
<li>线程 B 获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；</li>
<li>线程 A 处理完，删除自己的节点，线程 B 监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。</li>
</ol>
<h4 id="154-实现对比"><a class="markdownIt-Anchor" href="#154-实现对比"></a> 1.5.4. 实现对比</h4>
<p>ZooKeeper 具备高可用、可重入、阻塞锁特性，可解决失效死锁问题。<br />
但 ZooKeeper 因为需要频繁的创建和删除节点，性能上不如 Redis 方式。</p>
<h3 id="16-redis-的持久化方式有什么优缺点持久化实现原理"><a class="markdownIt-Anchor" href="#16-redis-的持久化方式有什么优缺点持久化实现原理"></a> 1.6. Redis 的持久化方式？有什么优缺点？持久化实现原理？</h3>
<h4 id="161-rdb-快照snapshot"><a class="markdownIt-Anchor" href="#161-rdb-快照snapshot"></a> 1.6.1. RDB 快照（snapshot）</h4>
<p>将存在于某一时刻的所有数据都写入到硬盘中。</p>
<h5 id="快照的原理"><a class="markdownIt-Anchor" href="#快照的原理"></a> 快照的原理</h5>
<p>在默认情况下，Redis 将数据库快照保存在名字为 dump.rdb 的二进制文件中。你可以对 Redis 进行设置， 让它在“N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动保存一次数据集。你也可以通过调用 SAVE 或者 BGSAVE，手动让 Redis 进行数据集保存操作。这种持久化方式被称为快照。</p>
<p>当 Redis 需要保存 dump.rdb 文件时， 服务器执行以下操作:</p>
<ul>
<li>Redis 创建一个子进程。</li>
<li>子进程将数据集写入到一个临时快照文件中。</li>
<li>当子进程完成对新快照文件的写入时，Redis 用新快照文件替换原来的快照文件，并删除旧的快照文件。</li>
</ul>
<p>这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益。</p>
<h5 id="快照的优点"><a class="markdownIt-Anchor" href="#快照的优点"></a> 快照的优点</h5>
<ul>
<li>它保存了某个时间点的数据集，非常适用于数据集的备份。</li>
<li>很方便传送到另一个远端数据中心或者亚马逊的 S3（可能加密），非常适用于灾难恢复。</li>
<li>快照在保存 RDB 文件时父进程唯一需要做的就是 fork 出一个子进程，接下来的工作全部由子进程来做，父进程不需要再做其他 IO 操作，所以快照持久化方式可以最大化 redis 的性能。</li>
<li>与 AOF 相比，在恢复大的数据集的时候，DB 方式会更快一些。</li>
</ul>
<h5 id="快照的缺点"><a class="markdownIt-Anchor" href="#快照的缺点"></a> 快照的缺点</h5>
<ul>
<li>如果你希望在 redis 意外停止工作（例如电源中断）的情况下丢失的数据最少的话，那么快照不适合你。</li>
<li>快照需要经常 fork 子进程来保存数据集到硬盘上。当数据集比较大的时候，fork 的过程是非常耗时的，可能会导致 Redis 在一些毫秒级内不能响应客户端的请求。</li>
</ul>
<h4 id="162-aof"><a class="markdownIt-Anchor" href="#162-aof"></a> 1.6.2. AOF</h4>
<p>AOF 持久化方式记录每次对服务器执行的写操作。当服务器重启的时候会重新执行这些命令来恢复原始的数据。</p>
<h4 id="163-aof-的原理"><a class="markdownIt-Anchor" href="#163-aof-的原理"></a> 1.6.3. AOF 的原理</h4>
<ul>
<li>Redis 创建一个子进程。</li>
<li>子进程开始将新 AOF 文件的内容写入到临时文件。</li>
<li>对于所有新执行的写入命令，父进程一边将它们累积到一个内存缓存中，一边将这些改动追加到现有 AOF 文件的末尾，这样样即使在重写的中途发生停机，现有的 AOF 文件也还是安全的。</li>
<li>当子进程完成重写工作时，它给父进程发送一个信号，父进程在接收到信号之后，将内存缓存中的所有数据追加到新 AOF 文件的末尾。</li>
<li>搞定！现在 Redis 原子地用新文件替换旧文件，之后所有命令都会直接追加到新 AOF 文件的末尾。</li>
</ul>
<h4 id="164-aof-的优点"><a class="markdownIt-Anchor" href="#164-aof-的优点"></a> 1.6.4. AOF 的优点</h4>
<ul>
<li>使用默认的每秒 fsync 策略，Redis 的性能依然很好(fsync 是由后台线程进行处理的,主线程会尽力处理客户端请求)，一旦出现故障，使用 AOF ，你最多丢失 1 秒的数据。</li>
<li>AOF 文件是一个只进行追加的日志文件，所以不需要写入 seek，即使由于某些原因(磁盘空间已满，写的过程中宕机等等)未执行完整的写入命令，你也也可使用 redis-check-aof 工具修复这些问题。</li>
<li>Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写：重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。整个重写操作是绝对安全的。</li>
<li>AOF 文件有序地保存了对数据库执行的所有写入操作，这些写入操作以 Redis 协议的格式保存。因此 AOF 文件的内容非常容易被人读懂，对文件进行分析（parse）也很轻松。</li>
</ul>
<h4 id="165-aof-的缺点"><a class="markdownIt-Anchor" href="#165-aof-的缺点"></a> 1.6.5. AOF 的缺点</h4>
<ul>
<li>对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。</li>
<li>根据所使用的 fsync 策略，AOF 的速度可能会慢于快照。在一般情况下，每秒 fsync 的性能依然非常高，而关闭 fsync 可以让 AOF 的速度和快照一样快，即使在高负荷之下也是如此。不过在处理巨大的写入载入时，快照可以提供更有保证的最大延迟时间（latency）。</li>
</ul>
<h3 id="17-redis-过期策略有哪些"><a class="markdownIt-Anchor" href="#17-redis-过期策略有哪些"></a> 1.7. Redis 过期策略有哪些？</h3>
<ul>
<li><strong>noeviction</strong> - 当内存使用达到阈值的时候，所有引起申请内存的命令会报错。</li>
<li><strong>allkeys-lru</strong> - 在主键空间中，优先移除最近未使用的 key。</li>
<li><strong>allkeys-random</strong> - 在主键空间中，随机移除某个 key。</li>
<li><strong>volatile-lru</strong> - 在设置了过期时间的键空间中，优先移除最近未使用的 key。</li>
<li><strong>volatile-random</strong> - 在设置了过期时间的键空间中，随机移除某个 key。</li>
<li><strong>volatile-ttl</strong> - 在设置了过期时间的键空间中，具有更早过期时间的 key 优先移除。</li>
</ul>
<h3 id="18-redis-和-memcached-有什么区别"><a class="markdownIt-Anchor" href="#18-redis-和-memcached-有什么区别"></a> 1.8. Redis 和 Memcached 有什么区别？</h3>
<p>两者都是非关系型内存键值数据库。有以下主要不同：</p>
<p><strong>数据类型</strong></p>
<ul>
<li>Memcached 仅支持字符串类型；</li>
<li>而 Redis 支持五种不同种类的数据类型，使得它可以更灵活地解决问题。</li>
</ul>
<p><strong>数据持久化</strong></p>
<ul>
<li>Memcached 不支持持久化；</li>
<li>Redis 支持两种持久化策略：RDB 快照和 AOF 日志。</li>
</ul>
<p><strong>分布式</strong></p>
<ul>
<li>Memcached 不支持分布式，只能通过在客户端使用像一致性哈希这样的分布式算法来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。</li>
<li>Redis Cluster 实现了分布式的支持。</li>
</ul>
<p><strong>内存管理机制</strong></p>
<ul>
<li>Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题，但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。</li>
<li>在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘。而 Memcached 的数据则会一直在内存中。</li>
</ul>
<h3 id="19-为什么单线程的-redis-性能反而优于多线程的-memcached"><a class="markdownIt-Anchor" href="#19-为什么单线程的-redis-性能反而优于多线程的-memcached"></a> 1.9. 为什么单线程的 Redis 性能反而优于多线程的 Memcached？</h3>
<p>Redis 快速的原因：</p>
<ol>
<li>绝大部分请求是纯粹的内存操作（非常快速）</li>
<li>采用单线程,避免了不必要的上下文切换和竞争条件</li>
<li>非阻塞 IO</li>
</ol>
<p>内部实现采用 epoll，采用了 epoll+自己实现的简单的事件框架。epoll 中的读、写、关闭、连接都转化成了事件，然后利用 epoll 的多路复用特性，绝不在 io 上浪费一点时间。</p>
<h2 id="2-分布式消息队列mq"><a class="markdownIt-Anchor" href="#2-分布式消息队列mq"></a> 2. 分布式消息队列（MQ）</h2>
<h3 id="21-为什么使用-mq"><a class="markdownIt-Anchor" href="#21-为什么使用-mq"></a> 2.1. 为什么使用 MQ？</h3>
<ul>
<li>异步处理 - 相比于传统的串行、并行方式，提高了系统吞吐量。</li>
<li>应用解耦 - 系统间通过消息通信，不用关心其他系统的处理。</li>
<li>流量削锋 - 可以通过消息队列长度控制请求量；可以缓解短时间内的高并发请求。</li>
<li>日志处理 - 解决大量日志传输。</li>
<li>消息通讯 - 消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等。</li>
</ul>
<h3 id="22-如何保证-mq-的高可用"><a class="markdownIt-Anchor" href="#22-如何保证-mq-的高可用"></a> 2.2. 如何保证 MQ 的高可用？</h3>
<h4 id="221-数据复制"><a class="markdownIt-Anchor" href="#221-数据复制"></a> 2.2.1. 数据复制</h4>
<ol>
<li>将所有 Broker 和待分配的 Partition 排序</li>
<li>将第 i 个 Partition 分配到第（i mod n）个 Broker 上</li>
<li>将第 i 个 Partition 的第 j 个 Replica 分配到第（(i + j) mode n）个 Broker 上</li>
</ol>
<h4 id="222-选举主服务器"><a class="markdownIt-Anchor" href="#222-选举主服务器"></a> 2.2.2. 选举主服务器</h4>
<h3 id="23-mq-有哪些常见问题如何解决这些问题"><a class="markdownIt-Anchor" href="#23-mq-有哪些常见问题如何解决这些问题"></a> 2.3. MQ 有哪些常见问题？如何解决这些问题？</h3>
<p>MQ 的常见问题有：</p>
<ol>
<li>消息的顺序问题</li>
<li>消息的重复问题</li>
</ol>
<h4 id="231-消息的顺序问题"><a class="markdownIt-Anchor" href="#231-消息的顺序问题"></a> 2.3.1. 消息的顺序问题</h4>
<p>消息有序指的是可以按照消息的发送顺序来消费。</p>
<p>假如生产者产生了 2 条消息：M1、M2，假定 M1 发送到 S1，M2 发送到 S2，如果要保证 M1 先于 M2 被消费，怎么做？</p>
<div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-23145c8b554a0f2f.jpg"/></div>
<p>解决方案：</p>
<p>（1）保证生产者 - MQServer - 消费者是一对一对一的关系</p>
<div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-034106d7e04c062d.jpg"/></div>
<p>缺陷：</p>
<ul>
<li>并行度就会成为消息系统的瓶颈（吞吐量不够）</li>
<li>更多的异常处理，比如：只要消费端出现问题，就会导致整个处理流程阻塞，我们不得不花费更多的精力来解决阻塞的问题。</li>
</ul>
<p>（2）通过合理的设计或者将问题分解来规避。</p>
<ul>
<li>不关注乱序的应用实际大量存在</li>
<li>队列无序并不意味着消息无序</li>
</ul>
<p>所以从业务层面来保证消息的顺序而不仅仅是依赖于消息系统，是一种更合理的方式。</p>
<h4 id="232-消息的重复问题"><a class="markdownIt-Anchor" href="#232-消息的重复问题"></a> 2.3.2. 消息的重复问题</h4>
<p>造成消息重复的根本原因是：网络不可达。</p>
<p>所以解决这个问题的办法就是绕过这个问题。那么问题就变成了：如果消费端收到两条一样的消息，应该怎样处理？</p>
<p>消费端处理消息的业务逻辑保持幂等性。只要保持幂等性，不管来多少条重复消息，最后处理的结果都一样。<br />
保证每条消息都有唯一编号且保证消息处理成功与去重表的日志同时出现。利用一张日志表来记录已经处理成功的消息的 ID，如果新到的消息 ID 已经在日志表中，那么就不再处理这条消息。</p>
<h3 id="24-kafka-activemq-rabbitmq-rocketmq-各有什么优缺点"><a class="markdownIt-Anchor" href="#24-kafka-activemq-rabbitmq-rocketmq-各有什么优缺点"></a> 2.4. Kafka, ActiveMQ, RabbitMQ, RocketMQ 各有什么优缺点？</h3>
<div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-c26f4a3048c38af4.jpg"/></div>
<h2 id="3-分布式服务rpc"><a class="markdownIt-Anchor" href="#3-分布式服务rpc"></a> 3. 分布式服务（RPC）</h2>
<h3 id="31-dubbo-的实现过程"><a class="markdownIt-Anchor" href="#31-dubbo-的实现过程"></a> 3.1. Dubbo 的实现过程？</h3>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/distributed/rpc/dubbo/dubbo基本架构.png!zp" width="500"/>
</div>
<p>节点角色：</p>
<table>
<thead>
<tr>
<th>节点</th>
<th>角色说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Provider</td>
<td>暴露服务的服务提供方</td>
</tr>
<tr>
<td>Consumer</td>
<td>调用远程服务的服务消费方</td>
</tr>
<tr>
<td>Registry</td>
<td>服务注册与发现的注册中心</td>
</tr>
<tr>
<td>Monitor</td>
<td>统计服务的调用次数和调用时间的监控中心</td>
</tr>
<tr>
<td>Container</td>
<td>服务运行容器</td>
</tr>
</tbody>
</table>
<p>调用关系：</p>
<ol>
<li>务容器负责启动，加载，运行服务提供者。</li>
<li>服务提供者在启动时，向注册中心注册自己提供的服务。</li>
<li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li>
<li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li>
<li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li>
<li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li>
</ol>
<h3 id="32-dubbo-负载均衡策略有哪些"><a class="markdownIt-Anchor" href="#32-dubbo-负载均衡策略有哪些"></a> 3.2. Dubbo 负载均衡策略有哪些？</h3>
<h5 id="random"><a class="markdownIt-Anchor" href="#random"></a> Random</h5>
<ul>
<li>随机，按权重设置随机概率。</li>
<li>在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</li>
</ul>
<h5 id="roundrobin"><a class="markdownIt-Anchor" href="#roundrobin"></a> RoundRobin</h5>
<ul>
<li>轮循，按公约后的权重设置轮循比率。</li>
<li>存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</li>
</ul>
<h5 id="leastactive"><a class="markdownIt-Anchor" href="#leastactive"></a> LeastActive</h5>
<ul>
<li>最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。</li>
<li>使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</li>
</ul>
<h5 id="consistenthash"><a class="markdownIt-Anchor" href="#consistenthash"></a> ConsistentHash</h5>
<ul>
<li>一致性 Hash，相同参数的请求总是发到同一提供者。</li>
<li>当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</li>
<li>算法参见：<a href="http://en.wikipedia.org/wiki/Consistent_hashing" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Consistent_hashing</a></li>
<li>缺省只对第一个参数 Hash，如果要修改，请配置 <code>&lt;dubbo:parameter key=&quot;hash.arguments&quot; value=&quot;0,1&quot; /&gt;</code></li>
<li>缺省用 160 份虚拟节点，如果要修改，请配置 <code>&lt;dubbo:parameter key=&quot;hash.nodes&quot; value=&quot;320&quot; /&gt;</code></li>
</ul>
<h3 id="33-dubbo-集群容错策略"><a class="markdownIt-Anchor" href="#33-dubbo-集群容错策略"></a> 3.3. Dubbo 集群容错策略 ？</h3>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/java/javaweb/distributed/rpc/dubbo/dubbo%E9%9B%86%E7%BE%A4%E5%AE%B9%E9%94%99.jpg!zp"/></div>
<ul>
<li><strong>Failover</strong> - 失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 retries=“2” 来设置重试次数(不含第一次)。</li>
<li><strong>Failfast</strong> - 快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</li>
<li><strong>Failsafe</strong> - 失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</li>
<li><strong>Failback</strong> - 失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</li>
<li><strong>Forking</strong> - 并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=“2” 来设置最大并行数。</li>
<li><strong>Broadcast</strong> - 播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。</li>
</ul>
<h3 id="34-动态代理策略"><a class="markdownIt-Anchor" href="#34-动态代理策略"></a> 3.4. 动态代理策略？</h3>
<p>Dubbo 作为 RPC 框架，首先要完成的就是跨系统，跨网络的服务调用。消费方与提供方遵循统一的接口定义，消费方调用接口时，Dubbo 将其转换成统一格式的数据结构，通过网络传输，提供方根据规则找到接口实现，通过反射完成调用。也就是说，消费方获取的是对远程服务的一个代理(Proxy)，而提供方因为要支持不同的接口实现，需要一个包装层(Wrapper)。调用的过程大概是这样：</p>
<div align="center"><img src="https://oscimg.oschina.net/oscnet/bef19cd5a31b5ae13aff35a8cb4898faaf0.jpg"/></div>
<p>消费方的 Proxy 和提供方的 Wrapper 得以让 Dubbo 构建出复杂、统一的体系。而这种动态代理与包装也是通过基于 SPI 的插件方式实现的，它的接口就是<strong>ProxyFactory</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SPI</span>(<span class="string">"javassist"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.PROXY_KEY&#125;)</span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.PROXY_KEY&#125;)</span><br><span class="line">    &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">(T proxy, Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ProxyFactory 有两种实现方式，一种是基于 JDK 的代理实现，一种是基于 javassist 的实现。ProxyFactory 接口上定义了@SPI(“javassist”)，默认为 javassist 的实现。</p>
<h3 id="35-dubbo-支持哪些序列化协议hessianhessian-的数据结构"><a class="markdownIt-Anchor" href="#35-dubbo-支持哪些序列化协议hessianhessian-的数据结构"></a> 3.5. Dubbo 支持哪些序列化协议？Hessian？Hessian 的数据结构？</h3>
<ol>
<li>dubbo 序列化，阿里尚不成熟的 java 序列化实现。</li>
<li>hessian2 序列化：hessian 是一种跨语言的高效二进制的序列化方式，但这里实际不是原生的 hessian2 序列化，而是阿里修改过的 hessian lite，它是 dubbo RPC 默认启用的序列化方式。</li>
<li>json 序列化：目前有两种实现，一种是采用的阿里的 fastjson 库，另一种是采用 dubbo 中自已实现的简单 json 库，一般情况下，json 这种文本序列化性能不如二进制序列化。</li>
<li>java 序列化：主要是采用 JDK 自带的 java 序列化实现，性能很不理想。</li>
<li>Kryo 和 FST：Kryo 和 FST 的性能依然普遍优于 hessian 和 dubbo 序列化。</li>
</ol>
<p>Hessian 序列化与 Java 默认的序列化区别？</p>
<p>Hessian 是一个轻量级的 remoting on http 工具，采用的是 Binary RPC 协议，所以它很适合于发送二进制数据，同时又具有防火墙穿透能力。</p>
<ol>
<li>Hessian 支持跨语言串行</li>
<li>比 java 序列化具有更好的性能和易用性</li>
<li>支持的语言比较多</li>
</ol>
<h3 id="36-protoco-buffer-是什么"><a class="markdownIt-Anchor" href="#36-protoco-buffer-是什么"></a> 3.6. Protoco Buffer 是什么？</h3>
<p>Protocol Buffer 是 Google 出品的一种轻量 &amp; 高效的结构化数据存储格式，性能比 Json、XML 真的强！太！多！</p>
<p>Protocol Buffer 的序列化 &amp; 反序列化简单 &amp; 速度快的原因是：</p>
<ol>
<li>编码 / 解码 方式简单（只需要简单的数学运算 = 位移等等）</li>
<li>采用 Protocol Buffer 自身的框架代码 和 编译器 共同完成</li>
</ol>
<p>Protocol Buffer 的数据压缩效果好（即序列化后的数据量体积小）的原因是：</p>
<ol>
<li>采用了独特的编码方式，如 Varint、Zigzag 编码方式等等</li>
<li>采用 T - L - V 的数据存储方式：减少了分隔符的使用 &amp; 数据存储得紧凑</li>
</ol>
<h3 id="37-注册中心挂了可以继续通信吗"><a class="markdownIt-Anchor" href="#37-注册中心挂了可以继续通信吗"></a> 3.7. 注册中心挂了可以继续通信吗？</h3>
<p>可以。Dubbo 消费者在应用启动时会从注册中心拉取已注册的生产者的地址接口，并缓存在本地。每次调用时，按照本地存储的地址进行调用。</p>
<h3 id="38-zookeeper-原理是什么zookeeper-有什么用"><a class="markdownIt-Anchor" href="#38-zookeeper-原理是什么zookeeper-有什么用"></a> 3.8. ZooKeeper 原理是什么？ZooKeeper 有什么用？</h3>
<p>ZooKeeper 是一个分布式应用协调系统，已经用到了许多分布式项目中，用来完成统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等工作。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/distributed/rpc/zookeeper/zookeeper-service.png!zp" />
</div>
<ol>
<li>每个 Server 在内存中存储了一份数据；</li>
<li>Zookeeper 启动时，将从实例中选举一个 leader（Paxos 协议）；</li>
<li>Leader 负责处理数据更新等操作（Zab 协议）；</li>
<li>一个更新操作成功，当且仅当大多数 Server 在内存中成功修改数据。</li>
</ol>
<h3 id="39-netty-有什么用niobioaio-有什么用有什么区别"><a class="markdownIt-Anchor" href="#39-netty-有什么用niobioaio-有什么用有什么区别"></a> 3.9. Netty 有什么用？NIO/BIO/AIO 有什么用？有什么区别？</h3>
<p>Netty 是一个“网络通讯框架”。</p>
<p>Netty 进行事件处理的流程。<code>Channel</code>是连接的通道，是 ChannelEvent 的产生者，而<code>ChannelPipeline</code>可以理解为 ChannelHandler 的集合。</p>
<div align="center"><img src="https://camo.githubusercontent.com/5f7331d15c79fba29474c5be6e9e86db465637c3/687474703a2f2f7374617469632e6f736368696e612e6e65742f75706c6f6164732f73706163652f323031332f303932312f3137343033325f313872625f3139303539312e706e67"/></div>
<blockquote>
<p>参考：<a href="https://github.com/code4craft/netty-learning/blob/master/posts/ch1-overview.md" target="_blank" rel="noopener">https://github.com/code4craft/netty-learning/blob/master/posts/ch1-overview.md</a></p>
</blockquote>
<p>IO 的方式通常分为几种：</p>
<ul>
<li>同步阻塞的 BIO</li>
<li>同步非阻塞的 NIO</li>
<li>异步非阻塞的 AIO</li>
</ul>
<p>在使用同步 I/O 的网络应用中，如果要同时处理多个客户端请求，或是在客户端要同时和多个服务器进行通讯，就必须使用多线程来处理。</p>
<p>NIO 基于 Reactor，当 socket 有流可读或可写入 socket 时，操作系统会相应的通知引用程序进行处理，应用再将流读取到缓冲区或写入操作系统。也就是说，这个时候，已经不是一个连接就要对应一个处理线程了，而是有效的请求，对应一个线程，当连接没有数据时，是没有工作线程来处理的。</p>
<p>与 NIO 不同，当进行读写操作时，只须直接调用 API 的 read 或 write 方法即可。这两种方法均为异步的，对于读操作而言，当有流可读取时，操作系统会将可读的流传入 read 方法的缓冲区，并通知应用程序；对于写操作而言，当操作系统将 write 方法传递的流写入完毕时，操作系统主动通知应用程序。 即可以理解为，read/write 方法都是异步的，完成后会主动调用回调函数。</p>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/skiof007/article/details/52873421" target="_blank" rel="noopener">https://blog.csdn.net/skiof007/article/details/52873421</a></p>
</blockquote>
<h3 id="310-为什么要进行系统拆分拆分不用-dubbo-可以吗"><a class="markdownIt-Anchor" href="#310-为什么要进行系统拆分拆分不用-dubbo-可以吗"></a> 3.10. 为什么要进行系统拆分？拆分不用 Dubbo 可以吗？</h3>
<p>系统拆分从资源角度分为：应用拆分和数据库拆分。</p>
<p>从采用的先后顺序可分为：水平扩展、垂直拆分、业务拆分、水平拆分。</p>
<div align="center"><img src="http://misc.linkedkeeper.com/misc/img/blog/201804/linkedkeeper0_9c2ed2ed-6156-40f7-ad08-20af067047ca.jpg"/></div>
<p>是否使用服务依据实际业务场景来决定。</p>
<p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。</p>
<p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。</p>
<h3 id="311-dubbo-和-thrift-有什么区别"><a class="markdownIt-Anchor" href="#311-dubbo-和-thrift-有什么区别"></a> 3.11. Dubbo 和 Thrift 有什么区别？</h3>
<ul>
<li>Thrift 是跨语言的 RPC 框架。</li>
<li>Dubbo 支持服务治理，而 Thrift 不支持。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/design/theory/distributed-base-theory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/design/theory/distributed-base-theory/" class="post-title-link" itemprop="url">分布式系统基本原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-09 17:43:00" itemprop="dateCreated datePublished" datetime="2018-07-09T17:43:00+08:00">2018-07-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-01-19 21:55:06" itemprop="dateModified" datetime="2020-01-19T21:55:06+08:00">2020-01-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index">
                    <span itemprop="name">设计</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/" itemprop="url" rel="index">
                    <span itemprop="name">系统原理</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/design/theory/distributed-base-theory/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="design/theory/distributed-base-theory/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="分布式系统基本原理"><a class="markdownIt-Anchor" href="#分布式系统基本原理"></a> 分布式系统基本原理</h1>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#1-%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%AF%E8%AF%AD">1. 分布式术语</a>
<ul>
<li><a href="#11-%E5%BC%82%E5%B8%B8">1.1. 异常</a></li>
<li><a href="#12-%E8%B6%85%E6%97%B6">1.2. 超时</a></li>
<li><a href="#13-%E8%A1%A1%E9%87%8F%E6%8C%87%E6%A0%87">1.3. 衡量指标</a></li>
</ul>
</li>
<li><a href="#2-%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83">2. 数据分布</a>
<ul>
<li><a href="#21-%E5%93%88%E5%B8%8C%E5%88%86%E5%B8%83">2.1. 哈希分布</a></li>
<li><a href="#22-%E9%A1%BA%E5%BA%8F%E5%88%86%E5%B8%83">2.2. 顺序分布</a></li>
<li><a href="#23-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">2.3. 负载均衡</a></li>
</ul>
</li>
<li><a href="#3-%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA">3. 分布式理论</a>
<ul>
<li><a href="#31-cap">3.1. CAP</a></li>
<li><a href="#32-base">3.2. BASE</a></li>
</ul>
</li>
<li><a href="#4-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98">4. 分布式事务问题</a>
<ul>
<li><a href="#41-%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A42pc">4.1. 两阶段提交（2PC）</a></li>
<li><a href="#42-%E8%A1%A5%E5%81%BF%E4%BA%8B%E5%8A%A1tcc">4.2. 补偿事务（TCC）</a></li>
<li><a href="#43-%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF%E8%A1%A8%E5%BC%82%E6%AD%A5%E7%A1%AE%E4%BF%9D">4.3. 本地消息表（异步确保）</a></li>
<li><a href="#44-mq-%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF">4.4. MQ 事务消息</a></li>
</ul>
</li>
<li><a href="#5-%E5%85%B1%E8%AF%86%E6%80%A7%E9%97%AE%E9%A2%98">5. 共识性问题</a>
<ul>
<li><a href="#51-paxos">5.1. Paxos</a></li>
<li><a href="#52-raft">5.2. Raft</a></li>
</ul>
</li>
<li><a href="#6-%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98">6. 分布式缓存问题</a>
<ul>
<li><a href="#61-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9">6.1. 缓存雪崩</a></li>
<li><a href="#62-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F">6.2. 缓存穿透</a></li>
<li><a href="#63-%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD">6.3. 缓存预热</a></li>
<li><a href="#64-%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0">6.4. 缓存更新</a></li>
<li><a href="#65-%E7%BC%93%E5%AD%98%E9%99%8D%E7%BA%A7">6.5. 缓存降级</a></li>
</ul>
</li>
<li><a href="#7-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">7. 参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="1-分布式术语"><a class="markdownIt-Anchor" href="#1-分布式术语"></a> 1. 分布式术语</h2>
<h3 id="11-异常"><a class="markdownIt-Anchor" href="#11-异常"></a> 1.1. 异常</h3>
<h4 id="服务器宕机"><a class="markdownIt-Anchor" href="#服务器宕机"></a> 服务器宕机</h4>
<p>内存错误、服务器停电等都会导致服务器宕机，此时节点无法正常工作，称为不可用。</p>
<p>服务器宕机会导致节点失去所有内存信息，因此需要将内存信息保存到持久化介质上。</p>
<h4 id="网络异常"><a class="markdownIt-Anchor" href="#网络异常"></a> 网络异常</h4>
<p>有一种特殊的网络异常称为——<strong>网络分区</strong> ，即集群的所有节点被划分为多个区域，每个区域内部可以通信，但是区域之间无法通信。</p>
<h4 id="磁盘故障"><a class="markdownIt-Anchor" href="#磁盘故障"></a> 磁盘故障</h4>
<p>磁盘故障是一种发生概率很高的异常。</p>
<p>使用冗余机制，将数据存储到多台服务器。</p>
<h3 id="12-超时"><a class="markdownIt-Anchor" href="#12-超时"></a> 1.2. 超时</h3>
<p>在分布式系统中，一个请求除了成功和失败两种状态，还存在着超时状态。</p>
<p>可以将服务器的操作设计为具有 <strong>幂等性</strong> ，即执行多次的结果与执行一次的结果相同。如果使用这种方式，当出现超时的时候，可以不断地重新请求直到成功。</p>
<h3 id="13-衡量指标"><a class="markdownIt-Anchor" href="#13-衡量指标"></a> 1.3. 衡量指标</h3>
<h4 id="性能"><a class="markdownIt-Anchor" href="#性能"></a> 性能</h4>
<p>常见的性能指标有：吞吐量、响应时间。</p>
<p>其中，吞吐量指系统在某一段时间可以处理的请求总数，通常为每秒的读操作数或者写操作数；响应时间指从某个请求发出到接收到返回结果消耗的时间。</p>
<p>这两个指标往往是矛盾的，追求高吞吐的系统，往往很难做到低响应时间，解释如下：</p>
<ul>
<li>
<p>在无并发的系统中，吞吐量为响应时间的倒数，例如响应时间为 10 ms，那么吞吐量为 100 req/s，因此高吞吐也就意味着低响应时间。</p>
</li>
<li>
<p>但是在并发的系统中，由于一个请求在调用 I/O 资源的时候，需要进行等待。服务器端一般使用的是异步等待方式，即等待的请求被阻塞之后不需要一直占用 CPU 资源。这种方式能大大提高 CPU 资源的利用率，例如上面的例子中，单个请求在无并发的系统中响应时间为 10 ms，如果在并发的系统中，那么吞吐量将大于 100 req/s。因此为了追求高吞吐量，通常会提高并发程度。但是并发程度的增加，会导致请求的平均响应时间也增加，因为请求不能马上被处理，需要和其它请求一起进行并发处理，响应时间自然就会增高。</p>
</li>
</ul>
<h4 id="可用性"><a class="markdownIt-Anchor" href="#可用性"></a> 可用性</h4>
<p>可用性指系统在面对各种异常时可以提供正常服务的能力。可以用系统可用时间占总时间的比值来衡量，4 个 9 的可用性表示系统 99.99% 的时间是可用的。</p>
<h4 id="一致性"><a class="markdownIt-Anchor" href="#一致性"></a> 一致性</h4>
<p>可以从两个角度理解一致性：从客户端的角度，读写操作是否满足某种特性；从服务器的角度，多个数据副本之间是否一致。</p>
<h4 id="可扩展性"><a class="markdownIt-Anchor" href="#可扩展性"></a> 可扩展性</h4>
<p>指系统通过扩展集群服务器规模来提高性能的能力。理想的分布式系统需要实现“线性可扩展”，即随着集群规模的增加，系统的整体性能也会线性增加。</p>
<h2 id="2-数据分布"><a class="markdownIt-Anchor" href="#2-数据分布"></a> 2. 数据分布</h2>
<p>分布式存储系统的数据分布在多个节点中，常用的数据分布方式有哈希分布和顺序分布。</p>
<p>数据库的水平切分（Sharding）也是一种分布式存储方法，下面的数据分布方法同样适用于 Sharding。</p>
<h3 id="21-哈希分布"><a class="markdownIt-Anchor" href="#21-哈希分布"></a> 2.1. 哈希分布</h3>
<p>哈希分布就是将数据计算哈希值之后，按照哈希值分配到不同的节点上。例如有 N 个节点，数据的主键为 key，则将该数据分配的节点序号为：hash(key)%N。</p>
<p>传统的哈希分布算法存在一个问题：当节点数量变化时，也就是 N 值变化，那么几乎所有的数据都需要重新分布，将导致大量的数据迁移。</p>
<p><strong>一致性哈希</strong></p>
<p>Distributed Hash Table（DHT）：对于哈希空间 [0, 2<sup>n</sup>-1]，将该哈希空间看成一个哈希环，将每个节点都配置到哈希环上。每个数据对象通过哈希取模得到哈希值之后，存放到哈希环中顺时针方向第一个大于等于该哈希值的节点上。</p>
<p>一致性哈希的优点是在增加或者删除节点时只会影响到哈希环中相邻的节点，例如下图中新增节点 X，只需要将数据对象 C 重新存放到节点 X 上即可，对于节点 A、B、D 都没有影响。</p>
<h3 id="22-顺序分布"><a class="markdownIt-Anchor" href="#22-顺序分布"></a> 2.2. 顺序分布</h3>
<p>哈希分布式破坏了数据的有序性，顺序分布则不会。</p>
<p>顺序分布的数据划分为多个连续的部分，按数据的 ID 或者时间分布到不同节点上。例如下图中，User 表的 ID 范围为 1 ~ 7000，使用顺序分布可以将其划分成多个子表，对应的主键范围为 1 ~ 1000，1001 ~ 2000，…，6001 ~ 7000。</p>
<p>顺序分布的优点是可以充分利用每个节点的空间，而哈希分布很难控制一个节点存储多少数据。</p>
<p>但是顺序分布需要使用一个映射表来存储数据到节点的映射，这个映射表通常使用单独的节点来存储。当数据量非常大时，映射表也随着变大，那么一个节点就可能无法存放下整个映射表。并且单个节点维护着整个映射表的开销很大，查找速度也会变慢。为了解决以上问题，引入了一个中间层，也就是 Meta 表，从而分担映射表的维护工作。</p>
<h3 id="23-负载均衡"><a class="markdownIt-Anchor" href="#23-负载均衡"></a> 2.3. 负载均衡</h3>
<p>衡量负载的因素很多，如 CPU、内存、磁盘等资源使用情况、读写请求数等。</p>
<p>分布式系统存储应当能够自动负载均衡，当某个节点的负载较高，将它的部分数据迁移到其它节点。</p>
<p>每个集群都有一个总控节点，其它节点为工作节点，由总控节点根据全局负载信息进行整体调度，工作节点定时发送心跳包（Heartbeat）将节点负载相关的信息发送给总控节点。</p>
<p>一个新上线的工作节点，由于其负载较低，如果不加控制，总控节点会将大量数据同时迁移到该节点上，造成该节点一段时间内无法工作。因此负载均衡操作需要平滑进行，新加入的节点需要较长的一段时间来达到比较均衡的状态。</p>
<h2 id="3-分布式理论"><a class="markdownIt-Anchor" href="#3-分布式理论"></a> 3. 分布式理论</h2>
<h3 id="31-cap"><a class="markdownIt-Anchor" href="#31-cap"></a> 3.1. CAP</h3>
<p>分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容忍性（P：Partition Tolerance），最多只能同时满足其中两项。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/分布式理论-CAP.jpg" width="450"/>
</div>
<h4 id="一致性-2"><a class="markdownIt-Anchor" href="#一致性-2"></a> 一致性</h4>
<p>一致性指的是多个数据副本是否能保持一致的特性。</p>
<p>在一致性的条件下，系统在执行数据更新操作之后能够从一致性状态转移到另一个一致性状态。</p>
<p>对系统的一个数据更新成功之后，如果所有用户都能够读取到最新的值，该系统就被认为具有强一致性。</p>
<h4 id="可用性-2"><a class="markdownIt-Anchor" href="#可用性-2"></a> 可用性</h4>
<p>可用性指分布式系统在面对各种异常时可以提供正常服务的能力，可以用系统可用时间占总时间的比值来衡量，4 个 9 的可用性表示系统 99.99% 的时间是可用的。</p>
<p>在可用性条件下，系统提供的服务一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。</p>
<h4 id="分区容忍性"><a class="markdownIt-Anchor" href="#分区容忍性"></a> 分区容忍性</h4>
<p>网络分区指分布式系统中的节点被划分为多个区域，每个区域内部可以通信，但是区域之间无法通信。</p>
<p>在分区容忍性条件下，分布式系统在遇到任何网络分区故障的时候，仍然需要能对外提供一致性和可用性的服务，除非是整个网络环境都发生了故障。</p>
<h4 id="权衡"><a class="markdownIt-Anchor" href="#权衡"></a> 权衡</h4>
<p>在分布式系统中，分区容忍性必不可少，因为需要总是假设网络是不可靠的。因此，CAP 理论实际在是要在可用性和一致性之间做权衡。</p>
<p>可用性和一致性往往是冲突的，很难都使它们同时满足。在多个节点之间进行数据同步时，</p>
<ul>
<li>为了保证一致性（CP），就需要让所有节点下线成为不可用的状态，等待同步完成；</li>
<li>为了保证可用性（AP），在同步过程中允许读取所有节点的数据，但是数据可能不一致。</li>
</ul>
<h3 id="32-base"><a class="markdownIt-Anchor" href="#32-base"></a> 3.2. BASE</h3>
<p>BASE 是基本可用（Basically Available）、软状态（Soft State）和最终一致性（Eventually Consistent）三个短语的缩写。</p>
<p>BASE 理论是对 CAP 中一致性和可用性权衡的结果，它的理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/distributed/architecture/分布式理论-BASE.png" />
</div>
<h4 id="基本可用"><a class="markdownIt-Anchor" href="#基本可用"></a> 基本可用</h4>
<p>指分布式系统在出现故障的时候，保证核心可用，允许损失部分可用性。</p>
<p>例如，电商在做促销时，为了保证购物系统的稳定性，部分消费者可能会被引导到一个降级的页面。</p>
<h4 id="软状态"><a class="markdownIt-Anchor" href="#软状态"></a> 软状态</h4>
<p>指允许系统中的数据存在中间状态，并认为该中间状态不会影响系统整体可用性，即允许系统不同节点的数据副本之间进行同步的过程存在延时。</p>
<h4 id="最终一致性"><a class="markdownIt-Anchor" href="#最终一致性"></a> 最终一致性</h4>
<p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能达到一致的状态。</p>
<p>ACID 要求强一致性，通常运用在传统的数据库系统上。而 BASE 要求最终一致性，通过牺牲强一致性来达到可用性，通常运用在大型分布式系统中。</p>
<p>在实际的分布式场景中，不同业务单元和组件对一致性的要求是不同的，因此 ACID 和 BASE 往往会结合在一起使用。</p>
<h2 id="4-分布式事务问题"><a class="markdownIt-Anchor" href="#4-分布式事务问题"></a> 4. 分布式事务问题</h2>
<h3 id="41-两阶段提交2pc"><a class="markdownIt-Anchor" href="#41-两阶段提交2pc"></a> 4.1. 两阶段提交（2PC）</h3>
<p>两阶段提交（Two-phase Commit，2PC）</p>
<p>主要用于实现分布式事务，分布式事务指的是事务操作跨越多个节点，并且要求满足事务的 ACID 特性。</p>
<p>通过引入协调者（Coordinator）来调度参与者的行为，并最终决定这些参与者是否要真正执行事务。</p>
<h4 id="运行过程"><a class="markdownIt-Anchor" href="#运行过程"></a> 运行过程</h4>
<h5 id="准备阶段"><a class="markdownIt-Anchor" href="#准备阶段"></a> 准备阶段</h5>
<p>协调者询问参与者事务是否执行成功，参与者发回事务执行结果。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/分布式事务两阶段提交-01.jpg" />
</div>
<h5 id="提交阶段"><a class="markdownIt-Anchor" href="#提交阶段"></a> 提交阶段</h5>
<p>如果事务在每个参与者上都执行成功，事务协调者发送通知让参与者提交事务；否则，协调者发送通知让参与者回滚事务。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/分布式事务两阶段提交-02.jpg" />
</div>
<p>需要注意的是，在准备阶段，参与者执行了事务，但是还未提交。只有在提交阶段接收到协调者发来的通知后，才进行提交或者回滚。</p>
<h4 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h4>
<h5 id="同步阻塞"><a class="markdownIt-Anchor" href="#同步阻塞"></a> 同步阻塞</h5>
<p>所有事务参与者在等待其它参与者响应的时候都处于同步阻塞状态，无法进行其它操作。</p>
<h5 id="单点问题"><a class="markdownIt-Anchor" href="#单点问题"></a> 单点问题</h5>
<p>协调者在 2PC 中起到非常大的作用，发生故障将会造成很大影响，特别是在阶段二发生故障，所有参与者会一直等待状态，无法完成其它操作。</p>
<h5 id="数据不一致"><a class="markdownIt-Anchor" href="#数据不一致"></a> 数据不一致</h5>
<p>在阶段二，如果协调者只发送了部分 Commit 消息，此时网络发生异常，那么只有部分参与者接收到 Commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。</p>
<h5 id="太过保守"><a class="markdownIt-Anchor" href="#太过保守"></a> 太过保守</h5>
<p>任意一个节点失败就会导致整个事务失败，没有完善的容错机制。</p>
<h4 id="pc-优缺点"><a class="markdownIt-Anchor" href="#pc-优缺点"></a> PC 优缺点</h4>
<p>优点：尽量保证了数据的强一致，适合对数据强一致要求很高的关键领域。（其实也不能 100%保证强一致）<br />
缺点：实现复杂，牺牲了可用性，对性能影响较大，不适合高并发高性能场景。</p>
<h3 id="42-补偿事务tcc"><a class="markdownIt-Anchor" href="#42-补偿事务tcc"></a> 4.2. 补偿事务（TCC）</h3>
<p>补偿事务（TCC）其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。它分为三个阶段：</p>
<ol>
<li>Try 阶段主要是对业务系统做检测及资源预留。</li>
<li>Confirm 阶段主要是对业务系统做确认提交，Try 阶段执行成功并开始执行 Confirm 阶段时，默认 Confirm 阶段是不会出错的。即：只要 Try 成功，Confirm 一定成功。</li>
<li>Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。</li>
</ol>
<p>举个例子，假设 Bob 要向 Smith 转账，思路大概是：</p>
<ol>
<li>首先在 Try 阶段，要先调用远程接口把 Smith 和 Bob 的钱给冻结起来。</li>
<li>在 Confirm 阶段，执行远程调用的转账的操作，转账成功进行解冻。</li>
<li>如果第 2 步执行成功，那么转账成功，如果第二步执行失败，则调用远程冻结接口对应的解冻方法 (Cancel)。</li>
</ol>
<h4 id="tcc-优缺点"><a class="markdownIt-Anchor" href="#tcc-优缺点"></a> TCC 优缺点</h4>
<ul>
<li>优点：跟 2PC 比起来，实现以及流程相对简单了一些，但数据的一致性比 2PC 也要差一些。</li>
<li>缺点：缺点还是比较明显的，在 2,3 步中都有可能失败。TCC 属于应用层的一种补偿方式，所以需要程序员在实现的时候多写很多补偿的代码，在一些场景中，一些业务流程可能用 TCC 不太好定义及处理。</li>
</ul>
<h3 id="43-本地消息表异步确保"><a class="markdownIt-Anchor" href="#43-本地消息表异步确保"></a> 4.3. 本地消息表（异步确保）</h3>
<p>本地消息表与业务数据表处于同一个数据库中，这样就能利用本地事务来保证在对这两个表的操作满足事务特性。</p>
<ol>
<li>在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送一个消息，本地事务能保证这个消息一定会被写入本地消息表中。</li>
<li>之后将本地消息表中的消息转发到 Kafka 等消息队列（MQ）中，如果转发成功则将消息从本地消息表中删除，否则继续重新转发。</li>
<li>在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作。</li>
</ol>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/分布式事务本地消息.jpg" />
</div>
<p>这种方案遵循 BASE 理论，采用的是最终一致性。</p>
<p>本地消息表利用了本地事务来实现分布式事务，并且使用了消息队列来保证最终一致性。</p>
<h4 id="本地消息表优缺点"><a class="markdownIt-Anchor" href="#本地消息表优缺点"></a> 本地消息表优缺点</h4>
<ul>
<li>优点：一种非常经典的实现，避免了分布式事务，实现了最终一致性。</li>
<li>缺点：消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。</li>
</ul>
<h3 id="44-mq-事务消息"><a class="markdownIt-Anchor" href="#44-mq-事务消息"></a> 4.4. MQ 事务消息</h3>
<p>有一些第三方的 MQ 是支持事务消息的，比如 RocketMQ，他们支持事务消息的方式也是类似于采用的二阶段提交。但是市面上一些主流的 MQ 都是不支持事务消息的，比如 RabbitMQ 和 Kafka 都不支持。</p>
<p>以阿里的 RocketMQ 中间件为例，其思路大致为：</p>
<ol>
<li>Prepared 消息，会拿到消息的地址。</li>
<li>执行本地事务。</li>
<li>通过第一阶段拿到的地址去访问消息，并修改状态。</li>
</ol>
<p>也就是说在业务方法内要想消息队列提交两次请求，一次发送消息和一次确认消息。如果确认消息发送失败了 RocketMQ 会定期扫描消息集群中的事务消息，这时候发现了 Prepared 消息，它会向消息发送者确认，所以生产方需要实现一个 check 接口，RocketMQ 会根据发送端设置的策略来决定是回滚还是继续发送确认消息。这样就保证了消息发送与本地事务同时成功或同时失败。</p>
<h4 id="mq-事务消息优缺点"><a class="markdownIt-Anchor" href="#mq-事务消息优缺点"></a> MQ 事务消息优缺点</h4>
<ul>
<li>优点：实现了最终一致性，不需要依赖本地数据库事务。</li>
<li>缺点：实现难度大，主流 MQ 不支持。</li>
</ul>
<h2 id="5-共识性问题"><a class="markdownIt-Anchor" href="#5-共识性问题"></a> 5. 共识性问题</h2>
<h3 id="51-paxos"><a class="markdownIt-Anchor" href="#51-paxos"></a> 5.1. Paxos</h3>
<p>用于达成共识性问题，即对多个节点产生的值，该算法能保证只选出唯一一个值。</p>
<p>主要有三类节点：</p>
<ul>
<li>提议者（Proposer）：提议一个值；</li>
<li>接受者（Acceptor）：对每个提议进行投票；</li>
<li>告知者（Learner）：被告知投票的结果，不参与投票过程。</li>
</ul>
<p>算法需要满足 safety 和 liveness 两方面的约束要求（实际上这两个基础属性是大部分分布式算法都该考虑的）：</p>
<ul>
<li>safety：保证决议结果是对的，无歧义的，不会出现错误情况。
<ul>
<li>决议（value）只有在被 proposers 提出的 proposal 才能被最终批准；</li>
<li>在一次执行实例中，只批准（chosen）一个最终决议，意味着多数接受（accept）的结果能成为决议；</li>
</ul>
</li>
<li>liveness：保证决议过程能在有限时间内完成。
<ul>
<li>决议总会产生，并且 learners 能获得被批准（chosen）的决议。</li>
</ul>
</li>
</ul>
<p>基本过程包括 proposer 提出提案，先争取大多数 acceptor 的支持，超过一半支持时，则发送结案结果给所有人进行确认。一个潜在的问题是 proposer 在此过程中出现故障，可以通过超时机制来解决。极为凑巧的情况下，每次新的一轮提案的 proposer 都恰好故障，系统则永远无法达成一致（概率很小）。</p>
<p>Paxos 能保证在超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">1/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord">2</span></span></span></span> 的正常节点存在时，系统能达成共识。</p>
<h4 id="单个提案者多接收者"><a class="markdownIt-Anchor" href="#单个提案者多接收者"></a> 单个提案者+多接收者</h4>
<p>如果系统中限定只有某个特定节点是提案者，那么一致性肯定能达成（只有一个方案，要么达成，要么失败）。提案者只要收到了来自多数接收者的投票，即可认为通过，因为系统中不存在其他的提案。</p>
<p>但一旦提案者故障，则系统无法工作。</p>
<h4 id="多个提案者单个接收者"><a class="markdownIt-Anchor" href="#多个提案者单个接收者"></a> 多个提案者+单个接收者</h4>
<p>限定某个节点作为接收者。这种情况下，共识也很容易达成，接收者收到多个提案，选第一个提案作为决议，拒绝掉后续的提案即可。</p>
<p>缺陷也是容易发生单点故障，包括接收者故障或首个提案者节点故障。</p>
<p>以上两种情形其实类似主从模式，虽然不那么可靠，但因为原理简单而被广泛采用。</p>
<p>当提案者和接收者都推广到多个的情形，会出现一些挑战。</p>
<h4 id="多个提案者多个接收者"><a class="markdownIt-Anchor" href="#多个提案者多个接收者"></a> 多个提案者+多个接收者</h4>
<p>既然限定单提案者或单接收者都会出现故障，那么就得允许出现多个提案者和多个接收者。问题一下子变得复杂了。</p>
<p>一种情况是同一时间片段（如一个提案周期）内只有一个提案者，这时可以退化到单提案者的情形。需要设计一种机制来保障提案者的正确产生，例如按照时间、序列、或者大家猜拳（出一个数字来比较）之类。考虑到分布式系统要处理的工作量很大，这个过程要尽量高效，满足这一条件的机制非常难设计。</p>
<p>另一种情况是允许同一时间片段内可以出现多个提案者。那同一个节点可能收到多份提案，怎么对他们进行区分呢？这个时候采用只接受第一个提案而拒绝后续提案的方法也不适用。很自然的，提案需要带上不同的序号。节点需要根据提案序号来判断接受哪个。比如接受其中序号较大（往往意味着是接受新提出的，因为旧提案者故障概率更大）的提案。</p>
<p>如何为提案分配序号呢？一种可能方案是每个节点的提案数字区间彼此隔离开，互相不冲突。为了满足递增的需求可以配合用时间戳作为前缀字段。</p>
<p>此外，提案者即便收到了多数接收者的投票，也不敢说就一定通过。因为在此过程中系统可能还有其它的提案。</p>
<h3 id="52-raft"><a class="markdownIt-Anchor" href="#52-raft"></a> 5.2. Raft</h3>
<p>Raft 算法是 Paxos 算法的一种简化实现。</p>
<p>包括三种角色：leader、candidate 和 follower，其基本过程为：</p>
<ul>
<li><strong>Leader 选举</strong> - 每个 candidate 随机经过一定时间都会提出选举方案，最近阶段中得票最多者被选为 leader；</li>
<li><strong>同步 log</strong> - leader 会找到系统中 log 最新的记录，并强制所有的 follower 来刷新到这个记录；</li>
</ul>
<p><em>注：此处 log 并非是指日志消息，而是各种事件的发生记录。</em></p>
<h4 id="单个-candidate-的竞选"><a class="markdownIt-Anchor" href="#单个-candidate-的竞选"></a> 单个 Candidate 的竞选</h4>
<p>有三种节点：Follower、Candidate 和 Leader。Leader 会周期性的发送心跳包给 Follower。每个 Follower 都设置了一个随机的竞选超时时间，一般为 150ms~300ms，如果在这个时间内没有收到 Leader 的心跳包，就会变成 Candidate，进入竞选阶段。</p>
<ul>
<li>下图表示一个分布式系统的最初阶段，此时只有 Follower，没有 Leader。Follower A 等待一个随机的竞选超时时间之后，没收到 Leader 发来的心跳包，因此进入竞选阶段。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/raft-candidate-01.gif" />
</div>
<ul>
<li>此时 A 发送投票请求给其它所有节点。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/raft-candidate-02.gif" />
</div>
<ul>
<li>其它节点会对请求进行回复，如果超过一半的节点回复了，那么该 Candidate 就会变成 Leader。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/raft-candidate-03.gif" />
</div>
<ul>
<li>之后 Leader 会周期性地发送心跳包给 Follower，Follower 接收到心跳包，会重新开始计时。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/raft-candidate-04.gif" />
</div>
<h4 id="多个-candidate-竞选"><a class="markdownIt-Anchor" href="#多个-candidate-竞选"></a> 多个 Candidate 竞选</h4>
<ul>
<li>如果有多个 Follower 成为 Candidate，并且所获得票数相同，那么就需要重新开始投票，例如下图中 Candidate B 和 Candidate D 都获得两票，因此需要重新开始投票。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/raft-multi-candidate-01.gif" />
</div>
<ul>
<li>当重新开始投票时，由于每个节点设置的随机竞选超时时间不同，因此能下一次再次出现多个 Candidate 并获得同样票数的概率很低。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/raft-multi-candidate-02.gif" />
</div>
<h4 id="同步日志"><a class="markdownIt-Anchor" href="#同步日志"></a> 同步日志</h4>
<ul>
<li>来自客户端的修改都会被传入 Leader。注意该修改还未被提交，只是写入日志中。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/raft-sync-log-01.gif" />
</div>
<ul>
<li>Leader 会把修改复制到所有 Follower。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/raft-sync-log-02.gif" />
</div>
<ul>
<li>Leader 会等待大多数的 Follower 也进行了修改，然后才将修改提交。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/raft-sync-log-03.gif" />
</div>
<ul>
<li>此时 Leader 会通知的所有 Follower 让它们也提交修改，此时所有节点的值达成一致。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/raft-sync-log-04.gif" />
</div>
<h2 id="6-分布式缓存问题"><a class="markdownIt-Anchor" href="#6-分布式缓存问题"></a> 6. 分布式缓存问题</h2>
<h3 id="61-缓存雪崩"><a class="markdownIt-Anchor" href="#61-缓存雪崩"></a> 6.1. 缓存雪崩</h3>
<p>缓存雪崩是指：在高并发场景下，由于原有缓存失效，新缓存未到期间(例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库 CPU 和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。</p>
<p>解决方案：</p>
<ul>
<li>用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。</li>
<li>还有一个简单的方案，就是将缓存失效时间分散开，不要所有缓存时间长度都设置成 5 分钟或者 10 分钟；比如我们可以在原有的失效时间基础上增加一个随机值，比如 1-5 分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</li>
</ul>
<p>缓存失效时产生的雪崩效应，将所有请求全部放在数据库上，这样很容易就达到数据库的瓶颈，导致服务无法正常提供。尽量避免这种场景的发生。</p>
<h3 id="62-缓存穿透"><a class="markdownIt-Anchor" href="#62-缓存穿透"></a> 6.2. 缓存穿透</h3>
<p>缓存穿透是指：用户查询的数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。</p>
<p>当在流量较大时，出现这样的情况，一直请求 DB，很容易导致服务挂掉。</p>
<p>解决方案：</p>
<ol>
<li>在封装的缓存 SET 和 GET 部分增加个步骤，如果查询一个 KEY 不存在，就以这个 KEY 为前缀设定一个标识 KEY；以后再查询该 KEY 的时候，先查询标识 KEY，如果标识 KEY 存在，就返回一个协定好的非 false 或者 NULL 值，然后 APP 做相应的处理，这样缓存层就不会被穿透。当然这个验证 KEY 的失效时间不能太长。</li>
<li>如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，一般只有几分钟。</li>
<li>采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。</li>
</ol>
<h3 id="63-缓存预热"><a class="markdownIt-Anchor" href="#63-缓存预热"></a> 6.3. 缓存预热</h3>
<p>缓存预热这个应该是一个比较常见的概念，相信很多小伙伴都应该可以很容易的理解，缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p>
<p>解决方案：</p>
<ol>
<li>直接写个缓存刷新页面，上线时手工操作下；</li>
<li>数据量不大，可以在项目启动的时候自动进行加载；</li>
<li>定时刷新缓存；</li>
</ol>
<h3 id="64-缓存更新"><a class="markdownIt-Anchor" href="#64-缓存更新"></a> 6.4. 缓存更新</h3>
<p>除了缓存服务器自带的缓存失效策略之外（Redis 默认的有 6 中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：</p>
<ol>
<li>定时去清理过期的缓存；</li>
<li>当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。</li>
</ol>
<p>两者各有优劣，第一种的缺点是维护大量缓存的 key 是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。</p>
<h3 id="65-缓存降级"><a class="markdownIt-Anchor" href="#65-缓存降级"></a> 6.5. 缓存降级</h3>
<p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</p>
<p>降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。</p>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li>杨传辉. 大规模分布式存储系统: 原理解析与架构实战[M]. 机械工业出版社, 2013.</li>
<li><a href="https://www.gitbook.com/book/yeasy/blockchain_guide/details" target="_blank" rel="noopener">区块链技术指南</a></li>
<li><a href="http://harry.me/blog/2014/12/27/neat-algorithms-paxos/" target="_blank" rel="noopener">NEAT ALGORITHMS - PAXOS</a></li>
<li><a href="http://thesecretlivesofdata.com/raft" target="_blank" rel="noopener">Raft: Understandable Distributed Consensus</a></li>
<li><a href="https://angus.nyc/2012/paxos-by-example/" target="_blank" rel="noopener">Paxos By Example</a></li>
<li><a href="https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html" target="_blank" rel="noopener">聊聊分布式事务，再说说解决方案</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/design/architecture/system-core-technologies/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/design/architecture/system-core-technologies/" class="post-title-link" itemprop="url">大型系统核心技术</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-09 00:00:00" itemprop="dateCreated datePublished" datetime="2018-07-09T00:00:00+08:00">2018-07-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-03 17:08:27" itemprop="dateModified" datetime="2019-12-03T17:08:27+08:00">2019-12-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index">
                    <span itemprop="name">设计</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/design/architecture/system-core-technologies/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="design/architecture/system-core-technologies/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="大型系统核心技术"><a class="markdownIt-Anchor" href="#大型系统核心技术"></a> 大型系统核心技术</h1>
<blockquote>
<p>大型系统的设计目标就是为了快速、高效、稳定的处理海量的数据以及高并发的请求。</p>
<p>单机服务受限于硬件，客观存在着资源瓶颈，难以应对不断增长的数据量和请求量，为了打破瓶颈，大型系统基本上都被设计为分布式系统。</p>
<p>分布式系统由于其面临的共性问题，在很多场景下的解决方案往往也存在着共性。因此，我们会发现，很多优秀的大型系统在设计方案上存在着很多的共同点。</p>
<p>本文主要讨论应对分布式系统共性问题的解决方案，这既可以加深对分布式系统运作原理的理解，也可以作为设计大型分布式系统时的借鉴。</p>
</blockquote>
<h2 id="1-分布式事务"><a class="markdownIt-Anchor" href="#1-分布式事务"></a> 1. 分布式事务</h2>
<blockquote>
<p>参考：<a href="%E5%88%86%E5%B8%83%E5%BC%8F%E5%8E%9F%E7%90%86.md#4-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98">分布式原理#4-分布式事务问题</a></p>
</blockquote>
<h2 id="2-分布式锁"><a class="markdownIt-Anchor" href="#2-分布式锁"></a> 2. 分布式锁</h2>
<p>Java 原生 API 虽然有并发锁，但并没有提供分布式锁的能力，所以针对分布式场景中的锁需要解决的方案。</p>
<p>分布式锁的解决方案大致有以下几种：</p>
<ul>
<li>基于数据库实现</li>
<li>基于缓存（redis，memcached 等）实现</li>
<li>基于 Zookeeper 实现</li>
</ul>
<h3 id="21-基于数据库实现分布式锁"><a class="markdownIt-Anchor" href="#21-基于数据库实现分布式锁"></a> 2.1. 基于数据库实现分布式锁</h3>
<h4 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h4>
<h5 id="1-创建表"><a class="markdownIt-Anchor" href="#1-创建表"></a> 1. 创建表</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`methodLock`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">  <span class="string">`method_name`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'锁定的方法名'</span>,</span><br><span class="line">  <span class="string">`desc`</span> <span class="built_in">varchar</span>(<span class="number">1024</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'备注信息'</span>,</span><br><span class="line">  <span class="string">`update_time`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'保存数据时间，自动生成'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`uidx_method_name`</span> (<span class="string">`method_name `</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'锁定中的方法'</span>;</span><br></pre></td></tr></table></figure>
<h5 id="2-获取锁"><a class="markdownIt-Anchor" href="#2-获取锁"></a> 2. 获取锁</h5>
<p>想要锁住某个方法时，执行以下 SQL：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> methodLock(method_name,<span class="keyword">desc</span>) <span class="keyword">values</span> (‘method_name’,‘<span class="keyword">desc</span>’)</span><br></pre></td></tr></table></figure>
<p>因为我们对 <code>method_name</code> 做了唯一性约束，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，可以执行方法体内容。</p>
<p>成功插入则获取锁。</p>
<h5 id="3-释放锁"><a class="markdownIt-Anchor" href="#3-释放锁"></a> 3. 释放锁</h5>
<p>当方法执行完毕之后，想要释放锁的话，需要执行以下 Sql:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> methodLock <span class="keyword">where</span> method_name =<span class="string">'method_name'</span></span><br></pre></td></tr></table></figure>
<h4 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h4>
<ol>
<li>这把锁强依赖数据库的可用性。如果数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。</li>
<li>这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。</li>
<li>这把锁只能是非阻塞的，因为数据的 insert 操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。</li>
<li>这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。</li>
</ol>
<h4 id="解决办法"><a class="markdownIt-Anchor" href="#解决办法"></a> 解决办法</h4>
<ol>
<li>单点问题可以用多数据库实例，同时塞 N 个表，N/2+1 个成功就任务锁定成功</li>
<li>写一个定时任务，隔一段时间清除一次过期的数据。</li>
<li>写一个 while 循环，不断的重试插入，直到成功。</li>
<li>在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。</li>
</ol>
<h4 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h4>
<ul>
<li>优点: 直接借助数据库，容易理解。</li>
<li>缺点: 会有各种各样的问题，在解决问题的过程中会使整个方案变得越来越复杂。操作数据库需要一定的开销，性能问题需要考虑。</li>
</ul>
<h3 id="22-基于-redis-实现分布式锁"><a class="markdownIt-Anchor" href="#22-基于-redis-实现分布式锁"></a> 2.2. 基于 Redis 实现分布式锁</h3>
<p>相比于用数据库来实现分布式锁，基于缓存实现的分布式锁的性能会更好一些。目前有很多成熟的分布式产品，包括 Redis、memcache、Tair 等。这里以 Redis 举例。</p>
<h4 id="redis-命令"><a class="markdownIt-Anchor" href="#redis-命令"></a> Redis 命令</h4>
<ul>
<li>setnx - setnx key val：当且仅当 key 不存在时，set 一个 key 为 val 的字符串，返回 1；若 key 存在，则什么都不做，返回 0。</li>
<li>expire - expire key timeout：为 key 设置一个超时时间，单位为 second，超过这个时间锁会自动释放，避免死锁。</li>
<li>delete - delete key：删除 key</li>
</ul>
<h4 id="实现-2"><a class="markdownIt-Anchor" href="#实现-2"></a> 实现</h4>
<p>单点实现步骤：</p>
<ol>
<li>获取锁的使用，使用 setnx 加锁，锁的 value 值为一个随机生成的 UUID，再使用 expire 设置一个过期值。</li>
<li>获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。</li>
<li>释放锁的时候，通过 UUID 判断是不是该锁，若是该锁，则执行 delete 进行锁释放。</li>
</ol>
<h4 id="问题-2"><a class="markdownIt-Anchor" href="#问题-2"></a> 问题</h4>
<ul>
<li>单点问题。如果单机 redis 挂掉了，那么程序会跟着出错。</li>
<li>如果转移使用 slave 节点，复制不是同步复制，会出现多个程序获取锁的情况</li>
</ul>
<h4 id="小结-2"><a class="markdownIt-Anchor" href="#小结-2"></a> 小结</h4>
<p>可以考虑使用 <a href="https://github.com/redisson/redisson/wiki/8.-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E5%99%A8" target="_blank" rel="noopener">redisson 的解决方案</a>。</p>
<h3 id="23-基于-zookeeper-实现分布式锁"><a class="markdownIt-Anchor" href="#23-基于-zookeeper-实现分布式锁"></a> 2.3. 基于 ZooKeeper 实现分布式锁</h3>
<h4 id="实现-3"><a class="markdownIt-Anchor" href="#实现-3"></a> 实现</h4>
<p>这也是 ZooKeeper 客户端 curator 的分布式锁实现。</p>
<ol>
<li>创建一个目录 mylock；</li>
<li>线程 A 想获取锁就在 mylock 目录下创建临时顺序节点；</li>
<li>获取 mylock 目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；</li>
<li>线程 B 获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；</li>
<li>线程 A 处理完，删除自己的节点，线程 B 监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。</li>
</ol>
<h4 id="小结-3"><a class="markdownIt-Anchor" href="#小结-3"></a> 小结</h4>
<p>ZooKeeper 版本的分布式锁问题相对比较来说少。</p>
<ul>
<li>锁的占用时间限制：redis 就有占用时间限制，而 ZooKeeper 则没有，最主要的原因是 redis 目前没有办法知道已经获取锁的客户端的状态，是已经挂了呢还是正在执行耗时较长的业务逻辑。而 ZooKeeper 通过临时节点就能清晰知道，如果临时节点存在说明还在执行业务逻辑，如果临时节点不存在说明已经执行完毕释放锁或者是挂了。由此看来 redis 如果能像 ZooKeeper 一样添加一些与客户端绑定的临时键，也是一大好事。</li>
<li>是否单点故障：redis 本身有很多中玩法，如客户端一致性 hash，服务器端 sentinel 方案或者 cluster 方案，很难做到一种分布式锁方式能应对所有这些方案。而 ZooKeeper 只有一种玩法，多台机器的节点数据是一致的，没有 redis 的那么多的麻烦因素要考虑。</li>
</ul>
<p>总体上来说 ZooKeeper 实现分布式锁更加的简单，可靠性更高。但 ZooKeeper 因为需要频繁的创建和删除节点，性能上不如 Redis 方式。</p>
<h2 id="3-分布式-session"><a class="markdownIt-Anchor" href="#3-分布式-session"></a> 3. 分布式 Session</h2>
<p>在分布式场景下，一个用户的 Session 如果只存储在一个服务器上，那么当负载均衡器把用户的下一个请求转发到另一个服务器上，该服务器没有用户的 Session，就可能导致用户需要重新进行登录等操作。</p>
<p>分布式 Session 的几种实现策略：</p>
<ol>
<li>粘性 session</li>
<li>应用服务器间的 session 复制共享</li>
<li>基于 cache DB 缓存的 session 共享</li>
</ol>
<h3 id="31-sticky-sessions"><a class="markdownIt-Anchor" href="#31-sticky-sessions"></a> 3.1. Sticky Sessions</h3>
<p>需要配置负载均衡器，使得一个用户的所有请求都路由到一个服务器节点上，这样就可以把用户的 Session 存放在该服务器节点中。</p>
<p>缺点：当服务器节点宕机时，将丢失该服务器节点上的所有 Session。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/MultiNode-StickySessions.jpg" />
</div>
<h3 id="32-session-replication"><a class="markdownIt-Anchor" href="#32-session-replication"></a> 3.2. Session Replication</h3>
<p>在服务器节点之间进行 Session 同步操作，这样的话用户可以访问任何一个服务器节点。</p>
<p>缺点：占用过多内存；同步过程占用网络带宽以及服务器处理器时间。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/MultiNode-SessionReplication.jpg" />
</div>
<h3 id="33-session-server"><a class="markdownIt-Anchor" href="#33-session-server"></a> 3.3. Session Server</h3>
<p>使用一个单独的服务器存储 Session 数据，可以存在 MySQL 数据库上，也可以存在 Redis 或者 Memcached 这种内存型数据库。</p>
<p>缺点：需要去实现存取 Session 的代码。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/MultiNode-SpringSession.jpg" />
</div>
<h2 id="4-分布式存储"><a class="markdownIt-Anchor" href="#4-分布式存储"></a> 4. 分布式存储</h2>
<p>通常有两种解决方案：</p>
<ol>
<li>数据分布：就是把数据分块存在不同的服务器上（分库分表）。</li>
<li>数据复制：让所有的服务器都有相同的数据，提供相当的服务。</li>
</ol>
<blockquote>
<p>参考：<a href="%E5%88%86%E5%B8%83%E5%BC%8F%E5%8E%9F%E7%90%86.md#2-%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83">分布式原理.md#2-数据分布</a></p>
</blockquote>
<h2 id="5-分布式缓存"><a class="markdownIt-Anchor" href="#5-分布式缓存"></a> 5. 分布式缓存</h2>
<p>使用缓存的好处：</p>
<ul>
<li>提升数据读取速度</li>
<li>提升系统扩展能力，通过扩展缓存，提升系统承载能力</li>
<li>降低存储成本，Cache+DB 的方式可以承担原有需要多台 DB 才能承担的请求量，节省机器成本</li>
</ul>
<p>根据业务场景，通常缓存有以下几种使用方式</p>
<ul>
<li>懒汉式(读时触发)：写入 DB 后, 然后把相关的数据也写入 Cache</li>
<li>饥饿式(写时触发)：先查询 DB 里的数据, 然后把相关的数据写入 Cache</li>
<li>定期刷新：适合周期性的跑数据的任务，或者列表型的数据，而且不要求绝对实时性</li>
</ul>
<p>缓存分类：</p>
<ul>
<li>应用内缓存：如：EHCache</li>
<li>分布式缓存：如：Memached、Redis</li>
</ul>
<blockquote>
<p>参考：<a href="%E5%88%86%E5%B8%83%E5%BC%8F%E5%8E%9F%E7%90%86.md#6-%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98">分布式原理.md#6-分布式缓存问题</a></p>
</blockquote>
<h2 id="6-分布式计算"><a class="markdownIt-Anchor" href="#6-分布式计算"></a> 6. 分布式计算</h2>
<h2 id="7-负载均衡"><a class="markdownIt-Anchor" href="#7-负载均衡"></a> 7. 负载均衡</h2>
<h3 id="71-算法"><a class="markdownIt-Anchor" href="#71-算法"></a> 7.1. 算法</h3>
<h4 id="轮询round-robin"><a class="markdownIt-Anchor" href="#轮询round-robin"></a> 轮询（Round Robin）</h4>
<p>轮询算法把每个请求轮流发送到每个服务器上。下图中，一共有 6 个客户端产生了 6 个请求，这 6 个请求按 (1, 2, 3, 4, 5, 6) 的顺序发送。最后，(1, 3, 5) 的请求会被发送到服务器 1，(2, 4, 6) 的请求会被发送到服务器 2。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/负载均衡算法之轮询-01.jpg" width="640"/>
</div>
<p>该算法比较适合每个服务器的性能差不多的场景，如果有性能存在差异的情况下，那么性能较差的服务器可能无法承担过大的负载（下图的 Server 2）。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/负载均衡算法之轮询-02.jpg" width="640"/>
</div>
<h4 id="加权轮询weighted-round-robbin"><a class="markdownIt-Anchor" href="#加权轮询weighted-round-robbin"></a> 加权轮询（Weighted Round Robbin）</h4>
<p>加权轮询是在轮询的基础上，根据服务器的性能差异，为服务器赋予一定的权值。例如下图中，服务器 1 被赋予的权值为 5，服务器 2 被赋予的权值为 1，那么 (1, 2, 3, 4, 5) 请求会被发送到服务器 1，(6) 请求会被发送到服务器 2。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/负载均衡算法之加权轮询.jpg" width="640"/>
</div>
<h4 id="最少连接least-connections"><a class="markdownIt-Anchor" href="#最少连接least-connections"></a> 最少连接（least Connections）</h4>
<p>由于每个请求的连接时间不一样，使用轮询或者加权轮询算法的话，可能会让一台服务器当前连接数过大，而另一台服务器的连接过小，造成负载不均衡。例如下图中，(1, 3, 5) 请求会被发送到服务器 1，但是 (1, 3) 很快就断开连接，此时只有 (5) 请求连接服务器 1；(2, 4, 6) 请求被发送到服务器 2，只有 (2) 的连接断开。该系统继续运行时，服务器 2 会承担过大的负载。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/负载均衡算法之最少连接-01.jpg" width="640"/>
</div>
<p>最少连接算法就是将请求发送给当前最少连接数的服务器上。例如下图中，服务器 1 当前连接数最小，那么新到来的请求 6 就会被发送到服务器 1 上。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/负载均衡算法之最少连接-02.jpg" width="640"/>
</div>
<h4 id="加权最少连接weighted-least-connection"><a class="markdownIt-Anchor" href="#加权最少连接weighted-least-connection"></a> 加权最少连接（Weighted Least Connection）</h4>
<p>在最少连接的基础上，根据服务器的性能为每台服务器分配权重，再根据权重计算出每台服务器能处理的连接数。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/负载均衡算法之加权最少连接.jpg" width="640"/>
</div>
<h4 id="随机算法random"><a class="markdownIt-Anchor" href="#随机算法random"></a> 随机算法（Random）</h4>
<p>把请求随机发送到服务器上。和轮询算法类似，该算法比较适合服务器性能差不多的场景。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/负载均衡算法之随机.jpg" width="640"/>
</div>
<h4 id="源地址哈希法-ip-hash"><a class="markdownIt-Anchor" href="#源地址哈希法-ip-hash"></a> 源地址哈希法 (IP Hash)</h4>
<p>源地址哈希通过对客户端 IP 哈希计算得到的一个数值，用该数值对服务器数量进行取模运算，取模结果便是目标服务器的序号。</p>
<ul>
<li>优点：保证同一 IP 的客户端都会被 hash 到同一台服务器上。</li>
<li>缺点：不利于集群扩展，后台服务器数量变更都会影响 hash 结果。可以采用一致性 Hash 改进。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/负载均衡算法之IpHash.jpg" width="640"/>
</div>
<h3 id="72-实现"><a class="markdownIt-Anchor" href="#72-实现"></a> 7.2. 实现</h3>
<h4 id="http-重定向"><a class="markdownIt-Anchor" href="#http-重定向"></a> HTTP 重定向</h4>
<p>HTTP 重定向负载均衡服务器收到 HTTP 请求之后会返回服务器的地址，并将该地址写入 HTTP 重定向响应中返回给浏览器，浏览器收到后需要再次发送请求。</p>
<p>缺点：</p>
<ul>
<li>用户访问的延迟会增加；</li>
<li>如果负载均衡器宕机，就无法访问该站点。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/Http重定向.png" width="640"/>
</div>
<h4 id="dns-重定向"><a class="markdownIt-Anchor" href="#dns-重定向"></a> DNS 重定向</h4>
<p>使用 DNS 作为负载均衡器，根据负载情况返回不同服务器的 IP 地址。大型网站基本使用了这种方式做为第一级负载均衡手段，然后在内部使用其它方式做第二级负载均衡。</p>
<p>缺点：</p>
<ul>
<li>DNS 查找表可能会被客户端缓存起来，那么之后的所有请求都会被重定向到同一个服务器。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/Dns重定向.png" width="640"/>
</div>
<h4 id="修改-mac-地址"><a class="markdownIt-Anchor" href="#修改-mac-地址"></a> 修改 MAC 地址</h4>
<p>使用 LVS（Linux Virtual Server）这种链路层负载均衡器，根据负载情况修改请求的 MAC 地址。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/修改Mac地址.png" width="640"/>
</div>
<h4 id="修改-ip-地址"><a class="markdownIt-Anchor" href="#修改-ip-地址"></a> 修改 IP 地址</h4>
<p>在网络层修改请求的目的 IP 地址。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/修改IP地址.png" width="640"/>
</div>
<h4 id="代理自动配置"><a class="markdownIt-Anchor" href="#代理自动配置"></a> 代理自动配置</h4>
<p>正向代理与反向代理的区别：</p>
<ul>
<li>正向代理：发生在客户端，是由用户主动发起的。比如翻墙，客户端通过主动访问代理服务器，让代理服务器获得需要的外网数据，然后转发回客户端。</li>
<li>反向代理：发生在服务器端，用户不知道代理的存在。</li>
</ul>
<p>PAC 服务器是用来判断一个请求是否要经过代理。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/代理自动配置.jpg" width="640"/>
</div>
<h2 id="8-资料"><a class="markdownIt-Anchor" href="#8-资料"></a> 8. 资料</h2>
<ul>
<li><a href="https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html" target="_blank" rel="noopener">https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html</a></li>
<li><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90.md" target="_blank" rel="noopener">https://github.com/CyC2018/Interview-Notebook/blob/master/notes/分布式问题分析.md</a></li>
<li><a href="https://www.jianshu.com/p/453c6e7ff81c" target="_blank" rel="noopener">https://www.jianshu.com/p/453c6e7ff81c</a></li>
<li><a href="https://juejin.im/post/5a20cd8bf265da43163cdd9a" target="_blank" rel="noopener">https://juejin.im/post/5a20cd8bf265da43163cdd9a</a></li>
<li><a href="https://github.com/redisson/redisson/wiki/8.-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E5%99%A8" target="_blank" rel="noopener">https://github.com/redisson/redisson/wiki/8.-分布式锁和同步器</a></li>
<li><a href="https://github.com/L316476844/distributed-session" target="_blank" rel="noopener">https://github.com/L316476844/distributed-session</a></li>
<li><a href="https://juejin.im/entry/57e39e320e3dd90058021bff" target="_blank" rel="noopener">分布式缓存架构基础</a></li>
<li><a href="https://www.toutiao.com/i6533812974807679495/?tt_from=weixin&amp;utm_campaign=client_share&amp;from=singlemessage&amp;timestamp=1521281305&amp;app=news_article&amp;utm_source=weixin&amp;iid=28128279343&amp;utm_medium=toutiao_android&amp;weixin_list=1&amp;wxshare_count=2&amp;pbid=6517746516513195523" target="_blank" rel="noopener">阿里 P8 技术专家细究分布式缓存问题</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/design/theory/load-balance-theory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/design/theory/load-balance-theory/" class="post-title-link" itemprop="url">负载均衡基本原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-05 15:50:00" itemprop="dateCreated datePublished" datetime="2018-07-05T15:50:00+08:00">2018-07-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-01-25 18:03:01" itemprop="dateModified" datetime="2020-01-25T18:03:01+08:00">2020-01-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index">
                    <span itemprop="name">设计</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/" itemprop="url" rel="index">
                    <span itemprop="name">系统原理</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/design/theory/load-balance-theory/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="design/theory/load-balance-theory/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="负载均衡基本原理"><a class="markdownIt-Anchor" href="#负载均衡基本原理"></a> 负载均衡基本原理</h1>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#1-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%80%E4%BB%8B">1. 负载均衡简介</a>
<ul>
<li><a href="#11-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E4%BD%9C%E7%94%A8">1.1. 负载均衡的作用</a></li>
<li><a href="#12-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E5%88%86%E7%B1%BB">1.2. 负载均衡的分类</a></li>
</ul>
</li>
<li><a href="#2-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95">2. 负载均衡算法</a>
<ul>
<li><a href="#21-%E8%BD%AE%E8%AF%A2">2.1. 轮询</a></li>
<li><a href="#22-%E9%9A%8F%E6%9C%BA">2.2. 随机</a></li>
<li><a href="#23-%E6%9C%80%E5%B0%91%E8%BF%9E%E6%8E%A5">2.3. 最少连接</a></li>
<li><a href="#24-%E6%BA%90%E5%9C%B0%E5%9D%80%E5%93%88%E5%B8%8C">2.4. 源地址哈希</a></li>
<li><a href="#25-%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C">2.5. 一致性哈希</a></li>
</ul>
</li>
<li><a href="#3-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%8A%80%E6%9C%AF">3. 负载均衡技术</a>
<ul>
<li><a href="#31-dns-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">3.1. DNS 负载均衡</a></li>
<li><a href="#32-http-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">3.2. HTTP 负载均衡</a></li>
<li><a href="#33-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86">3.3. 反向代理</a></li>
<li><a href="#34-%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E5%8F%91">3.4. 网络地址转发</a></li>
<li><a href="#35-%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF">3.5. 隧道技术</a></li>
<li><a href="#36-%E7%9B%B4%E6%8E%A5%E8%B7%AF%E7%94%B1">3.6. 直接路由</a></li>
<li><a href="#37-%E6%B7%B7%E5%90%88%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">3.7. 混合负载均衡</a></li>
</ul>
</li>
<li><a href="#4-%E6%9C%AF%E8%AF%AD">4. 术语</a></li>
<li><a href="#5-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">5. 参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="1-负载均衡简介"><a class="markdownIt-Anchor" href="#1-负载均衡简介"></a> 1. 负载均衡简介</h2>
<h3 id="11-负载均衡的作用"><a class="markdownIt-Anchor" href="#11-负载均衡的作用"></a> 1.1. 负载均衡的作用</h3>
<p>负载均衡（Load Balance，简称 LB）是高可用基础架构的关键组件，通常 <strong>用于将网络流量分发到多个服务器上，以提高应用的响应速度和可用性</strong>。</p>
<p>系统的扩展可分为垂直扩展和水平扩展。</p>
<ul>
<li><strong>垂直扩展</strong>，是从单机的角度通过<strong>增加硬件处理能力</strong>，比如 CPU 处理能力，内存容量，磁盘等方面，实现服务器处理能力的提升。这种方式不能满足大型分布式系统（网站），大流量，高并发，海量数据的问题。</li>
<li><strong>水平扩展</strong>，是通过<strong>添加机器</strong>来满足大型网站服务的处理能力。比如：一台机器不能满足，则增加两台或者多台机器，共同承担访问压力。
<ul>
<li>应用集群：将同一应用部署到多台机器上，组成处理集群，接收负载均衡设备分发的请求，进行处理，并返回相应数据。</li>
<li>负载均衡设备：将用户访问的请求，根据负载均衡算法，分发到集群中的一台处理服务器。（一种把网络请求分散到一个服务器集群中的可用服务器上去的设备）</li>
</ul>
</li>
</ul>
<p>负载均衡的作用：</p>
<ul>
<li><strong>高并发</strong> - 负载均衡通过调整负载，尽力让应用集群中的节点工作量达到均匀，以此提高应用集群的并发处理能力（吞吐量）。</li>
<li><strong>伸缩性</strong> - 添加或减少服务器数量，然后由负载均衡进行分发控制。这使得应用集群具备伸缩性。</li>
<li><strong>故障转移</strong> - 负载均衡器可以监控候选服务器，当服务器不可用时，自动跳过，将请求分发给可用的服务器。这使得应用集群具备高可用的特性。</li>
<li><strong>安全防护</strong> - 有些负载均衡软件或硬件提供了安全性功能，如：黑白名单处理、防火墙，防 DDos 攻击等。</li>
</ul>
<h3 id="12-负载均衡的分类"><a class="markdownIt-Anchor" href="#12-负载均衡的分类"></a> 1.2. 负载均衡的分类</h3>
<p>负载均衡大致可以分为两大类：</p>
<ul>
<li>软件负载均衡</li>
<li>硬件负载均衡</li>
</ul>
<h4 id="软件负载均衡"><a class="markdownIt-Anchor" href="#软件负载均衡"></a> 软件负载均衡</h4>
<p>软件负载均衡，应用最为广泛，无论大公司还是小公司都会使用。</p>
<p>软件负载均衡从软件层面实现负载均衡，一般可以在任何标准物理设备上运行。</p>
<p>软件负载均衡的 <strong>主流产品</strong> 有：<a href="https://www.nginx.com/" target="_blank" rel="noopener">Nginx</a>、<a href="http://www.haproxy.org/" target="_blank" rel="noopener">HAProxy</a>、<a href="https://github.com/alibaba/LVS" target="_blank" rel="noopener">LVS</a>。</p>
<ul>
<li><a href="https://github.com/alibaba/LVS" target="_blank" rel="noopener">LVS</a> 可以作为四层负载均衡器。其负载均衡的性能要优于 Nginx。</li>
<li><a href="http://www.haproxy.org/" target="_blank" rel="noopener">HAProxy</a> 可以作为 HTTP 和 TCP 负载均衡器。</li>
<li><a href="https://www.nginx.com/" target="_blank" rel="noopener">Nginx</a>、<a href="http://www.haproxy.org/" target="_blank" rel="noopener">HAProxy</a> 可以作为四层或七层负载均衡器。</li>
</ul>
<p>软件负载均衡的 <strong>优点</strong>：</p>
<ul>
<li><strong>扩展性好</strong> - 适应动态变化，可以通过添加软件负载均衡实例，动态扩展到超出初始容量的能力。</li>
<li><strong>成本低廉</strong> - 软件负载均衡可以在任何标准物理设备上运行，降低了购买和运维的成本。</li>
</ul>
<p>软件负载均衡的 <strong>缺点</strong>：</p>
<ul>
<li><strong>性能略差</strong> - 相比于硬件负载均衡，软件负载均衡的性能要略低一些。</li>
</ul>
<p>软件负载负载均衡从通信层面来看，又可以分为四层和七层负载均衡。</p>
<ul>
<li>四层负载均衡 - 基于 IP 地址和端口进行请求的转发。</li>
<li>七层负载均衡 - 就是可以根据访问用户的 HTTP 请求头、URL 信息将请求转发到特定的主机。</li>
</ul>
<h4 id="硬件负载均衡"><a class="markdownIt-Anchor" href="#硬件负载均衡"></a> 硬件负载均衡</h4>
<p>硬件负载均衡，一般是在定制处理器上运行的独立负载均衡服务器，价格昂贵，土豪专属。</p>
<p>硬件负载均衡的 <strong>主流产品</strong> 有：<a href="https://f5.com/zh" target="_blank" rel="noopener">F5</a> 和 <a href="https://www.a10networks.com.cn/" target="_blank" rel="noopener">A10</a>。</p>
<p>硬件负载均衡的 <strong>优点</strong>：</p>
<ul>
<li><strong>功能强大</strong> - 支持全局负载均衡并提供较全面的、复杂的负载均衡算法。</li>
<li><strong>性能强悍</strong> - 硬件负载均衡由于是在专用处理器上运行，因此吞吐量大，可支持单机百万以上的并发。</li>
<li><strong>安全性高</strong> - 往往具备防火墙，防 DDos 攻击等安全功能。</li>
</ul>
<p>硬件负载均衡的 <strong>缺点</strong>：</p>
<ul>
<li><strong>成本昂贵</strong> - 购买和维护硬件负载均衡的成本都很高。</li>
<li><strong>扩展性差</strong> - 当访问量突增时，超过限度不能动态扩容。</li>
</ul>
<h2 id="2-负载均衡算法"><a class="markdownIt-Anchor" href="#2-负载均衡算法"></a> 2. 负载均衡算法</h2>
<p>负载均衡产品多种多样，但是各种负载均衡算法原理是共性的。</p>
<p>负载均衡算法有很多种，分别适用于不同的应用场景，本文仅介绍最为常见的负载均衡算法的特性及原理：轮询、随机、最少连接、一致性 Hash。</p>
<h3 id="21-轮询"><a class="markdownIt-Anchor" href="#21-轮询"></a> 2.1. 轮询</h3>
<p><strong><code>轮询（Round Robin）</code></strong> 算法 <strong>将请求依次分发到候选服务器</strong>。</p>
<ul>
<li>特点：<strong>请求完全均匀分发</strong>，即服务器请求被完全均匀的分发到集群的各节点上。</li>
<li>场景：<strong>适合服务器硬件相同的场景</strong>。</li>
</ul>
<p>下图中，一共有 6 个客户端产生了 6 个请求，这 6 个请求按 (1, 2, 3, 4, 5, 6) 的顺序发送。最后，(1, 3, 5) 的请求会被发送到服务器 1，(2, 4, 6) 的请求会被发送到服务器 2。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/负载均衡算法之轮询-01.jpg" width="640"/>
</div>
<p>该算法比较适合每个服务器的性能差不多的场景，如果有性能存在差异的情况下，那么性能较差的服务器可能无法承担过大的负载（下图的 Server 2）。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/负载均衡算法之轮询-02.jpg" width="640"/>
</div>
<p>节点存储结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;V&gt; nodeList = Collections.emptyList();</span><br></pre></td></tr></table></figure>
<p>算法实现示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtil.isEmpty(<span class="keyword">this</span>.nodeList)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size = <span class="keyword">this</span>.nodeList.size();</span><br><span class="line">    offset.compareAndSet(size, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> nodeList.get(offset.getAndIncrement());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="加权轮询"><a class="markdownIt-Anchor" href="#加权轮询"></a> 加权轮询</h4>
<p><strong><code>加权轮询（Weighted Round Robbin）</code></strong> 算法在轮询算法的基础上，增加了权重属性。性能高、处理速度快的机器应该设置更高的权重，使得分发时优先将请求分发到权重较高的服务器上。</p>
<ul>
<li>优点：根据权重，调节转发服务器的请求数目。</li>
<li>缺点：比轮询算法复杂。</li>
</ul>
<p>加权轮询是在轮询的基础上，根据服务器的性能差异，为服务器赋予一定的权值。例如下图中，服务器 1 被赋予的权值为 5，服务器 2 被赋予的权值为 1，那么 (1, 2, 3, 4, 5) 请求会被发送到服务器 1，(6) 请求会被发送到服务器 2。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/负载均衡算法之加权轮询.jpg" width="640"/>
</div>
<p>节点存储结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// key 存储实际节点内容，value 存储节点的权重</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;V, Integer&gt; nodeMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>算法实现示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (MapUtil.isEmpty(nodeMap)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> totalWeight = nodeMap.values().stream().mapToInt(a -&gt; a).sum();</span><br><span class="line">    <span class="keyword">int</span> number = offset.getAndIncrement() % totalWeight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;V, Integer&gt; item : nodeMap.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (item.getValue() &gt; number) &#123;</span><br><span class="line">            <span class="keyword">return</span> item.getKey();</span><br><span class="line">        &#125;</span><br><span class="line">        number -= item.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="22-随机"><a class="markdownIt-Anchor" href="#22-随机"></a> 2.2. 随机</h3>
<p><strong><code>随机（Random）</code></strong> 算法 <strong>将请求随机分发到候选服务器</strong>。</p>
<ul>
<li>
<p>特点：调用量较小的时候，可能负载并不均匀，<strong>调用量越大，负载越均衡</strong>。</p>
</li>
<li>
<p>场景：<strong>适合服务器硬件相同的场景</strong>。</p>
</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/负载均衡算法之随机.jpg" width="640"/>
</div>
<p>节点存储结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;V&gt; nodeList = Collections.emptyList();</span><br></pre></td></tr></table></figure>
<p>算法实现示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtil.isEmpty(<span class="keyword">this</span>.nodeList)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> offset = random.nextInt(nodeList.size());</span><br><span class="line">    <span class="keyword">return</span> nodeList.get(offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="加权随机"><a class="markdownIt-Anchor" href="#加权随机"></a> 加权随机</h4>
<p><strong><code>加权随机（Weighted Random）</code></strong> 算法在随机算法的基础上，按照概率调整权重，进行负载分配。</p>
<p>节点存储结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// key 存储实际节点内容，value 存储节点的权重</span></span><br><span class="line">Map&lt;V, Integer&gt; nodeMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>算法实现示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (MapUtil.isEmpty(keyWeightMap)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;V&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;V, Integer&gt; item : keyWeightMap.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; item.getValue(); i++) &#123;</span><br><span class="line">            list.add(item.getKey());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> totalWeight = keyWeightMap.values().stream().mapToInt(a -&gt; a).sum();</span><br><span class="line">    <span class="keyword">int</span> number = random.nextInt(totalWeight);</span><br><span class="line">    <span class="keyword">return</span> list.get(number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="23-最少连接"><a class="markdownIt-Anchor" href="#23-最少连接"></a> 2.3. 最少连接</h3>
<p><strong><code>最少连接（Least Connection）</code></strong> 算法 <strong>将请求分发到连接数最少的候选服务器</strong>（目前处理请求最少的服务器）。</p>
<ul>
<li>特点：根据候选服务器当前的请求连接数，动态分配。</li>
<li>场景：<strong>适用于对系统负载较为敏感或请求连接时长相差较大的场景</strong>。</li>
</ul>
<p>由于每个请求的连接时长不一样，如果采用简单的轮循或随机算法，都可能出现<strong>某些服务器当前连接数过大，而另一些服务器的连接过小</strong>的情况，这就造成了负载并非真正均衡。虽然，轮询或算法都可以通过加权重属性的方式进行负载调整，但加权方式难以应对动态变化。</p>
<p>例如下图中，(1, 3, 5) 请求会被发送到服务器 1，但是 (1, 3) 很快就断开连接，此时只有 (5) 请求连接服务器 1；(2, 4, 6) 请求被发送到服务器 2，只有 (2) 的连接断开。该系统继续运行时，服务器 2 会承担过大的负载。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/负载均衡算法之最少连接-01.jpg!zp" width="640"/>
</div>
<p>最少连接算法会记录当前时刻，每个候选节点正在处理的连接数，然后选择连接数最小的节点。该策略能够动态、实时地反应服务器的当前状况，较为合理地将负责分配均匀，适用于对当前系统负载较为敏感的场景。</p>
<p>例如下图中，服务器 1 当前连接数最小，那么新到来的请求 6 就会被发送到服务器 1 上。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/负载均衡算法之最少连接-02.jpg!zp" width="640"/>
</div>
<h4 id="加权最少连接"><a class="markdownIt-Anchor" href="#加权最少连接"></a> 加权最少连接</h4>
<p>加权最少连接（Weighted Least Connection）在最少连接的基础上，根据服务器的性能为每台服务器分配权重，再根据权重计算出每台服务器能处理的连接数。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/负载均衡算法之加权最少连接.jpg!zp" width="640"/>
</div>
<h3 id="24-源地址哈希"><a class="markdownIt-Anchor" href="#24-源地址哈希"></a> 2.4. 源地址哈希</h3>
<p>**<code>源地址哈希（IP Hash）</code>**算法 <strong>根据请求源 IP，通过哈希计算得到一个数值，用该数值在候选服务器列表的进行取模运算，得到的结果便是选中的服务器</strong>。</p>
<ul>
<li>特点：保证特定用户总是请求到相同的服务器，若服务器宕机，会话会丢失。</li>
<li>场景：会话粘滞。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/负载均衡算法之IpHash.jpg!zp" width="640"/>
</div>
<p>算法示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; keyList = <span class="keyword">new</span> ArrayList&lt;String&gt;(serverMap.keySet());</span><br><span class="line">    String remoteIp = <span class="string">"192.168.2.215"</span>;</span><br><span class="line">    <span class="keyword">int</span> hashCode = remoteIp.hashCode();</span><br><span class="line">    <span class="keyword">int</span> idx = hashCode % keyList.size();</span><br><span class="line">    String server = keyList.get(Math.abs(idx));</span><br><span class="line">    System.out.println(server);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="25-一致性哈希"><a class="markdownIt-Anchor" href="#25-一致性哈希"></a> 2.5. 一致性哈希</h3>
<p>一致性哈希（Consistent Hash）算法的目标是：<strong>相同的请求尽可能落到同一个服务器上</strong>。</p>
<ul>
<li>相同的请求是指：一般在使用一致性哈希时，需要指定一个 key 用于 hash 计算，可能是：
<ul>
<li>用户 ID</li>
<li>请求方 IP</li>
<li>请求服务名称，参数列表构成的串</li>
</ul>
</li>
<li>尽可能是指：服务器可能发生上下线，少数服务器的变化不应该影响大多数的请求。</li>
</ul>
<p>当某台候选服务器宕机时，原本发往该服务器的请求，会基于虚拟节点，平摊到其它候选服务器，不会引起剧烈变动。</p>
<p>一致性哈希算法示例：</p>
<ul>
<li>构建虚拟 Hash 环</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> VIRTUAL_NODE_SIZE = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String VIRTUAL_NODE_SUFFIX = <span class="string">"&amp;&amp;"</span>;</span><br><span class="line"><span class="keyword">private</span> Set&lt;V&gt; nodes = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(collection);</span><br><span class="line"><span class="keyword">private</span> TreeMap&lt;Integer, V&gt; hashRing = buildConsistentHashRing(<span class="keyword">this</span>.nodes);</span><br><span class="line"></span><br><span class="line"><span class="function">TreeMap&lt;Integer, V&gt; <span class="title">buildConsistentHashRing</span><span class="params">(Set&lt;V&gt; nodes)</span> </span>&#123;</span><br><span class="line">    TreeMap&lt;Integer, V&gt; hashRing = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (V node : nodes) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; VIRTUAL_NODE_SIZE; i++) &#123;</span><br><span class="line">            <span class="comment">// 新增虚拟节点的方式如果有影响，也可以抽象出一个由物理节点扩展虚拟节点的类</span></span><br><span class="line">            hashRing.put(hashStrategy.hashCode(node + VIRTUAL_NODE_SUFFIX + i), node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hashRing;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心算法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">select</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hashCode = hashStrategy.hashCode(key);</span><br><span class="line">    <span class="comment">// 向右找到第一个 key</span></span><br><span class="line">    Map.Entry&lt;Integer, V&gt; entry = hashRing.ceilingEntry(hashCode);</span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 想象成一个环，超过尾部则取第一个 key</span></span><br><span class="line">        entry = hashRing.firstEntry();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-负载均衡技术"><a class="markdownIt-Anchor" href="#3-负载均衡技术"></a> 3. 负载均衡技术</h2>
<p>根据实现技术不同，可分划分如下：</p>
<ul>
<li>七层负载均衡
<ul>
<li>DNS 重定向</li>
<li>HTTP 重定向</li>
<li>反向代理</li>
</ul>
</li>
<li>四层负载均衡
<ul>
<li>修改 IP 地址</li>
<li>修改 MAC 地址</li>
</ul>
</li>
</ul>
<h3 id="31-dns-负载均衡"><a class="markdownIt-Anchor" href="#31-dns-负载均衡"></a> 3.1. DNS 负载均衡</h3>
<p>DNS 负载均衡一般用于互联网公司，复杂的业务系统不适合使用。大型网站一般使用 DNS 负载均衡作为 <strong>第一级负载均衡手段</strong>，然后在内部使用其它方式做第二级负载均衡。DNS 负载均衡属于七层负载均衡。</p>
<p>DNS 即 <strong>域名解析服务</strong>，是 OSI 第七层网络协议。DNS 被设计为一个树形结构的分布式应用，自上而下依次为：根域名服务器，一级域名服务器，二级域名服务器，… ，本地域名服务器。显然，如果所有数据都存储在根域名服务器，那么 DNS 查询的负载和开销会非常庞大。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200125143248.png" alt="" /></p>
<p>因此，DNS 查询相对于 DNS 层级结构，是一个逆向的递归流程，DNS 客户端依次请求本地 DNS 服务器，上一级 DNS 服务器，上上一级 DNS 服务器，… ，根 DNS 服务器（又叫权威 DNS 服务器），一旦命中，立即返回。为了减少查询次数，每一级 DNS 服务器都会设置 DNS 查询缓存。</p>
<p>DNS 负载均衡的工作原理就是：<strong>基于 DNS 查询缓存，按照负载情况返回不同服务器的 IP 地址</strong>。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/Dns重定向.png" width="640"/>
</div>
<p>DNS 重定向的 <strong>优点</strong>：</p>
<ul>
<li><strong>使用简单</strong> - 负载均衡工作，交给 DNS 服务器处理，省掉了负载均衡服务器维护的麻烦</li>
<li><strong>提高性能</strong> - 可以支持基于地址的域名解析，解析成距离用户最近的服务器地址（类似 CDN 的原理），可以加快访问速度，改善性能；</li>
</ul>
<p>DNS 重定向的 <strong>缺点</strong>：</p>
<ul>
<li><strong>可用性差</strong> - DNS 解析是多级解析，新增/修改 DNS 后，解析时间较长；解析过程中，用户访问网站将失败；</li>
<li><strong>扩展性低</strong> - DNS 负载均衡的控制权在域名商那里，无法对其做更多的改善和扩展；</li>
<li><strong>维护性差</strong> - 也不能反映服务器的当前运行状态；支持的算法少；不能区分服务器的差异（不能根据系统与服务的状态来判断负载）</li>
</ul>
<h3 id="32-http-负载均衡"><a class="markdownIt-Anchor" href="#32-http-负载均衡"></a> 3.2. HTTP 负载均衡</h3>
<p><strong>HTTP 负载均衡是基于 HTTP 重定向实现的</strong>。HTTP 负载均衡属于七层负载均衡。</p>
<p>HTTP 重定向原理是：<strong>根据用户的 HTTP 请求计算出一个真实的服务器地址，将该服务器地址写入 HTTP 重定向响应中，返回给浏览器，由浏览器重新进行访问</strong>。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/Http重定向.png" width="640"/>
</div>
<p>HTTP 重定向的 <strong>优点</strong>：<strong>方案简单</strong>。</p>
<p>HTTP 重定向的 <strong>缺点</strong>：</p>
<ul>
<li><strong>性能较差</strong> - 每次访问需要两次请求服务器，增加了访问的延迟。</li>
<li><strong>降低搜索排名</strong> - 使用重定向后，搜索引擎会视为 SEO 作弊。</li>
<li>如果负载均衡器宕机，就无法访问该站点。</li>
</ul>
<p>由于其缺点比较明显，所以这种负载均衡策略实际应用较少。</p>
<h3 id="33-反向代理"><a class="markdownIt-Anchor" href="#33-反向代理"></a> 3.3. 反向代理</h3>
<p>反向代理（Reverse Proxy）方式是指以 <strong>代理服务器</strong> 来接受网络请求，然后 <strong>将请求转发给内网中的服务器</strong>，并将从内网中的服务器上得到的结果返回给网络请求的客户端。反向代理负载均衡属于七层负载均衡。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/代理自动配置.jpg" width="640"/>
</div>
<p>反向代理服务的主流产品：Nginx、Apache。</p>
<p>正向代理与反向代理有什么区别？</p>
<ul>
<li>正向代理：发生在 <strong>客户端</strong>，是由用户主动发起的。翻墙软件就是典型的正向代理，客户端通过主动访问代理服务器，让代理服务器获得需要的外网数据，然后转发回客户端。</li>
<li>反向代理：发生在 <strong>服务端</strong>，用户不知道代理的存在。</li>
</ul>
<p><img src="http://dunwu.test.upcdn.net/cs/web/nginx/reverse-proxy.png" alt="img" /></p>
<p>反向代理的 <strong>优点</strong>：</p>
<ul>
<li><strong>多种负载均衡算法</strong> - 支持多种负载均衡算法，以应对不同的场景需求。</li>
<li><strong>可以监控服务器</strong> - 基于 HTTP 协议，可以监控转发服务器的状态，如：系统负载、响应时间、是否可用、连接数、流量等，从而根据这些数据调整负载均衡的策略。</li>
</ul>
<p>反向代理的 <strong>缺点</strong>：</p>
<ul>
<li>
<p><strong>额外的转发开销</strong> - 反向代理的转发操作本身是有性能开销的，可能会包括，创建连接，等待连接响应，分析响应结果等操作。</p>
</li>
<li>
<p><strong>增加系统复杂度</strong> - 反向代理常用于做分布式应用的水平扩展，但反向代理服务存在以下问题，为了解决以下问题会给系统整体增加额外的复杂度和运维成本：</p>
<ul>
<li>反向代理服务如果宕机，就无法访问站点，所以需要有 <strong>高可用</strong> 方案，常见的方案有：主备模式（一主一备）、双主模式（互为主备）。</li>
<li>反向代理服务自身也存在性能瓶颈，随着需要转发的请求量不断攀升，需要有 <strong>可扩展</strong> 方案。</li>
</ul>
</li>
</ul>
<h3 id="34-网络地址转发"><a class="markdownIt-Anchor" href="#34-网络地址转发"></a> 3.4. 网络地址转发</h3>
<p><strong><code>网络地址转发（Network Address Translation，简称 NAT）</code></strong> 是指 <strong>通过修改目的 IP 地址实现负载均衡</strong>。NAT 属于四层负载均衡。</p>
<p>NAT 工作原理：</p>
<ul>
<li>用户请求数据包到达 LB 后，LB 在操作系统内核进程获取网络数据包。</li>
<li>LB 器根据负载均衡算法得到 RIP，并将请求目的地址修改为 RIP，不需要经过用户进程处理。然后，将请求发送给 RS。</li>
<li>RS 处理完成请求后，将响应数据包返回到 LB。</li>
<li>LB 再将数据包源地址修改为自身的 IP 地址，发送给用户浏览器。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200125131843.png" alt="" /></p>
<p>NAT 的 <strong>优点</strong>：在内核进程完成数据分发，比在应用层分发 <strong>性能更好</strong>；</p>
<p>NAT 的 <strong>缺点</strong>：所有请求响应都需要经过负载均衡服务器，集群 <strong>最大吞吐量受限于负载均衡服务器网卡带宽</strong>；</p>
<p>网络层负载均衡主流的产品是：</p>
<ul>
<li><a href="https://github.com/alibaba/LVS" target="_blank" rel="noopener">LVS</a> 的 NAT 模式。</li>
<li>HAProxy 的 TCP 四层负载均衡。</li>
</ul>
<p>在 NAT 模式下，HAProxy 使用比 LVS 更方便。</p>
<h3 id="35-隧道技术"><a class="markdownIt-Anchor" href="#35-隧道技术"></a> 3.5. 隧道技术</h3>
<p><strong><code>隧道技术（ IP Tunneling，简称 TUN）</code></strong> 是指：采用 NAT 模式时，由于请求和响应的报文必须通过负载均衡器重写地址，当客户请求越来越多时，负载均衡器处理能力将成为瓶颈。为了解决这个问题，负载均衡器把请求的报文<strong>通过 IP 隧道转发到真实的服务器</strong>。真实的服务器将响应处理后的数据直接返回给客户端。这样负载均衡器就只需处理请求报文。</p>
<p>TUN 工作原理：</p>
<ul>
<li>客户请求数据包，根据目标地址 VIP 发送到 LB 上。</li>
<li>LB 接收到客户请求包，根据负载均衡算法计算出分发的 RS。</li>
<li>然后，进行 IP Tunnel 封装。即在原有的请求包上封装 IP Tunnel 的包头。然后发送出去。</li>
<li>RS 根据 IP Tunnel 包头信息（此时就又一种逻辑上的隐形隧道，只有 LB 和 RS 之间懂）收到请求包，然后解开 IP Tunnel 包头信息，得到客户的请求包并进行响应处理。</li>
<li>响应处理完毕之后，RS 使用自己的出公网的线路，将这个响应数据包发送给客户端。源 IP 地址还是 VIP 地址。</li>
</ul>
<h3 id="36-直接路由"><a class="markdownIt-Anchor" href="#36-直接路由"></a> 3.6. 直接路由</h3>
<p><strong><code>直接路由（Direct Routing，简称 DR）</code></strong> 是指 <strong>通过修改目的 MAC 地址实现负载均衡</strong>。DR 属于四层负载均衡。</p>
<p>DR 工作原理：</p>
<ul>
<li>客户请求数据包到达 LB 后，LB 根据调度算法选出一台 RS，将数据帧的 MAC 地址改写为 RS 的 MAC 地址，然后发送出去。</li>
<li>交换机会根据 MAC 地址将数据封包发送给 RS，RS 将处理完的结果直接返回给客户端。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200125131811.png" alt="" /></p>
<p>数据链路层负载均衡主流的产品是：<a href="https://github.com/alibaba/LVS" target="_blank" rel="noopener">LVS</a> 的 DR 模式。</p>
<p>DR 的 <strong>优点</strong>：</p>
<ul>
<li>不需要负载均衡服务器进行地址的转换。</li>
<li>数据响应时不需要经过负载均衡服务器，性能高于 NAT。</li>
</ul>
<p>DR 的 <strong>缺点</strong>：</p>
<ul>
<li>对网卡带宽要求较高。</li>
<li>提供服务的端口必须一致。VIP 的端口对外端口为 80，但后端服务的真实端口为 8080，通过 LVS 的 DR 模式无法实现。</li>
<li>LVS 和真实服务器必须在同一网络。</li>
</ul>
<h3 id="37-混合负载均衡"><a class="markdownIt-Anchor" href="#37-混合负载均衡"></a> 3.7. 混合负载均衡</h3>
<p>混合负载均衡就是集各家之所长，让不同的负载均衡技术在合适的场景发挥作用。</p>
<p>由于多个服务器群内硬件设备、各自的规模、提供的服务等的差异，可以考虑给每个服务器群采用最合适的负载均衡方式，然后又在这多个服务器群间再一次负载均衡或群集起来以一个整体向外界提供服务（即把这多个服务器群当做一个新的服务器群），从而达到最佳的性能。将这种方式称之为混合型负载均衡。</p>
<p>此种方式有时也用于单台均衡设备的性能不能满足大量连接请求的情况下。是目前大型互联网公司，普遍使用的方式。</p>
<p>方式一，如下图：</p>
<div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201512/820332-20151213200106747-94797427.png"/></div>
以上模式适合有动静分离的场景，反向代理服务器（集群）可以起到缓存和动态请求分发的作用，当时静态资源缓存在代理服务器时，则直接返回到浏览器。如果动态页面则请求后面的应用负载均衡（应用集群）。
<p>方式二，如下图：</p>
<div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201512/820332-20151213200117825-1452672107.png"/></div>
以上模式，适合动态请求场景。
<p>因混合模式，可以根据具体场景，灵活搭配各种方式，以上两种方式仅供参考。</p>
<h2 id="4-术语"><a class="markdownIt-Anchor" href="#4-术语"></a> 4. 术语</h2>
<ul>
<li>LB - Load Balancer，即负载均衡器。</li>
<li>RS - Real Server，即真实服务器。</li>
<li>RIP - Real Server IP，即真实服务器 IP。</li>
<li>VIP - Virtual IP，即虚拟 IP，是外部直接面向用户请求，作为用户请求的目标 IP 地址。</li>
<li>DIP - Director Server IP，即直连服务器 IP，主要用于和内部主机通信的 IP 地址。</li>
<li>CIP - Client IP，即客户端 IP。</li>
<li>NAT - Network Address Translation，即网络地址转发。</li>
<li>TUN - IP Tunneling，即 IP 隧道技术。</li>
<li>DR - Direct Routing，即直接路由。</li>
</ul>
<h2 id="5-参考资料"><a class="markdownIt-Anchor" href="#5-参考资料"></a> 5. 参考资料</h2>
<ul>
<li><a href="https://item.jd.com/11322972.html" target="_blank" rel="noopener">《大型网站技术架构：核心原理与案例分析》</a></li>
<li><a href="https://www.cnblogs.com/itfly8/p/5043435.html" target="_blank" rel="noopener">大型网站架构系列：负载均衡详解（1）</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/32841479" target="_blank" rel="noopener">什么是负载均衡</a></li>
<li><a href="https://avinetworks.com/what-is-load-balancing/" target="_blank" rel="noopener">What Is Load Balancing</a></li>
<li><a href="https://segmentfault.com/a/1190000004492447" target="_blank" rel="noopener">负载均衡算法及手段</a></li>
<li><a href="https://dubbo.apache.org/zh-cn/docs/source_code_guide/loadbalance.html" target="_blank" rel="noopener">Dubbo 负载均衡实现</a></li>
<li><a href="https://segmentfault.com/a/1190000002578457" target="_blank" rel="noopener">利用 dns 解析来实现网站的负载均衡</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/31777732" target="_blank" rel="noopener">原理上搞懂 LVS 的 DR 和 NAT 模式的缺陷，不看小心踩坑</a></li>
<li><a href="https://www.cnblogs.com/liwei0526vip/p/6370103.html" target="_blank" rel="noopener">使用 LVS 实现负载均衡原理及安装配置详解</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/design/architecture/system-architecture-overview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/design/architecture/system-architecture-overview/" class="post-title-link" itemprop="url">系统架构概述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-05 15:11:00" itemprop="dateCreated datePublished" datetime="2018-07-05T15:11:00+08:00">2018-07-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-03 16:27:36" itemprop="dateModified" datetime="2019-12-03T16:27:36+08:00">2019-12-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index">
                    <span itemprop="name">设计</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/design/architecture/system-architecture-overview/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="design/architecture/system-architecture-overview/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="系统架构概述"><a class="markdownIt-Anchor" href="#系统架构概述"></a> 系统架构概述</h1>
<blockquote>
<p><strong>架构</strong> 的一种通俗说法是：<strong>最高层次的规划，难以改变的决定。</strong></p>
<p><strong>软件架构</strong>是有关软件整体结构与组件的抽象描述，用于指导大型软件系统各个方面的设计。 ——维基百科</p>
</blockquote>
<h2 id="1-大型系统架构的问题和目标"><a class="markdownIt-Anchor" href="#1-大型系统架构的问题和目标"></a> 1. 大型系统架构的问题和目标</h2>
<p>大型系统面临的问题：</p>
<ul>
<li>用户体量大且分布广泛</li>
<li>海量数据</li>
<li>高并发、高吞吐</li>
<li>网络环境复杂</li>
<li>安全环境恶劣，易受网络攻击</li>
<li>产品需要快速迭代</li>
<li>从小到大，渐进发展</li>
<li>以用户为中心</li>
<li>免费服务，付费体验</li>
</ul>
<p>大型系统架构的目标：</p>
<ul>
<li><strong>高性能</strong> - 高并发、高吞吐，以应对大量的用户访问以及处理海量的数据。</li>
<li><strong>高可用</strong> - 提供稳定可靠的服务。一般通过备份、分布式等手段来提升系统的可用性。</li>
<li><strong>易伸缩</strong> - 通过增/减服务器节点数，来灵活的提高/降低系统处理能力。</li>
<li><strong>易扩展</strong> - 架构上耦合度低，易于在不影响现有功能的基础上支撑业务快速发展。</li>
<li><strong>安全性</strong> - 通过信息加密，认证、权限管理，风险控制等防护性手段，为系统保驾护航。</li>
<li><strong>易维护</strong> - 利用持续集成、持续部署等自动化手段，使得系统可以快速迭代（构建、部署、运维），缩减系统维护难度和成本。</li>
</ul>
<h2 id="2-大型软件架构演化"><a class="markdownIt-Anchor" href="#2-大型软件架构演化"></a> 2. 大型软件架构演化</h2>
<p>大型软件架构演化比较具有代表性的就是大型网站的演化过程。这里介绍一下大型网站演化的一般规律。</p>
<h3 id="21-初始阶段架构"><a class="markdownIt-Anchor" href="#21-初始阶段架构"></a> 2.1. 初始阶段架构</h3>
<ul>
<li><strong>问题</strong>：网站运营初期，访问用户少，一台服务器绰绰有余。</li>
<li><strong>特征</strong>：<strong>应用程序、数据库、文件等所有的资源都在一台服务器上。</strong></li>
<li><strong>描述</strong>：通常服务器操作系统使用 linux，应用程序使用 PHP 开发，然后部署在 Apache 上，数据库使用 Mysql，通俗称为 LAMP。汇集各种免费开源软件以及一台廉价服务器就可以开始系统的发展之路了。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/系统架构进化-初始阶段架构.jpg!zp" width="400"/>
</div>
<h3 id="22-应用服务和数据服务分离"><a class="markdownIt-Anchor" href="#22-应用服务和数据服务分离"></a> 2.2. 应用服务和数据服务分离</h3>
<ul>
<li><strong>问题</strong>：越来越多的用户访问导致性能越来越差，越来越多的数据导致存储空间不足，一台服务器已不足以支撑。</li>
<li><strong>特征</strong>：<strong>应用服务器、数据库服务器、文件服务器分别独立部署。</strong></li>
<li><strong>描述</strong>：三台服务器对性能要求各不相同：
<ul>
<li>应用服务器要处理大量业务逻辑，因此需要更快更强大的 CPU；</li>
<li>数据库服务器需要快速磁盘检索和数据缓存，因此需要更快的硬盘和更大的内存；</li>
<li>文件服务器需要存储大量文件，因此需要更大容量的硬盘。</li>
</ul>
</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/系统架构进化-应用服务和数据服务分离.jpg!zp" width="450"/>
</div>
<h3 id="23-使用缓存改善性能"><a class="markdownIt-Anchor" href="#23-使用缓存改善性能"></a> 2.3. 使用缓存改善性能</h3>
<ul>
<li><strong>问题</strong>：随着用户逐渐增多，数据库压力太大导致访问延迟。</li>
<li><strong>特征</strong>：由于网站访问和财富分配一样遵循二八定律：<em>80% 的业务访问集中在 20% 的数据上</em>。<strong>将数据库中访问较集中的少部分数据缓存在内存中，可以减少数据库的访问次数，降低数据库的访问压力。</strong></li>
<li><strong>描述</strong>：缓存分为两种：应用服务器上的本地缓存和分布式缓存服务器上的远程缓存。
<ul>
<li>本地缓存访问速度更快，但缓存数据量有限，同时存在与应用程序争用内存的情况。</li>
<li>分布式缓存可以采用集群方式，理论上可以做到不受内存容量限制的缓存服务。</li>
</ul>
</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/系统架构进化-使用缓存改善性能.jpg!zp" width="450"/>
</div>
<h3 id="24-使用应用服务器集群改善并发处理能力"><a class="markdownIt-Anchor" href="#24-使用应用服务器集群改善并发处理能力"></a> 2.4. 使用应用服务器集群改善并发处理能力</h3>
<ul>
<li><strong>问题</strong>：使用缓存后，数据库访问压力得到有效缓解。但是单一应用服务器能够处理的请求连接有限，在访问高峰期，成为瓶颈。</li>
<li><strong>特征</strong>：<strong>多台服务器通过负载均衡同时向外部提供服务，解决单一服务器处理能力和存储空间不足的问题。</strong></li>
<li><strong>描述</strong>：使用集群是系统解决高并发、海量数据问题的常用手段。通过向集群中追加资源，提升系统的并发处理能力，使得服务器的负载压力不再成为整个系统的瓶颈。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/系统架构进化-使用应用服务器集群.jpg!zp" width="500"/>
</div>
<h3 id="25-数据库读写分离"><a class="markdownIt-Anchor" href="#25-数据库读写分离"></a> 2.5. 数据库读写分离</h3>
<ul>
<li><strong>问题</strong>：网站使用缓存后，使绝大部分数据读操作访问都可以不通过数据库就能完成，但是仍有一部分读操作和全部的写操作需要访问数据库，在网站的用户达到一定规模后，数据库因为负载压力过高而成为网站的瓶颈。</li>
<li><strong>特征</strong>：目前大部分的主流数据库都提供主从热备功能，通过配置两台数据库主从关系，可以将一台数据库服务器的数据更新同步到一台服务器上。<strong>网站利用数据库的主从热备功能，实现数据库读写分离，从而改善数据库负载压力。</strong></li>
<li><strong>描述</strong>：应用服务器在写操作的时候，访问主数据库，主数据库通过主从复制机制将数据更新同步到从数据库。这样当应用服务器在读操作的时候，访问从数据库获得数据。为了便于应用程序访问读写分离后的数据库，通常在应用服务器端使用专门的数据访问模块，使数据库读写分离的对应用透明。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/系统架构进化-数据库读写分离.jpg!zp" width="500"/>
</div>
<h3 id="26-反向代理和-cdn-加速"><a class="markdownIt-Anchor" href="#26-反向代理和-cdn-加速"></a> 2.6. 反向代理和 CDN 加速</h3>
<ul>
<li><strong>问题</strong>：中国网络环境复杂，不同地区的用户访问网站时，速度差别也极大。</li>
<li><strong>特征</strong>：<strong>采用 CDN 和反向代理加快系统的静态资源访问速度。</strong></li>
<li><strong>描述</strong>：CDN 和反向代理的基本原理都是缓存，区别在于：
<ul>
<li>CDN 部署在网络提供商的机房，使用户在请求网站服务时，可以从距离自己最近的网络提供商机房获取数据；</li>
<li>而反向代理则部署在网站的中心机房，当用户请求到达中心机房后，首先访问的服务器时反向代理服务器，如果反向代理服务器中缓存着用户请求的资源，就将其直接返回给用户。</li>
</ul>
</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/系统架构进化-反向代理和CDN加速.jpg!zp" width="500"/>
</div>
<h3 id="27-分布式文件系统和分布式数据库"><a class="markdownIt-Anchor" href="#27-分布式文件系统和分布式数据库"></a> 2.7. 分布式文件系统和分布式数据库</h3>
<ul>
<li><strong>问题</strong>：随着大型网站业务持续增长，数据库经过读写分离，从一台服务器拆分为两台服务器，依然不能满足需求。</li>
<li><strong>特征</strong>：<strong>数据库采用分布式数据库，文件系统采用分布式文件系统。</strong></li>
<li><strong>描述</strong>：分布式数据库是数据库拆分的最后方法，只有在单表数据规模非常庞大的时候才使用。不到不得已时，更常用的数据库拆分手段是业务分库，将不同的业务数据库部署在不同的物理服务器上。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/系统架构进化-分布式文件系统和分布式数据库.jpg!zp" />
</div>
<h3 id="28-使用-nosql-和搜索引擎"><a class="markdownIt-Anchor" href="#28-使用-nosql-和搜索引擎"></a> 2.8. 使用 NoSQL 和搜索引擎</h3>
<ul>
<li><strong>问题</strong>：随着网站业务越来越复杂，对数据存储和检索的需求也越来越复杂。</li>
<li><strong>特征</strong>：<strong>系统引入 NoSQL 数据库及搜索引擎。</strong></li>
<li><strong>描述</strong>：NoSQL 数据库及搜索引擎对可伸缩的分布式特性具有更好的支持。应用服务器通过统一数据访问模块访问各种数据，减轻应用程序管理诸多数据源的麻烦。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/系统架构进化-使用NoSQL和搜索引擎.jpg!zp" />
</div>
<h3 id="29-业务拆分"><a class="markdownIt-Anchor" href="#29-业务拆分"></a> 2.9. 业务拆分</h3>
<ul>
<li><strong>问题</strong>：大型网站的业务场景日益复杂，分为多个产品线。</li>
<li><strong>特征</strong>：采用分而治之的手段将整个网站业务分成不同的产品线。<strong>系统上按照业务进行拆分改造，应用服务器按照业务区分进行分别部署。</strong></li>
<li><strong>描述</strong>：应用之间可以通过超链接建立关系，也可以通过消息队列进行数据分发，当然更多的还是通过访问同一个数据存储系统来构成一个关联的完整系统。
<ul>
<li><strong>纵向拆分</strong>：<strong>将一个大应用拆分为多个小应用</strong>，如果新业务较为独立，那么就直接将其设计部署为一个独立的 Web 应用系统。纵向拆分相对较为简单，通过梳理业务，将较少相关的业务剥离即可。</li>
<li><strong>横向拆分</strong>：<strong>将复用的业务拆分出来，独立部署为分布式服务</strong>，新增业务只需要调用这些分布式服务横向拆分需要识别可复用的业务，设计服务接口，规范服务依赖关系。</li>
</ul>
</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/系统架构进化-业务拆分.jpg!zp" />
</div>
<h3 id="210-分布式服务"><a class="markdownIt-Anchor" href="#210-分布式服务"></a> 2.10. 分布式服务</h3>
<ul>
<li><strong>问题</strong>：随着业务越拆越小，存储系统越来越庞大，应用系统整体复杂程度呈指数级上升，部署维护越来越困难。由于所有应用要和所有数据库系统连接，最终导致数据库连接资源不足，拒绝服务。</li>
<li><strong>特征</strong>：<strong>公共业务提取出来，独立部署。由这些可复用的业务连接数据库，通过分布式服务提供共用业务服务。</strong></li>
<li>描述：大型网站的架构演化到这里，基本上大多数的技术问题都得以解决，诸如跨数据中心的实时数据同步和具体网站业务相关的问题也都可以组合改进现有技术架构来解决。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/系统架构进化-分布式服务.jpg!zp" />
</div>
<h2 id="3-大型软件架构的考量"><a class="markdownIt-Anchor" href="#3-大型软件架构的考量"></a> 3. 大型软件架构的考量</h2>
<blockquote>
<p><strong>每一个模式描述了一个不但重复发生的问题及该问题解决方案的核心。这样，就可以不断复用该方案而减少重复工作</strong>。</p>
</blockquote>
<h3 id="31-原则"><a class="markdownIt-Anchor" href="#31-原则"></a> 3.1. 原则</h3>
<ul>
<li>架构设计应该<strong>按需设计</strong>。任何网站都是随着业务逐步发展，不断演化而成，不要指望一劳永逸。</li>
<li>驱动技术发展的主要力量是业务发展。</li>
<li>不要盲目跟风大公司的解决方案。</li>
<li>不要盲目追求流行技术，而脱离了业务发展的实际情况。</li>
<li>不要把所有问题都丢给技术。现实中，有很多案例告诉我们，很多问题不一定需要通过技术来解决。归根结底，技术始终都是业务的辅助，业务问题究竟是通过技术来解决还是直接通过业务来解决，需要根据实际情况去分析判断。这就需要对业务领域有比较深入的理解和思考。</li>
</ul>
<h3 id="32-性能"><a class="markdownIt-Anchor" href="#32-性能"></a> 3.2. 性能</h3>
<p>性能是软件系统的重要衡量标准。很多扩展性、伸缩性、可用性的问题，是为了解决性能问题而引入的。</p>
<p>常见的性能提升手段有：</p>
<ul>
<li>前端
<ul>
<li>浏览器缓存</li>
<li>静态资源压缩</li>
<li>合理布局页面</li>
<li>减少 cookie 传输</li>
<li>CDN</li>
</ul>
</li>
<li>应用服务
<ul>
<li>负载均衡和反向代理</li>
<li>本地缓存</li>
<li>分布式缓存</li>
<li>异步消息队列</li>
<li>集群</li>
<li>代码层面：使用多线程、改善内存管理</li>
</ul>
</li>
<li>数据库
<ul>
<li>索引</li>
<li>数据库缓存</li>
<li>SQL 优化</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：缓存是改善软件性能的第一手段。缓存除了可以加快数据访问速度以外，还可以减轻后端应用和数据存储的负载压力。所以，如果要提升系统性能，应该第一时间想到缓存。</p>
<p>使用缓存有两个前提：</p>
<ul>
<li>数据访问热点不均匀，频繁访问的数据应该放在缓存中</li>
<li>数据在某个时间段有效，不过很快过期，否则缓存数据会因已经失效而产生脏读</li>
</ul>
</blockquote>
<h3 id="33-扩展性"><a class="markdownIt-Anchor" href="#33-扩展性"></a> 3.3. 扩展性</h3>
<blockquote>
<p>衡量扩展性的标准就是增加新的业务产品时，是否可以实现对现有产品透明无影响，不需要任何改动或很少改动，既有功能就可以上线新产品。</p>
<p>软件发展的一个重要目标和驱动力是降低软件耦合性。事物之间直接关系越少，彼此影响就越小，也就更容易独立发展，即扩展性好。</p>
</blockquote>
<p>主要手段有：</p>
<ul>
<li>
<p><strong>分层</strong> - 分层是扩展性设计的最基本手段。通过分层，可以将一个的软件系统切分为不同的部分，便于分工合作开发和维护；各层间具有一定的独立性。</p>
<ul>
<li>分层架构的约束：<strong>禁止跨层次的调用及逆向调用</strong>。</li>
<li>即使系统规模很小，也应该考虑采用分层的架构，这样便于以后扩展。</li>
</ul>
</li>
<li>
<p><strong>分割</strong> - 将不同的功能和服务分割开来，包装成高内聚、低耦合的模块单元。这有助于软件的开发和维护，便于不同模块的分布式部署，提高系统的并发处理能力和功能扩展能力。</p>
</li>
<li>
<p><strong>异步</strong> - 业务间的消息传递不是同步调用，而是将一个业务操作拆分成多阶段，每个阶段间通过共享数据的方式异步执行进行协作。</p>
<ul>
<li><strong>在单一服务器内部可通过多线程共享内存队列的方式实现异步</strong>，处在业务操作前面的线程将操作输出到队列，后面的线程从队列中读取数据进行处理；</li>
<li>在分布式系统中，<strong>多个服务器集群通过分布式消息队列实现异步</strong>。</li>
</ul>
</li>
<li>
<p><strong>分布式</strong> - 将业务和可复用服务分离，通过分布式服务框架调用。分布式是指多台服务器部署相同应用构成一个集群，通过负载均衡设备共同对外提供服务。着意味着服务可以用更多的机器工作，即扩展 CPU、内存、IO 等资源，从而提高系统整体的吞吐量和并发处理能力。</p>
<ul>
<li>常用的分布式方案：
<ul>
<li>分布式应用和服务</li>
<li>分布式静态资源</li>
<li>分布式数据和存储</li>
<li>分布式计算</li>
</ul>
</li>
<li>分布式也引入了一些问题：
<ul>
<li>服务调用必须通过网络，网络延迟会影响性能。</li>
<li>服务器越多，宕机概率也越大，导致可用性降低。</li>
<li>数据一致性非常困难，分布式事务也难以保证。</li>
<li>网站依赖错综复杂，开发管理维护困难。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="34-伸缩性"><a class="markdownIt-Anchor" href="#34-伸缩性"></a> 3.4. 伸缩性</h3>
<blockquote>
<p>衡量伸缩的标准就是是否可以用多台服务器构建集群，是否容易向集群中增删服务器节点。增删服务器节点后是否可以提供和之前无差别的服务。集群中可容纳的总服务器数是否有限制。</p>
</blockquote>
<p>主要手段有:</p>
<ul>
<li><strong>应用服务器集群</strong> - 只要服务器上保存数据，则所有服务器都是对等的，通过负载均衡设备向集群中不断加入服务器即可</li>
<li><strong>缓存服务器集群</strong> - 加入新的服务器可能会导致缓存路由失效，进而导致集群中的大部分缓存数据都无法访问。虽然缓存数据可以通过数据库重新加载，但是如果应用严重依赖缓存，可能会导致网站崩溃。需要改进缓存路由算法保证缓存数据的可访问性。</li>
<li><strong>关系型数据库集群</strong> - 关系型数据库虽然支持数据复制，主从热备等机制，但是很难做到大规模集群的可伸缩性，因此关系型数据库的集群伸缩性方案必须在数据库之外实现，通过路由分区等手段将部署有多个数据库的服务器组成一个集群。</li>
<li><strong>Nosql 数据库集群</strong> - 由于先天就是为了应对海量数据而产生，因此对伸缩性的支持通常都非常好。</li>
</ul>
<h3 id="35-可用性"><a class="markdownIt-Anchor" href="#35-可用性"></a> 3.5. 可用性</h3>
<p>对于大型软件系统，出现服务器宕机是必然事件。要保证部分服务器宕机的情况下，系统依然可以继续对外提供服务，不丢失数据，就需要一定程度上的服务器冗余运行，数据冗余备份。这样当某台服务器宕机时，可以将其上的服务和数据访问转移到其他机器上。</p>
<p>一般的做法是：</p>
<ul>
<li><strong>负载均衡</strong> - 通过负载均衡设备建立集群共同对外提供服务。</li>
<li><strong>备份</strong> - 数据存储在多台服务器，互相备份。即使访问和负载很小的服务也必须部署至少两台服务器，构成一个集群，目的就是通过冗余实现服务的高可用。
<ul>
<li><strong>冷备份</strong> - 数据应该定期备份；</li>
<li><strong>热备份</strong> - 为了保证在线业务高可用，还需要对数据库进行主从分离，实时同步 。</li>
<li><strong>灾备</strong> - 为了抵御地震、海啸等不可抗因素导致的网站完全瘫痪，某些大型网站会对整个数据中心进行备份，全球范围内部署 <strong>灾备数据中心</strong>。网站程序和数据实时同步到多个灾备数据中心。</li>
</ul>
</li>
<li><strong>自动化</strong> - 自动化是指，大型系统有必要通过预发布验证、自动化测试、自动化发布、灰度发布等手段，减少将故障引入线上环境的可能。常见自动化手段有：
<ul>
<li>发布过程自动化
<ul>
<li>自动化代码管理</li>
<li>自动化测试</li>
<li>自动化安全监测</li>
<li>自动化部署</li>
</ul>
</li>
<li>运维自动化
<ul>
<li>自动化监控</li>
<li>自动化报警</li>
<li>自动化失效转移</li>
<li>自动化失效恢复</li>
<li>自动化降级</li>
<li>自动化分配资源</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="36-安全"><a class="markdownIt-Anchor" href="#36-安全"></a> 3.6. 安全</h3>
<p>安全是指系统应该对恶意攻击有一定的抵抗能力，保护重要数据不被窃取。</p>
<ul>
<li><strong>密码</strong> 和 <strong>手机校验码</strong> 进行身份认证</li>
<li>登录、交易等重要操作需要对网络通信进行 <strong>加密</strong>，存储的敏感数据如用户信息等也进行加密处理</li>
<li>防止机器人程序攻击网站，使用 <strong>验证码</strong> 进行识别</li>
<li>对常见用于 <strong>攻击</strong> 网站的 XSS 攻击、SQL 注入、进行编码转换等相应处理</li>
<li>对垃圾信息、敏感信息进行 <strong>过滤</strong></li>
<li>对交易转账等重要操作根据交易模式和交易信息进行 <strong>风险控制</strong></li>
</ul>
<h2 id="4-常见架构模型"><a class="markdownIt-Anchor" href="#4-常见架构模型"></a> 4. 常见架构模型</h2>
<h3 id="41-分层架构"><a class="markdownIt-Anchor" href="#41-分层架构"></a> 4.1. 分层架构</h3>
<p>分层架构（layered architecture）是最常见的软件架构，也是事实上的标准架构。</p>
<p>这种架构将软件分成若干个水平层，每一层都有清晰的角色和分工，不需要知道其他层的细节。层与层之间通过接口通信。</p>
<p>四层的结构最常见。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/layered-architecture.png" width="500"/>
</div>
<ul>
<li>表现层（presentation）：用户界面，负责视觉和用户互动</li>
<li>业务层（business）：实现业务逻辑</li>
<li>持久层（persistence）：提供数据，SQL 语句就放在这一层</li>
<li>数据库（database） ：保存数据</li>
</ul>
<p>优点</p>
<ul>
<li>结构简单，容易理解和开发</li>
<li>不同技能的程序员可以分工，负责不同的层，天然适合大多数软件公司的组织架构</li>
<li>每一层都可以独立测试，其他层的接口通过模拟解决</li>
</ul>
<p>缺点</p>
<ul>
<li>一旦环境变化，需要代码调整或增加功能时，通常比较麻烦和费时</li>
<li>部署比较麻烦，即使只修改一个小地方，往往需要整个软件重新部署，不容易做持续发布</li>
<li>软件升级时，可能需要整个服务暂停</li>
<li>扩展性差。用户请求大量增加时，必须依次扩展每一层，由于每一层内部是耦合的，扩展会很困难</li>
</ul>
<h3 id="42-事件驱动架构"><a class="markdownIt-Anchor" href="#42-事件驱动架构"></a> 4.2. 事件驱动架构</h3>
<p>事件（event）是状态发生变化时，软件发出的通知。</p>
<p>事件驱动架构（event-driven architecture）就是通过事件进行通信的软件架构。它分成四个部分。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/event-driven-architecture.png" width="500"/>
</div>
<ul>
<li>事件队列（event queue）：接收事件的入口</li>
<li>分发器（event mediator）：将不同的事件分发到不同的业务逻辑单元</li>
<li>事件通道（event channel）：分发器与处理器之间的联系渠道</li>
<li>事件处理器（event processor）：实现业务逻辑，处理完成后会发出事件，触发下一步操作</li>
</ul>
<p>对于简单的项目，事件队列、分发器和事件通道，可以合为一体，整个软件就分成事件代理和事件处理器两部分。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/simple-event-driven-architecture.png" width="500"/>
</div>
<p>优点</p>
<ul>
<li>分布式的异步架构，事件处理器之间高度解耦，软件的扩展性好</li>
<li>适用性广，各种类型的项目都可以用</li>
<li>性能较好，因为事件的异步本质，软件不易产生堵塞</li>
<li>事件处理器可以独立地加载和卸载，容易部署</li>
</ul>
<p>缺点</p>
<ul>
<li>涉及异步编程（要考虑远程通信、失去响应等情况），开发相对复杂</li>
<li>难以支持原子性操作，因为事件通过会涉及多个处理器，很难回滚</li>
<li>分布式和异步特性导致这个架构较难测试</li>
</ul>
<h3 id="43-微核架构"><a class="markdownIt-Anchor" href="#43-微核架构"></a> 4.3. 微核架构</h3>
<p>微核架构（microkernel architecture）又称为&quot;插件架构&quot;（plug-in architecture），指的是软件的内核相对较小，主要功能和业务逻辑都通过插件实现。</p>
<p>内核（core）通常只包含系统运行的最小功能。插件则是互相独立的，插件之间的通信，应该减少到最低，避免出现互相依赖的问题。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/plug-in-architecture.png" width="500"/>
</div>
<p>优点</p>
<ul>
<li>良好的功能延伸性（extensibility），需要什么功能，开发一个插件即可</li>
<li>功能之间是隔离的，插件可以独立的加载和卸载，使得它比较容易部署，</li>
<li>可定制性高，适应不同的开发需要</li>
<li>可以渐进式地开发，逐步增加功能</li>
</ul>
<p>缺点</p>
<ul>
<li>扩展性（scalability）差，内核通常是一个独立单元，不容易做成分布式</li>
<li>开发难度相对较高，因为涉及到插件与内核的通信，以及内部的插件登记机制</li>
</ul>
<h3 id="44-微服务架构"><a class="markdownIt-Anchor" href="#44-微服务架构"></a> 4.4. 微服务架构</h3>
<p>微服务架构（microservices architecture）是服务导向架构（service-oriented architecture，缩写 SOA）的升级。</p>
<p>每一个服务就是一个独立的部署单元（separately deployed unit）。这些单元都是分布式的，互相解耦，通过远程通信协议（比如 REST、SOAP）联系。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/microservices-architecture.png" width="500"/>
</div>
<p>微服务架构分成三种实现模式。</p>
<ul>
<li>RESTful API 模式：服务通过 API 提供，云服务就属于这一类</li>
<li>RESTful 应用模式：服务通过传统的网络协议或者应用协议提供，背后通常是一个多功能的应用程序，常见于企业内部</li>
<li>集中消息模式：采用消息代理（message broker），可以实现消息队列、负载均衡、统一日志和异常处理，缺点是会出现单点失败，消息代理可能要做成集群</li>
</ul>
<p>优点</p>
<ul>
<li>扩展性好，各个服务之间低耦合</li>
<li>容易部署，软件从单一可部署单元，被拆成了多个服务，每个服务都是可部署单元</li>
<li>容易开发，每个组件都可以进行持续集成式的开发，可以做到实时部署，不间断地升级</li>
<li>易于测试，可以单独测试每一个服务</li>
</ul>
<p>缺点</p>
<ul>
<li>由于强调互相独立和低耦合，服务可能会拆分得很细。这导致系统依赖大量的微服务，变得很凌乱和笨重，性能也会不佳。</li>
<li>一旦服务之间需要通信（即一个服务要用到另一个服务），整个架构就会变得复杂。典型的例子就是一些通用的 Utility 类，一种解决方案是把它们拷贝到每一个服务中去，用冗余换取架构的简单性。</li>
<li>分布式的本质使得这种架构很难实现原子性操作，交易回滚会比较困难。</li>
</ul>
<h3 id="45-云架构"><a class="markdownIt-Anchor" href="#45-云架构"></a> 4.5. 云架构</h3>
<p>云结构（cloud architecture）主要解决扩展性和并发的问题，是最容易扩展的架构。</p>
<p>它的高扩展性，主要原因是没使用中央数据库，而是把数据都复制到内存中，变成可复制的内存数据单元。然后，业务处理能力封装成一个个处理单元（prcessing unit）。访问量增加，就新建处理单元；访问量减少，就关闭处理单元。由于没有中央数据库，所以扩展性的最大瓶颈消失了。由于每个处理单元的数据都在内存里，最好要进行数据持久化。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/cloud-architecture.png" width="500"/>
</div>
<p>这个模式主要分成两部分：处理单元（processing unit）和虚拟中间件（virtualized middleware）。</p>
<ul>
<li>处理单元：实现业务逻辑</li>
<li>虚拟中间件：负责通信、保持 sessions、数据复制、分布式处理、处理单元的部署。</li>
</ul>
<p>虚拟中间件又包含四个组件。</p>
<blockquote>
<ul>
<li><strong>消息中间件</strong>（Messaging Grid）：管理用户请求和 session，当一个请求进来以后，决定分配给哪一个处理单元。</li>
<li><strong>数据中间件</strong>（Data Grid）：将数据复制到每一个处理单元，即数据同步。保证某个处理单元都得到同样的数据。</li>
<li><strong>处理中间件</strong>（Processing Grid）：可选，如果一个请求涉及不同类型的处理单元，该中间件负责协调处理单元</li>
<li><strong>部署中间件</strong>（Deployment Manager）：负责处理单元的启动和关闭，监控负载和响应时间，当负载增加，就新启动处理单元，负载减少，就关闭处理单元。</li>
</ul>
</blockquote>
<p>优点</p>
<ul>
<li>高负载，高扩展性</li>
<li>动态部署</li>
</ul>
<p>缺点</p>
<ul>
<li>实现复杂，成本较高</li>
<li>主要适合网站类应用，不合适大量数据吞吐的大型数据库应用</li>
<li>较难测试</li>
</ul>
<h2 id="5-参考资料"><a class="markdownIt-Anchor" href="#5-参考资料"></a> 5. 参考资料</h2>
<ul>
<li><a href="https://item.jd.com/11322972.html" target="_blank" rel="noopener">大型网站技术架构：核心原理与案例分析</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2016/09/software-architecture.html" target="_blank" rel="noopener">软件架构入门- 阮一峰的网络日志</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/design/architecture/extensible-architecture/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/design/architecture/extensible-architecture/" class="post-title-link" itemprop="url">扩展性架构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-05 15:11:00" itemprop="dateCreated datePublished" datetime="2018-07-05T15:11:00+08:00">2018-07-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-03 16:31:45" itemprop="dateModified" datetime="2019-12-03T16:31:45+08:00">2019-12-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index">
                    <span itemprop="name">设计</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/design/architecture/extensible-architecture/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="design/architecture/extensible-architecture/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="扩展性架构"><a class="markdownIt-Anchor" href="#扩展性架构"></a> 扩展性架构</h1>
<blockquote>
<p>扩展性和伸缩性是不同的概念：</p>
<ul>
<li><strong>扩展性（Extensibility）</strong> - 指对现有系统影响最小的情况下，系统功能可持续扩展或提升的能力。表现在系统基础设施稳定不需要经常变更，应用之间较少依赖和耦合，对需求变更可以敏捷响应。它是系统架构设计层面的开闭原则（对扩展开放、对修改关闭），架构设计考虑未来功能扩展，当系统增加新功能时，不需要对现有系统的结构和代码进行修改。</li>
<li><strong>伸缩性（Scalability）</strong> - 指系统能够通过增加减少自身资源规模的方式增减自己计算处理事务的能力。如果这种增减是成比例的，就被称作线性伸缩性。在网站架构中 ，通常指利用集群的方式增加服务器数量、提高系统的整体事务吞吐能力。</li>
</ul>
</blockquote>
<h2 id="1-易扩展的系统架构"><a class="markdownIt-Anchor" href="#1-易扩展的系统架构"></a> 1. 易扩展的系统架构</h2>
<blockquote>
<p><strong>低耦合的系统更容易扩展、复用</strong>。</p>
</blockquote>
<p><strong>可扩展架构的核心思想是模块化，并在此基础上，降低模块间的耦合性，提高模块的复用性</strong>。</p>
<p>分层和分割不仅可以进行架构伸缩，也是模块化设计的重要手段，利用分层和分割的方式将软件分割为若干个低耦合的独立的组件模块，这些组件模块以消息传递及依赖调用的方式聚合成一个完整的系统。</p>
<p>在大型网站中，这些模块通过分布式部署的方式，独立的模块部署在独立的服务器上，从物理上分离模块间的耦合关系，进一步降低耦合性提高复用性。</p>
<h2 id="2-利用分布式消息队列降低系统耦合性"><a class="markdownIt-Anchor" href="#2-利用分布式消息队列降低系统耦合性"></a> 2. 利用分布式消息队列降低系统耦合性</h2>
<h3 id="21-事件驱动架构"><a class="markdownIt-Anchor" href="#21-事件驱动架构"></a> 2.1. 事件驱动架构</h3>
<p><strong>事件驱动架构通过在低耦合的模块间传输事件消息，以保持模块的松散耦合，并借助事件消息的通信完成模块间合作</strong>。典型的事件驱动架构就是操作系统中常见的生产者消费者模式。在大型网站中，最常见的实现手段就是分布式消息队列。</p>
<h3 id="22-分布式消息队列"><a class="markdownIt-Anchor" href="#22-分布式消息队列"></a> 2.2. 分布式消息队列</h3>
<p>消息生产者应用程序通过远程访问接口将消息推送给消息队列服务器，消息队列服务器将消息写入本地内存队列后立即返回成功响应给消息生产者。消息队列服务器根据消息订阅列表查找订阅该消息的消息消费者应用程序，将消息队列中的消息按照先进先出（FIFO）的原则将消息通过远程通信接口发送给消息消费者程序。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/architecture/分布式消息队列架构原理.png!zp" />
</div>
<p>在伸缩性方面，由于消息队列服务器上的数据可以看作是即时处理的，因此类似于无状态的服务器，伸缩性设计比较简单。将新服务器加入分布式消息队列集群中，通知生产者服务器更改消息队列服务器列表即可。</p>
<p>在可用性方面，为了避免消费者进程处理缓慢，分布式消息队列服务器内存空间不足造成的问题，如果内存队列已满，会将消息写入磁盘，消息推送模块在将内存队列消息处理完成以后，将磁盘内容加载到内存队列继续处理。</p>
<h2 id="3-利用分布式服务打造可复用的业务平台"><a class="markdownIt-Anchor" href="#3-利用分布式服务打造可复用的业务平台"></a> 3. 利用分布式服务打造可复用的业务平台</h2>
<p>巨无霸系统的问题：</p>
<ul>
<li>构建、部署困难</li>
<li>代码分支管理困难</li>
<li>数据库连接耗尽</li>
<li>扩展业务困难</li>
</ul>
<p>而解决巨无霸系统问题的方案就是拆分：</p>
<ul>
<li>通过纵向拆分将业务拆分多个应用或模块；</li>
<li>通过横向拆分将可复用业务作为独立应用。</li>
</ul>
<p>然后，需要通过一个分布式服务管理框架将这些应用或服务组织管理起来：通过接口分解系统耦合性，不同子系统通过相同的接口描述进行服务调用。常见的分布式服务管理框架如：Spring Cloud、Dubbo 等。</p>
<p>大型网站分布式服务的需求与特点：</p>
<ul>
<li>负载均衡</li>
<li>失效转移</li>
<li>高效的远程通信</li>
<li>整合异构系统</li>
<li>对应用最少侵入</li>
<li>版本管理</li>
<li>实时监控</li>
</ul>
<h2 id="4-可扩展的数据结构"><a class="markdownIt-Anchor" href="#4-可扩展的数据结构"></a> 4. 可扩展的数据结构</h2>
<p>传统的关系型数据库为了保证关系运算的正确性，在设计数据库表结构的时候，就需要指定表的 schema ——字段名称，数据类型等，并要遵循特定的设计范式。这些规范带来一个问题：难以面对需求变更带来的挑战，所以有人通过预先设计一些冗余字段来应对。</p>
<p>许多 NoSql 数据库使用 ColumnFamily 设计来设计可扩展的数据结构。</p>
<h2 id="5-开放平台"><a class="markdownIt-Anchor" href="#5-开放平台"></a> 5. 开放平台</h2>
<p>很多大公司会利用开放平台提供大量开放性 API 使得企业和个人可以方便的接入业务。通过开放平台，可以构建生态圈，提升品牌价值以及竞争力。</p>
<p>开放平台不是一朝一夕完成的，这需要大量 OPEN API 的沉淀。系统架构在设计之初，应该有意识的将未来可能被复用的接口好好设计，以便于需要开放 OPEN API 时，可以便捷的暴露服务接口。</p>
<h2 id="6-参考资料"><a class="markdownIt-Anchor" href="#6-参考资料"></a> 6. 参考资料</h2>
<ul>
<li><a href="https://item.jd.com/11322972.html" target="_blank" rel="noopener">大型网站技术架构：核心原理与案例分析</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/design/architecture/scalable-architecture/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/design/architecture/scalable-architecture/" class="post-title-link" itemprop="url">伸缩性架构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-05 15:11:00" itemprop="dateCreated datePublished" datetime="2018-07-05T15:11:00+08:00">2018-07-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-03 16:31:45" itemprop="dateModified" datetime="2019-12-03T16:31:45+08:00">2019-12-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index">
                    <span itemprop="name">设计</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/design/architecture/scalable-architecture/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="design/architecture/scalable-architecture/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="伸缩性架构"><a class="markdownIt-Anchor" href="#伸缩性架构"></a> 伸缩性架构</h1>
<blockquote>
<p>伸缩性架构是指不需要改变系统的软硬件设计，仅通过改变部署服务器数量就可以扩大或缩小系统的服务处理能力。</p>
</blockquote>
<h2 id="1-系统架构的伸缩性设计"><a class="markdownIt-Anchor" href="#1-系统架构的伸缩性设计"></a> 1. 系统架构的伸缩性设计</h2>
<h3 id="11-不同功能进行物理分离实现伸缩"><a class="markdownIt-Anchor" href="#11-不同功能进行物理分离实现伸缩"></a> 1.1. 不同功能进行物理分离实现伸缩</h3>
<ul>
<li><strong>纵向分离（分层后分离）</strong> - 将业务处理流程上的不同部分分离部署，实现系统伸缩性。</li>
<li><strong>横向分离（业务分割后分离）</strong> - 将不同的业务模块分离部署，实现系统伸缩性。</li>
</ul>
<h3 id="12-单一功能通过集群规模实现伸缩"><a class="markdownIt-Anchor" href="#12-单一功能通过集群规模实现伸缩"></a> 1.2. 单一功能通过集群规模实现伸缩</h3>
<p>将不同功能分离部署可以实现一定程度的伸缩性，但是随着访问量逐步增加，即使分离到最小粒度的独立部署，单一的服务器也不能满足业务规模的要求。因此必须使用服务器集群，即将相同服务部署在多态服务器上构成一个集群整体对外提供服务。</p>
<h2 id="2-应用服务器集群的伸缩性设计"><a class="markdownIt-Anchor" href="#2-应用服务器集群的伸缩性设计"></a> 2. 应用服务器集群的伸缩性设计</h2>
<p>如果 HTTP 请求分发装置可以感知或者可以配置集群的服务器数量，可以及时发现集群中新上线或下线的服务器，并能向新上线的服务器分发请求，停止向已下线的服务器分发请求，那么就实现了应用服务器集群的伸缩性。</p>
<h3 id="21-http-重定向负载均衡"><a class="markdownIt-Anchor" href="#21-http-重定向负载均衡"></a> 2.1. HTTP 重定向负载均衡</h3>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/architecture/负载均衡-HTTP重定向.png!zp" width="500"/>
</div>
<p>利用 HTTP 重定向协议实现负载均衡。</p>
<p>这种负载均衡方案的优点是比较简单。</p>
<p>缺点是浏览器需要两次请求服务器才能完成一次访问，性能较差：重定向服务器自身的处理能力有可能成为瓶颈，整个集群的伸缩性规模有限；使用 HTTP 302 响应码重定向，可能使搜索引擎判断为 SEO 作弊，降低搜索排名。</p>
<h3 id="22-dns-域名解析负载均衡"><a class="markdownIt-Anchor" href="#22-dns-域名解析负载均衡"></a> 2.2. DNS 域名解析负载均衡</h3>
<p>利用 DNS 处理域名解析请求的同时进行负载均衡处理的一种方案。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/architecture/负载均衡-DNS域名解析.png!zp" width="500"/>
</div>
<p>在 DNS 服务器中配置多个 A 记录，如：</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line"><span class="number">114.100.40.1</span> www.mysite.com</span><br><span class="line"><span class="number">114.100.40.2</span> www.mysite.com</span><br><span class="line"><span class="number">114.100.40.3</span> www.mysite.com</span><br></pre></td></tr></table></figure>
<p>每次域名解析请求都会根据负载均衡算法计算一个不同的 IP 地址返回，这样 A 记录中配置的多个服务器就构成一个集群，并可以实现负载均衡。</p>
<p>DNS 域名解析负载均衡的优点：</p>
<ul>
<li>将负载均衡的工作转交给了 DNS，省掉了网站管理维护的麻烦。</li>
<li>同时，许多 DNS 服务器还支持基于地理位置的域名解析，即将域名解析成距离用户地理最近的一个服务器地址，这样可以加快用户访问速度，改善性能。</li>
</ul>
<p>DNS 域名解析负载均衡的缺点：</p>
<ul>
<li>DNS 是多级解析，每一级 DNS 都可能缓存 A 记录，当某台服务器下线后，即使修改了 DNS 的 A 记录，要使其生效也需要较长时间。这段时间，依然会域名解析到已经下线的服务器，导致用户访问失败。</li>
<li>DNS 的负载均衡的控制权在域名服务商那里，网站无法对其做更多改善和更强大的管理。</li>
</ul>
<h3 id="23-反向代理负载均衡"><a class="markdownIt-Anchor" href="#23-反向代理负载均衡"></a> 2.3. 反向代理负载均衡</h3>
<p>大多数反向代理服务器同时提供反向代理和负载均衡的功能。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/architecture/负载均衡-反向代理.png!zp" width="500"/>
</div>
<p>反向代理服务器的优点是部署简单。缺点是反向代理服务器是所有请求和响应的中转站，其性能可能会成为瓶颈。</p>
<h3 id="24-ip-负载均衡"><a class="markdownIt-Anchor" href="#24-ip-负载均衡"></a> 2.4. IP 负载均衡</h3>
<p>在网络层通过修改请求目标地址进行负载均衡。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/architecture/负载均衡-IP层.png!zp" width="500"/>
</div>
<p>负载均衡服务器（网关服务器）在操作系统内核获取网络数据包，根据负载均衡算法计算得到一台真实 Web 服务器 10.0.0.1，然后将目的 IP 地址修改为 10.0.0.1，不需要通过用户进程。真实 Web 服务器处理完成后，响应数据包回到负载均衡服务器，负载均衡服务器再将数据包原地址修改为自身的 IP 地址（114.100.80.10）发送给浏览器。</p>
<p>IP 负载均衡在内核完成数据分发，所以处理性能优于反向代理负载均衡。但是因为所有请求响应都要经过负载均衡服务器，集群的最大响应数据吞吐量受制于负载均衡服务器网卡带宽。</p>
<h3 id="25-数据链路层负载均衡"><a class="markdownIt-Anchor" href="#25-数据链路层负载均衡"></a> 2.5. 数据链路层负载均衡</h3>
<p>数据链路层负载均衡是指在通信协议的数据链路层修改 mac 地址进行负载均衡。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/architecture/负载均衡-数据链路层.png!zp" width="500"/>
</div>
<p>这种方式又称作三角传输方式，负载均衡数据分发过程中不修改 IP 地址，只修改目的 mac 地址，通过配置真实物理服务器集群所有机器虚拟 IP 和负载均衡服务器 IP 地址一致，从而达到不修改数据包的源地址和目的地址就可以进行数据分发的目的，由于实际处理请求的真实物理服务器 IP 和数据请求目的 IP 一致，不需要通过负载均衡服务器进行地址转换，可将响应数据包直接返回给用户浏览器，避免负载均衡服务器网卡带宽成为瓶颈。这种负载方式又称作直接路由方式。</p>
<p>在 Linux 平台上最好的链路层负载均衡开源产品是 <strong>LVS(Linux Virtual Server)</strong>。</p>
<h3 id="26-负载均衡算法"><a class="markdownIt-Anchor" href="#26-负载均衡算法"></a> 2.6. 负载均衡算法</h3>
<p>负载均衡服务器的实现可以分为两个部分：</p>
<ol>
<li>根据负载均衡算法和 Web 服务器列表计算得到集群中一台 Web 服务器的地址。</li>
<li>将请求数据发送到该地址对应的 Web 服务器上。</li>
</ol>
<p>负载均衡算法通常有以下几种：</p>
<ul>
<li><strong>轮询（Round Robin）</strong> - 所有请求被依次分发到每台应用服务器上，即每台服务器需要处理的请求数据都相同，适合于所有服务器硬件都相同的场景。</li>
<li><strong>加权轮询（Weighted Round Robin）</strong> - 根据服务器硬件性能情况，在轮询的基础上，按照配置权重将请求分发到每个服务器，高性能服务器能分配更多请求。</li>
<li><strong>随机（Random）</strong> - 请求被随机分配到各个应用服务器，在许多场合下，这种方案都很简单实用，因为好的随机数本身就很平均，即使应用服务器硬件配置不同，也可以使用加权随机算法。</li>
<li><strong>最少连接（Least Connection）</strong> - 记录每个应用服务器正在处理的连接数，将新到的请求分发到最少连接的服务器上，应该说，这是最符合负载均衡定义的算法。</li>
<li><strong>源地址 Hash（Source Hash）</strong> - 根据请求来源的 IP 地址进行 Hash 计算，得到应用服务器，这样来自同一个 IP 地址的请求总在同一个服务器上处理，该请求的上下文信息可以存储在这台服务器上，在一个会话周期内重复使用，从而实现会话粘滞。</li>
</ul>
<h2 id="3-分布式缓存集群的伸缩性设计"><a class="markdownIt-Anchor" href="#3-分布式缓存集群的伸缩性设计"></a> 3. 分布式缓存集群的伸缩性设计</h2>
<p>目前比较流行的分布式集群伸缩性方案就是：一致性 HASH 算法</p>
<h2 id="4-数据存储服务集群的伸缩性设计"><a class="markdownIt-Anchor" href="#4-数据存储服务集群的伸缩性设计"></a> 4. 数据存储服务集群的伸缩性设计</h2>
<h3 id="41-关系型数据库的伸缩性设计"><a class="markdownIt-Anchor" href="#41-关系型数据库的伸缩性设计"></a> 4.1. 关系型数据库的伸缩性设计</h3>
<ul>
<li><strong>主从复制</strong> - 主流关系型数据库一般都支持主从复制。</li>
<li><strong>分库</strong> - 根据业务对数据库进行分割。制约条件是跨库的表不能进行 Join 操作。</li>
<li><strong>分表</strong> - 使用数据库分片中间件，如 Cobar 等。</li>
</ul>
<h3 id="42-nosql-数据库的伸缩性设计"><a class="markdownIt-Anchor" href="#42-nosql-数据库的伸缩性设计"></a> 4.2. NoSql 数据库的伸缩性设计</h3>
<p>一般而言，Nosql 不支持 SQL 和 ACID，但是强化了对于高可用和伸缩性的支持。</p>
<h2 id="5-参考资料"><a class="markdownIt-Anchor" href="#5-参考资料"></a> 5. 参考资料</h2>
<ul>
<li><a href="https://item.jd.com/11322972.html" target="_blank" rel="noopener">大型网站技术架构：核心原理与案例分析</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/design/architecture/high-availability-architecture/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/design/architecture/high-availability-architecture/" class="post-title-link" itemprop="url">高可用架构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-05 15:11:00" itemprop="dateCreated datePublished" datetime="2018-07-05T15:11:00+08:00">2018-07-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-03 16:31:45" itemprop="dateModified" datetime="2019-12-03T16:31:45+08:00">2019-12-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index">
                    <span itemprop="name">设计</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/design/architecture/high-availability-architecture/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="design/architecture/high-availability-architecture/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="高可用架构"><a class="markdownIt-Anchor" href="#高可用架构"></a> 高可用架构</h1>
<h2 id="1-网站可用性的度量"><a class="markdownIt-Anchor" href="#1-网站可用性的度量"></a> 1. 网站可用性的度量</h2>
<p>网站不可用也被称作网站故障，业界通常用多个 9 来衡量网站的可用性。如 QQ 的可用性为 4 个 9，即 99.99% 可用。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">网站不可用时间 = 故障修复时间点 - 故障发现时间点</span><br><span class="line">网站年度可用性指标 = (<span class="number">1</span> - 网站不可用时间/年度总时间) * <span class="number">100</span>%</span><br></pre></td></tr></table></figure>
<p>一般来说：</p>
<ul>
<li>2 个 9 是基本可用，一年不可用时间小于 88 小时；</li>
<li>3 个 9 是较高可用，一年不可用时间小于 9 小时；</li>
<li>4 个 9 是具有自动恢复能力的高可用，一年不可用时间小于 55 分钟；</li>
<li>5 个 9 是极高可用，一年不可用时间小于 5 分钟。</li>
</ul>
<h2 id="2-高可用的系统架构"><a class="markdownIt-Anchor" href="#2-高可用的系统架构"></a> 2. 高可用的系统架构</h2>
<p>通常，企业级应用系统为提高系统可用性，会采用较昂贵的软硬件设备，当然这样的设备也比较稳定。</p>
<p>互联网公司或一些初创型公司基于成本考虑，更多采用 PC 级软硬件设备，节约成本所付出的代价就是设备较为不稳定。服务器一年中出现几次宕机，高强度读写磁盘导致磁盘损坏等事件实属正常。</p>
<p>综上，硬件出现故障应视为必然的，而<strong>高可用的系统架构设计目标就是要保证当出现硬件故障时，服务依然可用，数据依然能够保存并被访问</strong>。</p>
<p><strong>实现高可用的系统架构的主要手段是数据和服务的冗余备份及失效转移</strong>，一旦某些服务器宕机，就将服务切换到其他可用的服务器上；如果磁盘损坏，则从备份的磁盘读取数据。</p>
<h2 id="3-高可用的应用"><a class="markdownIt-Anchor" href="#3-高可用的应用"></a> 3. 高可用的应用</h2>
<blockquote>
<p>应用层主要处理网站应用的业务逻辑，一个显著的特点是应用的 <strong>无状态</strong> 性。</p>
<p>所谓的 <strong>无状态</strong> 的应用是指应用服务器不保存业务的上下文信息，而仅根据每次请求提交的数据进行相应的业务逻辑处理，多个服务实例之间完全对等，请求提交到任意服务器，处理结果都是完全一样的。</p>
</blockquote>
<h3 id="31-通过负载均衡进行无状态服务的失效转移"><a class="markdownIt-Anchor" href="#31-通过负载均衡进行无状态服务的失效转移"></a> 3.1. 通过负载均衡进行无状态服务的失效转移</h3>
<p>无状态的应用实现高可用架构十分简单，由于服务器不保存请求状态，那么所有服务器完全对等，在任意节点执行同样的请求，结果总是一致的。这种情况下，最简单的高可用方案就是使用负载均衡。</p>
<p>负载均衡，顾名思义，主要使用在业务量和数据量较高的情况下，当单台服务器不足以承担所有的负载压力时，通过负载均衡手段，将流量和数据分摊到一个集群组成的多台服务器上，以提高整体的负载处理能力。</p>
<h3 id="32-应用服务器集群的-session-管理"><a class="markdownIt-Anchor" href="#32-应用服务器集群的-session-管理"></a> 3.2. 应用服务器集群的 Session 管理</h3>
<p>应用服务器的高可用架构设计主要基于服务无状态这一特性。事实上，业务总是有状态的，如购物车记录用户的购买信息；用户的登录状态；最新发布的消息等等。</p>
<p>Web 应用中将这些多次请求修改使用的上下文对象称作会话。单机情况下，Session 可由部署在服务器上的 Web 容器管理。</p>
<p>而在集群环境下，Session 管理有以下手段：</p>
<h4 id="321-session-复制"><a class="markdownIt-Anchor" href="#321-session-复制"></a> 3.2.1. Session 复制</h4>
<p>Session 复制是指应用服务器开启 Web 容器的 Session 复制功能，在集群中的几台服务器之间同步 Session 对象，使得每台服务器上都保存所有用户的 Session 信息。</p>
<p>这种方案很简单但不可取。因为当集群规模较大时，集群服务间需要大量的通信来进行 Session 复制，占用服务器和网络的大量资源。</p>
<h4 id="322-session-绑定"><a class="markdownIt-Anchor" href="#322-session-绑定"></a> 3.2.2. Session 绑定</h4>
<p>Session 绑定可以利用负载均衡的源地址 Hash 算法实现，负载均衡服务器总是将来源于同一 IP 的请求分发到同一台服务器上。这样在整个会话期间，用户所有的请求都在同一台服务器上处理，即 Session 绑定到某台特定服务器上。这种方法又被称作会话黏滞。</p>
<p>但是这种策略不符合系统高可用的需求，因为一旦某台服务器宕机，那么该机器上的 Session 也就不复存在了。</p>
<h4 id="323-利用-cookie-记录-session"><a class="markdownIt-Anchor" href="#323-利用-cookie-记录-session"></a> 3.2.3. 利用 Cookie 记录 Session</h4>
<p>可以将 Session 记录在客户端（浏览器 Cookie），每次请求服务器时，将 Session 放在请求中发送给服务器，服务器处理完请求后再将修改过的 Session 响应给客户端。</p>
<p>这种策略的缺点是：</p>
<ul>
<li>Cookie 有大小限制，能记录的信息有限；</li>
<li>每次请求响应都需要传输 Cookie，影响性能；</li>
<li>如果用户关闭 Cookie，访问就不能工作。</li>
</ul>
<h4 id="324-session-服务器"><a class="markdownIt-Anchor" href="#324-session-服务器"></a> 3.2.4. Session 服务器</h4>
<p>利用独立部署的 Session 服务器（集群）统一管理 Session，应用服务器每次读写 Session 时，都访问 Session 服务器。</p>
<p>实现 Session 服务器的一种简单方法时：利用分布式缓存、数据库等，在此基础上进行包装，使其符合 Session 的存储和访问要求。如果业务对 Session 管理有较高要求，如利用 Session 服务集成单点登录（SSO）、用户服务等功能，则需要开发独立的 Session 服务管理平台。</p>
<h2 id="4-高可用的服务"><a class="markdownIt-Anchor" href="#4-高可用的服务"></a> 4. 高可用的服务</h2>
<p>高可用的服务策略：</p>
<ul>
<li><strong>分级管理</strong>
<ul>
<li>将服务根据业务重要性进行分级管理，核心应用和服务优先使用更好的硬件，在运维响应速度上也格外迅速。</li>
<li>在服务部署上进行必要的隔离，避免故障的连锁反应。低优先级的服务通过启动不同的线程或部署在不同的虚拟机上进行隔离，而高优先级的服务则需要部署在不同的物理机上，核心服务和数据甚至要部署在不同地域的数据中心。</li>
</ul>
</li>
<li><strong>超时设置</strong> - 由于服务器宕机、线程死锁等原因，可能导致应用程序对服务端的调用失去响应。所以有必要引入超时机制，一旦调用超时，服务化框架抛出异常，应用程序根据服务调度策略，选择重试或请求转移到其他机器上。</li>
<li><strong>异步调用</strong> - 对于需要即时响应的业务，应用在调用服务时可以通过消息队列等异步方式完成，避免一个服务失败导致整个应用请求失败的情况。当然不是所有服务调用都可以异步调用，对于获取用户信息这类调用，采用异步方式会延长响应时间，得不偿失；此外，对于那些必须确认服务调用才能继续下一步操作的应用也不适宜食用异步调用。</li>
<li><strong>服务降级</strong> - 网站访问高峰期，服务可能因为大量并发调用而性能下降，严重时可能会导致宕机。为了保证核心功能的正常运行，需要对服务进行降级。降级有两种手段：
<ul>
<li><strong>拒绝服务</strong> - 拒绝低优先级应用的调用，减少服务调用并发数，确保核心应用正常使用。或者随机拒绝部分调用，节约资源，避免要死大家一起死的惨剧。</li>
<li><strong>关闭服务</strong> - 关闭部分不重要的服务，或者服务内部关闭部分不重要的功能，以节约资源。</li>
</ul>
</li>
<li><strong>幂等性设计</strong> - 为了避免服务重复调用，可以通过设置编号的方式进行服务调用有效性校验，有效的操作才能继续执行。</li>
</ul>
<h2 id="5-高可用的数据"><a class="markdownIt-Anchor" href="#5-高可用的数据"></a> 5. 高可用的数据</h2>
<h3 id="51-cap-原理"><a class="markdownIt-Anchor" href="#51-cap-原理"></a> 5.1. CAP 原理</h3>
<p>分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容忍性（P：Partition Tolerance），最多只能同时满足其中两项。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/分布式理论-CAP.jpg!zp" width="450"/>
</div>
<h4 id="511-可用性"><a class="markdownIt-Anchor" href="#511-可用性"></a> 5.1.1. 可用性</h4>
<p><strong>可用性指分布式系统在面对各种异常时可以提供正常服务的能力</strong>。可以用系统可用时间占总时间的比值来衡量，4 个 9 的可用性表示系统 99.99% 的时间是可用的。</p>
<p>在可用性条件下，系统提供的服务一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。</p>
<h4 id="512-分区容忍性"><a class="markdownIt-Anchor" href="#512-分区容忍性"></a> 5.1.2. 分区容忍性</h4>
<p>网络分区指分布式系统中的节点被划分为多个区域，每个区域内部可以通信，但是区域之间无法通信。</p>
<p>在分区容忍性条件下，<strong>分布式系统在遇到任何网络分区故障的时候，仍然需要能对外提供一致性和可用性的服务，除非是整个网络环境都发生了故障</strong>。</p>
<h4 id="513-一致性"><a class="markdownIt-Anchor" href="#513-一致性"></a> 5.1.3. 一致性</h4>
<p><strong>一致性指的是多个数据副本是否能保持一致的特性</strong>。</p>
<p>在一致性的条件下，系统在执行数据更新操作之后能够从一致性状态转移到另一个一致性状态。</p>
<p>数据一致性又可以分为以下几点：</p>
<ul>
<li><strong>强一致性</strong> - 数据更新操作结果和操作响应总是一致的，即操作响应通知更新失败，那么数据一定没有被更新，而不是处于不确定状态。</li>
<li><strong>最终一致性</strong> - 即物理存储的数据可能是不一致的，终端用户访问到的数据可能也是不一致的，但系统经过一段时间的自我修复和修正，数据最终会达到一致。</li>
</ul>
<h4 id="514-权衡"><a class="markdownIt-Anchor" href="#514-权衡"></a> 5.1.4. 权衡</h4>
<p>在分布式系统中，分区容忍性必不可少，因为需要总是假设网络是不可靠的。因此，CAP 理论实际在是要在可用性和一致性之间做权衡。</p>
<p>可用性和一致性往往是冲突的，很难都使它们同时满足。在多个节点之间进行数据同步时，</p>
<ul>
<li>为了保证一致性（CP），就需要让所有节点下线成为不可用的状态，等待同步完成；</li>
<li>为了保证可用性（AP），在同步过程中允许读取所有节点的数据，但是数据可能不一致。</li>
</ul>
<h3 id="52-数据备份"><a class="markdownIt-Anchor" href="#52-数据备份"></a> 5.2. 数据备份</h3>
<ul>
<li><strong>冷备份</strong> - 定期将数据复制到某种存储介质。</li>
<li><strong>热备份</strong>
<ul>
<li><strong>异步热备方式</strong> - 异步热备方式是指多份数据副本的写入操作异步完成，应用程序收到数据服务系统的写操作成功响应时，只写成功了一份，存储系统将会异步地写其他副本。</li>
<li><strong>同步热备方式</strong> - 同步热备方式是指多份数据副本的写入操作同步完成，即应用程序收到数据服务系统的写成功响应时，多份数据都已经写操作成功。但是当应用程序收到数据写操作失败的响应式，可能有部分副本或者全部副本都已经写入成功了（因为网络或者系统故障，无法返回操作成功的响应）。</li>
</ul>
</li>
</ul>
<h3 id="53-失效转移"><a class="markdownIt-Anchor" href="#53-失效转移"></a> 5.3. 失效转移</h3>
<h4 id="531-失效确认"><a class="markdownIt-Anchor" href="#531-失效确认"></a> 5.3.1. 失效确认</h4>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/architecture/check-fail.png!zp" width="500" />
</div>
<p>判断服务器宕机的手段有两种：<strong>心跳检测</strong>和<strong>访问失败报告</strong>。</p>
<p>对于应用程序的访问失败报告，控制中心还需要再一次发送心跳检测进行确认，以免错误判断服务器宕机。因为一旦进行数据访问的失效转移，意味着数据存储多份副本不一致，需要进行后续一系列的复杂动作。</p>
<h4 id="532-访问转移"><a class="markdownIt-Anchor" href="#532-访问转移"></a> 5.3.2. 访问转移</h4>
<p>确认某台数据服务器宕机后，就需要将数据读写访问重新路由到其他服务器上。对于完全对等存储的服务器，当其中一台宕机后，应用程序根据配置直接切换到对等服务器上。如果存储不对等，就需要重新计算路由，选择存储服务器。</p>
<h4 id="533-数据恢复"><a class="markdownIt-Anchor" href="#533-数据恢复"></a> 5.3.3. 数据恢复</h4>
<p>因为某台服务器宕机，所以数据存储的副本数目会减少，必须将副本的数目恢复到系统设定的值，否则，再有服务器宕机时，就可能出现无法访问转移，数据永久丢失的情况。因此系统需要从健康的服务器复制数据，将数据副本数目恢复到设定值。</p>
<h2 id="6-高可用的软件质量保证"><a class="markdownIt-Anchor" href="#6-高可用的软件质量保证"></a> 6. 高可用的软件质量保证</h2>
<p>高可用的软件质量保证的手段：</p>
<ul>
<li>自动化发布</li>
<li>自动化测试</li>
<li>预发布验证</li>
<li>代码控制</li>
<li>灰度发布</li>
</ul>
<h2 id="7-系统监控"><a class="markdownIt-Anchor" href="#7-系统监控"></a> 7. 系统监控</h2>
<blockquote>
<p>不允许没有监控的系统上线。</p>
</blockquote>
<ul>
<li><strong>监控数据采集</strong>
<ul>
<li><strong>用户行为日志收集</strong>
<ul>
<li>服务端日志收集 - Apache、Nginx 等几乎所有 Web 服务器都具备日志记录功能，只要开启日志记录即可。如果是服务器比较多，需要集中采集日志，通常会使用 Elastic 来进行收集。</li>
<li>客户端日志收集 - 利用页面嵌入专门的 JavaScript 脚本可以收集用户真实的操作行为。</li>
<li>日志分析 - 可以利用 ElasticSearch 做语义分析及搜索；利用实时计算框架 Storm、Flink 等开发日志统计与分析工具。</li>
</ul>
</li>
<li><strong>服务器性能监控</strong> - 收集服务器性能指标，如系统负载、内存占用、CPU 占用、磁盘 IO、网络 IO 等。常用的监控工具有：<a href="https://github.com/apache/skywalking" target="_blank" rel="noopener">Apache SkyWalking</a> 、<a href="https://github.com/naver/pinpoint" target="_blank" rel="noopener">Pinpoint</a> 等。</li>
<li><strong>运行数据报告</strong> - 应该监控一些与具体业务场景相关的技术和业务指标，如：缓存命中率、平均响应时延、TPS、QPS 等。</li>
</ul>
</li>
<li><strong>监控管理</strong>
<ul>
<li><strong>系统报警</strong> - 设置阈值。当达到阈值，及时触发告警（短信、邮件、通信工具均可），通过及时判断状况，防患于未然。</li>
<li><strong>失效转移</strong> - 监控系统可以在发现故障的情况下主动通知应用进行失效转移。</li>
<li><strong>自动优雅降级</strong>
<ul>
<li>优雅降级是为了应付突然爆发的访问高峰，主动关闭部分功能，释放部分资源，以保证核心功能的优先访问。</li>
<li>系统在监控管理基础之上实现自动优雅降级，是柔性架构的理想状态。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="8-资料"><a class="markdownIt-Anchor" href="#8-资料"></a> 8. 资料</h2>
<ul>
<li><a href="https://item.jd.com/11322972.html" target="_blank" rel="noopener">大型网站技术架构：核心原理与案例分析</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/design/architecture/high-performance-architecture/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/design/architecture/high-performance-architecture/" class="post-title-link" itemprop="url">高性能架构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-05 15:11:00" itemprop="dateCreated datePublished" datetime="2018-07-05T15:11:00+08:00">2018-07-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-03 16:31:45" itemprop="dateModified" datetime="2019-12-03T16:31:45+08:00">2019-12-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index">
                    <span itemprop="name">设计</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/design/architecture/high-performance-architecture/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="design/architecture/high-performance-architecture/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="高性能架构"><a class="markdownIt-Anchor" href="#高性能架构"></a> 高性能架构</h1>
<h2 id="1-性能测试"><a class="markdownIt-Anchor" href="#1-性能测试"></a> 1. 性能测试</h2>
<blockquote>
<p>性能测试是性能优化的前提和基础，也是性能优化结果的检查和度量标准。不同视角下的性能有不同标准，也有不同的优化手段。</p>
</blockquote>
<h3 id="11-性能指标"><a class="markdownIt-Anchor" href="#11-性能指标"></a> 1.1. 性能指标</h3>
<p>性能测试的主要指标有：</p>
<ul>
<li><strong>响应时间</strong> - 响应时间(RT)是指从客户端发一个请求开始计时，到客户端接收到从服务器端返回的响应结果结束所经历的时间，响应时间由请求发送时间、网络传输时间和服务器处理时间三部分组成。</li>
<li><strong>并发数</strong> - 系统能同时处理的请求、事务数。</li>
<li><strong>吞吐量</strong> - <strong><code>TPS(每秒事务数)</code></strong>、<strong><code>HPS(每秒 HTTP 请求数)</code></strong>、<strong><code>QPS(每秒查询数)</code></strong>。</li>
<li><strong>性能计数器</strong> - 系统负载、对象与线程数、内存使用、CPU 使用、磁盘与网络 IO 等。这些指标也是系统监控的重要参数。</li>
</ul>
<h3 id="12-性能测试方法"><a class="markdownIt-Anchor" href="#12-性能测试方法"></a> 1.2. 性能测试方法</h3>
<ul>
<li>性能测试</li>
<li>负载测试</li>
<li>压力测试</li>
<li>稳定性测试</li>
</ul>
<h3 id="13-性能测试报告"><a class="markdownIt-Anchor" href="#13-性能测试报告"></a> 1.3. 性能测试报告</h3>
<p>性能测试报告示例：</p>
<div align="center">
<img src="https://upload-images.jianshu.io/upload_images/3101171-3d533a36f42608a1.png" />
</div>
<h3 id="14-性能优化策略"><a class="markdownIt-Anchor" href="#14-性能优化策略"></a> 1.4. 性能优化策略</h3>
<ol>
<li><strong>性能分析</strong> - 如果请求响应慢，存在性能问题。需要对请求经历的各个环节逐一分析，排查可能出现性能瓶颈的地方，定位问题。检查监控数据，分析影响性能的主要因素：内存、磁盘、网络、CPU，可能是代码或架构设计不合理，又或者是系统资源确实不足。</li>
<li><strong>性能优化</strong> - 性能优化根据网站分层架构，大致可分为前端性能优化、应用服务性能优化、存储服务性能优化。</li>
</ol>
<h2 id="2-前端性能优化"><a class="markdownIt-Anchor" href="#2-前端性能优化"></a> 2. 前端性能优化</h2>
<h3 id="21-浏览器访问优化"><a class="markdownIt-Anchor" href="#21-浏览器访问优化"></a> 2.1. 浏览器访问优化</h3>
<ol>
<li><strong>减少 HTTP 请求</strong> - HTTP 请求需要建立通信链路，进行数据传输，开销高昂，所以减少 HTTP 请求数可以有效提高访问性能。减少 HTTP 的主要手段是合并 Css、JavaScript、图片。</li>
<li><strong>使用浏览器缓存</strong> - 因为静态资源文件更新频率低，可以缓存浏览器中以提高性能。设置 HTTP 头中的 <code>Cache-Control</code> 和 <code>Expires</code> 属性，可设定浏览器缓存。</li>
<li><strong>启用压缩</strong> - 在服务器端压缩静态资源文件，在浏览器端解压缩，可以有效减少传输的数据量。由于文本文件压缩率可达 80% 以上，所以可以对静态资源，如 Html、Css、JavaScrip 进行压缩。</li>
<li><strong>CSS 放在页面最上面，JavaScript 放在页面最下面</strong> - 浏览器会在下载完全部的 Css 后才对整个页面进行渲染，所以最好的做法是将 Css 放在页面最上面，让浏览器尽快下载 Css；JavaScript 则相反，浏览器加载 JavaScript 后立即执行，可能会阻塞整个页面，造成页面显示缓慢，因此 JavaScript 最好放在页面最下面。</li>
<li><strong>减少 Cookie 传输</strong> - Cookie 包含在 HTTP 每次的请求和响应中，太大的 Cookie 会严重影响数据传输。</li>
</ol>
<h3 id="22-cdn"><a class="markdownIt-Anchor" href="#22-cdn"></a> 2.2. CDN</h3>
<p>CDN 一般缓存的是静态资源。</p>
<p>CDN 的本质仍然是一个缓存，而且将数据缓存在离用户最近的地方，使用户已最快速度获取数据，即所谓网络访问第一跳。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/architecture/cdn.png!zp" width="640" />
</div>
<h3 id="23-反向代理"><a class="markdownIt-Anchor" href="#23-反向代理"></a> 2.3. 反向代理</h3>
<p>传统代理服务器位于浏览器一侧，代理浏览器将 HTTP 请求发送到互联网上，而反向代理服务器位于网站机房一侧，代理网站服务器接收 HTTP 请求。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/architecture/reverse-proxy.jpg!zp" width="640" />
</div>
<p>反向代理服务器可以配置缓存功能加速 Web 请求，当用户第一次访问静态内容时，静态内容就会被缓存在反向代理服务器上。</p>
<p>反向代理还可以实现负载均衡，通过负载均衡构建的集群可以提高系统总体处理能力。</p>
<p>因为所有请求都必须先经过反向代理服务器，所以可以屏蔽一些攻击 IP，达到保护网站安全的作用。</p>
<h2 id="3-应用服务性能优化"><a class="markdownIt-Anchor" href="#3-应用服务性能优化"></a> 3. 应用服务性能优化</h2>
<h3 id="31-分布式缓存"><a class="markdownIt-Anchor" href="#31-分布式缓存"></a> 3.1. 分布式缓存</h3>
<blockquote>
<p>网站性能优化第一定律：优先考虑使用缓存优化性能。</p>
</blockquote>
<h4 id="311-缓存原理"><a class="markdownIt-Anchor" href="#311-缓存原理"></a> 3.1.1. 缓存原理</h4>
<p>缓存指将数据存储在相对较高访问速度的存储介质中，以供系统处理。一方面缓存访问速度快，可以减少数据访问的时间，另一方面如果缓存的数据是经过计算处理得到的，那么被缓存的数据无需重复计算即可直接使用，因此缓存还起到减少计算时间的作用。</p>
<p>缓存的本质是一个内存 HASH 表。</p>
<p>缓存主要用来存放那些读写比很高、很少变化的数据，如商品的类目信息，热门词的搜索列表信息、热门商品信息等。</p>
<h4 id="312-合理使用缓存"><a class="markdownIt-Anchor" href="#312-合理使用缓存"></a> 3.1.2. 合理使用缓存</h4>
<p>缓存数据的选择：</p>
<ul>
<li>不要存储频繁修改的数据</li>
<li>不要存储非热点数据</li>
<li>数据不一致与脏读：缓存有有效期，所以存在一定时间的数据不一致和脏读问题。如果不能接受，可以考虑使用数据更新立即更新缓存策略</li>
</ul>
<p>需要考虑的缓存问题：</p>
<ul>
<li><strong>缓存雪崩</strong> - 当缓存服务崩溃时，数据库会因为不能承受过大的压力而宕机。</li>
<li><strong>缓存预热</strong> - 对于一些明确的热点数据、元数据，如地名、类目信息等，可以在启动时加载到缓存进行预热。</li>
<li><strong>缓存穿透</strong> - 如果因不恰当的业务或恶意攻击持续高并发地请求某个不存在的数据，由于缓存中没有该数据，就会导致请求都落在数据库上，导致数据库最终崩溃。一个简单的策略是将不存在的数据也缓存起来（即缓存 null 值）。</li>
</ul>
<h3 id="32-异步操作"><a class="markdownIt-Anchor" href="#32-异步操作"></a> 3.2. 异步操作</h3>
<p>异步处理不仅可以减少系统服务间的耦合度，提高扩展性，事实上，它还可以提高系统的性能。异步处理可以有效减少响应等待时间，从而提高响应速度。</p>
<p>异步处理一般是通过分布式消息队列的方式。</p>
<p>异步处理可以解决以下问题：</p>
<ul>
<li>异步处理</li>
<li>应用解耦</li>
<li>流量削锋</li>
<li>日志处理</li>
<li>消息通讯</li>
</ul>
<h3 id="33-使用集群"><a class="markdownIt-Anchor" href="#33-使用集群"></a> 3.3. 使用集群</h3>
<p>在高并发场景下，使用负载均衡技术为一个应用构建一个由多台服务器组成的服务器集群，将并发访问请求分发到多台服务器上处理，避免单一服务器因负载压力过大而响应缓慢，使用户请求具有更好的响应延迟特性。</p>
<h3 id="34-代码优化"><a class="markdownIt-Anchor" href="#34-代码优化"></a> 3.4. 代码优化</h3>
<h4 id="341-多线程"><a class="markdownIt-Anchor" href="#341-多线程"></a> 3.4.1. 多线程</h4>
<p>从资源利用的角度看，使用多线程的原因主要有两个：IO 阻塞和多 CPU。</p>
<p>线程数并非越多越好，那么启动多少线程合适呢？</p>
<p>有个参考公式：</p>
<figure class="highlight fix"><table><tr><td class="code"><pre><span class="line"><span class="attr">启动线程数 </span>=<span class="string"> (任务执行时间 / (任务执行时间 - IO 等待时间)) * CPU 内核数</span></span><br></pre></td></tr></table></figure>
<p>最佳启动线程数和 CPU 内核数成正比，和 IO 阻塞时间成反比。</p>
<ul>
<li>如果任务都是 CPU 计算型任务，那么线程数最多不要超过 CPU 内核数，因为启动再多线程，CPU 也来不及调度；</li>
<li>相反，如果是任务需要等待磁盘操作，网络响应，那么多启动线程有助于任务并罚赌，提高系统吞吐量。</li>
</ul>
<h5 id="线程安全问题"><a class="markdownIt-Anchor" href="#线程安全问题"></a> 线程安全问题</h5>
<p>线程安全问题时指多个线程并发访问某个资源，导致数据混乱。</p>
<p>解决手段有：</p>
<ul>
<li><strong>将对象设计为无状态对象</strong> - 典型应用：Servlet 就是无状态对象，可以被服务器多线程并发调用处理用户请求。</li>
<li><strong>使用局部对象</strong></li>
<li><strong>并发访问资源时使用锁</strong> - 但是引入锁会产生性能开销，应尽量使用轻量级的锁。</li>
</ul>
<h4 id="342-资源复用"><a class="markdownIt-Anchor" href="#342-资源复用"></a> 3.4.2. 资源复用</h4>
<p>应该尽量减少那些开销很大的系统资源的创建和销毁，如数据库连接、网络通信连接、线程、复杂对象等。从编程角度，资源复用主要有两种模式：单例模式和对象池。</p>
<h4 id="343-数据结构"><a class="markdownIt-Anchor" href="#343-数据结构"></a> 3.4.3. 数据结构</h4>
<p>根据具体场景，选择合适的数据结构。</p>
<h4 id="344-垃圾回收"><a class="markdownIt-Anchor" href="#344-垃圾回收"></a> 3.4.4. 垃圾回收</h4>
<p>如果 Web 应用运行在 JVM 等具有垃圾回收功能的环境中，那么垃圾回收可能会对系统的性能特性产生巨大影响。立即垃圾回收机制有助于程序优化和参数调优，以及编写内存安全的代码。</p>
<h2 id="4-存储性能优化"><a class="markdownIt-Anchor" href="#4-存储性能优化"></a> 4. 存储性能优化</h2>
<h3 id="41-机械键盘和固态硬盘"><a class="markdownIt-Anchor" href="#41-机械键盘和固态硬盘"></a> 4.1. 机械键盘和固态硬盘</h3>
<p>考虑使用固态硬盘替代机械键盘，因为它的读写速度更快。</p>
<h3 id="42-b数和-lsm-树"><a class="markdownIt-Anchor" href="#42-b数和-lsm-树"></a> 4.2. B+数和 LSM 树</h3>
<p>传统关系数据库的数据库索引一般都使用两级索引的 <strong>B+ 树</strong> 结构，树的层次最多三层。因此可能需要 5 次磁盘访问才能更新一条记录（三次磁盘访问获得数据索引及行 ID，然后再进行一次数据文件读操作及一次数据文件写操作）。</p>
<p>由于磁盘访问是随机的，传统机械键盘在数据随机访问时性能较差，每次数据访问都需要多次访问磁盘影响数据访问性能。</p>
<p>许多 Nosql 数据库中的索引采用 <strong>LSM 树</strong> 作为主要数据结构。LSM 树可视为一个 N 阶合并树。数据写操作都在内存中进行。在 <strong>LSM 树上进行一次数据更新不需要磁盘访问，速度远快于 B+ 树</strong>。</p>
<h3 id="43-raid-和-hdfs"><a class="markdownIt-Anchor" href="#43-raid-和-hdfs"></a> 4.3. RAID 和 HDFS</h3>
<p>RAID 是 Redundant Array of Independent Disks 的缩写，中文简称为独立冗余磁盘阵列。</p>
<p>RAID 是一种把多块独立的硬盘（物理硬盘）按不同的方式组合起来形成一个硬盘组（逻辑硬盘），从而提供比单个硬盘更高的存储性能和提供数据备份技术。</p>
<p>HDFS(分布式文件系统) 更被大型网站所青睐。它可以配合 <code>MapReduce</code> 并发计算任务框架进行大数据处理，可以在整个集群上并发访问所有磁盘，无需 RAID 支持。</p>
<p>HDFS 对数据存储空间的管理以数据块（Block）为单位，默认为 64 MB。所以，HDFS 更适合存储较大的文件。</p>
<h2 id="5-参考资料"><a class="markdownIt-Anchor" href="#5-参考资料"></a> 5. 参考资料</h2>
<ul>
<li><a href="https://item.jd.com/11322972.html" target="_blank" rel="noopener">大型网站技术架构：核心原理与案例分析</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/design/architecture/security-architecture/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/design/architecture/security-architecture/" class="post-title-link" itemprop="url">系统安全性架构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-05 15:11:00" itemprop="dateCreated datePublished" datetime="2018-07-05T15:11:00+08:00">2018-07-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-01-19 21:47:09" itemprop="dateModified" datetime="2020-01-19T21:47:09+08:00">2020-01-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index">
                    <span itemprop="name">设计</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/design/architecture/security-architecture/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="design/architecture/security-architecture/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>15k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>14 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="系统安全性架构"><a class="markdownIt-Anchor" href="#系统安全性架构"></a> 系统安全性架构</h1>
<blockquote>
<p>关键词：XSS、CSRF、SQL 注入、DoS、消息摘要、加密算法、证书</p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#%E4%B8%80%E8%AE%A4%E8%AF%81">一、认证</a>
<ul>
<li><a href="#sso">SSO</a></li>
<li><a href="#oauth-20">Oauth 2.0</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E9%89%B4%E6%9D%83">二、鉴权</a>
<ul>
<li><a href="#rbac">RBAC</a></li>
<li><a href="#%E8%A7%92%E8%89%B2%E7%BB%A7%E6%89%BF">角色继承</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89%E5%AE%A1%E8%AE%A1">三、审计</a></li>
<li><a href="#%E5%9B%9B%E7%BD%91%E7%AB%99%E6%94%BB%E5%87%BB">四、网站攻击</a>
<ul>
<li><a href="#xss">XSS</a></li>
<li><a href="#csrf">CSRF</a></li>
<li><a href="#sql-%E6%B3%A8%E5%85%A5">SQL 注入</a></li>
<li><a href="#dos">DoS</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF">五、加密技术</a>
<ul>
<li><a href="#%E6%B6%88%E6%81%AF%E6%91%98%E8%A6%81">消息摘要</a></li>
<li><a href="#%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95">加密算法</a></li>
<li><a href="#%E8%AF%81%E4%B9%A6">证书</a></li>
</ul>
</li>
<li><a href="#%E5%85%AD%E4%BF%A1%E6%81%AF%E8%BF%87%E6%BB%A4">六、信息过滤</a>
<ul>
<li><a href="#%E6%96%87%E6%9C%AC%E5%8C%B9%E9%85%8D">文本匹配</a></li>
<li><a href="#%E9%BB%91%E5%90%8D%E5%8D%95">黑名单</a></li>
<li><a href="#%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95">分类算法</a></li>
</ul>
</li>
<li><a href="#%E4%B8%83%E9%A3%8E%E9%99%A9%E6%8E%A7%E5%88%B6">七、风险控制</a>
<ul>
<li><a href="#%E9%A3%8E%E9%99%A9%E7%A7%8D%E7%B1%BB">风险种类</a></li>
<li><a href="#%E9%A3%8E%E9%99%A9%E6%8E%A7%E5%88%B6%E6%89%8B%E6%AE%B5">风险控制手段</a></li>
<li><a href="#%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E">规则引擎</a></li>
<li><a href="#%E7%BB%9F%E8%AE%A1%E6%A8%A1%E5%9E%8B">统计模型</a></li>
</ul>
</li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="一-认证"><a class="markdownIt-Anchor" href="#一-认证"></a> 一、认证</h2>
<h3 id="sso"><a class="markdownIt-Anchor" href="#sso"></a> SSO</h3>
<p><strong>SSO(Single Sign On)，即单点登录</strong>。所谓单点登录，就是同平台的诸多应用登陆一次，下一次就免登陆的功能。</p>
<p>SSO 需要解决多个异构系统之间的问题：</p>
<ul>
<li>Session 共享问题</li>
<li>跨域问题</li>
</ul>
<h4 id="session-共享问题"><a class="markdownIt-Anchor" href="#session-共享问题"></a> Session 共享问题</h4>
<p>分布式 Session 的几种实现策略：</p>
<ul>
<li>粘性 Session - 缺点：当<strong>服务器节点宕机时，将丢失该服务器节点上的所有 Session</strong>。</li>
<li>应用服务器间的 Session 复制共享 - 缺点：<strong>占用过多内存</strong>；<strong>同步过程占用网络带宽以及服务器处理器时间</strong>。</li>
<li>基于缓存的 Session 共享 ✅ （推荐方案） - 不过需要程序自身控制 Session 读写，可以考虑基于 spring-session + redis 这种成熟的方案来处理。</li>
</ul>
<blockquote>
<p>详情请参考：<a href="../theory/distributed-session-theory.md">Session 原理</a></p>
</blockquote>
<h4 id="cookie-跨域"><a class="markdownIt-Anchor" href="#cookie-跨域"></a> Cookie 跨域</h4>
<p><strong>Cookie 不能跨域</strong>！比如：浏览器不会把 <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> 的 cookie 传给 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a>。</p>
<p>这就存在一个问题：由于域名不同，用户在系统 A 登录后，浏览器记录系统 A 的 Cookie，但是访问系统 B 的时候不会携带这个 Cookie。</p>
<p>针对 <strong>Cookie 不能跨域</strong> 的问题，有几种解决方案：</p>
<ul>
<li>服务端生成 Cookie 后，返回给客户端，客户端解析 Cookie ，提取 Token （比如 JWT），此后每次请求都携带这个 Token。</li>
<li>多个域名共享 Cookie，在返回 Cookie 给客户端的时候，在 Cookie 中设置 domain 白名单。</li>
<li>将 Token 保存在 <strong><code>SessionStroage</code></strong> 中（不依赖 Cookie 就没有跨域的问题了）。</li>
</ul>
<h4 id="cas"><a class="markdownIt-Anchor" href="#cas"></a> CAS</h4>
<p>CAS 是实现 SSO 的主流方式。</p>
<p>CAS 分为两部分，CAS Server 和 CAS Client</p>
<ul>
<li><strong><code>CAS Server</code></strong> - 负责用户的认证工作，就像是把第一次登录用户的一个标识存在这里，以便此用户在其他系统登录时验证其需不需要再次登录。</li>
<li><strong><code>CAS Client</code></strong> - 业务应用，需要接入 CAS Server。当用户访问我们的应用时，首先需要重定向到 CAS Server 端进行验证，要是原来登陆过，就免去登录，重定向到下游系统，否则进行用户名密码登陆操作。</li>
</ul>
<p>术语：</p>
<ul>
<li><strong><code>Ticket Granting Ticket (TGT)</code></strong> - 可以认为是 CAS Server 根据用户名、密码生成的一张票，存在 Server 端。</li>
<li><strong><code>Ticket Granting Cookie (TGC)</code></strong> - 其实就是一个 Cookie，存放用户身份信息，由 Server 发给 Client 端。</li>
<li><strong><code>Service Ticket (ST)</code></strong> - 由 TGT 生成的一次性票据，用于验证，只能用一次。</li>
</ul>
<p>CAS 工作流程：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200119195646.png" alt="" /></p>
<ol>
<li>用户访问 CAS Client A（业务系统），第一次访问，重定向到认证服务中心（CAS Server）。CAS Server 发现当前请求中没有 Cookie，再重定向到 CAS Server 的登录页面。重定向请求的 URL 中包含访问地址，以便认证成功后直接跳转到访问页面。</li>
<li>用户在登录页面输入用户名、密码等认证信息，认证成功后，CAS Server 生成 TGT，再用 TGT 生成一个 ST。然后返回 ST 和 TGC（Cookie）给浏览器。</li>
<li>浏览器携带 ST 再度访问之前想访问的 CAS Client A 页面。</li>
<li>CAS Client A 收到 ST 后，向 CAS Server 验证 ST 的有效性。验证通过则允许用户访问页面。</li>
<li>此时，如果登录另一个 CAS Client B，会先重定向到 CAS Server，CAS Server 可以判断这个 CAS Client B 是第一次访问，但是本地有 TGC，所以无需再次登录。用 TGC 创建一个 ST，返回给浏览器。</li>
<li>重复类似 3、4 步骤。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200119202448.png" alt="" /></p>
<p>以上了归纳总结如下：</p>
<ol>
<li>
<p><strong>访问服务</strong> - 用户访问 SSO Client 资源。</p>
</li>
<li>
<p><strong>定向认证</strong> - SSO Client 重定向用户请求到 SSO Server。</p>
</li>
<li>
<p><strong>用户认证</strong> - 用户身份认证。</p>
</li>
<li>
<p><strong>发放票据</strong> - SSO Server 会产生一个 Service Ticket (ST) 并返回给浏览器。</p>
</li>
<li>
<p><strong>验证票据</strong> - 浏览器每次访问 SSO Client 时，携带 ST，SSO Client 向 SSO Server 验证票据。只有验证通过，才允许访问。</p>
</li>
<li>
<p><strong>传输用户信息</strong> - SSO Server 验证票据通过后，传输用户认证结果信息给 SSO Client。</p>
</li>
</ol>
<h3 id="oauth-20"><a class="markdownIt-Anchor" href="#oauth-20"></a> Oauth 2.0</h3>
<h4 id="基本原理"><a class="markdownIt-Anchor" href="#基本原理"></a> 基本原理</h4>
<p>OAuth 在&quot;客户端&quot;与&quot;服务提供商&quot;之间，设置了一个授权层（authorization layer）。“客户端&quot;不能直接登录&quot;服务提供商”，只能登录授权层，以此将用户与客户端区分开来。&quot;客户端&quot;登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。</p>
<p>&quot;客户端&quot;登录授权层以后，&quot;服务提供商&quot;根据令牌的权限范围和有效期，向&quot;客户端&quot;开放用户储存的资料。</p>
<p>OAuth 2.0 的运行流程如下图，摘自 RFC 6749。</p>
<div align="center"><img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014051203.png"/></div>
（A）用户打开客户端以后，客户端要求用户给予授权。
<p>（B）用户同意给予客户端授权。</p>
<p>（C）客户端使用上一步获得的授权，向认证服务器申请令牌。</p>
<p>（D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。</p>
<p>（E）客户端使用令牌，向资源服务器申请获取资源。</p>
<p>（F）资源服务器确认令牌无误，同意向客户端开放资源。</p>
<p>不难看出来，上面六个步骤之中，B 是关键，即用户怎样才能给于客户端授权。有了这个授权以后，客户端就可以获取令牌，进而凭令牌获取资源。</p>
<h4 id="授权模式"><a class="markdownIt-Anchor" href="#授权模式"></a> 授权模式</h4>
<p>客户端必须得到用户的授权（authorization grant），才能获得令牌（access token）。OAuth 2.0 定义了四种授权方式。</p>
<ul>
<li>授权码模式（authorization code）</li>
<li>简化模式（implicit）</li>
<li>密码模式（resource owner password credentials）</li>
<li>客户端模式（client credentials）</li>
</ul>
<h4 id="授权码模式"><a class="markdownIt-Anchor" href="#授权码模式"></a> 授权码模式</h4>
<p>授权码模式（authorization code）是功能最完整、流程最严密的授权模式。它的特点就是通过客户端的后台服务器，与&quot;服务提供商&quot;的认证服务器进行互动。</p>
<div align="center"><img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014051204.png"/></div>
它的步骤如下：
<p>（A）用户访问客户端，后者将前者导向认证服务器。</p>
<p>（B）用户选择是否给予客户端授权。</p>
<p>（C）假设用户给予授权，认证服务器将用户导向客户端事先指定的&quot;重定向 URI&quot;（redirection URI），同时附上一个授权码。</p>
<p>（D）客户端收到授权码，附上早先的&quot;重定向 URI&quot;，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见。</p>
<p>（E）认证服务器核对了授权码和重定向 URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）。</p>
<p>下面是上面这些步骤所需要的参数。</p>
<p>A 步骤中，客户端申请认证的 URI，包含以下参数：</p>
<ul>
<li>response_type：表示授权类型，必选项，此处的值固定为&quot;code&quot;</li>
<li>client_id：表示客户端的 ID，必选项</li>
<li>redirect_uri：表示重定向 URI，可选项</li>
<li>scope：表示申请的权限范围，可选项</li>
<li>state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET /authorize?response_type=code&amp;client_id=s6BhdRkqt3&amp;state=xyz</span><br><span class="line">  &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br></pre></td></tr></table></figure>
<p>C 步骤中，服务器回应客户端的 URI，包含以下参数：</p>
<ul>
<li>code：表示授权码，必选项。该码的有效期应该很短，通常设为 10 分钟，客户端只能使用该码一次，否则会被授权服务器拒绝。该码与客户端 ID 和重定向 URI，是一一对应关系。</li>
<li>state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">302</span> Found</span><br><span class="line"><span class="attribute">Location</span>: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA</span><br><span class="line">    &amp;state=xyz</span><br></pre></td></tr></table></figure>
<p>D 步骤中，客户端向认证服务器申请令牌的 HTTP 请求，包含以下参数：</p>
<ul>
<li>grant_type：表示使用的授权模式，必选项，此处的值固定为&quot;authorization_code&quot;。</li>
<li>code：表示上一步获得的授权码，必选项。</li>
<li>redirect_uri：表示重定向 URI，必选项，且必须与 A 步骤中的该参数值保持一致。</li>
<li>client_id：表示客户端 ID，必选项。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/token</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br><span class="line"><span class="attribute">Authorization</span>: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=authorization_code&amp;code=SplxlOBeZQQYbYS6WxSbIA</span><br><span class="line">&amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb</span><br></pre></td></tr></table></figure>
<p>E 步骤中，认证服务器发送的 HTTP 回复，包含以下参数：</p>
<ul>
<li>access_token：表示访问令牌，必选项。</li>
<li>token_type：表示令牌类型，该值大小写不敏感，必选项，可以是 bearer 类型或 mac 类型。</li>
<li>expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</li>
<li>refresh_token：表示更新令牌，用来获取下一次的访问令牌，可选项。</li>
<li>scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json;charset=UTF-8</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-store</span><br><span class="line"><span class="attribute">Pragma</span>: no-cache</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"> "access_token":"2YotnFZFEjr1zCsicMWpAA",</span><br><span class="line"> "token_type":"example",</span><br><span class="line"> "expires_in":3600,</span><br><span class="line"> "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",</span><br><span class="line"> "example_parameter":"example_value"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面代码可以看到，相关参数使用 JSON 格式发送（Content-Type: application/json）。此外，HTTP 头信息中明确指定不得缓存。</p>
<h4 id="简化模式"><a class="markdownIt-Anchor" href="#简化模式"></a> 简化模式</h4>
<p>简化模式（implicit grant type）不通过第三方应用程序的服务器，直接在浏览器中向认证服务器申请令牌，跳过了&quot;授权码&quot;这个步骤，因此得名。所有步骤在浏览器中完成，令牌对访问者是可见的，且客户端不需要认证。</p>
<div align="center"><img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014051205.png"/></div>
它的步骤如下：
<p>（A）客户端将用户导向认证服务器。</p>
<p>（B）用户决定是否给于客户端授权。</p>
<p>（C）假设用户给予授权，认证服务器将用户导向客户端指定的&quot;重定向 URI&quot;，并在 URI 的 Hash 部分包含了访问令牌。</p>
<p>（D）浏览器向资源服务器发出请求，其中不包括上一步收到的 Hash 值。</p>
<p>（E）资源服务器返回一个网页，其中包含的代码可以获取 Hash 值中的令牌。</p>
<p>（F）浏览器执行上一步获得的脚本，提取出令牌。</p>
<p>（G）浏览器将令牌发给客户端。</p>
<p>下面是上面这些步骤所需要的参数。</p>
<p>A 步骤中，客户端发出的 HTTP 请求，包含以下参数：</p>
<ul>
<li>response_type：表示授权类型，此处的值固定为&quot;token&quot;，必选项。</li>
<li>client_id：表示客户端的 ID，必选项。</li>
<li>redirect_uri：表示重定向的 URI，可选项。</li>
<li>scope：表示权限范围，可选项。</li>
<li>state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET /authorize?response_type=token&amp;client_id=s6BhdRkqt3&amp;state=xyz</span><br><span class="line">  &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br></pre></td></tr></table></figure>
<p>C 步骤中，认证服务器回应客户端的 URI，包含以下参数：</p>
<ul>
<li>access_token：表示访问令牌，必选项。</li>
<li>token_type：表示令牌类型，该值大小写不敏感，必选项。</li>
<li>expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</li>
<li>scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。</li>
<li>state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">302</span> Found</span><br><span class="line"><span class="attribute">Location</span>: http://example.com/cb#access_token=2YotnFZFEjr1zCsicMWpAA</span><br><span class="line">         &amp;state=xyz&amp;token_type=example&amp;expires_in=3600</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，认证服务器用 HTTP 头信息的 Location 栏，指定浏览器重定向的网址。注意，在这个网址的 Hash 部分包含了令牌。</p>
<p>根据上面的 D 步骤，下一步浏览器会访问 Location 指定的网址，但是 Hash 部分不会发送。接下来的 E 步骤，服务提供商的资源服务器发送过来的代码，会提取出 Hash 中的令牌。</p>
<p>密码模式</p>
<p>密码模式（Resource Owner Password Credentials Grant）中，用户向客户端提供自己的用户名和密码。客户端使用这些信息，向&quot;服务商提供商&quot;索要授权。</p>
<p>在这种模式中，用户必须把自己的密码给客户端，但是客户端不得储存密码。这通常用在用户对客户端高度信任的情况下，比如客户端是操作系统的一部分，或者由一个著名公司出品。而认证服务器只有在其他授权模式无法执行的情况下，才能考虑使用这种模式。</p>
<div align="center"><img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014051206.png"/></div>
它的步骤如下：
<p>（A）用户向客户端提供用户名和密码。</p>
<p>（B）客户端将用户名和密码发给认证服务器，向后者请求令牌。</p>
<p>（C）认证服务器确认无误后，向客户端提供访问令牌。</p>
<p>B 步骤中，客户端发出的 HTTP 请求，包含以下参数：</p>
<ul>
<li>grant_type：表示授权类型，此处的值固定为&quot;password&quot;，必选项。</li>
<li>username：表示用户名，必选项。</li>
<li>password：表示用户的密码，必选项。</li>
<li>scope：表示权限范围，可选项。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/token</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br><span class="line"><span class="attribute">Authorization</span>: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=password&amp;username=johndoe&amp;password=A3ddj3w</span><br></pre></td></tr></table></figure>
<p>C 步骤中，认证服务器向客户端发送访问令牌，下面是一个例子。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json;charset=UTF-8</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-store</span><br><span class="line"><span class="attribute">Pragma</span>: no-cache</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"> "access_token":"2YotnFZFEjr1zCsicMWpAA",</span><br><span class="line"> "token_type":"example",</span><br><span class="line"> "expires_in":3600,</span><br><span class="line"> "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",</span><br><span class="line"> "example_parameter":"example_value"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，各个参数的含义参见《授权码模式》一节。</p>
<p>整个过程中，客户端不得保存用户的密码。</p>
<p>客户端模式</p>
<p>客户端模式（Client Credentials Grant）指客户端以自己的名义，而不是以用户的名义，向&quot;服务提供商&quot;进行认证。严格地说，客户端模式并不属于 OAuth 框架所要解决的问题。在这种模式中，用户直接向客户端注册，客户端以自己的名义要求&quot;服务提供商&quot;提供服务，其实不存在授权问题。</p>
<div align="center"><img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014051207.png"/></div>
它的步骤如下：
<p>（A）客户端向认证服务器进行身份认证，并要求一个访问令牌。</p>
<p>（B）认证服务器确认无误后，向客户端提供访问令牌。</p>
<p>A 步骤中，客户端发出的 HTTP 请求，包含以下参数：</p>
<ul>
<li>grant<em>type：表示授权类型，此处的值固定为&quot;client</em>credentials&quot;，必选项。</li>
<li>scope：表示权限范围，可选项。</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/token</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br><span class="line"><span class="attribute">Authorization</span>: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=client_credentials</span><br></pre></td></tr></table></figure>
<p>认证服务器必须以某种方式，验证客户端身份。</p>
<p>B 步骤中，认证服务器向客户端发送访问令牌，下面是一个例子。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json;charset=UTF-8</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-store</span><br><span class="line"><span class="attribute">Pragma</span>: no-cache</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"> "access_token":"2YotnFZFEjr1zCsicMWpAA",</span><br><span class="line"> "token_type":"example",</span><br><span class="line"> "expires_in":3600,</span><br><span class="line"> "example_parameter":"example_value"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，各个参数的含义参见《授权码模式》一节。</p>
<h4 id="更新令牌"><a class="markdownIt-Anchor" href="#更新令牌"></a> 更新令牌</h4>
<p>如果用户访问的时候，客户端的&quot;访问令牌&quot;已经过期，则需要使用&quot;更新令牌&quot;申请一个新的访问令牌。</p>
<p>客户端发出更新令牌的 HTTP 请求，包含以下参数：</p>
<ul>
<li>grant<em>type：表示使用的授权模式，此处的值固定为&quot;refresh</em>token&quot;，必选项。</li>
<li>refresh_token：表示早前收到的更新令牌，必选项。</li>
<li>scope：表示申请的授权范围，不可以超出上一次申请的范围，如果省略该参数，则表示与上一次一致。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/token</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br><span class="line"><span class="attribute">Authorization</span>: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=refresh_token&amp;refresh_token=tGzv3JOkF0XG5Qx2TlKWIA</span><br></pre></td></tr></table></figure>
<h2 id="二-鉴权"><a class="markdownIt-Anchor" href="#二-鉴权"></a> 二、鉴权</h2>
<h3 id="rbac"><a class="markdownIt-Anchor" href="#rbac"></a> RBAC</h3>
<p>基于角色的访问控制（RBAC: Role-Based Access Control)</p>
<p>每个用户关联一个或多个角色，每个角色关联一个或多个权限，从而可以实现了非常灵活的权限管理。角色可以根据实际业务需求灵活创建，这样就省去了每新增一个用户就要关联一遍所有权限的麻烦。简单来说 RBAC 就是：用户关联角色，角色关联权限。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200119210359.png" alt="" /></p>
<h3 id="角色继承"><a class="markdownIt-Anchor" href="#角色继承"></a> 角色继承</h3>
<p>角色继承(Hierarchical Role) 就是指角色可以继承于其他角色，在拥有其他角色权限的同时，自己还可以关联额外的权限。这种设计可以给角色分组和分层，一定程度简化了权限管理工作。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200119210528.png" alt="" /></p>
<h4 id="职责分离separation-of-duty"><a class="markdownIt-Anchor" href="#职责分离separation-of-duty"></a> 职责分离(Separation of Duty)</h4>
<p>为了避免用户拥有过多权限而产生利益冲突，例如一个篮球运动员同时拥有裁判的权限（看一眼就给你判犯规狠不狠？），另一种职责分离扩展版的 RBAC 被提出。</p>
<p>职责分离有两种模式：</p>
<p>静态职责分离(Static Separation of Duty)：用户无法同时被赋予有冲突的角色。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/594774-feb7c1074d151113.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/509/format/webp" alt="img" /></p>
<p>动态职责分离(Dynamic Separation of Duty)：用户在一次会话（Session）中不能同时激活自身所拥有的、互相有冲突的角色，只能选择其一。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/594774-059b93e4209e8fa6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/397/format/webp" alt="img" /></p>
<p>讲了这么多 RBAC，都还只是在用户和权限之间进行设计，并没有涉及到用户和对象之间的权限判断，而在实际业务系统中限制用户能够使用的对象是很常见的需求。</p>
<h2 id="三-审计"><a class="markdownIt-Anchor" href="#三-审计"></a> 三、审计</h2>
<p>TODO</p>
<h2 id="四-网站攻击"><a class="markdownIt-Anchor" href="#四-网站攻击"></a> 四、网站攻击</h2>
<p>互联网环境鱼龙混杂，网站被攻击是常见现象，所以了解一些常见的网站攻击手段十分必要。下面列举比较常见的 4 种攻击手段：</p>
<h3 id="xss"><a class="markdownIt-Anchor" href="#xss"></a> XSS</h3>
<h4 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h4>
<p><strong><code>跨站脚本（Cross-site scripting，通常简称为XSS）</code></strong> 是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了 HTML 以及用户端脚本语言。</p>
<p>XSS 攻击示例：</p>
<p>假如有下面一个 textbox</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"address1"</span> <span class="attr">value</span>=<span class="string">"value1from"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>value1from 是来自用户的输入，如果用户不是输入 value1from,而是输入 <code>&quot;/&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&lt;!-</code> 那么就会变成：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"address1"</span> <span class="attr">value</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">	alert(<span class="built_in">document</span>.cookie)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">!-</span> "&gt;</span></span><br></pre></td></tr></table></figure>
<p>嵌入的 JavaScript 代码将会被执行。攻击的威力，取决于用户输入了什么样的脚本。</p>
<h4 id="攻击手段和目的"><a class="markdownIt-Anchor" href="#攻击手段和目的"></a> 攻击手段和目的</h4>
<p>常用的 XSS 攻击手段和目的有：</p>
<ul>
<li>盗用 cookie，获取敏感信息。</li>
<li>利用植入 Flash，通过 <code>crossdomain</code> 权限设置进一步获取更高权限；或者利用 Java 等得到类似的操作。</li>
<li>利用 <code>iframe</code>、<code>frame</code>、<code>XMLHttpRequest</code> 或上述 Flash 等方式，以（被攻击）用户的身份执行一些管理动作，或执行一些一般的如发微博、加好友、发私信等操作。</li>
<li>利用可被攻击的域受到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动。</li>
<li>在访问量极大的一些页面上的 XSS 可以攻击一些小型网站，实现 DDoS 攻击的效果。</li>
</ul>
<h4 id="应对手段"><a class="markdownIt-Anchor" href="#应对手段"></a> 应对手段</h4>
<ul>
<li><strong>过滤特殊字符</strong> - 将用户所提供的内容进行过滤，从而避免 HTML 和 Jascript 代码的运行。如 <code>&gt;</code> 转义为 <code>&amp;gt</code>、<code>&lt;</code> 转义为 <code>&amp;lt</code> 等，就可以防止大部分攻击。为了避免对不必要的内容错误转移，如 <code>3&lt;5</code> 中的 <code>&lt;</code> 需要进行文本匹配后再转移，如：<code>&lt;img src=</code> 这样的上下文中的 <code>&lt;</code> 才转义。</li>
<li><strong>设置 Cookie 为 HttpOnly</strong> - 设置了 HttpOnly 的 Cookie 可以防止 JavaScript 脚本调用，就无法通过 document.cookie 获取用户 Cookie 信息。</li>
</ul>
<blockquote>
<p>👉 参考阅读：</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%B6%B2%E7%AB%99%E6%8C%87%E4%BB%A4%E7%A2%BC" target="_blank" rel="noopener">Wiki 词条 - 跨站脚本</a></li>
<li><a href="https://www.cnblogs.com/TankXiao/archive/2012/03/21/2337194.html" target="_blank" rel="noopener">Web 安全测试之 XSS</a></li>
</ul>
</blockquote>
<h3 id="csrf"><a class="markdownIt-Anchor" href="#csrf"></a> CSRF</h3>
<h4 id="概念-2"><a class="markdownIt-Anchor" href="#概念-2"></a> 概念</h4>
<p><strong><code>跨站请求伪造（Cross-site request forgery，CSRF）</code></strong>，也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF。它是一种挟持用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。和跨站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。</p>
<h4 id="攻击手段和目的-2"><a class="markdownIt-Anchor" href="#攻击手段和目的-2"></a> 攻击手段和目的</h4>
<p>可以如此理解 CSRF：攻击者盗用了你的身份，以你的名义发送恶意请求。</p>
<p>CSRF 能做的事太多：</p>
<ul>
<li>以你名义发送邮件，发消息</li>
<li>用你的账号购买商品</li>
<li>用你的名义完成虚拟货币转账</li>
<li>泄露个人隐私</li>
<li>…</li>
</ul>
<h4 id="应对手段-2"><a class="markdownIt-Anchor" href="#应对手段-2"></a> 应对手段</h4>
<ul>
<li><strong>表单 Token</strong> - CSRF 是一个伪造用户请求的操作，所以需要构造用户请求的所有参数才可以。表单 Token 通过在请求参数中添加随机数的办法来阻止攻击者获得所有请求参数。</li>
<li><strong>验证码</strong> - 请求提交时，需要用户输入验证码，以避免用户在不知情的情况下被攻击者伪造请求。</li>
<li><strong>Referer check</strong> - HTTP 请求头的 Referer 域中记录着请求资源，可通过检查请求来源，验证其是否合法。</li>
</ul>
<blockquote>
<p>👉 参考阅读：</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0" target="_blank" rel="noopener">Wiki 词条 - 跨站请求伪造</a></li>
<li><a href="http://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html" target="_blank" rel="noopener">浅谈 CSRF 攻击方式</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/22521378" target="_blank" rel="noopener">「每日一题」CSRF 是什么？</a><a href="https://zhuanlan.zhihu.com/p/22521378" target="_blank" rel="noopener">「每日一题」CSRF 是什么？</a></li>
<li><a href="https://www.jianshu.com/p/855395f9603b" target="_blank" rel="noopener">WEB 安全之-CSRF（跨站请求伪造）</a></li>
</ul>
</blockquote>
<h3 id="sql-注入"><a class="markdownIt-Anchor" href="#sql-注入"></a> SQL 注入</h3>
<h4 id="概念-3"><a class="markdownIt-Anchor" href="#概念-3"></a> 概念</h4>
<p><strong><code>SQL 注入攻击（SQL injection）</code></strong>，是发生于应用程序之数据层的安全漏洞。简而言之，是在输入的字符串之中注入 SQL 指令，在设计不良的程序当中忽略了检查，那么这些注入进去的指令就会被数据库服务器误认为是正常的 SQL 指令而运行，因此遭到破坏或是入侵。</p>
<p>攻击示例：</p>
<p>考虑以下简单的登录表单：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/login"</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span>Username: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span>Password: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"登陆"</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们的处理里面的 SQL 可能是这样的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">username:=r.Form.Get("username")</span><br><span class="line">password:=r.Form.Get("password")</span><br><span class="line">sql:="<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> username=<span class="string">'"+username+"'</span> <span class="keyword">AND</span> <span class="keyword">password</span>=<span class="string">'"+password+"'</span><span class="string">"</span></span><br></pre></td></tr></table></figure>
<p>如果用户的输入的用户名如下，密码任意</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">myuser' or 'foo' = 'foo' <span class="comment">--</span></span><br></pre></td></tr></table></figure>
<p>那么我们的 SQL 变成了如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> username=<span class="string">'myuser'</span> <span class="keyword">or</span> <span class="string">'foo'</span> = <span class="string">'foo'</span> <span class="comment">--'' AND password='xxx'</span></span><br></pre></td></tr></table></figure>
<p>在 SQL 里面 <code>--</code> 是注释标记，所以查询语句会在此中断。这就让攻击者在不知道任何合法用户名和密码的情况下成功登录了。</p>
<p>对于 MSSQL 还有更加危险的一种 SQL 注入，就是控制系统，下面这个可怕的例子将演示如何在某些版本的 MSSQL 数据库上执行系统命令。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sql:="<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">LIKE</span> <span class="string">'%"+prod+"%'</span><span class="string">"</span></span><br><span class="line"><span class="string">Db.Exec(sql)</span></span><br></pre></td></tr></table></figure>
<p>如果攻击提交 <code>a%' exec master..xp_cmdshell 'net user test testpass /ADD' --</code> 作为变量 prod 的值，那么 sql 将会变成</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sql:="<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">LIKE</span> <span class="string">'%a%'</span> exec master..xp_cmdshell <span class="string">'net user test testpass /ADD'</span><span class="comment">--%'"</span></span><br></pre></td></tr></table></figure>
<p>MSSQL 服务器会执行这条 SQL 语句，包括它后面那个用于向系统添加新用户的命令。如果这个程序是以 sa 运行而 MSSQLSERVER 服务又有足够的权限的话，攻击者就可以获得一个系统帐号来访问主机了。</p>
<p>虽然以上的例子是针对某一特定的数据库系统的，但是这并不代表不能对其它数据库系统实施类似的攻击。针对这种安全漏洞，只要使用不同方法，各种数据库都有可能遭殃。</p>
<h4 id="攻击手段和目的-3"><a class="markdownIt-Anchor" href="#攻击手段和目的-3"></a> 攻击手段和目的</h4>
<ul>
<li>数据表中的数据外泄，例如个人机密数据，账户数据，密码等。</li>
<li>数据结构被黑客探知，得以做进一步攻击（例如 <code>SELECT * FROM sys.tables</code>）。</li>
<li>数据库服务器被攻击，系统管理员账户被窜改（例如 <code>ALTER LOGIN sa WITH PASSWORD='xxxxxx'</code>）。</li>
<li>获取系统较高权限后，有可能得以在网页加入恶意链接、恶意代码以及 XSS 等。</li>
<li>经由数据库服务器提供的操作系统支持，让黑客得以修改或控制操作系统（例如 xp_cmdshell &quot;net stop iisadmin&quot;可停止服务器的 IIS 服务）。</li>
<li>破坏硬盘数据，瘫痪全系统（例如 xp_cmdshell “FORMAT C:”）。</li>
</ul>
<h4 id="应对手段-3"><a class="markdownIt-Anchor" href="#应对手段-3"></a> 应对手段</h4>
<ul>
<li><strong>使用参数化查询</strong> - 建议使用数据库提供的参数化查询接口，参数化的语句使用参数而不是将用户输入变量嵌入到 SQL 语句中，即不要直接拼接 SQL 语句。例如使用 database/sql 里面的查询函数 <code>Prepare</code> 和 <code>Query</code> ，或者 <code>Exec(query string, args ...interface{})</code>。</li>
<li><strong>单引号转换</strong> - 在组合 SQL 字符串时，先针对所传入的参数进行字符替换（将单引号字符替换为连续 2 个单引号字符）。</li>
</ul>
<blockquote>
<p>👉 参考阅读：</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/SQL%E8%B3%87%E6%96%99%E9%9A%B1%E7%A2%BC%E6%94%BB%E6%93%8A" target="_blank" rel="noopener">Wiki 词条 - SQL 注入攻击</a></li>
<li><a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/09.4.md" target="_blank" rel="noopener">避免 SQL 注入</a></li>
<li><a href="http://blog.jobbole.com/83092/" target="_blank" rel="noopener">实例讲解 SQL 注入攻击</a></li>
</ul>
</blockquote>
<h3 id="dos"><a class="markdownIt-Anchor" href="#dos"></a> DoS</h3>
<p><strong><code>拒绝服务攻击（denial-of-service attack, DoS）亦称洪水攻击</code></strong>，是一种网络攻击手法，其目的在于使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。</p>
<p>当黑客使用网络上两个或以上被攻陷的电脑作为“僵尸”向特定的目标发动“拒绝服务”式攻击时，称为分布式拒绝服务攻击（distributed denial-of-service attack，缩写：DDoS attack、DDoS）。</p>
<h4 id="攻击方式"><a class="markdownIt-Anchor" href="#攻击方式"></a> 攻击方式</h4>
<ul>
<li>带宽消耗型攻击</li>
<li>资源消耗型攻击</li>
</ul>
<h4 id="应对手段-4"><a class="markdownIt-Anchor" href="#应对手段-4"></a> 应对手段</h4>
<ul>
<li><strong>防火墙</strong> - 允许或拒绝特定通讯协议，端口或 IP 地址。当攻击从少数不正常的 IP 地址发出时，可以简单的使用拒绝规则阻止一切从攻击源 IP 发出的通信。</li>
<li><strong>路由器、交换机</strong> - 具有速度限制和访问控制能力。</li>
<li><strong>流量清洗</strong> - 通过采用抗 DDoS 软件处理，将正常流量和恶意流量区分开。</li>
</ul>
<blockquote>
<p>👉 参考阅读：</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E9%98%BB%E6%96%B7%E6%9C%8D%E5%8B%99%E6%94%BB%E6%93%8A" target="_blank" rel="noopener">拒绝服务攻击</a></li>
</ul>
</blockquote>
<h2 id="五-加密技术"><a class="markdownIt-Anchor" href="#五-加密技术"></a> 五、加密技术</h2>
<p>对于网站来说，用户信息、账户等等敏感数据一旦泄漏，后果严重，所以为了保护数据，应对这些信息进行加密处理。</p>
<p>信息加密技术一般分为：</p>
<ul>
<li>消息摘要</li>
<li>加密算法
<ul>
<li>对称加密</li>
<li>非对称加密</li>
</ul>
</li>
<li>证书</li>
</ul>
<h3 id="消息摘要"><a class="markdownIt-Anchor" href="#消息摘要"></a> 消息摘要</h3>
<p>常用数字签名算法：MD5、SHA 等。</p>
<p>应用场景：将用户密码以消息摘要形式保存到数据库中。</p>
<blockquote>
<p>👉 参考阅读：</p>
<ul>
<li><a href="https://github.com/dunwu/javacore/blob/master/docs/advanced/encode/java-message-digest.md" target="_blank" rel="noopener">消息摘要</a></li>
</ul>
</blockquote>
<h3 id="加密算法"><a class="markdownIt-Anchor" href="#加密算法"></a> 加密算法</h3>
<h4 id="对称加密"><a class="markdownIt-Anchor" href="#对称加密"></a> 对称加密</h4>
<p>对称加密指加密和解密所使用的密钥是同一个密钥。</p>
<p>常用对称加密算法：DES、AES 等。</p>
<p>应用场景：Cookie 加密、通信机密等。</p>
<h4 id="非对称加密"><a class="markdownIt-Anchor" href="#非对称加密"></a> 非对称加密</h4>
<p>非对称加密指加密和解密所使用的不是同一个密钥，而是一个公私钥对。用公钥加密的信息必须用私钥才能解开；反之，用私钥加密的信息只有用公钥才能解开。</p>
<p>常用非对称加密算法：RSA 等。</p>
<p>应用场景：HTTPS 传输中浏览器使用的数字证书实质上是经过权威机构认证的非对称加密公钥。</p>
<blockquote>
<p>👉 参考阅读：</p>
<ul>
<li><a href="https://github.com/dunwu/javacore/blob/master/docs/advanced/encode/java-encryption.md" target="_blank" rel="noopener">加密</a></li>
</ul>
</blockquote>
<h4 id="密钥安全管理"><a class="markdownIt-Anchor" href="#密钥安全管理"></a> 密钥安全管理</h4>
<p>保证密钥安全的方法：</p>
<ol>
<li>把密钥和算法放在一个独立的服务器上，对外提供加密和解密服务，应用系统通过调用这个服务，实现数据的加解密。</li>
<li>把加解密算法放在应用系统中，密钥则放在独立服务器中，为了提高密钥的安全性，实际存储时，密钥被切分成数片，加密后分别保存在不同存储介质中。</li>
</ol>
<h3 id="证书"><a class="markdownIt-Anchor" href="#证书"></a> 证书</h3>
<p><strong>证书可以称为信息安全加密的终极手段</strong>。公开密钥认证（英语：Public key certificate），又称公开密钥证书、公钥证书、数字证书（digital certificate）、数字认证、身份证书（identity certificate）、电子证书或安全证书，是用于公开密钥基础建设的电子文件，用来证明公开密钥拥有者的身份。此文件包含了公钥信息、拥有者身份信息（主体）、以及数字证书认证机构（发行者）对这份文件的数字签名，以保证这个文件的整体内容正确无误。</p>
<p>透过信任权威数字证书认证机构的根证书、及其使用公开密钥加密作数字签名核发的公开密钥认证，形成信任链架构，已在 TLS 实现并在万维网的 HTTP 以 HTTPS、在电子邮件的 SMTP 以 STARTTLS 引入并广泛应用。</p>
<p>众所周知，常见的应用层协议 HTTP、FTP、Telnet 本身不保证信息安全。但是加入了 SSL/TLS 加密数据包机制的 HTTPS、FTPS、Telnets 是信息安全的。传输层安全性协议（Transport Layer Security, TLS），及其前身安全套接层（Secure Sockets Layer, SSL）是一种安全协议，目的是为互联网通信，提供安全及数据完整性保障。</p>
<h4 id="证书原理"><a class="markdownIt-Anchor" href="#证书原理"></a> 证书原理</h4>
<p>SSL/TLS 协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</p>
<p>这里有两个问题：</p>
<p>（1）<strong>如何保证公钥不被篡改？</strong></p>
<p>解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。</p>
<p>（2）<strong>公钥加密计算量太大，如何减少耗用的时间？</strong></p>
<p>解决方法：每一次对话（session），客户端和服务器端都生成一个&quot;对话密钥&quot;（session key），用它来加密信息。由于&quot;对话密钥&quot;是对称加密，所以运算速度非常快，而服务器公钥只用于加密&quot;对话密钥&quot;本身，这样就减少了加密运算的消耗时间。</p>
<p>SSL/TLS 协议的基本过程是这样的：</p>
<ol>
<li>客户端向服务器端索要并验证公钥。</li>
<li>双方协商生成&quot;对话密钥&quot;。</li>
<li>双方采用&quot;对话密钥&quot;进行加密通信。</li>
</ol>
<blockquote>
<p>👉 参考阅读：</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E6%80%A7%E5%8D%94%E5%AE%9A" target="_blank" rel="noopener">传输层安全性协议</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%85%AC%E9%96%8B%E9%87%91%E9%91%B0%E8%AA%8D%E8%AD%89" target="_blank" rel="noopener">公开密钥认证</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">SSL/TLS 协议运行机制的概述</a></li>
</ul>
</blockquote>
<h2 id="六-信息过滤"><a class="markdownIt-Anchor" href="#六-信息过滤"></a> 六、信息过滤</h2>
<p>在网络中，广告和垃圾信息屡见不鲜，泛滥成灾。</p>
<p>常见的信息过滤与反垃圾手段有：</p>
<h3 id="文本匹配"><a class="markdownIt-Anchor" href="#文本匹配"></a> 文本匹配</h3>
<p>解决敏感词过滤。系统维护一份敏感词清单，如果信息中含有敏感词，则自动进行过滤或拒绝信息。</p>
<h3 id="黑名单"><a class="markdownIt-Anchor" href="#黑名单"></a> 黑名单</h3>
<p>黑名单就是将一些已经被识别出有违规行为的 IP、域名、邮箱等加入黑名单，拒绝其请求。</p>
<p>黑名单可以通过 Hash 表来实现，方法简单，复杂度小，适于一般应用场景。</p>
<p>但如果黑名单列表非常大时，Hash 表要占用很大的内存空间，这时就不再使用了。这种情况下，可以使用布隆过滤器来实现，即通过一个二进制列表和一组随机数映射函数来实现。</p>
<h3 id="分类算法"><a class="markdownIt-Anchor" href="#分类算法"></a> 分类算法</h3>
<p>对于海量信息，难以通过人工去审核。对广告贴。</p>
<p>垃圾邮件等内容的识别比较好的自动化方法就是采用分类算法。</p>
<p>简单来说，即将批量已分类的样本输入分类算法进行训练，得到一个分类模型，然后利用分类算法结合分类模型去对信息进行识别。想了解具体做法，需要去理解机器学习相关知识。</p>
<h2 id="七-风险控制"><a class="markdownIt-Anchor" href="#七-风险控制"></a> 七、风险控制</h2>
<p>网络给商务、金融领域带来极大便利的同时，也将风险带给了对网络安全一无所知的人们。由于交易双方信息的不对等，使得交易存在着风险，而当交易发生在网络上时，风险就更加难以控制了。</p>
<h3 id="风险种类"><a class="markdownIt-Anchor" href="#风险种类"></a> 风险种类</h3>
<ul>
<li>账户风险 - 盗用账户、恶意注册账户等</li>
<li>买家风险 - 虚假询盘、恶意拒收、恶意下单、黄牛党抢购热门商品等</li>
<li>卖家风险 - 虚假发货、出售违禁品、侵权等</li>
<li>交易风险 - 信用卡盗刷、交易欺诈、洗钱、套现、电信诈骗等</li>
</ul>
<h3 id="风险控制手段"><a class="markdownIt-Anchor" href="#风险控制手段"></a> 风险控制手段</h3>
<p>大型电商网站系统或金融系统都配备专业的风控团队进行风险控制。风险控制手段既包括人工审核也包括自动审核。</p>
<p>自动风控的技术手段主要有规则引擎和统计模型。</p>
<h3 id="规则引擎"><a class="markdownIt-Anchor" href="#规则引擎"></a> 规则引擎</h3>
<p>在交易中，买家、卖家的某些指标满足一定条件时，就会被认为存在风险。如：交易金额超过某个数值；用户来自黑名单；用户和上次登录的地址距离差距很大；用户在一定时间内频繁交易等等。</p>
<p>如果以上这些条件都通过 if … else … 式样的代码去实现，代码维护、扩展会非常不便。因此，就有了规则引擎来处理这类问题。规则引擎是一种将业务规则和规则处理逻辑相分离的技术，业务规则由运营人员通过管理界面去编辑，实现无需修改代码，即可实时的使用新规则。</p>
<h3 id="统计模型"><a class="markdownIt-Anchor" href="#统计模型"></a> 统计模型</h3>
<p>规则引擎虽然技术简单，但是随着规则不断增加，规模越来越大。可能会出现规则冲突，难以维护的情况，并且规则越多，性能也越差。</p>
<p>为了解决这种问题，就有了统计模型。统计模型会使用分类算法或更复杂的机器学习算法进行智能统计。根据历史交易中的信息训练分类，然后将经过采集加工后的交易信息输入分类算法，得到交易风险值，然后基于此，做出预测。</p>
<p>经过充分训练后的统计模型，准确率不低于规则引擎。但是，需要有领域专家、行业专家介入，建立合理的训练模型，并不断优化。</p>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><a href="https://item.jd.com/11322972.html" target="_blank" rel="noopener">《大型网站技术架构：核心原理与案例分析》</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%B6%B2%E7%AB%99%E6%8C%87%E4%BB%A4%E7%A2%BC" target="_blank" rel="noopener">Wiki 词条 - 跨站脚本</a></li>
<li><a href="https://www.cnblogs.com/TankXiao/archive/2012/03/21/2337194.html" target="_blank" rel="noopener">Web 安全测试之 XSS</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0" target="_blank" rel="noopener">Wiki 词条 - 跨站请求伪造</a></li>
<li><a href="http://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html" target="_blank" rel="noopener">浅谈 CSRF 攻击方式</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/22521378" target="_blank" rel="noopener">「每日一题」CSRF 是什么？</a><a href="https://zhuanlan.zhihu.com/p/22521378" target="_blank" rel="noopener">「每日一题」CSRF 是什么？</a></li>
<li><a href="https://www.jianshu.com/p/855395f9603b" target="_blank" rel="noopener">WEB 安全之-CSRF（跨站请求伪造）</a></li>
<li><a href="https://zh.wikipedia.org/wiki/SQL%E8%B3%87%E6%96%99%E9%9A%B1%E7%A2%BC%E6%94%BB%E6%93%8A" target="_blank" rel="noopener">Wiki 词条 - SQL 注入攻击</a></li>
<li><a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/09.4.md" target="_blank" rel="noopener">避免 SQL 注入</a></li>
<li><a href="http://blog.jobbole.com/83092/" target="_blank" rel="noopener">实例讲解 SQL 注入攻击</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E9%98%BB%E6%96%B7%E6%9C%8D%E5%8B%99%E6%94%BB%E6%93%8A" target="_blank" rel="noopener">拒绝服务攻击</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E6%80%A7%E5%8D%94%E5%AE%9A" target="_blank" rel="noopener">传输层安全性协议</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%85%AC%E9%96%8B%E9%87%91%E9%91%B0%E8%AA%8D%E8%AD%89" target="_blank" rel="noopener">公开密钥认证</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">SSL/TLS 协议运行机制的概述</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html</a></li>
<li><a href="http://www.coin163.com/java/cas/cas.html" target="_blank" rel="noopener">CAS 实现 SSO 单点登录原理</a></li>
<li><a href="https://www.jianshu.com/p/ce0944b4a903" target="_blank" rel="noopener">权限系统设计模型分析（DAC，MAC，RBAC，ABAC）</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/page/5/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/blog/page/7/">7</a><a class="extend next" rel="next" href="/blog/page/7/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="Zhang Peng"
    src="/blog/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Zhang Peng</p>
  <div class="site-description" itemprop="description">Dunwu's Blog</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">69</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">42</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/dunwu" title="GitHub &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;dunwu" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/blog/mailto:forbreak@163.com" title="E-Mail &amp;rarr; mailto:forbreak@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/blog/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-paper-plane"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhang Peng</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">350k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">5:18</span>
</div>

        












        
      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest.min.js"></script>
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>
<script src="/blog/js/utils.js"></script><script src="/blog/js/motion.js"></script>
<script src="/blog/js/schemes/pisces.js"></script>
<script src="/blog/js/next-boot.js"></script><script src="/blog/js/bookmark.js"></script>



  




  <script src="/blog/js/local-search.js"></script>













  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://blog-ajay4qmfci.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>

</body>
</html>

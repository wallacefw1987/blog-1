<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/themes/blue/pace-theme-minimal.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":true},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":true,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="Dunwu&amp;apos;s Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Dunwu">
<meta property="og:url" content="https:&#x2F;&#x2F;dunwu.github.io&#x2F;blog&#x2F;page&#x2F;2&#x2F;index.html">
<meta property="og:site_name" content="Dunwu">
<meta property="og:description" content="Dunwu&amp;apos;s Blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://dunwu.github.io/blog/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Dunwu</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/blog/atom.xml" title="Dunwu" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Dunwu</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">大道至简，知易行难</h1>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/blog/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">47</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">11</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">74</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/dunwu" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/distributed/distributed-storage-theory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/distributed/distributed-storage-theory/" class="post-title-link" itemprop="url">分布式存储基本原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-21 11:30:00" itemprop="dateCreated datePublished" datetime="2019-08-21T11:30:00+08:00">2019-08-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-02 18:07:05" itemprop="dateModified" datetime="2020-02-02T18:07:05+08:00">2020-02-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/distributed/distributed-storage-theory/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="distributed/distributed-storage-theory/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="分布式存储基本原理"><a class="markdownIt-Anchor" href="#分布式存储基本原理"></a> 分布式存储基本原理</h1>
<blockquote>
<p>📦 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p>
</blockquote>
<h2 id="1-分区规则"><a class="markdownIt-Anchor" href="#1-分区规则"></a> 1. 分区规则</h2>
<p><strong>分布式数据库</strong> 首先要解决把 <strong>整个数据集</strong> 按照 <strong>分区规则</strong> 映射到 <strong>多个节点</strong> 的问题，即把 <strong>数据集</strong> 划分到 <strong>多个节点</strong> 上，每个节点负责 <strong>整体数据</strong> 的一个 <strong>子集</strong>。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/partition-rule.png!zp" />
</div>
<p>数据分布通常有 <strong>哈希分区</strong> 和 <strong>顺序分区</strong> 两种方式，对比如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">分区方式</th>
<th style="text-align:left">特点</th>
<th style="text-align:left">相关产品</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">哈希分区</td>
<td style="text-align:left">离散程度好，数据分布与业务无关，无法顺序访问</td>
<td style="text-align:left">Redis Cluster，Cassandra，Dynamo</td>
</tr>
<tr>
<td style="text-align:left">顺序分区</td>
<td style="text-align:left">离散程度易倾斜，数据分布与业务相关，可以顺序访问</td>
<td style="text-align:left">BigTable，HBase，Hypertable</td>
</tr>
</tbody>
</table>
<p>由于 <code>Redis Cluster</code> 采用 <strong>哈希分区规则</strong>，这里重点讨论 <strong>哈希分区</strong>。常见的 <strong>哈希分区</strong> 规则有几种，下面分别介绍：</p>
<h3 id="11-节点取余分区"><a class="markdownIt-Anchor" href="#11-节点取余分区"></a> 1.1. 节点取余分区</h3>
<p>使用特定的数据，如 <code>Redis</code> 的 <strong>键</strong> 或 <strong>用户</strong> <code>ID</code>，再根据 <strong>节点数量</strong> <code>N</code> 使用公式：<code>hash（key）% N</code> 计算出 <strong>哈希值</strong>，用来决定数据 <strong>映射</strong> 到哪一个节点上。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/partition-hash-mod.png!zp" />
</div>
<ul>
<li><strong>优点</strong></li>
</ul>
<p>这种方式的突出优点是 <strong>简单性</strong>，常用于 <strong>数据库</strong> 的 <strong>分库分表规则</strong>。一般采用 <strong>预分区</strong> 的方式，提前根据 <strong>数据量</strong> 规划好 <strong>分区数</strong>，比如划分为 <code>512</code> 或 <code>1024</code> 张表，保证可支撑未来一段时间的 <strong>数据容量</strong>，再根据 <strong>负载情况</strong> 将 <strong>表</strong> 迁移到其他 <strong>数据库</strong> 中。扩容时通常采用 <strong>翻倍扩容</strong>，避免 <strong>数据映射</strong> 全部被 <strong>打乱</strong>，导致 <strong>全量迁移</strong> 的情况。</p>
<ul>
<li><strong>缺点</strong></li>
</ul>
<p>当 <strong>节点数量</strong> 变化时，如 <strong>扩容</strong> 或 <strong>收缩</strong> 节点，数据节点 <strong>映射关系</strong> 需要重新计算，会导致数据的 <strong>重新迁移</strong>。</p>
<h3 id="12-一致性哈希分区"><a class="markdownIt-Anchor" href="#12-一致性哈希分区"></a> 1.2. 一致性哈希分区</h3>
<p><strong>一致性哈希</strong> 可以很好的解决 <strong>稳定性问题</strong>，可以将所有的 <strong>存储节点</strong> 排列在 <strong>首尾相接</strong> 的 <code>Hash</code> 环上，每个 <code>key</code> 在计算 <code>Hash</code> 后会 <strong>顺时针</strong> 找到 <strong>临接</strong> 的 <strong>存储节点</strong> 存放。而当有节点 <strong>加入</strong> 或 <strong>退出</strong> 时，仅影响该节点在 <code>Hash</code> 环上 <strong>顺时针相邻</strong> 的 <strong>后续节点</strong>。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/partition-consistent-hash.png!zp" />
</div>
<ul>
<li><strong>优点</strong></li>
</ul>
<p><strong>加入</strong> 和 <strong>删除</strong> 节点只影响 <strong>哈希环</strong> 中 <strong>顺时针方向</strong> 的 <strong>相邻的节点</strong>，对其他节点无影响。</p>
<ul>
<li><strong>缺点</strong></li>
</ul>
<p><strong>加减节点</strong> 会造成 <strong>哈希环</strong> 中部分数据 <strong>无法命中</strong>。当使用 <strong>少量节点</strong> 时，<strong>节点变化</strong> 将大范围影响 <strong>哈希环</strong> 中 <strong>数据映射</strong>，不适合 <strong>少量数据节点</strong> 的分布式方案。<strong>普通</strong> 的 <strong>一致性哈希分区</strong> 在增减节点时需要 <strong>增加一倍</strong> 或 <strong>减去一半</strong> 节点才能保证 <strong>数据</strong> 和 <strong>负载的均衡</strong>。</p>
<blockquote>
<p><strong>注意</strong>：因为 <strong>一致性哈希分区</strong> 的这些缺点，一些分布式系统采用 <strong>虚拟槽</strong> 对 <strong>一致性哈希</strong> 进行改进，比如 <code>Dynamo</code> 系统。</p>
</blockquote>
<h3 id="13-虚拟槽分区"><a class="markdownIt-Anchor" href="#13-虚拟槽分区"></a> 1.3. 虚拟槽分区</h3>
<p><strong>虚拟槽分区</strong> 巧妙地使用了 <strong>哈希空间</strong>，使用 <strong>分散度良好</strong> 的 <strong>哈希函数</strong> 把所有数据 <strong>映射</strong> 到一个 <strong>固定范围</strong> 的 <strong>整数集合</strong> 中，整数定义为 <strong>槽</strong>（<code>slot</code>）。这个范围一般 <strong>远远大于</strong> 节点数，比如 <code>Redis Cluster</code> 槽范围是 <code>0 ~ 16383</code>。<strong>槽</strong> 是集群内 <strong>数据管理</strong> 和 <strong>迁移</strong> 的 <strong>基本单位</strong>。采用 <strong>大范围槽</strong> 的主要目的是为了方便 <strong>数据拆分</strong> 和 <strong>集群扩展</strong>。每个节点会负责 <strong>一定数量的槽</strong>，如图所示：</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/partition-hash-slot.png!zp" />
</div>
当前集群有 `3` 个节点，每个节点平均大约负责 `5460` 个 **槽**。由于采用 **高质量** 的 **哈希算法**，每个槽所映射的数据通常比较 **均匀**，将数据平均划分到 `3` 个节点进行 **数据分区**。`Redis Cluster` 就是采用 **虚拟槽分区**。
<p>集群中的每个节点负责一部分哈希槽，比如集群中有３个节点，则：</p>
<ul>
<li>节点Ａ存储的哈希槽范围是：0 – 5460</li>
<li>节点Ｂ存储的哈希槽范围是：5461 – 10922</li>
<li>节点Ｃ存储的哈希槽范围是：10923 – 16383</li>
</ul>
<p>这种结构很容易 <strong>添加</strong> 或者 <strong>删除</strong> 节点。如果 <strong>增加</strong> 一个节点 <code>4</code>，就需要从节点 <code>1 ~ 3</code> 获得部分 <strong>槽</strong> 分配到节点 <code>4</code> 上。如果想 <strong>移除</strong> 节点 <code>1</code>，需要将节点 <code>1</code> 中的 <strong>槽</strong> 移到节点 <code>2 ~ 3</code> 上，然后将 <strong>没有任何槽</strong> 的节点 <code>1</code> 从集群中 <strong>移除</strong> 即可。</p>
<blockquote>
<p>由于从一个节点将 <strong>哈希槽</strong> 移动到另一个节点并不会 <strong>停止服务</strong>，所以无论 <strong>添加删除</strong> 或者 <strong>改变</strong> 某个节点的 <strong>哈希槽的数量</strong> 都不会造成 <strong>集群不可用</strong> 的状态.</p>
</blockquote>
<h2 id="2-参考资料"><a class="markdownIt-Anchor" href="#2-参考资料"></a> 2. 参考资料</h2>
<ul>
<li><a href="https://juejin.im/post/5b8fc5536fb9a05d2d01fb11" target="_blank" rel="noopener">深入剖析 Redis 系列(三) - Redis 集群模式搭建与原理详解</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/distributed/distributed-id-theory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/distributed/distributed-id-theory/" class="post-title-link" itemprop="url">分布式 ID 基本原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-24 11:55:00" itemprop="dateCreated datePublished" datetime="2019-07-24T11:55:00+08:00">2019-07-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-02 18:07:05" itemprop="dateModified" datetime="2020-02-02T18:07:05+08:00">2020-02-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/distributed/distributed-id-theory/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="distributed/distributed-id-theory/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="分布式-id-基本原理"><a class="markdownIt-Anchor" href="#分布式-id-基本原理"></a> 分布式 ID 基本原理</h1>
<blockquote>
<p>📦 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p>
<p>传统数据库软件开发中，主键自动生成技术是基本需求。而各个数据库对于该需求也提供了相应的支持，比如 MySQL 的自增键，Oracle 的自增序列等。</p>
<p>数据分片后，不同数据节点生成全局唯一主键是非常棘手的问题。同一个逻辑表内的不同实际表之间的自增键由于无法互相感知而产生重复主键。 虽然可通过约束自增主键初始值和步长的方式避免碰撞，但需引入额外的运维规则，使解决方案缺乏完整性和可扩展性。</p>
<p>为此，需要使用分布式 ID 来解决此问题。本文总结业界常用的分布式 ID 解决方案。</p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#1-%E7%AE%80%E4%BB%8B">1. 简介</a></li>
<li><a href="#2-uuid">2. UUID</a>
<ul>
<li><a href="#21-uuid-%E7%9A%84%E4%BC%98%E7%82%B9">2.1. UUID 的优点</a></li>
<li><a href="#22-uuid-%E7%9A%84%E7%BC%BA%E7%82%B9">2.2. UUID 的缺点</a></li>
<li><a href="#23-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">2.3. 适用场景</a></li>
</ul>
</li>
<li><a href="#3-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%87%AA%E5%A2%9E%E9%94%AE">3. 数据库自增键</a>
<ul>
<li><a href="#31-%E4%BC%98%E7%82%B9">3.1. 优点</a></li>
<li><a href="#32-%E7%BC%BA%E7%82%B9">3.2. 缺点</a></li>
<li><a href="#33-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">3.3. 适用场景</a></li>
<li><a href="#34-%E6%94%B9%E8%BF%9B">3.4. 改进</a></li>
</ul>
</li>
<li><a href="#4-%E5%88%A9%E7%94%A8-redis-%E7%94%9F%E6%88%90%E9%94%AE">4. 利用 Redis 生成键</a>
<ul>
<li><a href="#41-%E4%BC%98%E7%82%B9">4.1. 优点</a></li>
<li><a href="#42-%E7%BC%BA%E7%82%B9">4.2. 缺点</a></li>
<li><a href="#43-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">4.3. 适用场景</a></li>
</ul>
</li>
<li><a href="#5-%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95snowflake">5. 雪花算法（Snowflake）</a>
<ul>
<li><a href="#51-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86">5.1. 基本原理</a></li>
<li><a href="#52-%E4%BC%98%E7%82%B9">5.2. 优点</a></li>
<li><a href="#53-%E7%BC%BA%E7%82%B9">5.3. 缺点</a></li>
<li><a href="#54-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">5.4. 适用场景</a></li>
<li><a href="#55-%E9%98%B2%E6%AD%A2%E6%97%B6%E9%92%9F%E5%9B%9E%E6%8B%A8">5.5. 防止时钟回拨</a></li>
</ul>
</li>
<li><a href="#6-leaf">6. Leaf</a>
<ul>
<li><a href="#61-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86">6.1. 基本原理</a></li>
<li><a href="#62-%E4%BC%98%E7%82%B9">6.2. 优点</a></li>
<li><a href="#63-%E7%BC%BA%E7%82%B9">6.3. 缺点</a></li>
<li><a href="#64-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">6.4. 适用场景</a></li>
</ul>
</li>
<li><a href="#7-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">7. 参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="1-简介"><a class="markdownIt-Anchor" href="#1-简介"></a> 1. 简介</h2>
<p>首先，分布式 ID 应该具备哪些特性呢？</p>
<ol>
<li><strong>全局唯一性</strong> - 不能出现重复的 ID 号，既然是唯一标识，这是最基本的要求。</li>
<li><strong>趋势递增</strong> - 在 MySQL InnoDB 引擎中使用的是聚集索引，由于多数 RDBMS 使用 B-tree 的数据结构来存储索引数据，在主键的选择上面我们应该尽量使用有序的主键保证写入性能。</li>
<li><strong>单调递增</strong> - 保证下一个 ID 一定大于上一个 ID，例如事务版本号、IM 增量消息、排序等特殊需求。</li>
<li><strong>信息安全</strong> - 如果 ID 是连续的，恶意用户的扒取工作就非常容易做了，直接按照顺序下载指定 URL 即可；如果是订单号就更危险了，竞对可以直接知道我们一天的单量。所以在一些应用场景下，会需要 ID 无规则、不规则。</li>
</ol>
<h2 id="2-uuid"><a class="markdownIt-Anchor" href="#2-uuid"></a> 2. UUID</h2>
<p>UUID 是通用唯一识别码（Universally Unique Identifier)的缩写，开放软件基金会(OSF)规范定义了包括网卡 MAC 地址、时间戳、名字空间（Namespace）、随机或伪随机数、时序等元素。利用这些元素来生成 UUID。</p>
<p>UUID 是由 128 位二进制组成，一般转换成十六进制，然后用 String 表示。在 java 中有个 UUID 类,在他的注释中我们看见这里有 4 种不同的 UUID 的生成策略:</p>
<ul>
<li>random - 基于随机数生成 UUID，由于 Java 中的随机数是伪随机数，其重复的概率是可以被计算出来的。这个一般我们用下面的代码获取基于随机数的 UUID:</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String id = UUID.randomUUID().toString();</span><br></pre></td></tr></table></figure>
<ul>
<li>time-based - 基于时间的 UUID,这个一般是通过当前时间，随机数，和本地 Mac 地址来计算出来，自带的 JDK 包并没有这个算法的我们在一些 UUIDUtil 中，比如我们的 log4j.core.util，会重新定义 UUID 的高位和低位。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UUID <span class="title">getTimeBasedUuid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> time = System.currentTimeMillis() * <span class="number">10000L</span> + <span class="number">122192928000000000L</span> + (<span class="keyword">long</span>)(COUNT.incrementAndGet() % <span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">long</span> timeLow = (time &amp; <span class="number">4294967295L</span>) &lt;&lt; <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">long</span> timeMid = (time &amp; <span class="number">281470681743360L</span>) &gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">long</span> timeHi = (time &amp; <span class="number">1152640029630136320L</span>) &gt;&gt; <span class="number">48</span>;</span><br><span class="line">    <span class="keyword">long</span> most = timeLow | timeMid | <span class="number">4096L</span> | timeHi;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UUID(most, LEAST);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>DCE security - DCE 安全的 UUID。</p>
</li>
<li>
<p>name-based - 基于名字的 UUID，通过计算名字和名字空间的 MD5 来计算 UUID。</p>
</li>
</ul>
<h3 id="21-uuid-的优点"><a class="markdownIt-Anchor" href="#21-uuid-的优点"></a> 2.1. UUID 的优点</h3>
<ul>
<li>通过本地生成，没有经过网络 I/O，性能较快</li>
</ul>
<h3 id="22-uuid-的缺点"><a class="markdownIt-Anchor" href="#22-uuid-的缺点"></a> 2.2. UUID 的缺点</h3>
<ul>
<li><strong>长度过长</strong> - UUID 太长，16 字节 128 位，通常以 36 长度的字符串表示，很多场景不适用。例如：Mysql 官方明确建议主键越短越好，36 个字符长度的 UUID 不符合要求。</li>
<li><strong>信息不安全</strong> - 基于 MAC 地址生成 UUID 的算法可能会造成 MAC 地址泄露，这个漏洞曾被用于寻找梅丽莎病毒的制作者位置。</li>
<li><strong>无序性</strong> - 不能生成递增有序的数字。这对于一些特定场景不利。例如：如果作为数据库主键，在 InnoDB 引擎下，UUID 的无序性可能会引起数据位置频繁变动，严重影响性能。</li>
</ul>
<h3 id="23-适用场景"><a class="markdownIt-Anchor" href="#23-适用场景"></a> 2.3. 适用场景</h3>
<p>UUID 的适用场景可以为不需要担心过多的空间占用，以及不需要生成有递增趋势的数字。在 Log4j 里 <code>UuidPatternConverter</code> 中加入了 UUID 来标识每一条日志。</p>
<h2 id="3-数据库自增键"><a class="markdownIt-Anchor" href="#3-数据库自增键"></a> 3. 数据库自增键</h2>
<p>提到自增键，最先想到的肯定是直接使用数据库自增键。<em>各数据库对于该需求也提供了相应的支持，比如 MySQL 的自增键，Oracle 的自增序列等</em>。</p>
<h3 id="31-优点"><a class="markdownIt-Anchor" href="#31-优点"></a> 3.1. 优点</h3>
<ul>
<li>非常简单，利用现有数据库的功能实现，成本小，有 DBA 专业维护</li>
<li>有序递增</li>
<li>方便排序和分页</li>
</ul>
<h3 id="32-缺点"><a class="markdownIt-Anchor" href="#32-缺点"></a> 3.2. 缺点</h3>
<ul>
<li>强依赖数据库，当数据库异常时整个系统不可用。配置主从复制可以尽可能的增加可用性，但是数据一致性在特殊情况下难以保证。主从切换时的不一致可能会导致重复发号。</li>
<li>生成 ID 性能瓶颈限制在单台 MySQL 的读写性能。</li>
<li>简单递增容易被其他人分析利用
<ul>
<li>比如根据用户 ID 来分析注册人数，猜测出服务的一个大概状况。</li>
</ul>
</li>
</ul>
<h3 id="33-适用场景"><a class="markdownIt-Anchor" href="#33-适用场景"></a> 3.3. 适用场景</h3>
<p>数据量不大，并发不高的场景。</p>
<h3 id="34-改进"><a class="markdownIt-Anchor" href="#34-改进"></a> 3.4. 改进</h3>
<p>对于 MySQL 性能问题，可用如下方案解决：在分布式系统中我们可以多部署几台机器，每台机器设置不同的初始值，且步长和机器数相等。比如有两台机器。设置步长 step 为 2，TicketServer1 的初始值为 1（1，3，5，7，9，11…）、TicketServer2 的初始值为 2（2，4，6，8，10…）。这是 Flickr 团队在 2010 年撰文介绍的一种主键生成策略（<a href="http://code.flickr.net/2010/02/08/ticket-servers-distributed-unique-primary-keys-on-the-cheap/" target="_blank" rel="noopener">Ticket Servers: Distributed Unique Primary Keys on the Cheap </a>）。如下所示，为了实现上述方案分别设置两台机器对应的参数，TicketServer1 从 1 开始发号，TicketServer2 从 2 开始发号，两台机器每次发号之后都递增 2。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">TicketServer1:</span><br><span class="line">auto-<span class="keyword">increment</span>-<span class="keyword">increment</span> = <span class="number">2</span></span><br><span class="line">auto-<span class="keyword">increment</span>-offset = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">TicketServer2:</span><br><span class="line">auto-<span class="keyword">increment</span>-<span class="keyword">increment</span> = <span class="number">2</span></span><br><span class="line">auto-<span class="keyword">increment</span>-offset = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/6d2c9ec8.png" alt="image" /></p>
<p>这种架构存在以下缺点：</p>
<ul>
<li>系统水平扩展比较困难，比如定义好了步长和机器台数之后，如果要添加机器该怎么做？假设现在只有一台机器发号是 1,2,3,4,5（步长是 1），这个时候需要扩容机器一台。可以这样做：把第二台机器的初始值设置得比第一台超过很多，比如 14（假设在扩容时间之内第一台不可能发到 14），同时设置步长为 2，那么这台机器下发的号码都是 14 以后的偶数。然后摘掉第一台，把 ID 值保留为奇数，比如 7，然后修改第一台的步长为 2。让它符合我们定义的号段标准，对于这个例子来说就是让第一台以后只能产生奇数。扩容方案看起来复杂吗？貌似还好，现在想象一下如果我们线上有 100 台机器，这个时候要扩容该怎么做？简直是噩梦。所以系统水平扩展方案复杂难以实现。</li>
<li>ID 没有了单调递增的特性，只能趋势递增，这个缺点对于一般业务需求不是很重要，可以容忍。</li>
<li>数据库压力还是很大，每次获取 ID 都得读写一次数据库，只能靠堆机器来提高性能。</li>
</ul>
<h2 id="4-利用-redis-生成键"><a class="markdownIt-Anchor" href="#4-利用-redis-生成键"></a> 4. 利用 Redis 生成键</h2>
<p>Redis 中有两个命令 <code>Incr</code>，<code>IncrBy</code>。</p>
<p>因为 Redis 是单线程的，所以能保证原子性。</p>
<h3 id="41-优点"><a class="markdownIt-Anchor" href="#41-优点"></a> 4.1. 优点</h3>
<ul>
<li>性能比数据库好</li>
<li>能满足有序递增</li>
</ul>
<h3 id="42-缺点"><a class="markdownIt-Anchor" href="#42-缺点"></a> 4.2. 缺点</h3>
<ul>
<li>由于 Redis 是内存数据库，即使支持持久化（AOF 和 RDB），但是依然可能丢失数据，造成 ID 重复。</li>
<li>依赖于 Redis 生成键，如果 Redis 服务不稳定，会影响 ID 生成。</li>
</ul>
<h3 id="43-适用场景"><a class="markdownIt-Anchor" href="#43-适用场景"></a> 4.3. 适用场景</h3>
<p>Redis 性能比数据库好，但是有可能会出现 ID 重复和不稳定。如果可以接受，那么就可以使用这种方案。</p>
<h2 id="5-雪花算法snowflake"><a class="markdownIt-Anchor" href="#5-雪花算法snowflake"></a> 5. 雪花算法（Snowflake）</h2>
<p>雪花算法（Snowflake）是由 Twitter 公布的分布式主键生成算法，<strong>它会生成一个 <code>64 bit</code> 的整数</strong>，可以保证不同进程主键的不重复性，以及相同进程主键的有序性。</p>
<p>在同一个进程中，它首先是通过时间位保证不重复，如果时间相同则是通过序列位保证。 同时由于时间位是单调递增的，且各个服务器如果大体做了时间同步，那么生成的主键在分布式环境可以认为是总体有序的，这就保证了对索引字段的插入的高效性。</p>
<h3 id="51-基本原理"><a class="markdownIt-Anchor" href="#51-基本原理"></a> 5.1. 基本原理</h3>
<h4 id="键的组成"><a class="markdownIt-Anchor" href="#键的组成"></a> 键的组成</h4>
<p>使用<strong>雪花算法生成的主键，二进制表示形式包含 4 部分</strong>，从高位到低位分表为：1bit 符号位、41bit 时间戳位、10bit 工作进程位以及 12bit 序列号位。</p>
<ul>
<li><strong>符号位(1bit)</strong></li>
</ul>
<p>预留的符号位，恒为零。</p>
<ul>
<li><strong>时间戳位(41bit)</strong></li>
</ul>
<p>41 位的时间戳可以容纳的毫秒数是 2 的 41 次幂，一年所使用的毫秒数是：<code>365 * 24 * 60 * 60 * 1000</code>。通过计算可知：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Math.pow(<span class="number">2</span>, <span class="number">41</span>) / (<span class="number">365</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000L</span>);</span><br></pre></td></tr></table></figure>
<p>结果约等于 69.73 年。ShardingSphere 的雪花算法的时间纪元从 2016 年 11 月 1 日零点开始，可以使用到 2086 年，相信能满足绝大部分系统的要求。</p>
<ul>
<li><strong>工作进程位(10bit)</strong></li>
</ul>
<p>该标志在 Java 进程内是唯一的，如果是分布式应用部署应保证每个工作进程的 id 是不同的。该值默认为 0，可通过属性设置。</p>
<ul>
<li><strong>序列号位(12bit)</strong></li>
</ul>
<p>该序列是用来在同一个毫秒内生成不同的 ID。如果在这个毫秒内生成的数量超过 4096(2 的 12 次幂)，那么生成器会等待到下个毫秒继续生成。</p>
<p>雪花算法主键的详细结构见下图：</p>
<p><img src="https://shardingsphere.apache.org/document/current/img/sharding/snowflake_cn_v2.png" alt="雪花算法" /></p>
<h4 id="时钟回拨"><a class="markdownIt-Anchor" href="#时钟回拨"></a> 时钟回拨</h4>
<p>服务器时钟回拨会导致产生重复序列，因此默认分布式主键生成器提供了一个最大容忍的时钟回拨毫秒数。 如果时钟回拨的时间超过最大容忍的毫秒数阈值，则程序报错；如果在可容忍的范围内，默认分布式主键生成器会等待时钟同步到最后一次主键生成的时间后再继续工作。 最大容忍的时钟回拨毫秒数的默认值为 0，可通过属性设置。</p>
<h4 id="灵活定制"><a class="markdownIt-Anchor" href="#灵活定制"></a> 灵活定制</h4>
<p>上面只是一个将 <code>64bit</code> 划分的标准，当然也不一定这么做，可以根据不同业务的具体场景来划分，比如下面给出一个业务场景：</p>
<ul>
<li>服务目前 QPS10 万，预计几年之内会发展到百万。</li>
<li>当前机器三地部署，上海，北京，深圳都有。</li>
<li>当前机器 10 台左右，预计未来会增加至百台。</li>
</ul>
<p>这个时候我们根据上面的场景可以再次合理的划分 62bit，QPS 几年之内会发展到百万，那么每毫秒就是千级的请求，目前 10 台机器那么每台机器承担百级的请求，为了保证扩展，后面的循环位可以限制到 1024，也就是 2^10，那么循环位 10 位就足够了。</p>
<p>机器三地部署我们可以用 3bit 总共 8 来表示机房位置，当前的机器 10 台，为了保证扩展到百台那么可以用 7bit 128 来表示，时间位依然是 41bit，那么还剩下 64-10-3-7-41-1 = 2bit，还剩下 2bit 可以用来进行扩展。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/29/16624909d2007c22?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="" /></p>
<h3 id="52-优点"><a class="markdownIt-Anchor" href="#52-优点"></a> 5.2. 优点</h3>
<ul>
<li>生成的 ID 都是趋势递增的。</li>
<li>不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成 ID 的性能也是非常高的。</li>
<li>可以根据自身业务特性分配 bit 位，非常灵活。</li>
</ul>
<h3 id="53-缺点"><a class="markdownIt-Anchor" href="#53-缺点"></a> 5.3. 缺点</h3>
<ul>
<li>强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。</li>
</ul>
<h3 id="54-适用场景"><a class="markdownIt-Anchor" href="#54-适用场景"></a> 5.4. 适用场景</h3>
<p>当我们需要无序不能被猜测的 ID，并且需要一定高性能，且需要 long 型，那么就可以使用我们雪花算法。比如常见的订单 ID，用雪花算法别人就无法猜测你每天的订单量是多少。</p>
<h3 id="55-防止时钟回拨"><a class="markdownIt-Anchor" href="#55-防止时钟回拨"></a> 5.5. 防止时钟回拨</h3>
<p>雪花算法是强依赖于时间的，而如果机器时间发生回拨，有可能会生成重复的 ID。</p>
<p>我们可以针对算法做一些优化，来防止时钟回拨生成重复 ID。</p>
<p>用当前时间和上一次的时间进行判断，如果当前时间小于上一次的时间那么肯定是发生了回拨。普通的算法会直接抛出异常，这里我们可以对其进行优化，一般分为两个情况:</p>
<ul>
<li>如果时间回拨时间较短，比如配置 <code>5ms</code> 以内，那么可以直接等待一定的时间，让机器的时间追上来。</li>
<li>如果时间的回拨时间较长，我们不能接受这么长的阻塞等待，那么又有两个策略:
<ul>
<li>直接拒绝，抛出异常。打日志，通知 RD 时钟回滚。</li>
<li>利用扩展位。上面我们讨论过，不同业务场景位数可能用不到那么多比特位，那么我们可以把扩展位数利用起来。比如：当这个时间回拨比较长的时候，我们可以不需要等待，直接在扩展位加 1。两位的扩展位允许我们有三次大的时钟回拨，一般来说就够了，如果其超过三次我们还是选择抛出异常，打日志。</li>
</ul>
</li>
</ul>
<h2 id="6-leaf"><a class="markdownIt-Anchor" href="#6-leaf"></a> 6. Leaf</h2>
<blockquote>
<p>美团提供了一种分布式 ID 解决方案 Leaf，其本质可以视为数据库分段+服务缓存 ID。</p>
<p>详情可以参考 <a href="https://tech.meituan.com/2017/04/21/mt-leaf.html" target="_blank" rel="noopener">Leaf——美团点评分布式 ID 生成系统</a></p>
</blockquote>
<h3 id="61-基本原理"><a class="markdownIt-Anchor" href="#61-基本原理"></a> 6.1. 基本原理</h3>
<p>使用数据库生成 ID，但是做了如下改进：</p>
<p>原方案每次获取 ID 都得读写一次数据库，造成数据库压力大。改为利用 proxy server 批量获取，每次获取一个 segment(step 决定大小)号段的值。用完之后再去数据库获取新的号段，可以大大的减轻数据库的压力。 - 各个业务不同的发号需求用 biz_tag 字段来区分，每个 biz-tag 的 ID 获取相互隔离，互不影响。如果以后有性能需求需要对数据库扩容，不需要上述描述的复杂的扩容操作，只需要对 biz_tag 分库分表就行。</p>
<p>数据库表设计如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">+<span class="comment">-------------+--------------+------+-----+-------------------+-----------------------------+</span></span><br><span class="line">| Field       | Type         | Null | Key | Default           | Extra                       |</span><br><span class="line">+<span class="comment">-------------+--------------+------+-----+-------------------+-----------------------------+</span></span><br><span class="line">| biz_tag     | varchar(128) | NO   | PRI |                   |                             |</span><br><span class="line">| max_id      | bigint(20)   | NO   |     | 1                 |                             |</span><br><span class="line">| step        | int(11)      | NO   |     | NULL              |                             |</span><br><span class="line">| desc        | varchar(256) | YES  |     | NULL              |                             |</span><br><span class="line">| update_time | timestamp    | NO   |     | CURRENT_TIMESTAMP | on <span class="keyword">update</span> <span class="keyword">CURRENT_TIMESTAMP</span> |</span><br><span class="line">+<span class="comment">-------------+--------------+------+-----+-------------------+-----------------------------+</span></span><br></pre></td></tr></table></figure>
<p>重要字段说明：</p>
<ul>
<li><code>biz_tag</code> 用来区分业务</li>
<li><code>max_id</code> 表示该 <code>biz_tag</code> 目前所被分配的 ID 号段的最大值</li>
<li><code>step</code> 表示每次分配的号段长度。原来获取 ID 每次都需要写数据库，现在只需要把 <code>step</code> 设置得足够大，比如 1000。那么只有当 1000 个号被消耗完了之后才会去重新读写一次数据库。读写数据库的频率从 1 减小到了 1/step。</li>
</ul>
<p>大致架构如下图所示：</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/5e4ff128.png" alt="image" /></p>
<p>test_tag 在第一台 Leaf 机器上是 <code>1~1000</code> 的号段，当这个号段用完时，会去加载另一个长度为 step=1000 的号段，假设另外两台号段都没有更新，这个时候第一台机器新加载的号段就应该是 <code>3001~4000</code>。同时数据库对应的 biz_tag 这条数据的 max_id 会从 3000 被更新成 4000，更新号段的 SQL 语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Begin</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">table</span> <span class="keyword">SET</span> max_id=max_id+step <span class="keyword">WHERE</span> biz_tag=xxx</span><br><span class="line"><span class="keyword">SELECT</span> tag, max_id, step <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> biz_tag=xxx</span><br><span class="line"><span class="keyword">Commit</span></span><br></pre></td></tr></table></figure>
<h3 id="62-优点"><a class="markdownIt-Anchor" href="#62-优点"></a> 6.2. 优点</h3>
<ul>
<li>比数据库自增键性能高</li>
<li>能保证键趋势递增。</li>
<li>如果数据库宕机，由于 proxServer 有缓存，依然可以坚持一段时间。</li>
</ul>
<h3 id="63-缺点"><a class="markdownIt-Anchor" href="#63-缺点"></a> 6.3. 缺点</h3>
<ul>
<li>和主键递增一样，容易被人猜测。</li>
<li>数据库宕机后，虽然能支撑一段时间，但是仍然会造成系统不可用。</li>
</ul>
<h3 id="64-适用场景"><a class="markdownIt-Anchor" href="#64-适用场景"></a> 6.4. 适用场景</h3>
<p>需要趋势递增，并且 ID 大小可控制的，可以使用这套方案。</p>
<p>当然这个方案也可以通过一些手段避免被人猜测，把 ID 变成是无序的，比如把我们生成的数据是一个递增的 long 型，把这个 Long 分成几个部分，比如可以分成几组三位数，几组四位数，然后在建立一个映射表，将我们的数据变成无序。</p>
<h2 id="7-参考资料"><a class="markdownIt-Anchor" href="#7-参考资料"></a> 7. 参考资料</h2>
<ul>
<li><a href="https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md" target="_blank" rel="noopener">百度分布式 ID</a></li>
<li><a href="https://juejin.im/post/5bb0217ef265da0ac2567b42" target="_blank" rel="noopener">如果再有人问你分布式 ID，这篇文章丢给他</a></li>
<li><a href="https://segmentfault.com/a/1190000011282426" target="_blank" rel="noopener">理解分布式 id 生成算法 SnowFlake</a></li>
<li><a href="https://tech.meituan.com/2017/04/21/mt-leaf.html" target="_blank" rel="noopener">Leaf——美团点评分布式 ID 生成系统</a></li>
<li><a href="https://www.ietf.org/rfc/rfc4122.txt" target="_blank" rel="noopener">UUID 规范</a></li>
<li><a href="https://shardingsphere.apache.org/document/current/cn/features/sharding/other-features/key-generator/" target="_blank" rel="noopener">ShardingSphere 分布式主键</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/distributed/mq-theory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/distributed/mq-theory/" class="post-title-link" itemprop="url">消息队列基本原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-05 15:11:00" itemprop="dateCreated datePublished" datetime="2019-07-05T15:11:00+08:00">2019-07-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-02 18:07:05" itemprop="dateModified" datetime="2020-02-02T18:07:05+08:00">2020-02-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/distributed/mq-theory/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="distributed/mq-theory/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="消息队列基本原理"><a class="markdownIt-Anchor" href="#消息队列基本原理"></a> 消息队列基本原理</h1>
<blockquote>
<p>📦 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p>
<p>消息队列（Message Queue，简称 MQ）技术是分布式应用间交换信息的一种技术。</p>
<p>消息队列主要解决应用耦合，异步消息，流量削锋等问题，实现高性能，高可用，可伸缩和最终一致性架构。是大型分布式系统不可缺少的中间件。</p>
<p>注意：<em>为了简便，下文中除了文章标题，一律使用 MQ 简称</em>。</p>
</blockquote>
<h2 id="1-为什么要使用-mq"><a class="markdownIt-Anchor" href="#1-为什么要使用-mq"></a> 1. 为什么要使用 MQ</h2>
<p>MQ 比较核心的优点有 3 个：<strong>解耦</strong>、<strong>异步</strong>、<strong>削峰</strong>。</p>
<h3 id="11-解耦"><a class="markdownIt-Anchor" href="#11-解耦"></a> 1.1. 解耦</h3>
<p>不同系统如果要建立通信，传统的做法是：调用接口。</p>
<p>如果需要和新的系统建立通信或删除已建立的通信，都需要修改代码，这种方案显然耦合度很高。</p>
<p><img src="http://dunwu.test.upcdn.net/cs/design/theory/mq/mq_1.png" alt="" /></p>
<p>如果使用 MQ，系统间的通信只需要通过发布/订阅（Pub/Sub）模型即可，彼此没有直接联系，也就不需要相互感知，从而达到 <strong>解耦</strong>。</p>
<p><img src="http://dunwu.test.upcdn.net/cs/design/theory/mq/mq_2.png" alt="" /></p>
<h3 id="12-异步"><a class="markdownIt-Anchor" href="#12-异步"></a> 1.2. 异步</h3>
<p>假设这样一个场景，用户向系统 A 发起请求，系统 A 处理计算只需要 10 ms，然后通知系统 BCD 写库，系统 BCD 写库耗时分别为：100ms、200ms、300ms。最终总耗时为： 10+100ms+200ms+300ms=610ms。此外，加上请求和响应的网络传输时间，从用户角度看，可能要等待将近 1s 才能得到结果。</p>
<p><img src="http://dunwu.test.upcdn.net/cs/design/theory/mq/mq_3.png" alt="" /></p>
<p>如果使用 MQ，系统 A 接到请求后，耗时 10ms 处理计算，然后向系统 BCD 连续发送消息，假设耗时 5ms。那么 这一过程的总耗时为 3ms + 5ms = 8ms，这相比于 610 ms，大大缩短了响应时间。至于系统 BCD 的写库操作，只要自行消费 MQ 后处理即可，用户无需关注。</p>
<p><img src="http://dunwu.test.upcdn.net/cs/design/theory/mq/mq_4.png" alt="" /></p>
<h3 id="13-削峰"><a class="markdownIt-Anchor" href="#13-削峰"></a> 1.3. 削峰</h3>
<p>假设某个系统读写数据库的稳定性能为每秒处理 1000 条数据。平常情况下，远远达不到这么大的处理量。假设，因为因为做活动，系统的瞬时请求量剧增，达到每秒 10000 个并发请求，数据库根本承受不了，可能直接就把数据库给整崩溃了，这样系统服务就不可用了。</p>
<p><img src="http://dunwu.test.upcdn.net/cs/design/theory/mq/mq_5.png" alt="" /></p>
<p>如果使用 MQ，每秒写入 10000 条请求，但是系统 A 每秒只从 MQ 中消费 1000 条请求，然后写入数据库。这样，就不会超过数据库的承受能力，而是把请求积压在 MQ 中。只要高峰期一过，系统 A 就会很快把积压的消息给处理掉。</p>
<p><img src="http://dunwu.test.upcdn.net/cs/design/theory/mq/mq_6.png" alt="" /></p>
<h2 id="2-mq-引入的问题"><a class="markdownIt-Anchor" href="#2-mq-引入的问题"></a> 2. MQ 引入的问题</h2>
<p>凡事有利有弊，使用 MQ 给系统带来很多好处，也会付出一定的代价。</p>
<p>它引入了以下问题：</p>
<ul>
<li><strong>系统可用性降低</strong> - 引入了 MQ 后，通信需要基于 MQ 完成，如果 MQ 宕机，则服务不可用。因此，MQ 要保证是高可用的，详情参考：<a href="#MQ-%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8">MQ 的高可用</a></li>
<li><strong>系统复杂度提高</strong> - 使用 MQ，需要关注一些新的问题：
<ul>
<li>如何保证消息没有重复消费？</li>
<li>如何处理消息丢失的问题？</li>
<li>如何保证消息传递的顺序性？</li>
<li>如何处理大量消息积压的问题？</li>
</ul>
</li>
<li><strong>一致性问题</strong> - 假设系统 A 处理完直接返回成功的结果给用户，用户认为请求成功。但如果此时，系统 BCD 中只要有任意一个写库失败，那么数据就不一致了。这种情况如何处理？</li>
</ul>
<h3 id="21-重复消费"><a class="markdownIt-Anchor" href="#21-重复消费"></a> 2.1. 重复消费</h3>
<p><strong>如何保证消息不被重复消费</strong> 和 <strong>如何保证消息消费的幂等性</strong> 是同一个问题。</p>
<p>必须先明确产生重复消费的原因，才能对症下药。</p>
<h4 id="211-重复消费问题原因"><a class="markdownIt-Anchor" href="#211-重复消费问题原因"></a> 2.1.1. 重复消费问题原因</h4>
<p>重复消费问题通常不是 MQ 来处理，而是由开发来处理的。</p>
<p>以 Kafka 举例：Kafka 每个 Partition 都是一个有序的、不可变的记录序列，不断追加到结构化的提交日志中。Partition 中的记录每个分配一个连续的 id 号，称为偏移量（Offset），用于唯一标识 Partition 内的每条记录。</p>
<p><img src="http://kafka.apachecn.org/10/images/log_consumer.png" alt="" /></p>
<p>Kafka 的客户端和 Broker 都会保存 Offset。客户端消费消息后，每隔一段时间，就把已消费的 Offset 提交给 Kafka Broker，表示已消费。</p>
<p>在这个过程中，如果客户端应用消费消息后，因为宕机、重启等情况而没有提交已消费的 Offset 。当系统恢复后，会继续消费消息，由于 Offset 未提交，就会出现重复消费的问题。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3101171-75abe308f9cf21f8.png" alt="" /></p>
<h4 id="212-重复消费解决方案"><a class="markdownIt-Anchor" href="#212-重复消费解决方案"></a> 2.1.2. 重复消费解决方案</h4>
<p>应对重复消费问题，就要通过幂等性来解决。</p>
<p>这个问题可以从业务层面来解决。</p>
<p>MQ 重复消费不可怕，可怕的是没有应对机制，可以借鉴的思路有：</p>
<ul>
<li>如果是写库，可以先根据主键查询，判断数据是否已存在，存在则更新，不存在则插入；</li>
<li>如果是写 Redis，set 操作，由于天然具有幂等性，大可放心；</li>
<li>如果是根据消息做较复杂的逻辑处理，可以在消息中加入全局唯一 ID，例如：订单 ID 等。在客户端存储中（Mysql、Redis 等）保存已消费消息的 ID。一旦接受到新消息，先判断消息中的 ID 是否在已消费消息 ID 表中存在，存在则不再处理，不存在则处理。</li>
</ul>
<h3 id="22-消息丢失"><a class="markdownIt-Anchor" href="#22-消息丢失"></a> 2.2. 消息丢失</h3>
<p><strong>如何处理消息丢失的问题</strong> 和 <strong>如何保证消息不被重复消费</strong> 是同一个问题。关注点有按个：</p>
<ul>
<li>Kafka 丢失数据</li>
<li>消费方丢失数据</li>
<li>生产方丢失数据</li>
</ul>
<h4 id="221-消费方丢失数据"><a class="markdownIt-Anchor" href="#221-消费方丢失数据"></a> 2.2.1. 消费方丢失数据</h4>
<p>唯一可能导致消费方丢失数据的情况，就是：消费方设置了<strong>自动提交 Offset</strong>。设置了自动提交 Offset，接受到消息后就会自动提交 Offset 给 Kafka ，Kafka 就认为消息已被消费。如果此时，消费方尚未来得及处理消息就挂了，那么消息就丢了。</p>
<p>解决方法就是消费方关闭自动提交 Offset，处理完消息后手动提交 Offset。但这种情况下可能会出现重复消费的情形，需要自行保证幂等性。</p>
<h4 id="222-kafka-丢失数据"><a class="markdownIt-Anchor" href="#222-kafka-丢失数据"></a> 2.2.2. Kafka 丢失数据</h4>
<p>当 Kafka 某个 Broker 宕机，需要重新选举 Partition 的 Leader。若此时其他的 Follower 尚未同步 Leader 的数据，那么新选某个 Follower 为 Leader 后，就丢失了部分数据。</p>
<p>为此，一般要求至少设置 4 个参数：</p>
<ul>
<li>给 Topic 设置 <code>replication.factor</code> 参数 - 这个值必须大于 1，要求每个 Partition 必须有至少 2 个副本。</li>
<li>在 Kafka 服务端设置 <code>min.insync.replicas</code> 参数 - 这个值必须大于 1，这是要求一个 Leader 需要和至少一个 Follower 保持通信，这样才能确保 Leader 挂了还有替补。</li>
<li>在 Producer 端设置 <code>acks=all</code> - 这意味着：要求每条数据，必须是<strong>写入所有 replica 之后，才能认为是写成功了</strong>。</li>
<li>在 Producer 端设置 <code>retries=MAX</code>（很大很大很大的一个值，无限次重试的意思） - 这意味着<strong>要求一旦写入失败，就无限重试</strong>，卡在这里了。</li>
</ul>
<h4 id="223-生产方丢失数据"><a class="markdownIt-Anchor" href="#223-生产方丢失数据"></a> 2.2.3. 生产方丢失数据</h4>
<p>如果按照上述的思路设置了 <code>acks=all</code>，生产方一定不会丢数据。</p>
<p>要求是，你的 Leader 接收到消息，所有的 Follower 都同步到了消息之后，才认为本生产消息成功了。如果未满足这个条件，生产者会自动不断的重试，重试无限次。</p>
<h3 id="23-消息的顺序性"><a class="markdownIt-Anchor" href="#23-消息的顺序性"></a> 2.3. 消息的顺序性</h3>
<blockquote>
<p>以 Kafka 为例</p>
</blockquote>
<p>要保证 MQ 的顺序性，势必要付出一定的代价，所以实施方案前，要先明确业务场景是不是有必要保证消息的顺序性。只有那些明确对消息处理顺序有要求的业务场景才值得去保证消息顺序性。</p>
<p>方案一</p>
<p>一个 Topic，一个 Partition，一个 Consumer，内部单线程消费，单线程吞吐量太低，一般不会用这个。</p>
<p>方案二</p>
<ul>
<li>写入数据到 Partition 时指定一个唯一的 Key，例如订单 ID。由发送方保证相同 Key 的消息只能发送到同一个 Partition 并且这个 Partition 中的数据一定是顺序的。</li>
<li>基于上一点，消费方从 Kafka Partition 中消费消息时，此刻一定是顺序的。但如果消费方式以并发方式消费消息，顺序就可能会被打乱。为此，还有做到以下几点：
<ul>
<li>消费方维护 N 个缓存队列，具有相同 key 的数据都写入同一个队列中；</li>
<li>创建 N 个线程，每个线程只负责从指定的一个队列中取数据。</li>
</ul>
</li>
</ul>
<p><img src="http://dunwu.test.upcdn.net/cs/design/theory/mq/mq_7.png" alt="" /></p>
<h3 id="24-消息积压"><a class="markdownIt-Anchor" href="#24-消息积压"></a> 2.4. 消息积压</h3>
<p>假设一个 MQ 消费者可以一秒处理 1000 条消息，三个 MQ 消费者可以一秒处理 3000 条消息，那么一分钟的处理量是 18 万条。如果 MQ 中积压了几百万到上千万的数据，即使消费者恢复了，也需要大概很长的时间才能恢复过来。</p>
<p>对于产线环境来说，漫长的等待是不可接受的，所以面临这种窘境时，只能临时紧急扩容以应对了，具体操作步骤和思路如下：</p>
<ul>
<li>先修复 Consumer 的问题，确保其恢复消费速度，然后将现有 Consumer 都停掉。</li>
<li>新建一个 Topic，Partition 是原来的 10 倍，临时建立好原先 10 倍的 Queue 数量。</li>
<li>然后写一个临时的分发数据的 Consumer 程序，这个程序部署上去消费积压的数据，<strong>消费之后不做耗时的处理</strong>，直接均匀轮询写入临时建立好的 10 倍数量的 Queue。</li>
<li>接着临时征用 10 倍的机器来部署 Consumer ，每一批 Consumer 消费一个临时 Queue 的数据。这种做法相当于是临时将 Queue 资源和 Consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。</li>
<li>等快速消费完积压数据之后，<strong>得恢复原先部署的架构</strong>，<strong>重新</strong>用原先的 consumer 机器来消费消息。</li>
</ul>
<h2 id="3-mq-的高可用"><a class="markdownIt-Anchor" href="#3-mq-的高可用"></a> 3. MQ 的高可用</h2>
<p>不同 MQ 实现高可用的原理各不相同。因为 Kafka 比较具有代表性，所以这里以 Kafka 为例。</p>
<h3 id="31-kafka-的高可用"><a class="markdownIt-Anchor" href="#31-kafka-的高可用"></a> 3.1. Kafka 的高可用</h3>
<h4 id="311-kafka-的核心概念"><a class="markdownIt-Anchor" href="#311-kafka-的核心概念"></a> 3.1.1. Kafka 的核心概念</h4>
<p>了解 Kafka，必须先了解 Kafka 的核心概念：</p>
<ul>
<li>
<p><strong>Broker</strong> - Kafka 集群包含一个或多个节点，这种节点被称为 Broker。</p>
</li>
<li>
<p><strong>Topic</strong> - 每条发布到 Kafka 集群的消息都有一个类别，这个类别被称为 Topic。（不同 Topic 的消息是物理隔离的；同一个 Topic 的消息保存在一个或多个 Broker 上，但用户只需指定消息的 Topic 即可生产或消费数据而不必关心数据存于何处）。对于每一个 Topic， Kafka 集群都会维持一个分区日志。</p>
</li>
<li>
<p><strong>Partition</strong> - 了提高 Kafka 的吞吐率，每个 Topic 包含一个或多个 Partition，每个 Partition 在物理上对应一个文件夹，该文件夹下存储这个 Partition 的所有消息和索引文件。</p>
<ul>
<li>Kafka 日志的分区（Partition）分布在 Kafka 集群的节点上。每个节点在处理数据和请求时，共享这些分区。每一个分区都会在已配置的节点上进行备份，确保容错性。</li>
</ul>
</li>
</ul>
<p><img src="http://dunwu.test.upcdn.net/cs/java/javaweb/distributed/mq/kafka/kafka-cluster-roles.png" alt="" /></p>
<h4 id="312-kafka-的副本机制"><a class="markdownIt-Anchor" href="#312-kafka-的副本机制"></a> 3.1.2. Kafka 的副本机制</h4>
<p>Kafka 是如何实现高可用的呢？</p>
<p>Kafka 在 0.8 以前的版本中，如果一个 Broker 宕机了，其上面的 Partition 都不能用了，这自然不是高可用的。</p>
<p>为了实现高可用，Kafka 引入了复制功能。</p>
<p>简单来说，就是副本机制（ Replicate ）。</p>
<p>每个 Partition 都有一个 Broker 作为 Leader，零个或者多个 Broker 作为 Follower。每个 Broker 都会成为某些分区的 Leader 和某些分区的 Follower，因此集群的负载是平衡的。</p>
<ul>
<li><strong>Leader 处理一切对 Partition （分区）的读写请求</strong>；</li>
<li><strong>而 Follower 只需被动的同步 Leader 上的数据</strong>。</li>
</ul>
<p>同一个 Topic 的不同 Partition 会分布在多个 Broker 上，而且一个 Partition 还会在其他的 Broker 上面进行备份，Producer 在发布消息到某个 Partition 时，先找到该 Partition 的 Leader，然后向这个 Leader 推送消息；每个 Follower 都从 Leader 拉取消息，拉取消息成功之后，向 Leader 发送一个 ACK 确认。</p>
<p><img src="http://dunwu.test.upcdn.net/cs/java/javaweb/distributed/mq/kafka/kafka-replication.png" alt="" /></p>
<blockquote>
<p>FAQ</p>
<p>问：为什么让 Leader 处理一切对对 Partition （分区）的读写请求？</p>
<p>答：因为如果允许所有 Broker 都可以处理读写请求，就可能产生数据一致性问题。</p>
</blockquote>
<h4 id="313-kafka-选举-leader"><a class="markdownIt-Anchor" href="#313-kafka-选举-leader"></a> 3.1.3. Kafka 选举 Leader</h4>
<p>由上文可知，Partition 在多个 Broker 上存在副本。</p>
<p>如果某个 Follower 宕机，啥事儿没有，正常工作。</p>
<p>如果 Leader 宕机了，会从 Follower 中<strong>重新选举</strong>一个新的 Leader。</p>
<h2 id="4-mq-的通信模式"><a class="markdownIt-Anchor" href="#4-mq-的通信模式"></a> 4. MQ 的通信模式</h2>
<p>MQ 可驻留在内存或磁盘上，队列存储消息直到它们被应用程序读取。通过 MQ，应用程序可独立地执行，它们不需要知道彼此的位置，不需要等待接收程序接收此消息。在分布式计算环境中，为了集成分布式应用，开发者需要对异构网络环境下的分布式应用提供有效的通信手段。为了管理需要共享的信息，对应用提供公共的信息交换机制是重要的。</p>
<ul>
<li><strong>点对点</strong> - 点对点方式是最为传统和常见的通讯方式，它支持一对一、一对多、多对多、多对一等多种配置方式，支持树状、网状等多种拓扑结构。</li>
<li><strong>多点广播</strong> - MQ 适用于不同类型的应用。其中重要的，也是正在发展中的是&quot;多点广播&quot;应用，即能够将消息发送到多个目标站点 (Destination List)。可以使用一条 MQ 指令将单一消息发送到多个目标站点，并确保为每一站点可靠地提供信息。MQ 不仅提供了多点广播的功能，而且还拥有智能消息分发功能，在将一条消息发送到同一系统上的多个用户时，MQ 将消息的一个复制版本和该系统上接收者的名单发送到目标 MQ 系统。目标 MQ 系统在本地复制这些消息，并将它们发送到名单上的队列，从而尽可能减少网络的传输量。</li>
<li><strong>发布/订阅 (Publish/Subscribe)</strong> - 发布/订阅模式使消息的分发可以突破目的队列地理位置的限制，使消息按照特定的主题甚至内容进行分发，用户或应用程序可以根据主题或内容接收到所需要的消息。发布/订阅模式使得发送者和接收者之间的耦合关系变得更为松散，发送者不必关心接收者的目的地址，而接收者也不必关心消息的发送地址，而只是根据消息的主题进行消息的收发。</li>
<li><strong>集群 (Cluster)</strong> - 为了简化点对点通讯模式中的系统配置，MQ 提供 Cluster(集群) 的解决方案。集群类似于一个域 (Domain)，集群内部的队列管理器之间通讯时，不需要两两之间建立消息通道，而是采用集群 (Cluster) 通道与其它成员通讯，从而大大简化了系统配置。此外，集群中的队列管理器之间能够自动进行负载均衡，当某一队列管理器出现故障时，其它队列管理器可以接管它的工作，从而大大提高系统的高可靠性。</li>
</ul>
<h2 id="5-常用-mq-对比"><a class="markdownIt-Anchor" href="#5-常用-mq-对比"></a> 5. 常用 MQ 对比</h2>
<table>
<thead>
<tr>
<th>特性</th>
<th>ActiveMQ</th>
<th>RabbitMQ</th>
<th>RocketMQ</th>
<th>Kafka</th>
</tr>
</thead>
<tbody>
<tr>
<td>单机吞吐量</td>
<td>万级，比 RocketMQ、Kafka 低一个数量级</td>
<td>同 ActiveMQ</td>
<td>10 万级，支撑高吞吐</td>
<td>10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td>
</tr>
<tr>
<td>topic 数量对吞吐量的影响</td>
<td></td>
<td></td>
<td>topic 可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic</td>
<td>topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源</td>
</tr>
<tr>
<td>时效性</td>
<td>ms 级</td>
<td>微秒级，这是 RabbitMQ 的一大特点，延迟最低</td>
<td>ms 级</td>
<td>延迟在 ms 级以内</td>
</tr>
<tr>
<td>可用性</td>
<td>高，基于主从架构实现高可用</td>
<td>同 ActiveMQ</td>
<td>非常高，分布式架构</td>
<td>非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td>
</tr>
<tr>
<td>消息可靠性</td>
<td>有较低的概率丢失数据</td>
<td>基本不丢</td>
<td>经过参数优化配置，可以做到 0 丢失</td>
<td>同 RocketMQ</td>
</tr>
<tr>
<td>功能支持</td>
<td>MQ 领域的功能极其完备</td>
<td>基于 erlang 开发，并发能力很强，性能极好，延时很低</td>
<td>MQ 功能较为完善，还是分布式的，扩展性好</td>
<td>功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用</td>
</tr>
</tbody>
</table>
<p>综上，各种对比之后，有如下建议：</p>
<ul>
<li>一般的业务系统要引入 MQ，最早大家都用 ActiveMQ，但是现在确实大家用的不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃，所以大家还是算了吧，我个人不推荐用这个了；</li>
<li>后来大家开始用 RabbitMQ，但是确实 erlang 语言阻止了大量的 Java 工程师去深入研究和掌控它，对公司而言，几乎处于不可控的状态，但是确实人家是开源的，比较稳定的支持，活跃度也高；</li>
<li>不过现在确实越来越多的公司会去用 RocketMQ，确实很不错，毕竟是阿里出品，但社区可能有突然黄掉的风险（目前 RocketMQ 已捐给 <a href="https://github.com/apache/rocketmq" target="_blank" rel="noopener">Apache</a>，但 GitHub 上的活跃度其实不算高）对自己公司技术实力有绝对自信的，推荐用 RocketMQ，否则回去老老实实用 RabbitMQ 吧，人家有活跃的开源社区，绝对不会黄。</li>
<li>所以<strong>中小型公司</strong>，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是不错的选择；<strong>大型公司</strong>，基础架构研发实力较强，用 RocketMQ 是很好的选择。</li>
<li>如果是<strong>大数据领域</strong>的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</li>
</ul>
<h2 id="6-jms"><a class="markdownIt-Anchor" href="#6-jms"></a> 6. JMS</h2>
<p>谈 MQ 就不得不提一下 JMS 。</p>
<p><strong>JMS（JAVA Message Service，java 消息服务）API 是一个消息服务的标准/规范，允许应用程序组件基于 JavaEE 平台创建、发送、接收和读取消息</strong>。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。</p>
<p>在 EJB 架构中，有消息 bean 可以无缝的与 JM 消息服务集成。在 J2EE 架构模式中，有消息服务者模式，用于实现消息与应用直接的解耦。</p>
<h3 id="61-消息模型"><a class="markdownIt-Anchor" href="#61-消息模型"></a> 6.1. 消息模型</h3>
<p>在 JMS 标准中，有两种消息模型：</p>
<ul>
<li>P2P(Point to Point)</li>
<li>Pub/Sub(Publish/Subscribe)</li>
</ul>
<h4 id="611-p2p-模式"><a class="markdownIt-Anchor" href="#611-p2p-模式"></a> 6.1.1. P2P 模式</h4>
<div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-2adc66e2367cd2c2.png"/></div>
P2P 模式包含三个角色：MQ（Queue），发送者(Sender)，接收者(Receiver)。每个消息都被发送到一个特定的队列，接收者从队列中获取消息。队列保留着消息，直到他们被消费或超时。
<p>P2P 的特点</p>
<ul>
<li>每个消息只有一个消费者（Consumer）(即一旦被消费，消息就不再在 MQ 中)</li>
<li>发送者和接收者之间在时间上没有依赖性，也就是说当发送者发送了消息之后，不管接收者有没有正在运行，它不会影响到消息被发送到队列</li>
<li>接收者在成功接收消息之后需向队列应答成功</li>
</ul>
<p>如果希望发送的每个消息都会被成功处理的话，那么需要 P2P 模式。</p>
<h4 id="612-pubsub-模式"><a class="markdownIt-Anchor" href="#612-pubsub-模式"></a> 6.1.2. Pub/sub 模式</h4>
<div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-12afe9581da889ea.png"/></div>
包含三个角色主题（Topic），发布者（Publisher），订阅者（Subscriber） 。多个发布者将消息发送到 Topic,系统将这些消息传递给多个订阅者。
<p>Pub/Sub 的特点</p>
<ul>
<li>每个消息可以有多个消费者</li>
<li>发布者和订阅者之间有时间上的依赖性。针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息。</li>
<li>为了消费消息，订阅者必须保持运行的状态。</li>
</ul>
<p>为了缓和这样严格的时间相关性，JMS 允许订阅者创建一个可持久化的订阅。这样，即使订阅者没有被激活（运行），它也能接收到发布者的消息。</p>
<p>如果希望发送的消息可以不被做任何处理、或者只被一个消息者处理、或者可以被多个消费者处理的话，那么可以采用 Pub/Sub 模型。</p>
<h3 id="62-消息消费"><a class="markdownIt-Anchor" href="#62-消息消费"></a> 6.2. 消息消费</h3>
<p>在 JMS 中，消息的产生和消费都是异步的。对于消费来说，JMS 的消息者可以通过两种方式来消费消息。</p>
<ul>
<li><strong>同步</strong> - 订阅者或接收者通过 <code>receive</code> 方法来接收消息，<code>receive</code> 方法在接收到消息之前（或超时之前）将一直阻塞；</li>
<li><strong>异步</strong> - 订阅者或接收者可以注册为一个消息监听器。当消息到达之后，系统自动调用监听器的 <code>onMessage</code> 方法。</li>
</ul>
<p><code>JNDI</code> - Java 命名和目录接口,是一种标准的 Java 命名系统接口。可以在网络上查找和访问服务。通过指定一个资源名称，该名称对应于数据库或命名服务中的一个记录，同时返回资源连接建立所必须的信息。</p>
<p>JNDI 在 JMS 中起到查找和访问发送目标或消息来源的作用。</p>
<h3 id="63-jms-编程模型"><a class="markdownIt-Anchor" href="#63-jms-编程模型"></a> 6.3. JMS 编程模型</h3>
<h4 id="631-connectionfactory"><a class="markdownIt-Anchor" href="#631-connectionfactory"></a> 6.3.1. ConnectionFactory</h4>
<p>创建 Connection 对象的工厂，针对两种不同的 jms 消息模型，分别有 QueueConnectionFactory 和 TopicConnectionFactory 两种。可以通过 JNDI 来查找 ConnectionFactory 对象。</p>
<h4 id="632-destination"><a class="markdownIt-Anchor" href="#632-destination"></a> 6.3.2. Destination</h4>
<p>Destination 的意思是消息生产者的消息发送目标或者说消息消费者的消息来源。对于消息生产者来说，它的 Destination 是某个队列（Queue）或某个主题（Topic）;对于消息消费者来说，它的 Destination 也是某个队列或主题（即消息来源）。</p>
<p>所以，Destination 实际上就是两种类型的对象：Queue、Topic。可以通过 JNDI 来查找 Destination。</p>
<h4 id="633-3-connection"><a class="markdownIt-Anchor" href="#633-3-connection"></a> 6.3.3. (3) Connection</h4>
<p>Connection 表示在客户端和 JMS 系统之间建立的链接（对 TCP/IP socket 的包装）。Connection 可以产生一个或多个 Session。跟 ConnectionFactory 一样，Connection 也有两种类型：QueueConnection 和 TopicConnection。</p>
<h4 id="634-4-session"><a class="markdownIt-Anchor" href="#634-4-session"></a> 6.3.4. (4) Session</h4>
<p>Session 是操作消息的接口。可以通过 session 创建生产者、消费者、消息等。Session 提供了事务的功能。当需要使用 session 发送/接收多个消息时，可以将这些发送/接收动作放到一个事务中。同样，也分 QueueSession 和 TopicSession。</p>
<h4 id="635-消息的生产者"><a class="markdownIt-Anchor" href="#635-消息的生产者"></a> 6.3.5. 消息的生产者</h4>
<p>消息生产者由 Session 创建，并用于将消息发送到 Destination。同样，消息生产者分两种类型：QueueSender 和 TopicPublisher。可以调用消息生产者的方法（send 或 publish 方法）发送消息。</p>
<h4 id="636-消息消费者"><a class="markdownIt-Anchor" href="#636-消息消费者"></a> 6.3.6. 消息消费者</h4>
<p>消息消费者由 Session 创建，用于接收被发送到 Destination 的消息。两种类型：QueueReceiver 和 TopicSubscriber。可分别通过 session 的 createReceiver(Queue)或 createSubscriber(Topic)来创建。当然，也可以 session 的 creatDurableSubscriber 方法来创建持久化的订阅者。</p>
<h4 id="637-messagelistener"><a class="markdownIt-Anchor" href="#637-messagelistener"></a> 6.3.7. MessageListener</h4>
<p>消息监听器。如果注册了消息监听器，一旦消息到达，将自动调用监听器的 onMessage 方法。EJB 中的 MDB（Message-Driven Bean）就是一种 MessageListener。</p>
<p>深入学习 JMS 对掌握 JAVA 架构，EJB 架构有很好的帮助，消息中间件也是大型分布式系统必须的组件。本次分享主要做全局性介绍，具体的深入需要大家学习，实践，总结，领会。</p>
<h2 id="7-参考资料"><a class="markdownIt-Anchor" href="#7-参考资料"></a> 7. 参考资料</h2>
<ul>
<li><a href="https://www.cnblogs.com/itfly8/p/5155983.html" target="_blank" rel="noopener">大型网站架构系列：分布式 MQ（一）</a></li>
<li><a href="https://www.cnblogs.com/itfly8/p/5156155.html" target="_blank" rel="noopener">大型网站架构系列：MQ（二）</a></li>
<li><a href="https://www.jianshu.com/p/453c6e7ff81c" target="_blank" rel="noopener">分布式开放 MQ(RocketMQ)的原理与实践</a></li>
<li><a href="https://juejin.im/entry/5a0abfb5f265da43062a4a91" target="_blank" rel="noopener">阿里 RocketMQ 优势对比</a></li>
<li><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/mq-interview.md" target="_blank" rel="noopener">advanced-java 之 MQ</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/distributed/cache-theory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/distributed/cache-theory/" class="post-title-link" itemprop="url">缓存基本原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-27 15:36:00" itemprop="dateCreated datePublished" datetime="2019-06-27T15:36:00+08:00">2019-06-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-02 18:07:05" itemprop="dateModified" datetime="2020-02-02T18:07:05+08:00">2020-02-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/distributed/cache-theory/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="distributed/cache-theory/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="缓存基本原理"><a class="markdownIt-Anchor" href="#缓存基本原理"></a> 缓存基本原理</h1>
<blockquote>
<p>📦 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#1-%E7%BC%93%E5%AD%98%E6%A6%82%E8%BF%B0">1. 缓存概述</a>
<ul>
<li><a href="#11-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98">1.1. 什么是缓存</a></li>
<li><a href="#12-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%95%E5%85%A5%E7%BC%93%E5%AD%98">1.2. 为什么引入缓存</a></li>
<li><a href="#13-%E7%BC%93%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86">1.3. 缓存的基本原理</a></li>
<li><a href="#14-%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95">1.4. 缓存淘汰算法</a></li>
<li><a href="#15-%E7%BC%93%E5%AD%98%E7%9A%84%E5%88%86%E7%B1%BB">1.5. 缓存的分类</a></li>
<li><a href="#16-%E7%BC%93%E5%AD%98%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84">1.6. 缓存整体架构</a></li>
</ul>
</li>
<li><a href="#2-cdn-%E7%BC%93%E5%AD%98">2. CDN 缓存</a>
<ul>
<li><a href="#21-cdn-%E5%8E%9F%E7%90%86">2.1. CDN 原理</a></li>
<li><a href="#22-cdn-%E7%89%B9%E7%82%B9">2.2. CDN 特点</a></li>
</ul>
</li>
<li><a href="#3-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98">3. 反向代理缓存</a>
<ul>
<li><a href="#31-%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86">3.1. 缓存原理</a></li>
<li><a href="#32-%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98%E6%AF%94%E8%BE%83">3.2. 代理缓存比较</a></li>
</ul>
</li>
<li><a href="#4-%E8%BF%9B%E7%A8%8B%E5%86%85%E7%BC%93%E5%AD%98">4. 进程内缓存</a>
<ul>
<li><a href="#41-concurrenthashmap">4.1. ConcurrentHashMap</a></li>
<li><a href="#42-lruhashmap">4.2. LRUHashMap</a></li>
<li><a href="#43-guava-cache">4.3. Guava Cache</a></li>
<li><a href="#44-caffeine">4.4. Caffeine</a></li>
<li><a href="#45-%E9%80%89%E6%8B%A9%E8%BF%9B%E7%A8%8B%E5%86%85%E7%BC%93%E5%AD%98">4.5. 选择进程内缓存</a></li>
</ul>
</li>
<li><a href="#5-%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98">5. 分布式缓存</a>
<ul>
<li><a href="#51-memcache">5.1. Memcache</a></li>
<li><a href="#52-redis">5.2. Redis</a></li>
<li><a href="#53-%E9%80%89%E6%8B%A9%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98">5.3. 选择分布式缓存</a></li>
</ul>
</li>
<li><a href="#6-%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98">6. 多级缓存</a>
<ul>
<li><a href="#61-%E4%BD%BF%E7%94%A8%E8%BF%9B%E7%A8%8B%E5%86%85%E7%BC%93%E5%AD%98">6.1. 使用进程内缓存</a></li>
<li><a href="#62-%E4%BD%BF%E7%94%A8%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98">6.2. 使用分布式缓存</a></li>
<li><a href="#63-%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98">6.3. 使用多级缓存</a></li>
</ul>
</li>
<li><a href="#7-%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98">7. 缓存问题</a>
<ul>
<li><a href="#71-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9">7.1. 缓存雪崩</a></li>
<li><a href="#72-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F">7.2. 缓存穿透</a></li>
<li><a href="#73-%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF">7.3. 缓存击穿</a></li>
<li><a href="#74-%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0">7.4. 缓存更新</a></li>
<li><a href="#75-%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD">7.5. 缓存预热</a></li>
<li><a href="#76-%E7%BC%93%E5%AD%98%E9%99%8D%E7%BA%A7">7.6. 缓存降级</a></li>
</ul>
</li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="1-缓存概述"><a class="markdownIt-Anchor" href="#1-缓存概述"></a> 1. 缓存概述</h2>
<h3 id="11-什么是缓存"><a class="markdownIt-Anchor" href="#11-什么是缓存"></a> 1.1. 什么是缓存</h3>
<p><strong>缓存就是数据交换的缓冲区</strong>。</p>
<p>缓存是用于存储数据的硬件或软件的组成部分，以使得后续更快访问相应的数据。缓存中的数据可能是提前计算好的结果、数据的副本等。典型的应用场景：有 cpu cache, 磁盘 cache 等。本文中提及到缓存主要是指互联网应用中所使用的缓存组件。</p>
<h3 id="12-为什么引入缓存"><a class="markdownIt-Anchor" href="#12-为什么引入缓存"></a> 1.2. 为什么引入缓存</h3>
<p>传统的后端业务场景中，访问量以及对响应时间的要求均不高，通常只使用数据库即可满足要求。这种架构简单，便于快速部署，很多网站发展初期均考虑使用这种架构。但是随着访问量的上升，以及对响应时间的要求提升，一个数据库服务已无法再满足要求。这时候通常会考虑数据库拆分(sharding)、读写分离、甚至硬件升级(SSD)等以满足新的业务需求。但是这种方式仍然会面临很多问题，主要体现在：</p>
<ul>
<li>性能提升有限，很难达到数量级上的提升，尤其在互联网业务场景下，随着网站的发展，访问量经常会面临十倍、百倍的上涨。</li>
<li>成本高昂，为了承载 N 倍的访问量，通常需要 N 倍的机器，这个代价难以接受。</li>
</ul>
<p>在数据层引入缓存，有以下几个好处：</p>
<ul>
<li>提升数据读取速度。</li>
<li>提升系统扩展能力，通过扩展缓存，提升系统承载能力。</li>
<li>降低存储成本，Cache+DB 的方式可以承担原有需要多台 DB 才能承担的请求量，节省机器成本。</li>
</ul>
<p>根据业务场景，通常缓存有以下几种使用方式：</p>
<ul>
<li>懒汉式(读时触发)：写入 DB 后, 然后把相关的数据也写入 Cache。</li>
<li>饥饿式(写时触发)：先查询 DB 里的数据, 然后把相关的数据写入 Cache。</li>
<li>定期刷新：适合周期性的跑数据的任务，或者列表型的数据，而且不要求绝对实时性。</li>
</ul>
<h3 id="13-缓存的基本原理"><a class="markdownIt-Anchor" href="#13-缓存的基本原理"></a> 1.3. 缓存的基本原理</h3>
<ol>
<li>将数据写入/读取速度更快的存储（设备）；</li>
<li>将数据缓存到离应用最近的位置；</li>
<li>将数据缓存到离用户最近的位置。</li>
</ol>
<h3 id="14-缓存淘汰算法"><a class="markdownIt-Anchor" href="#14-缓存淘汰算法"></a> 1.4. 缓存淘汰算法</h3>
<p>常见的缓存淘汰算法有以下几种：</p>
<ul>
<li><strong>FIFO</strong> - 先进先出，在这种淘汰算法中，先进入缓存的会先被淘汰。这种可谓是最简单的了，但是会导致我们命中率很低。试想一下我们如果有个访问频率很高的数据是所有数据第一个访问的，而那些不是很高的是后面再访问的，那这样就会把我们的首个数据但是他的访问频率很高给挤出。</li>
<li><strong>LRU</strong> - 最近最少使用算法。在这种算法中避免了上面的问题，每次访问数据都会将其放在我们的队尾，如果需要淘汰数据，就只需要淘汰队首即可。但是这个依然有个问题，如果有个数据在 1 个小时的前 59 分钟访问了 1 万次(可见这是个热点数据),再后一分钟没有访问这个数据，但是有其他的数据访问，就导致了我们这个热点数据被淘汰。</li>
<li><strong>LFU</strong> - 最近最少频率使用。在这种算法中又对上面进行了优化，利用额外的空间记录每个数据的使用频率，然后选出频率最低进行淘汰。这样就避免了 LRU 不能处理时间段的问题。</li>
</ul>
<p>这三种缓存淘汰算法，实现复杂度一个比一个高，同样的命中率也是一个比一个好。而我们一般来说选择的方案居中即可，即实现成本不是太高，而命中率也还行的 LRU。</p>
<h3 id="15-缓存的分类"><a class="markdownIt-Anchor" href="#15-缓存的分类"></a> 1.5. 缓存的分类</h3>
<p>在分布式系统中，缓存的应用非常广泛，从部署角度有以下几个方面的缓存应用。</p>
<ul>
<li><strong>CDN 缓存</strong> - 存放 HTML、CSS、JS 等静态资源。</li>
<li><strong>反向代理缓存</strong> - 动静分离，只缓存用户请求的静态资源。</li>
<li><strong>进程内缓存</strong> - 缓存应用字典等常用数据。</li>
<li><strong>分布式缓存</strong> - 缓存数据库中的热点数据。</li>
</ul>
<h3 id="16-缓存整体架构"><a class="markdownIt-Anchor" href="#16-缓存整体架构"></a> 1.6. 缓存整体架构</h3>
<p>通常，网站的缓存整体架构如下图所示：</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/java/javaweb/technology/cache/缓存整体架构.png!zp" /></div>
请求过程：
<ol>
<li>浏览器向客户端发起请求，如果 CDN 有缓存则直接返回；</li>
<li>如果 CDN 无缓存，则访问反向代理服务器；</li>
<li>如果反向代理服务器有缓存则直接返回；</li>
<li>如果反向代理服务器无缓存或动态请求，则访问应用服务器；</li>
<li>应用服务器访问进程内缓存；如果有缓存，则返回代理服务器，并缓存数据；（动态请求不缓存）</li>
<li>如果进程内缓存无数据，则读取分布式缓存；并返回应用服务器；应用服务器将数据缓存到本地缓存（部分）；</li>
<li>如果分布式缓存无数据，则应用程序读取数据库数据，并放入分布式缓存；</li>
</ol>
<h2 id="2-cdn-缓存"><a class="markdownIt-Anchor" href="#2-cdn-缓存"></a> 2. CDN 缓存</h2>
<blockquote>
<p><strong>CDN 将数据缓存到离用户物理距离最近的服务器，使得用户可以就近获取请求内容。CDN 一般缓存静态资源文件（页面，脚本，图片，视频，文件等）</strong>。</p>
<p>国内网络异常复杂，跨运营商的网络访问会很慢。为了解决跨运营商或各地用户访问问题，可以在重要的城市，部署 CDN 应用。使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。</p>
</blockquote>
<div align="center"><img src="http://dunwu.test.upcdn.net/snap/1559138689425.png!zp"/></div>
### 2.1. CDN 原理
<p>CDN 的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。</p>
<p>（1）未部署 CDN 应用前的网络路径：</p>
<ul>
<li>请求：本机网络（局域网）=&gt; 运营商网络 =&gt; 应用服务器机房</li>
<li>响应：应用服务器机房 =&gt; 运营商网络 =&gt; 本机网络（局域网）</li>
</ul>
<p>在不考虑复杂网络的情况下，从请求到响应需要经过 3 个节点，6 个步骤完成一次用户访问操作。</p>
<p>（2）部署 CDN 应用后网络路径：</p>
<ul>
<li>请求：本机网络（局域网） =&gt; 运营商网络</li>
<li>响应：运营商网络 =&gt; 本机网络（局域网）</li>
</ul>
<p>在不考虑复杂网络的情况下，从请求到响应需要经过 2 个节点，2 个步骤完成一次用户访问操作。</p>
<p>与不部署 CDN 服务相比，减少了 1 个节点，4 个步骤的访问。极大的提高的系统的响应速度。</p>
<h3 id="22-cdn-特点"><a class="markdownIt-Anchor" href="#22-cdn-特点"></a> 2.2. CDN 特点</h3>
<ul>
<li><strong>优点</strong>
<ul>
<li><strong>本地 Cache 加速</strong> - 提升访问速度，尤其含有大量图片和静态页面站点；</li>
<li><strong>镜像服务</strong> - 消除了不同运营商之间互联的瓶颈造成的影响，实现了跨运营商的网络加速，保证不同网络中的用户都能得到良好的访问质量；</li>
<li><strong>远程加速</strong> - 远程访问用户根据 DNS 负载均衡技术智能自动选择 Cache 服务器，选择最快的 Cache 服务器，加快远程访问的速度；</li>
<li><strong>带宽优化</strong> - 自动生成服务器的远程 Mirror（镜像）cache 服务器，远程用户访问时从 cache 服务器上读取数据，减少远程访问的带宽、分担网络流量、减轻原站点 WEB 服务器负载等功能。</li>
<li><strong>集群抗攻击</strong> - 广泛分布的 CDN 节点加上节点之间的智能冗余机制，可以有效地预防黑客入侵以及降低各种 D.D.o.S 攻击对网站的影响，同时保证较好的服务质量。</li>
</ul>
</li>
<li><strong>缺点</strong>
<ul>
<li><strong>不适宜缓存动态资源</strong>
<ul>
<li>解决方案：主要缓存静态资源，动态资源建立多级缓存或准实时同步；</li>
</ul>
</li>
<li><strong>存在数据的一致性问题</strong>
<ul>
<li>解决方案（主要是在性能和数据一致性二者间寻找一个平衡）
<ul>
<li>设置缓存失效时间（1 个小时，过期后同步数据）。</li>
<li>针对资源设置版本号。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-反向代理缓存"><a class="markdownIt-Anchor" href="#3-反向代理缓存"></a> 3. 反向代理缓存</h2>
<blockquote>
<p><strong>反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</strong></p>
</blockquote>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/web/nginx/reverse-proxy.png!zp"/></div>
### 3.1. 缓存原理
<p>反向代理位于应用服务器同一网络，处理所有对 WEB 服务器的请求。</p>
<p>反向代理缓存的原理：</p>
<ul>
<li>如果用户请求的页面在代理服务器上有缓存的话，代理服务器直接将缓存内容发送给用户。</li>
<li>如果没有缓存则先向 WEB 服务器发出请求，取回数据，本地缓存后再发送给用户。</li>
</ul>
<p>这种方式通过降低向 WEB 服务器的请求数，从而降低了 WEB 服务器的负载。</p>
<p><strong>反向代理缓存一般针对的是静态资源，而将动态资源请求转发到应用服务器处理</strong>。常用的缓存应用服务器有 Varnish，Ngnix，Squid。</p>
<h3 id="32-代理缓存比较"><a class="markdownIt-Anchor" href="#32-代理缓存比较"></a> 3.2. 代理缓存比较</h3>
<p>常用的代理缓存有 Varnish，Squid，Ngnix，简单比较如下：</p>
<ul>
<li>Varnish 和 Squid 是专业的 cache 服务，Ngnix 需要第三方模块支持；</li>
<li>Varnish 采用内存型缓存，避免了频繁在内存、磁盘中交换文件，性能比 Squid 高；</li>
<li>Varnish 由于是内存 cache，所以对小文件如 css、js、小图片的支持很棒，后端的持久化缓存可以采用的是 Squid 或 ATS；</li>
<li>Squid 功能全而大，适合于各种静态的文件缓存，一般会在前端挂一个 HAProxy 或 Ngnix 做负载均衡跑多个实例；</li>
<li>Nginx 采用第三方模块 ncache 做的缓冲，性能基本达到 Varnish，一般作为反向代理使用，可以实现简单的缓存。</li>
</ul>
<h2 id="4-进程内缓存"><a class="markdownIt-Anchor" href="#4-进程内缓存"></a> 4. 进程内缓存</h2>
<blockquote>
<p>进程内缓存是指应用内部的缓存，标准的分布式系统，一般有多级缓存构成。本地缓存是离应用最近的缓存，一般可以将数据缓存到硬盘或内存。</p>
</blockquote>
<ul>
<li><code>硬盘缓存</code> - 将数据缓存到硬盘到，读取时从硬盘读取。原理是直接读取本机文件，减少了网络传输消耗，比通过网络读取数据库速度更快。可以应用在对速度要求不是很高，但需要大量缓存存储的场景。</li>
<li><code>内存缓存</code> - 直接将数据存储到本机内存中，通过程序直接维护缓存对象，是访问速度最快的方式。</li>
</ul>
<p>常见的本地缓存实现方案：HashMap、Guava Cache、Caffeine、Ehcache。</p>
<h3 id="41-concurrenthashmap"><a class="markdownIt-Anchor" href="#41-concurrenthashmap"></a> 4.1. ConcurrentHashMap</h3>
<p>最简单的进程内缓存可以通过 JDK 自带的 <code>HashMap</code> 或 <code>ConcurrentHashMap</code> 实现。</p>
<p>适用场景：不需要淘汰的缓存数据。</p>
<p>缺点：无法进行缓存淘汰，内存会无限制的增长。</p>
<h3 id="42-lruhashmap"><a class="markdownIt-Anchor" href="#42-lruhashmap"></a> 4.2. LRUHashMap</h3>
<p>可以通过继承 <code>LinkedHashMap</code> 来实现一个简单的 <code>LRUHashMap</code>。重写 <code>removeEldestEntry</code> 方法，即可完成一个简单的最近最少使用算法。</p>
<ul>
<li>缺点：
<ul>
<li>锁竞争严重，性能比较低。</li>
<li>不支持过期时间</li>
<li>不支持自动刷新</li>
</ul>
</li>
</ul>
<h3 id="43-guava-cache"><a class="markdownIt-Anchor" href="#43-guava-cache"></a> 4.3. Guava Cache</h3>
<p>解决了 <code>LRUHashMap</code> 中的几个缺点。</p>
<p>Guava Cache 采用了类似 <code>ConcurrentHashMap</code> 的思想，分段加锁，减少锁竞争。</p>
<p>Guava Cache 对于过期的 Entry 并没有马上过期(也就是并没有后台线程一直在扫)，而是通过进行读写操作的时候进行过期处理，这样做的好处是避免后台线程扫描的时候进行全局加锁。</p>
<p>直接通过查询，判断其是否满足刷新条件，进行刷新。</p>
<h3 id="44-caffeine"><a class="markdownIt-Anchor" href="#44-caffeine"></a> 4.4. Caffeine</h3>
<p>Caffeine 实现了 W-TinyLFU(LFU+LRU 算法的变种)，其命中率和读写吞吐量大大优于 Guava Cache。</p>
<p>其实现原理较复杂，可以参考<a href="https://juejin.im/post/5b7593496fb9a009b62904fa#comment" target="_blank" rel="noopener">你应该知道的缓存进化史</a>。</p>
<h3 id="45-选择进程内缓存"><a class="markdownIt-Anchor" href="#45-选择进程内缓存"></a> 4.5. 选择进程内缓存</h3>
<table>
<thead>
<tr>
<th>比较项</th>
<th>ConcurrentHashMap</th>
<th>LRUMap</th>
<th>Ehcache</th>
<th>Guava Cache</th>
<th>Caffeine</th>
</tr>
</thead>
<tbody>
<tr>
<td>读写性能</td>
<td>很好，分段锁</td>
<td>一般，全局加锁</td>
<td>好</td>
<td>好，需要做淘汰操作</td>
<td>很好</td>
</tr>
<tr>
<td>淘汰算法</td>
<td>无</td>
<td>LRU，一般</td>
<td>支持多种淘汰算法,LRU,LFU,FIFO</td>
<td>LRU，一般</td>
<td>W-TinyLFU, 很好</td>
</tr>
<tr>
<td>功能丰富程度</td>
<td>功能比较简单</td>
<td>功能比较单一</td>
<td>功能很丰富</td>
<td>功能很丰富，支持刷新和虚引用等</td>
<td>功能和 Guava Cache 类似</td>
</tr>
<tr>
<td>工具大小</td>
<td>jdk 自带类，很小</td>
<td>基于 LinkedHashMap，较小</td>
<td>很大，最新版本 1.4MB</td>
<td>是 Guava 工具类中的一个小部分，较小</td>
<td>一般，最新版本 644KB</td>
</tr>
<tr>
<td>是否持久化</td>
<td>否</td>
<td>否</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>是否支持集群</td>
<td>否</td>
<td>否</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
</tbody>
</table>
<ul>
<li><strong><code>ConcurrentHashMap</code></strong> - 比较适合缓存比较固定不变的元素，且缓存的数量较小的。虽然从上面表格中比起来有点逊色，但是其由于是 JDK 自带的类，在各种框架中依然有大量的使用，比如我们可以用来缓存我们反射的 Method，Field 等等；也可以缓存一些链接，防止其重复建立。在 Caffeine 中也是使用的 <code>ConcurrentHashMap</code> 来存储元素。</li>
<li><strong><code>LRUMap</code></strong> - 如果不想引入第三方包，又想使用淘汰算法淘汰数据，可以使用这个。</li>
<li><strong><code>Ehcache</code></strong> - 由于其 jar 包很大，较重量级。对于需要持久化和集群的一些功能的，可以选择 Ehcache。笔者没怎么使用过这个缓存，如果要选择的话，可以选择分布式缓存来替代 Ehcache。</li>
<li><strong><code>Guava Cache</code></strong> - Guava 这个 jar 包在很多 Java 应用程序中都有大量的引入，所以很多时候其实是直接用就好了，并且其本身是轻量级的而且功能较为丰富，在不了解 Caffeine 的情况下可以选择 Guava Cache。</li>
<li><strong><code>Caffeine</code></strong> - 其在命中率，读写性能上都比 Guava Cache 好很多，并且其 API 和 Guava cache 基本一致，甚至会多一点。在真实环境中使用 Caffeine，取得过不错的效果。</li>
</ul>
<p>总结一下：如果不需要淘汰算法则选择 <code>ConcurrentHashMap</code>，如果需要淘汰算法和一些丰富的 API，推荐选择 Caffeine。</p>
<h2 id="5-分布式缓存"><a class="markdownIt-Anchor" href="#5-分布式缓存"></a> 5. 分布式缓存</h2>
<blockquote>
<p><strong>分布式缓存解决了进程内缓存最大的问题：如果应用是分布式系统，节点之间无法共享彼此的进程内缓存</strong>。</p>
<p>分布式缓存的应用场景：</p>
<ul>
<li>缓存经过复杂计算得到的数据</li>
<li>缓存系统中频繁访问的热点数据，减轻数据库压力</li>
</ul>
</blockquote>
<p>不同分布式缓存的实现原理往往有比较大的差异。本文主要针对 Memcached 和 Redis 进行说明。</p>
<h3 id="51-memcache"><a class="markdownIt-Anchor" href="#51-memcache"></a> 5.1. Memcache</h3>
<blockquote>
<p><a href="https://memcached.org/" target="_blank" rel="noopener">Memcache</a> 是一个高性能，分布式内存对象缓存系统，通过在内存里维护一个统一的巨大的 hash 表，它能够用来存储各种格式的数据，包括图像、视频、文件以及数据库检索的结果等。</p>
<p>简单的说就是：将数据缓存到内存中，然后从内存中读取，从而大大提高读取速度。</p>
</blockquote>
<h4 id="memcache-特性"><a class="markdownIt-Anchor" href="#memcache-特性"></a> Memcache 特性</h4>
<ul>
<li><strong>使用物理内存作为缓存区，可独立运行在服务器上</strong>。每个进程最大 2G，如果想缓存更多的数据，可以开辟更多的 Memcache 进程（不同端口）或者使用分布式 Memcache 进行缓存，将数据缓存到不同的物理机或者虚拟机上。</li>
<li><strong>使用 key-value 的方式来存储数据</strong>。这是一种单索引的结构化数据组织形式，可使数据项查询时间复杂度为 O(1)。</li>
<li><strong>协议简单，基于文本行的协议</strong>。直接通过 telnet 在 Memcached 服务器上可进行存取数据操作，简单，方便多种缓存参考此协议；</li>
<li><strong>基于 libevent 高性能通信</strong>。Libevent 是一套利用 C 开发的程序库，它将 BSD 系统的 kqueue,Linux 系统的 epoll 等事件处理功能封装成一个接口，与传统的 select 相比，提高了性能。</li>
<li><strong>分布式能力取决于 Memcache 客户端，服务器之间互不通信</strong>。各个 Memcached 服务器之间互不通信，各自独立存取数据，不共享任何信息。服务器并不具有分布式功能，分布式部署取决于 Memcached 客户端。</li>
<li><strong>采用 LRU 缓存淘汰策略</strong>。在 Memcached 内存储数据项时，可以指定它在缓存的失效时间，默认为永久。当 Memcached 服务器用完分配的内时，失效的数据被首先替换，然后也是最近未使用的数据。在 LRU 中，Memcached 使用的是一种 Lazy Expiration 策略，自己不会监控存入的 key/vlue 对是否过期，而是在获取 key 值时查看记录的时间戳，检查 key/value 对空间是否过期，这样可减轻服务器的负载。</li>
<li><strong>内置了一套高效的内存管理算法</strong>。这套内存管理效率很高，而且不会造成内存碎片，但是它最大的缺点就是会导致空间浪费。当内存满后，通过 LRU 算法自动删除不使用的缓存。</li>
<li><strong>不支持持久化</strong>。Memcached 没有考虑数据的容灾问题，重启服务，所有数据会丢失。</li>
</ul>
<h4 id="memcache-工作原理"><a class="markdownIt-Anchor" href="#memcache-工作原理"></a> Memcache 工作原理</h4>
<p>（1）内存管理</p>
<p>Memcached 利用 <strong>slab allocation</strong> 机制来分配和管理内存，它按照预先规定的大小，将分配的内存分割成特定长度的内存块，再把尺寸相同的内存块分成组，数据在存放时，根据键值 大小去匹配 slab 大小，找就近的 slab 存放，所以存在空间浪费现象。</p>
<p>这套内存管理效率很高，而且不会造成内存碎片，但是它最大的缺点就是会导致空间浪费。</p>
<p>（2）缓存淘汰策略</p>
<p>Memcached 的缓存淘汰策略是 <strong>LRU</strong> + 到期失效策略。</p>
<p>当你在 Memcached 内存储数据项时，你有可能会指定它在缓存的失效时间，默认为永久。当 Memcached 服务器用完分配的内时，失效的数据被首先替换，然后是最近未使用的数据。</p>
<p>在 LRU 中，Memcached 使用的是一种 Lazy Expiration 策略：<strong>Memcached 不会监控存入的 key/vlue 对是否过期</strong>，而是在获取 key 值时查看记录的时间戳，<strong>检查 key/value 对空间是否过期</strong>，这样可减轻服务器的负载。</p>
<p>（3）分区</p>
<p>Memcached 服务器之间彼此不通信，它的分布式能力是依赖客户端来实现。</p>
<p>具体来说，就是在客户端实现一种算法，根据 key 来计算出数据应该向哪个服务器节点读/写。</p>
<p>而这种选取集群节点的算法常见的有三种：</p>
<ul>
<li><strong>哈希取余算法</strong> - 使用公式：<code>hash（key）% N</code> 计算出 <strong>哈希值</strong> 来决定数据映射到哪一个节点。</li>
<li><strong>一致性哈希算法</strong> - 可以很好的解决 <strong>稳定性问题</strong>，可以将所有的 <strong>存储节点</strong> 排列在 <strong>首尾相接</strong> 的 <code>Hash</code> 环上，每个 <code>key</code> 在计算 <code>Hash</code> 后会 <strong>顺时针</strong> 找到 <strong>临接</strong> 的 <strong>存储节点</strong> 存放。而当有节点 <strong>加入</strong> 或 <strong>退出</strong> 时，仅影响该节点在 <code>Hash</code> 环上 <strong>顺时针相邻</strong> 的 <strong>后续节点</strong>。</li>
<li><strong>虚拟 Hash 槽算法</strong> - 使用 <strong>分散度良好</strong> 的 <strong>哈希函数</strong> 把所有数据 <strong>映射</strong> 到一个 <strong>固定范围</strong> 的 <strong>整数集合</strong> 中，整数定义为 <strong>槽</strong>（<code>slot</code>），这个范围一般 <strong>远远大于</strong> 节点数。<strong>槽</strong> 是集群内 <strong>数据管理</strong> 和 <strong>迁移</strong> 的 <strong>基本单位</strong>。采用 <strong>大范围槽</strong> 的主要目的是为了方便 <strong>数据拆分</strong> 和 <strong>集群扩展</strong>。每个节点会负责 <strong>一定数量的槽</strong>。</li>
</ul>
<h3 id="52-redis"><a class="markdownIt-Anchor" href="#52-redis"></a> 5.2. Redis</h3>
<blockquote>
<p>Redis 是一个开源（BSD 许可）的，基于内存的，多数据结构存储系统。可以用作数据库、缓存和消息中间件。</p>
<p>Redis 还可以使用客户端分片来扩展写性能。内置了 复制（replication），LUA 脚本（Lua scripting），LRU 驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis 哨兵（Sentinel）和自动分区（Cluster）提供高可用性（high availability）。</p>
</blockquote>
<h4 id="redis-特性"><a class="markdownIt-Anchor" href="#redis-特性"></a> Redis 特性</h4>
<ul>
<li>
<p>支持多种数据类型 - string、hash、list、set、sorted set。</p>
</li>
<li>
<p>支持多种数据淘汰策略</p>
<ul>
<li><strong>volatile-lru</strong> - 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</li>
<li><strong>volatile-ttl</strong> - 从已设置过期时间的数据集中挑选将要过期的数据淘汰</li>
<li><strong>volatile-random</strong> - 从已设置过期时间的数据集中任意选择数据淘汰</li>
<li><strong>allkeys-lru</strong> - 从所有数据集中挑选最近最少使用的数据淘汰</li>
<li><strong>allkeys-random</strong> - 从所有数据集中任意选择数据进行淘汰</li>
<li><strong>noeviction</strong> - 禁止驱逐数据</li>
</ul>
</li>
<li>
<p>提供两种持久化方式 - RDB 和 AOF</p>
</li>
<li>
<p>通过 Redis cluster 提供集群模式。</p>
</li>
</ul>
<h4 id="redis-原理"><a class="markdownIt-Anchor" href="#redis-原理"></a> Redis 原理</h4>
<ul>
<li>缓存淘汰
<ul>
<li>Redis 有两种数据淘汰实现
<ul>
<li>消极方式 - 访问 Redis key 时，如果发现它已经失效，则删除它</li>
<li>积极方式 - 周期性从设置了失效时间的 key 中，根据淘汰策略，选择一部分失效的 key 进行删除。</li>
</ul>
</li>
</ul>
</li>
<li>分区
<ul>
<li>Redis Cluster 集群包含 16384 个虚拟 Hash 槽，它通过一个高效的算法来计算 key 属于哪个 Hash 槽。</li>
<li>Redis Cluster 支持请求分发 - 节点在接到一个命令请求时，会先检测这个命令请求要处理的键所在的槽是否由自己负责，如果不是的话，节点将向客户端返回一个 MOVED 错误，MOVED 错误携带的信息可以指引客户端将请求重定向至正在负责相关槽的节点。</li>
</ul>
</li>
<li>主从复制
<ul>
<li>Redis 2.8 后支持异步复制。它有两种模式：
<ul>
<li><code>完整重同步（full resychronization）</code> - 用于初次复制。执行步骤与 <code>SYNC</code> 命令基本一致。</li>
<li><code>部分重同步（partial resychronization）</code> - 用于断线后重复制。如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只需接收并执行这些写命令，即可将主从服务器的数据库状态保持一致。</li>
</ul>
</li>
<li>集群中每个节点都会定期向集群中的其他节点发送 PING 消息，以此来检测对方是否在线。</li>
<li>如果一个主节点被认为下线，则在其从节点中，根据 Raft 算法，选举出一个节点，升级为主节点。</li>
</ul>
</li>
<li>数据一致性
<ul>
<li>Redis 不保证强一致性，因为这会使得集群性能大大降低。</li>
<li>Redis 是通过异步复制来实现最终一致性。</li>
</ul>
</li>
</ul>
<h3 id="53-选择分布式缓存"><a class="markdownIt-Anchor" href="#53-选择分布式缓存"></a> 5.3. 选择分布式缓存</h3>
<p>不同的分布式缓存功能特性和实现原理方面有很大的差异，因此他们所适应的场景也有所不同。</p>
<p>这里选取三个比较出名的分布式缓存（MemCache，Redis，Tair）来作为比较：</p>
<table>
<thead>
<tr>
<th>比较项</th>
<th>MemCache</th>
<th>Redis</th>
<th>Tair</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据结构</td>
<td>只支持简单的 Key-Value 结构</td>
<td>String,Hash, List, Set, Sorted Set</td>
<td>String,HashMap, List，Set</td>
</tr>
<tr>
<td>持久化</td>
<td>不支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>容量大小</td>
<td>数据纯内存，数据存储不宜过多</td>
<td>数据全内存，资源成本考量不宜超过 100GB</td>
<td>可以配置全内存或内存+磁盘引擎，数据容量可无限扩充</td>
</tr>
<tr>
<td>读写性能</td>
<td>很高</td>
<td>很高(RT0.5ms 左右)</td>
<td>String 类型比较高(RT1ms 左右)，复杂类型比较慢(RT5ms 左右)</td>
</tr>
<tr>
<td>过期策略</td>
<td>过期后，不删除缓存</td>
<td>有六种策略来处理过期数据</td>
<td>支持</td>
</tr>
</tbody>
</table>
<ul>
<li><code>MemCache</code> - 这一块接触得比较少，不做过多的推荐。其吞吐量较大，但是支持的数据结构较少，并且不支持持久化。</li>
<li><code>Redis</code> - 支持丰富的数据结构，读写性能很高，但是数据全内存，必须要考虑资源成本，支持持久化。</li>
<li><code>Tair</code> - 支持丰富的数据结构，读写性能较高，部分类型比较慢，理论上容量可以无限扩充。</li>
</ul>
<p>总结：如果服务对延迟比较敏感，Map/Set 数据也比较多的话，比较适合 Redis。如果服务需要放入缓存量的数据很大，对延迟又不是特别敏感的话，那就可以选择 Tair。</p>
<h2 id="6-多级缓存"><a class="markdownIt-Anchor" href="#6-多级缓存"></a> 6. 多级缓存</h2>
<h3 id="61-使用进程内缓存"><a class="markdownIt-Anchor" href="#61-使用进程内缓存"></a> 6.1. 使用进程内缓存</h3>
<p>如果应用服务不是分布式系统，那么进程内缓存当然是缓存的首选方案。</p>
<p>对于进程内缓存，其本来受限于内存的大小的限制，以及进程缓存更新后其他缓存无法得知，所以一般来说进程缓存适用于:</p>
<ol>
<li>数据量不是很大且更新频率较低的数据。</li>
<li>如果更新频繁的数据，也想使用进程内缓存，那么可以将其过期时间设置为较短的时间，或者设置较短的自动刷新时间。</li>
</ol>
<p>这种方案存在以下问题：</p>
<ul>
<li>如果应用服务是分布式系统，应用节点之间无法共享缓存，存在数据不一致问题。</li>
<li>由于进程内缓存受限于内存大小的限制，所以缓存不能无限扩展。</li>
</ul>
<h3 id="62-使用分布式缓存"><a class="markdownIt-Anchor" href="#62-使用分布式缓存"></a> 6.2. 使用分布式缓存</h3>
<p>如果应用服务是分布式系统，那么最简单的缓存方案就是直接使用分布式缓存。</p>
<p>其应用场景如图所示：</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/java/javaweb/technology/cache/多级缓存1.png!zp" width="600px"/></div>
Redis 用来存储热点数据，如果缓存不命中，则去查询数据库，并更新缓存。
<p>这种方案存在以下问题：</p>
<ol>
<li>缓存服务如果挂了，这时应用只能访问数据库，容易造成缓存雪崩。</li>
<li>访问分布式缓存服务会有一定的 I/O 以及序列化反序列化的开销，虽然性能很高，但是其终究没有在内存中查询快。</li>
</ol>
<h3 id="63-使用多级缓存"><a class="markdownIt-Anchor" href="#63-使用多级缓存"></a> 6.3. 使用多级缓存</h3>
<p>单纯使用进程内缓存和分布式缓存都存在各自的不足。如果需要更高的性能以及更好的可用性，我们可以将缓存设计为多级结构。将最热的数据使用进程内缓存存储在内存中，进一步提升访问速度。</p>
<p>这个设计思路在计算机系统中也存在，比如 CPU 使用 L1、L2、L3 多级缓存，用来减少对内存的直接访问，从而加快访问速度。</p>
<p>一般来说，多级缓存架构使用二级缓存已可以满足大部分业务需求，过多的分级会增加系统的复杂度以及维护的成本。因此，多级缓存不是分级越多越好，需要根据实际情况进行权衡。</p>
<p>一个典型的二级缓存架构，可以使用进程内缓存（如： Caffeine/Google Guava/Ehcache/HashMap）作为一级缓存；使用分布式缓存（如：Redis/Memcached）作为二级缓存。</p>
<h4 id="多级缓存查询"><a class="markdownIt-Anchor" href="#多级缓存查询"></a> 多级缓存查询</h4>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/java/javaweb/technology/cache/多级缓存2.png!zp" width="600" /></div>
多级缓存查询流程如下：
<ol>
<li>首先，查询 L1 缓存，如果缓存命中，直接返回结果；如果没有命中，执行下一步。</li>
<li>接下来，查询 L2 缓存，如果缓存命中，直接返回结果并回填 L1 缓存；如果没有命中，执行下一步。</li>
<li>最后，查询数据库，返回结果并依次回填 L2 缓存、L1 缓存。</li>
</ol>
<h4 id="多级缓存更新"><a class="markdownIt-Anchor" href="#多级缓存更新"></a> 多级缓存更新</h4>
<p>对于 L1 缓存，如果有数据更新，只能删除并更新所在机器上的缓存，其他机器只能通过超时机制来刷新缓存。超时设定可以有两种策略:</p>
<ul>
<li>设置成写入后多少时间后过期</li>
<li>设置成写入后多少时间刷新</li>
</ul>
<p>对于 L1 缓存，如果有数据更新，其他机器立马可见。但是，也必须要设置超时时间，其时间应该比 L1 缓存的有效时间长。</p>
<p>为了解决进程内缓存不一致的问题，设计可以进一步优化:</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/java/javaweb/technology/cache/多级缓存3.png!zp" /></div>
通过消息队列的发布、订阅机制，可以通知其他应用节点对进程内缓存进行更新。使用这种方案，即使消息队列服务挂了或不可靠，由于先执行了数据库更新，但进程内缓存过期，刷新缓存时，也能保证数据的最终一致性。
<h2 id="7-缓存问题"><a class="markdownIt-Anchor" href="#7-缓存问题"></a> 7. 缓存问题</h2>
<h3 id="71-缓存雪崩"><a class="markdownIt-Anchor" href="#71-缓存雪崩"></a> 7.1. 缓存雪崩</h3>
<blockquote>
<p><strong>缓存雪崩是指缓存不可用或者大量缓存由于超时时间相同在同一时间段失效，大量请求直接访问数据库，数据库压力过大导致系统雪崩</strong>。</p>
</blockquote>
<p>解决方案：</p>
<ul>
<li>增加缓存系统可用性。通过监控关注缓存的健康程度，根据业务量适当的扩容缓存。</li>
<li>采用多级缓存。不同级别缓存设置的超时时间不同，即使某个级别缓存都过期，也有其他级别缓存兜底。</li>
<li>缓存的过期时间可以取个随机值。比如以前是设置 10 分钟的超时时间，那每个 Key 都可以随机 8-13 分钟过期，尽量让不同 Key 的过期时间不同。</li>
<li>对数据库进行过载保护或应用层限流。</li>
</ul>
<h3 id="72-缓存穿透"><a class="markdownIt-Anchor" href="#72-缓存穿透"></a> 7.2. 缓存穿透</h3>
<blockquote>
<p><strong>缓存穿透是指：查询的数据在数据库中不存在，那么缓存中自然也不存在。所以，应用在缓存中查不到，则会去查询数据库。当这样的请求多了后，数据库的压力就会增大。</strong></p>
</blockquote>
<p>解决缓存穿透，一般有两种方法：</p>
<ul>
<li><strong>对于返回为 NULL 的依然缓存，对于抛出异常的返回不进行缓存</strong>。</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/java/javaweb/technology/cache/缓存穿透1.png!zp" width="350px"/></div>
采用这种手段的会增加我们缓存的维护成本，需要在插入缓存的时候删除这个空缓存，当然我们可以通过设置较短的超时时间来解决这个问题。
<ul>
<li><strong>过滤不可能存在的数据</strong></li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/java/javaweb/technology/cache/缓存穿透2.png!zp" width="350px"/></div>
**制定一些规则过滤一些不可能存在的数据**。小数据用 BitMap，大数据可以用布隆过滤器，比如你的订单 ID 明显是在一个范围 1-1000，如果不是 1-1000 之内的数据那其实可以直接给过滤掉。
<h3 id="73-缓存击穿"><a class="markdownIt-Anchor" href="#73-缓存击穿"></a> 7.3. 缓存击穿</h3>
<p>对于某些 key 设置了过期时间，但是其是热点数据，如果某个 key 失效，可能大量的请求打过来，缓存未命中，然后去数据库访问，此时数据库访问量会急剧增加。</p>
<p>为了避免这个问题，我们可以采取下面的两个手段:</p>
<ul>
<li><strong>分布式锁</strong> - 锁住热点数据的 key，避免大量线程同时访问同一个 key。</li>
<li><strong>异步加载</strong> - 可以对部分数据采取到期自动刷新的策略，而不是到期自动淘汰。淘汰其实也是为了数据的时效性，所以采用自动刷新也可以。</li>
</ul>
<h3 id="74-缓存更新"><a class="markdownIt-Anchor" href="#74-缓存更新"></a> 7.4. 缓存更新</h3>
<p>一般来说缓存的更新有两种情况:</p>
<ul>
<li>先删除缓存，再更新数据库。</li>
<li>先更新数据库，再删除缓存。</li>
</ul>
<blockquote>
<p><strong>为什么是删除缓存，而不是更新缓存呢？</strong></p>
<p>你可以想想当有多个并发的请求更新数据，你并不能保证更新数据库的顺序和更新缓存的顺序一致，那就会出现数据库中和缓存中数据不一致的情况。所以一般来说考虑删除缓存。</p>
</blockquote>
<ul>
<li><strong>先删除缓存，再更新数据库</strong></li>
</ul>
<p>对于一个更新操作简单来说，就是先去各级缓存进行删除，然后更新数据库。</p>
<p>这个操作有一个比较大的问题，在对缓存删除完之后，有一个读请求，这个时候由于缓存被删除所以直接会读库，读操作的数据是老的并且会被加载进入缓存当中，后续读请求全部访问的老数据。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/java/javaweb/technology/cache/缓存更新.png!zp" width="400px"/></div>
对缓存的操作不论成功失败都不能阻塞我们对数据库的操作，那么很多时候删除缓存可以用异步的操作，但是先删除缓存不能很好的适用于这个场景。
<p>先删除缓存也有一个好处是，如果对数据库操作失败了，那么由于先删除的缓存，最多只是造成 Cache Miss。</p>
<ul>
<li><strong>先更新数据库，再删除缓存</strong></li>
</ul>
<blockquote>
<p>注：更推荐使用这种策略</p>
</blockquote>
<p>如果我们使用更新数据库，再删除缓存就能避免上面的问题。</p>
<p>但是同样的引入了新的问题：假设执行更新操作时，又接收到查询请求，此时就会返回缓存中的老数据。更麻烦的是，如果数据库更新操作执行失败，则缓存中可能永远是脏数据。</p>
<ul>
<li>应该选择哪种更新测录</li>
</ul>
<p>通过上面的内容，我们知道，两种更新策略都存在并发问题。</p>
<p>但是建议选择先更新数据库，再删除缓存，因为其并发问题出现的概率可能非常低，因为这个条件需要发生在读缓存时缓存失效，而且并发着有一个写操作。而实际上数据库的写操作会比读操作慢得多，而且还要锁表，而读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存，所有的这些条件都具备的概率基本并不大。</p>
<p>如果需要数据库和缓存保证强一致性，则可以通过 2PC 或 Paxos 协议来实现。但是 2PC 太慢，而 Paxos 太复杂，所以如果不是非常重要的数据，不建议使用强一致性方案。</p>
<h3 id="75-缓存预热"><a class="markdownIt-Anchor" href="#75-缓存预热"></a> 7.5. 缓存预热</h3>
<p>缓存预热是指系统启动后，将常用的数据直接缓存。这样就可以避免用户请求的时候，先查询数据库，然后再更新缓存的问题。</p>
<p>解决方案：</p>
<ul>
<li>直接写个缓存刷新页面，上线时手工操作下。</li>
<li>数据量不大，可以在项目启动的时候自动进行加载。</li>
<li>定时刷新缓存。</li>
</ul>
<h3 id="76-缓存降级"><a class="markdownIt-Anchor" href="#76-缓存降级"></a> 7.6. 缓存降级</h3>
<p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</p>
<p>降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。</p>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li>《大型网站技术架构》</li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fjuejin.im%2Fpost%2F5b7593496fb9a009b62904fa">你应该知道的缓存进化史</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fjuejin.im%2Fpost%2F5b849878e51d4538c77a974a">如何优雅的设计和使用缓存？</a></li>
<li><a href="https://www.jianshu.com/p/73ce0ef820f9" target="_blank" rel="noopener">理解分布式系统中的缓存架构(上)</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/distributed/distributed-transaction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/distributed/distributed-transaction/" class="post-title-link" itemprop="url">分布式事务基本原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-21 11:30:00" itemprop="dateCreated datePublished" datetime="2019-06-21T11:30:00+08:00">2019-06-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-05 23:17:18" itemprop="dateModified" datetime="2020-02-05T23:17:18+08:00">2020-02-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/distributed/distributed-transaction/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="distributed/distributed-transaction/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="分布式事务基本原理"><a class="markdownIt-Anchor" href="#分布式事务基本原理"></a> 分布式事务基本原理</h1>
<blockquote>
<p>📦 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p>
<p><strong>分布式事务指的是事务操作跨越多个节点，并且要求满足事务的 ACID 特性。</strong></p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%AE%80%E4%BB%8B">一、分布式事务简介</a>
<ul>
<li><a href="#%E6%9C%AC%E5%9C%B0%E4%BA%8B%E5%8A%A1">本地事务</a></li>
<li><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1">分布式事务</a></li>
<li><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%BE%E7%82%B9">分布式事务的难点</a></li>
<li><a href="#cap-%E5%92%8C-base">CAP 和 BASE</a></li>
<li><a href="#%E6%9F%94%E6%80%A7%E4%BA%8B%E5%8A%A1">柔性事务</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4">二、两阶段提交</a>
<ul>
<li><a href="#%E6%96%B9%E6%A1%88%E7%AE%80%E4%BB%8B">方案简介</a></li>
<li><a href="#%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B">处理流程</a></li>
<li><a href="#%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93">方案总结</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4">三、三阶段提交</a>
<ul>
<li><a href="#%E6%96%B9%E6%A1%88%E7%AE%80%E4%BB%8B-1">方案简介</a></li>
<li><a href="#%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B-1">处理流程</a></li>
<li><a href="#%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93-1">方案总结</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B%E8%A1%A5%E5%81%BF%E4%BA%8B%E5%8A%A1">四、补偿事务</a>
<ul>
<li><a href="#%E6%96%B9%E6%A1%88%E7%AE%80%E4%BB%8B-2">方案简介</a></li>
<li><a href="#%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B-2">处理流程</a></li>
<li><a href="#%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93-2">方案总结</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF%E8%A1%A8">五、本地消息表</a>
<ul>
<li><a href="#%E6%96%B9%E6%A1%88%E7%AE%80%E4%BB%8B-3">方案简介</a></li>
<li><a href="#%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B-3">处理流程</a></li>
<li><a href="#%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93-3">方案总结</a></li>
</ul>
</li>
<li><a href="#%E5%85%ADmq-%E4%BA%8B%E5%8A%A1">六、MQ 事务</a>
<ul>
<li><a href="#%E6%96%B9%E6%A1%88%E7%AE%80%E4%BB%8B-4">方案简介</a></li>
<li><a href="#%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B-4">处理流程</a></li>
<li><a href="#%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93-4">方案总结</a></li>
</ul>
</li>
<li><a href="#%E4%B8%83saga">七、SAGA</a>
<ul>
<li><a href="#%E6%96%B9%E6%A1%88%E7%AE%80%E4%BB%8B-5">方案简介</a></li>
<li><a href="#%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B-5">处理流程</a></li>
<li><a href="#%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93-5">方案总结</a></li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a>
<ul>
<li><a href="#%E5%90%84%E6%96%B9%E6%A1%88%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">各方案使用场景</a></li>
<li><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1">分布式事务方案设计</a></li>
</ul>
</li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="一-分布式事务简介"><a class="markdownIt-Anchor" href="#一-分布式事务简介"></a> 一、分布式事务简介</h2>
<h3 id="本地事务"><a class="markdownIt-Anchor" href="#本地事务"></a> 本地事务</h3>
<p>学习分布式之前，先了解一下本地事务的概念。</p>
<p>事务简单来说：<strong>一个会话中所进行所有的操作，要么同时成功，要么同时失败</strong>。</p>
<p><img src="http://dunwu.test.upcdn.net/cs/database/RDB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1.png" alt="img" /></p>
<p>具体来说，事务指的是满足 ACID 特性的一组操作，可以通过 <code>Commit</code> 提交一个事务，也可以使用 <code>Rollback</code> 进行回滚。</p>
<ul>
<li>原子性（Atomicity）</li>
<li>一致性（Consistency）</li>
<li>隔离性（Isolation）</li>
<li>持久性（Durability）</li>
</ul>
<blockquote>
<p>💡 更详细的内容可以参考：<a href="https://dunwu.github.io/db-tutorial/#/sql/sql-interview?id=%e4%ba%8c%e3%80%81%e4%ba%8b%e5%8a%a1">事务</a></p>
</blockquote>
<h3 id="分布式事务"><a class="markdownIt-Anchor" href="#分布式事务"></a> 分布式事务</h3>
<p><strong>分布式事务指的是事务操作跨越多个节点，并且要求满足事务的 ACID 特性。</strong></p>
<p>随着互联网快速发展，微服务，SOA 等服务架构模式正在被大规模的使用，现在分布式系统一般由多个独立的子系统组成，多个子系统通过网络通信互相协作配合完成各个功能。</p>
<p>有很多用例会跨多个子系统才能完成，比较典型的是电子商务网站的下单支付流程，至少会涉及交易系统和支付系统，而且这个过程中会涉及到事务的概念，即保证交易系统和支付系统的数据一致性，此处我们称这种<strong>跨系统的事务为分布式事务</strong>，具体一点而言，分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。</p>
<p>举个互联网常用的交易业务为例：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200205112615.png" alt="img" /></p>
<p>上图中包含了库存和订单两个独立的微服务，每个微服务维护了自己的数据库。在交易系统的业务逻辑中，一个商品在下单之前需要先调用库存服务，进行扣除库存，再调用订单服务，创建订单记录。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200205112518.png" alt="img" /></p>
<p>可以看到，如果多个数据库之间的数据更新没有保证事务，将会导致出现子系统数据不一致，业务出现问题。</p>
<h3 id="分布式事务的难点"><a class="markdownIt-Anchor" href="#分布式事务的难点"></a> 分布式事务的难点</h3>
<ul>
<li><strong>事务的原子性</strong> 事务操作跨不同节点，当多个节点某一节点操作失败时，需要保证多节点操作的**都做或都不做（All or Nothing）**的原子性。</li>
<li><strong>事务的一致性</strong> 当发生网络传输故障或者节点故障，节点间数据复制通道中断，在进行事务操作时需要保证数据一致性，保证事务的任何操作都不会使得数据违反数据库定义的约束、触发器等规则。</li>
<li><strong>事务的隔离性</strong> 事务隔离性的本质就是如何正确多个并发事务的处理的读写冲突和写写冲突，因为在分布式事务控制中，可能会出现提交不同步的现象，这个时候就有可能出现“部分已经提交”的事务。此时并发应用访问数据如果没有加以控制，有可能出现“脏读”问题。</li>
</ul>
<h3 id="cap-和-base"><a class="markdownIt-Anchor" href="#cap-和-base"></a> CAP 和 BASE</h3>
<p>CAP 定理又称为 CAP 原则，指的是：<strong>在一个分布式系统中， <code>一致性（C：Consistency）</code>、<code>可用性（A：Availability）</code> 和 <code>分区容忍性（P：Partition Tolerance）</code>，最多只能同时满足其中两项</strong>。</p>
<p>BASE 是 <strong><code>基本可用（Basically Available）</code></strong>、<strong><code>软状态（Soft State）</code></strong> 和 <strong><code>最终一致性（Eventually Consistent）</code></strong> 三个短语的缩写。BASE 理论是对 CAP 中一致性和可用性权衡的结果，它的理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p>
<blockquote>
<p>💡 更详细的内容可以参考：<a href="#distributed-base-theory.md">分布式基础理论</a></p>
</blockquote>
<h3 id="柔性事务"><a class="markdownIt-Anchor" href="#柔性事务"></a> 柔性事务</h3>
<h4 id="柔性事务的概念"><a class="markdownIt-Anchor" href="#柔性事务的概念"></a> 柔性事务的概念</h4>
<p>在电商等互联网场景下，传统的事务在数据库性能和处理能力上都暴露出了瓶颈。在分布式领域基于 CAP 理论以及 BASE 理论，有人就提出了<strong>柔性事务</strong>的概念。</p>
<p>基于 BASE 理论的设计思想，柔性事务下，在不影响系统整体可用性的情况下(Basically Available 基本可用)，允许系统存在数据不一致的中间状态(Soft State 软状态)，在经过数据同步的延时之后，最终数据能够达到一致。<strong>并不是完全放弃了 ACID，而是通过放宽一致性要求，借助本地事务来实现最终分布式事务一致性的同时也保证系统的吞吐</strong>。</p>
<h4 id="柔性事务的特性"><a class="markdownIt-Anchor" href="#柔性事务的特性"></a> 柔性事务的特性</h4>
<p>下面介绍的是实现柔性事务的一些常见特性，这些特性在具体的方案中不一定都要满足，因为不同的方案要求不一样。</p>
<p><strong>可见性(对外可查询)</strong> 在分布式事务执行过程中，如果某一个步骤执行出错，就需要明确的知道其他几个操作的处理情况，这就需要其他的服务都能够提供查询接口，保证可以通过查询来判断操作的处理情况。</p>
<p>为了保证操作的可查询，需要对于每一个服务的每一次调用都有一个全局唯一的标识，可以是业务单据号（如订单号）、也可以是系统分配的操作流水号（如支付记录流水号）。除此之外，操作的时间信息也要有完整的记录。</p>
<p><strong>操作幂等性</strong> 幂等性，其实是一个数学概念。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。也就是说，同一个方法，使用同样的参数，调用多次产生的业务结果与调用一次产生的业务结果相同。</p>
<p>之所以需要操作幂等性，是因为为了保证数据的最终一致性，很多事务协议都会有很多重试的操作，如果一个方法不保证幂等，那么将无法被重试。幂等操作的实现方式有多种，如在系统中缓存所有的请求与处理结果、检测到重复操作后，直接返回上一次的处理结果等。</p>
<h2 id="二-两阶段提交"><a class="markdownIt-Anchor" href="#二-两阶段提交"></a> 二、两阶段提交</h2>
<h3 id="方案简介"><a class="markdownIt-Anchor" href="#方案简介"></a> 方案简介</h3>
<p>二阶段提交协议（Two-phase Commit，即 2PC）是常用的分布式事务解决方案，即<strong>将事务的提交过程分为两个阶段来进行处理：准备阶段和提交阶段</strong>。事务的发起者称协调者，事务的执行者称参与者。</p>
<p>在分布式系统里，每个节点都可以知晓自己操作的成功或者失败，却无法知道其他节点操作的成功或失败。当一个事务跨多个节点时，为了保持事务的原子性与一致性，而引入一个协调者来统一掌控所有参与者的操作结果，并指示它们是否要把操作结果进行真正的提交或者回滚（rollback）。</p>
<p>二阶段提交的思路可以概括为：<strong>参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作</strong>。</p>
<p>核心思想就是对每一个事务都采用先尝试后提交的处理方式，处理后所有的读操作都要能获得最新的数据，因此也可以将二阶段提交看作是一个强一致性算法。</p>
<h3 id="处理流程"><a class="markdownIt-Anchor" href="#处理流程"></a> 处理流程</h3>
<p>简单一点理解，可以把协调者节点比喻为带头大哥，参与者理解比喻为跟班小弟，带头大哥统一协调跟班小弟的任务执行。</p>
<h4 id="阶段-1准备阶段"><a class="markdownIt-Anchor" href="#阶段-1准备阶段"></a> 阶段 1：准备阶段</h4>
<ol>
<li>协调者向所有参与者发送事务内容，询问是否可以提交事务，并等待所有参与者答复。</li>
<li>各参与者执行事务操作，将 undo 和 redo 信息记入事务日志中（但不提交事务）。</li>
<li>如参与者执行成功，给协调者反馈 yes，即可以提交；如执行失败，给协调者反馈 no，即不可提交。</li>
</ol>
<h4 id="阶段-2提交阶段"><a class="markdownIt-Anchor" href="#阶段-2提交阶段"></a> 阶段 2：提交阶段</h4>
<p>如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(rollback)消息；否则，发送提交(commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源) 接下来分两种情况分别讨论提交阶段的过程。</p>
<p><strong>情况 1，当所有参与者均反馈 yes，提交事务</strong>：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200205153529.png" alt="img" /></p>
<blockquote>
<ol>
<li>协调者向所有参与者发出正式提交事务的请求（即 commit 请求）。</li>
<li>参与者执行 commit 请求，并释放整个事务期间占用的资源。</li>
<li>各参与者向协调者反馈 ack(应答)完成的消息。</li>
<li>协调者收到所有参与者反馈的 ack 消息后，即完成事务提交。</li>
</ol>
</blockquote>
<p><strong>情况 2，当任何阶段 1 一个参与者反馈 no，中断事务</strong>：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200205154145.png" alt="img" /></p>
<blockquote>
<ol>
<li>协调者向所有参与者发出回滚请求（即 rollback 请求）。</li>
<li>参与者使用阶段 1 中的 undo 信息执行回滚操作，并释放整个事务期间占用的资源。</li>
<li>各参与者向协调者反馈 ack 完成的消息。</li>
<li>协调者收到所有参与者反馈的 ack 消息后，即完成事务中断。</li>
</ol>
</blockquote>
<h3 id="方案总结"><a class="markdownIt-Anchor" href="#方案总结"></a> 方案总结</h3>
<p>2PC 方案实现起来简单，实际项目中使用比较少，主要因为以下问题：</p>
<ul>
<li><strong>性能问题</strong> - 所有参与者在事务提交阶段处于同步阻塞状态，占用系统资源，容易导致性能瓶颈。</li>
<li><strong>可靠性问题</strong> - 如果协调者存在单点故障问题，如果协调者出现故障，参与者将一直处于锁定状态。</li>
<li><strong>数据一致性问题</strong> - 在阶段 2 中，如果发生局部网络问题，一部分事务参与者收到了提交消息，另一部分事务参与者没收到提交消息，那么就导致了节点之间数据的不一致。</li>
</ul>
<h2 id="三-三阶段提交"><a class="markdownIt-Anchor" href="#三-三阶段提交"></a> 三、三阶段提交</h2>
<h3 id="方案简介-2"><a class="markdownIt-Anchor" href="#方案简介-2"></a> 方案简介</h3>
<p>三阶段提交协议（Three-phase Commit，3PC），是二阶段提交协议的改进版本，与二阶段提交不同的是，引入超时机制。同时在协调者和参与者中都引入超时机制。</p>
<p>三阶段提交将二阶段的准备阶段拆分为 2 个阶段，插入了一个 preCommit 阶段，使得原先在二阶段提交中，参与者在准备之后，由于协调者发生崩溃或错误，而导致参与者处于无法知晓是否提交或者中止的“不确定状态”所产生的可能相当长的延时的问题得以解决。</p>
<h3 id="处理流程-2"><a class="markdownIt-Anchor" href="#处理流程-2"></a> 处理流程</h3>
<h4 id="阶段-1cancommit"><a class="markdownIt-Anchor" href="#阶段-1cancommit"></a> 阶段 1：canCommit</h4>
<p>协调者向参与者发送 commit 请求，参与者如果可以提交就返回 yes 响应(参与者不执行事务操作)，否则返回 no 响应：</p>
<ol>
<li>协调者向所有参与者发出包含事务内容的 canCommit 请求，询问是否可以提交事务，并等待所有参与者答复。</li>
<li>参与者收到 canCommit 请求后，如果认为可以执行事务操作，则反馈 yes 并进入预备状态，否则反馈 no。</li>
</ol>
<h4 id="阶段-2precommit"><a class="markdownIt-Anchor" href="#阶段-2precommit"></a> 阶段 2：preCommit</h4>
<p>协调者根据阶段 1 canCommit 参与者的反应情况来决定是否可以基于事务的 preCommit 操作。根据响应情况，有以下两种可能。</p>
<p><strong>情况 1：阶段 1 所有参与者均反馈 yes，参与者预执行事务：</strong></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200205180242.png" alt="img" /></p>
<blockquote>
<ol>
<li>协调者向所有参与者发出 preCommit 请求，进入准备阶段。</li>
<li>参与者收到 preCommit 请求后，执行事务操作，将 undo 和 redo 信息记入事务日志中（但不提交事务）。</li>
<li>各参与者向协调者反馈 ack 响应或 no 响应，并等待最终指令。</li>
</ol>
</blockquote>
<p><strong>情况 2：阶段 1 任何一个参与者反馈 no，或者等待超时后协调者尚无法收到所有参与者的反馈，即中断事务:</strong></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200205205117.png" alt="img" /></p>
<blockquote>
<ol>
<li>协调者向所有参与者发出 abort 请求。</li>
<li>无论收到协调者发出的 abort 请求，或者在等待协调者请求过程中出现超时，参与者均会中断事务。</li>
</ol>
</blockquote>
<h4 id="阶段-3docommit"><a class="markdownIt-Anchor" href="#阶段-3docommit"></a> 阶段 3：doCommit</h4>
<p>该阶段进行真正的事务提交，也可以分为以下两种情况：</p>
<p><strong>情况 1：阶段 2 所有参与者均反馈 ack 响应，执行真正的事务提交：</strong></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200205180425.png" alt="img" /></p>
<blockquote>
<ol>
<li>如果协调者处于工作状态，则向所有参与者发出 do Commit 请求。</li>
<li>参与者收到 do Commit 请求后，会正式执行事务提交，并释放整个事务期间占用的资源。</li>
<li>各参与者向协调者反馈 ack 完成的消息。</li>
<li>协调者收到所有参与者反馈的 ack 消息后，即完成事务提交。</li>
</ol>
</blockquote>
<p><strong>阶段 2 任何一个参与者反馈 no，或者等待超时后协调者尚无法收到所有参与者的反馈，即中断事务：</strong></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200205180515.png" alt="img" /></p>
<blockquote>
<ol>
<li>如果协调者处于工作状态，向所有参与者发出 abort 请求。</li>
<li>参与者使用阶段 1 中的 undo 信息执行回滚操作，并释放整个事务期间占用的资源。</li>
<li>各参与者向协调者反馈 ack 完成的消息。</li>
<li>协调者收到所有参与者反馈的 ack 消息后，即完成事务中断。</li>
</ol>
</blockquote>
<p>注意：进入阶段 3 后，无论协调者出现问题，或者协调者与参与者网络出现问题，都会导致参与者无法接收到协调者发出的 do Commit 请求或 abort 请求。此时，参与者都会在等待超时之后，继续执行事务提交。</p>
<h3 id="方案总结-2"><a class="markdownIt-Anchor" href="#方案总结-2"></a> 方案总结</h3>
<p>优点：</p>
<ul>
<li>相比二阶段提交，三阶段降低了阻塞范围，在等待超时后协调者或参与者会中断事务。避免了协调者单点问题，阶段 3 中协调者出现问题时，参与者会继续提交事务。</li>
</ul>
<p>缺点：</p>
<ul>
<li>数据不一致问题依然存在，当在参与者收到 preCommit 请求后等待 do commite 指令时，此时如果协调者请求中断事务，而协调者无法与参与者正常通信，会导致参与者继续提交事务，造成数据不一致。</li>
</ul>
<h2 id="四-补偿事务"><a class="markdownIt-Anchor" href="#四-补偿事务"></a> 四、补偿事务</h2>
<h3 id="方案简介-3"><a class="markdownIt-Anchor" href="#方案简介-3"></a> 方案简介</h3>
<p>TCC（Try-Confirm-Cancel）的概念，最早是由 Pat Helland 于 2007 年发表的一篇名为《Life beyond Distributed Transactions:an Apostate’s Opinion》的论文提出。</p>
<p>TCC 是服务化的二阶段编程模型，其 Try、Confirm、Cancel 3 个方法均由业务编码实现；</p>
<ul>
<li><strong>Try</strong> - 操作作为一阶段，负责资源的检查和预留。</li>
<li><strong>Confirm</strong> - 操作作为二阶段提交操作，执行真正的业务。</li>
<li><strong>Cancel</strong> - 是预留资源的取消。</li>
</ul>
<p>TCC 事务的 Try、Confirm、Cancel 可以理解为 SQL 事务中的 Lock、Commit、Rollback。</p>
<h3 id="处理流程-3"><a class="markdownIt-Anchor" href="#处理流程-3"></a> 处理流程</h3>
<p>为了方便理解，下面以电商下单为例进行方案解析，这里把整个过程简单分为扣减库存，订单创建 2 个步骤，库存服务和订单服务分别在不同的服务器节点上。</p>
<h4 id="try-阶段"><a class="markdownIt-Anchor" href="#try-阶段"></a> Try 阶段</h4>
<p>从执行阶段来看，与传统事务机制中业务逻辑相同。但从业务角度来看，却不一样。TCC 机制中的 Try 仅是一个初步操作，它和后续的确认一起才能真正构成一个完整的业务逻辑，这个阶段主要完成：</p>
<ul>
<li>完成所有业务检查( 一致性 )</li>
<li>预留必须业务资源( 准隔离性 )</li>
<li>Try 尝试执行业务 TCC 事务机制以初步操作（Try）为中心的，确认操作（Confirm）和取消操作（Cancel）都是围绕初步操作（Try）而展开。因此，Try 阶段中的操作，其保障性是最好的，即使失败，仍然有取消操作（Cancel）可以将其执行结果撤销。</li>
</ul>
<p>假设商品库存为 100，购买数量为 2，这里检查和更新库存的同时，冻结用户购买数量的库存，同时创建订单，订单状态为待确认。</p>
<h4 id="confirm-cancel-阶段"><a class="markdownIt-Anchor" href="#confirm-cancel-阶段"></a> Confirm / Cancel 阶段</h4>
<p>根据 Try 阶段服务是否全部正常执行，继续执行确认操作（Confirm）或取消操作（Cancel）。 Confirm 和 Cancel 操作满足幂等性，如果 Confirm 或 Cancel 操作执行失败，将会不断重试直到执行完成。</p>
<p><strong>Confirm：当 Try 阶段服务全部正常执行， 执行确认业务逻辑操作</strong></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200205205200.png" alt="img" /></p>
<p>这里使用的资源一定是 Try 阶段预留的业务资源。在 TCC 事务机制中认为，如果在 Try 阶段能正常的预留资源，那 Confirm 一定能完整正确的提交。Confirm 阶段也可以看成是对 Try 阶段的一个补充，Try+Confirm 一起组成了一个完整的业务逻辑。</p>
<p><strong>Cancel：当 Try 阶段存在服务执行失败， 进入 Cancel 阶段</strong></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200205205221.png" alt="img" /></p>
<p>Cancel 取消执行，释放 Try 阶段预留的业务资源，上面的例子中，Cancel 操作会把冻结的库存释放，并更新订单状态为取消。</p>
<h3 id="方案总结-3"><a class="markdownIt-Anchor" href="#方案总结-3"></a> 方案总结</h3>
<p>TCC 事务机制相对于传统事务机制（X/Open XA），TCC 事务机制相比于上面介绍的 XA 事务机制，有以下优点:</p>
<ul>
<li><strong>性能提升</strong> - 具体业务来实现控制资源锁的粒度变小，不会锁定整个资源。</li>
<li><strong>数据最终一致性</strong> - 基于 Confirm 和 Cancel 的幂等性，保证事务最终完成确认或者取消，保证数据的一致性。</li>
<li><strong>可靠性</strong> - 解决了 XA 协议的协调者单点故障问题，由主业务方发起并控制整个业务活动，业务活动管理器也变成多点，引入集群。</li>
</ul>
<p>缺点： TCC 的 Try、Confirm 和 Cancel 操作功能要按具体业务来实现，业务耦合度较高，提高了开发成本。</p>
<h2 id="五-本地消息表"><a class="markdownIt-Anchor" href="#五-本地消息表"></a> 五、本地消息表</h2>
<h3 id="方案简介-4"><a class="markdownIt-Anchor" href="#方案简介-4"></a> 方案简介</h3>
<p>本地消息表的方案最初是由 ebay 提出，核心思路是将分布式事务拆分成本地事务进行处理。</p>
<p>方案通过在事务主动发起方额外新建事务消息表，事务发起方处理业务和记录事务消息在本地事务中完成，轮询事务消息表的数据发送事务消息，事务被动方基于消息中间件消费事务消息表中的事务。</p>
<p>这样设计可以避免”<strong>业务处理成功 + 事务消息发送失败</strong>&quot;，或&quot;<strong>业务处理失败 + 事务消息发送成功</strong>&quot;的棘手情况出现，保证 2 个系统事务的数据一致性。</p>
<h3 id="处理流程-4"><a class="markdownIt-Anchor" href="#处理流程-4"></a> 处理流程</h3>
<p>下面把分布式事务最先开始处理的事务方成为事务主动方，在事务主动方之后处理的业务内的其他事务成为事务被动方。</p>
<p>为了方便理解，下面继续以电商下单为例进行方案解析，这里把整个过程简单分为扣减库存，订单创建 2 个步骤，库存服务和订单服务分别在不同的服务器节点上，其中库存服务是事务主动方，订单服务是事务被动方。</p>
<p>事务的主动方需要额外新建事务消息表，用于记录分布式事务的消息的发生、处理状态。</p>
<p>整个业务处理流程如下：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200205220246.png" alt="img" /></p>
<blockquote>
<ol>
<li><strong>步骤 1 事务主动方处理本地事务。</strong> 事务主动发在本地事务中处理业务更新操作和写消息表操作。 上面例子中库存服务阶段再本地事务中完成扣减库存和写消息表(图中 1、2)。</li>
<li><strong>步骤 2 事务主动方通过 MQ 通知事务被动方处理事务</strong>。 消息中间件可以基于 Kafka、RocketMQ 消息队列，事务主动方法主动写消息到消息队列，事务消费方消费并处理消息队列中的消息。 上面例子中，库存服务把事务待处理消息写到消息中间件，订单服务消费消息中间件的消息，完成新增订单（图中 3 - 5）。</li>
<li><strong>步骤 3 事务被动方通过 MQ 反会处理结果。</strong> 上面例子中，订单服务把事务已处理消息写到消息中间件，库存服务消费中间件的消息，并将事务消息的状态更新为已完成(图中 6 - 8)</li>
</ol>
</blockquote>
<p>为了数据的一致性，当处理错误需要重试，事务发送方和事务接收方相关业务处理需要支持幂等。具体保存一致性的容错处理如下：</p>
<blockquote>
<ul>
<li>当步骤 1 处理出错，事务回滚，相当于什么都没发生。</li>
<li>当步骤 2、步骤 3 处理出错，由于未处理的事务消息还是保存在事务发送方，事务发送方可以定时轮询为超时消息数据，再次发送的消息中间件进行处理。事务被动方消费事务消息重试处理。</li>
<li>如果是业务上的失败，事务被动方可以发消息给事务主动方进行回滚。</li>
<li>如果多个事务被动方已经消费消息，事务主动方需要回滚事务时需要通知事务被动方回滚。</li>
</ul>
</blockquote>
<h3 id="方案总结-4"><a class="markdownIt-Anchor" href="#方案总结-4"></a> 方案总结</h3>
<p>方案的优点如下：</p>
<ul>
<li>从应用设计开发的角度实现了消息数据的可靠性，消息数据的可靠性不依赖于消息中间件，弱化了对 MQ 中间件特性的依赖。</li>
<li>方案轻量，容易实现。</li>
</ul>
<p>缺点如下：</p>
<ul>
<li>与具体的业务场景绑定，耦合性强，不可复用。</li>
<li>消息数据与业务数据同库，占用业务系统资源。</li>
<li>业务系统在使用关系型数据库的情况下，消息服务性能会受到关系型数据库并发性能的局限。</li>
</ul>
<h2 id="六-mq-事务"><a class="markdownIt-Anchor" href="#六-mq-事务"></a> 六、MQ 事务</h2>
<h3 id="方案简介-5"><a class="markdownIt-Anchor" href="#方案简介-5"></a> 方案简介</h3>
<p>基于 MQ 的分布式事务方案其实是对本地消息表的封装，将本地消息表基于 MQ 内部，其他方面的协议基本与本地消息表一致。</p>
<h3 id="处理流程-5"><a class="markdownIt-Anchor" href="#处理流程-5"></a> 处理流程</h3>
<p>下面主要基于 RocketMQ4.3 之后的版本介绍 MQ 的分布式事务方案。</p>
<p>在本地消息表方案中，保证事务主动方发写业务表数据和写消息表数据的一致性是基于数据库事务，RocketMQ 的事务消息相对于普通 MQ，相对于提供了 2PC 的提交接口，方案如下：</p>
<p><strong>正常情况——事务主动方发消息</strong> 这种情况下，事务主动方服务正常，没有发生故障，发消息流程如下：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200205230320.png" alt="" /></p>
<blockquote>
<ol>
<li>发送方向 MQ 服务端(MQ Server)发送 half 消息。</li>
<li>MQ Server 将消息持久化成功之后，向发送方 ACK 确认消息已经发送成功。</li>
<li>发送方开始执行本地事务逻辑。</li>
<li>发送方根据本地事务执行结果向 MQ Server 提交二次确认（commit 或是 rollback）。</li>
<li>MQ Server 收到 commit 状态则将半消息标记为可投递，订阅方最终将收到该消息；MQ Server 收到 rollback 状态则删除半消息，订阅方将不会接受该消息。</li>
</ol>
</blockquote>
<p><strong>异常情况——事务主动方消息恢复</strong> 在断网或者应用重启等异常情况下，图中 4 提交的二次确认超时未到达 MQ Server，此时处理逻辑如下：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200205230412.png" alt="" /></p>
<blockquote>
<ol start="5">
<li>MQ Server 对该消息发起消息回查。</li>
<li>发送方收到消息回查后，需要检查对应消息的本地事务执行的最终结果。</li>
<li>发送方根据检查得到的本地事务的最终状态再次提交二次确认</li>
<li>MQ Server 基于 commit / rollback 对消息进行投递或者删除</li>
</ol>
</blockquote>
<h3 id="方案总结-5"><a class="markdownIt-Anchor" href="#方案总结-5"></a> 方案总结</h3>
<p>相比本地消息表方案，MQ 事务方案优点是：</p>
<ul>
<li>消息数据独立存储 ，降低业务系统与消息系统之间的耦合。</li>
<li>吞吐量优于使用本地消息表方案。</li>
</ul>
<p>缺点是：</p>
<ul>
<li>一次消息发送需要两次网络请求(half 消息 + commit/rollback 消息)</li>
<li>业务处理服务需要实现消息状态回查接口</li>
</ul>
<h2 id="七-saga"><a class="markdownIt-Anchor" href="#七-saga"></a> 七、SAGA</h2>
<h3 id="方案简介-6"><a class="markdownIt-Anchor" href="#方案简介-6"></a> 方案简介</h3>
<p>Saga 事务源于 1987 年普林斯顿大学的 Hecto 和 Kenneth 发表的如何处理 long lived transaction（长活事务）论文，Saga 事务核心思想是将长事务拆分为多个本地短事务，由 Saga 事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作。</p>
<h3 id="处理流程-6"><a class="markdownIt-Anchor" href="#处理流程-6"></a> 处理流程</h3>
<p><strong>Saga 事务基本协议如下</strong>：</p>
<ul>
<li>每个 Saga 事务由一系列幂等的有序子事务(sub-transaction) Ti 组成。</li>
<li>每个 Ti 都有对应的幂等补偿动作 Ci，补偿动作用于撤销 Ti 造成的结果。</li>
</ul>
<p>可以看到，和 TCC 相比，Saga 没有“预留”动作，它的 Ti 就是直接提交到库。</p>
<p>下面以下单流程为例，整个操作包括：创建订单、扣减库存、支付、增加积分 Saga 的执行顺序有两种：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/12/10/1679817d8ce9b4b7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Saga事务执行顺序" /></p>
<ul>
<li>事务正常执行完成 T1, T2, T3, …, Tn，例如：扣减库存(T1)，创建订单(T2)，支付(T3)，依次有序完成整个事务。</li>
<li>事务回滚 T1, T2, …, Tj, Cj,…, C2, C1，其中 0 &lt; j &lt; n，例如：扣减库存(T1)，创建订单(T2)，支付(T3，支付失败)，支付回滚(C3)，订单回滚(C2)，恢复库存(C1)。</li>
</ul>
<h4 id="恢复策略"><a class="markdownIt-Anchor" href="#恢复策略"></a> 恢复策略</h4>
<p>Saga 定义了两种恢复策略：</p>
<ul>
<li>向前恢复(forward recovery)</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/12/10/1679817da631d59c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Saga事务向前恢复" /></p>
<p>对应于上面第一种执行顺序，适用于必须要成功的场景，发生失败进行重试，执行顺序是类似于这样的：T1, T2, …, Tj(失败), Tj(重试),…, Tn，其中 j 是发生错误的子事务(sub-transaction)。该情况下不需要 Ci。</p>
<ul>
<li>向后恢复(backward recovery)</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/12/10/1679817da706b3c2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Saga事务向后恢复" /></p>
<p>对应于上面提到的第二种执行顺序，其中 j 是发生错误的子事务(sub-transaction)，这种做法的效果是撤销掉之前所有成功的子事务，使得整个 Saga 的执行结果撤销。</p>
<p>Saga 事务常见的有两种不同的实现方式：命令协调和事件编排。</p>
<h4 id="命令协调"><a class="markdownIt-Anchor" href="#命令协调"></a> 命令协调</h4>
<ul>
<li><strong>命令协调(Order Orchestrator)：中央协调器负责集中处理事件的决策和业务逻辑排序。</strong></li>
</ul>
<p>中央协调器（Orchestrator，简称 OSO）以命令/回复的方式与每项服务进行通信，全权负责告诉每个参与者该做什么以及什么时候该做什么。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/12/10/1679817daa1798dd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="命令协调模式" /></p>
<p>以电商订单的例子为例：</p>
<blockquote>
<ol>
<li>事务发起方的主业务逻辑请求 OSO 服务开启订单事务。</li>
<li>OSO 向库存服务请求扣减库存，库存服务回复处理结果。</li>
<li>OSO 向订单服务请求创建订单，订单服务回复创建结果。</li>
<li>OSO 向支付服务请求支付，支付服务回复处理结果。</li>
<li>主业务逻辑接收并处理 OSO 事务处理结果回复。</li>
</ol>
</blockquote>
<p>中央协调器必须事先知道执行整个订单事务所需的流程(例如通过读取配置)。如果有任何失败，它还负责通过向每个参与者发送命令来撤销之前的操作来协调分布式的回滚。基于中央协调器协调一切时，回滚要容易得多，因为协调器默认是执行正向流程，回滚时只要执行反向流程即可。</p>
<h4 id="事件编排"><a class="markdownIt-Anchor" href="#事件编排"></a> 事件编排</h4>
<ul>
<li><strong>事件编排 (Event Choreography0：没有中央协调器（没有单点风险）时，每个服务产生并观察其他服务的事件，并决定是否应采取行动</strong>。</li>
</ul>
<p>在事件编排方法中，第一个服务执行一个事务，然后发布一个事件。该事件被一个或多个服务进行监听，这些服务再执行本地事务并发布（或不发布）新的事件。</p>
<p>当最后一个服务执行本地事务并且不发布任何事件时，意味着分布式事务结束，或者它发布的事件没有被任何 Saga 参与者听到都意味着事务结束。</p>
<p>以电商订单的例子为例：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/12/10/1679817dba9b2b61?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="事件编排模式" /></p>
<blockquote>
<ol>
<li>事务发起方的主业务逻辑发布开始订单事件</li>
<li>库存服务监听开始订单事件，扣减库存，并发布库存已扣减事件</li>
<li>订单服务监听库存已扣减事件，创建订单，并发布订单已创建事件</li>
<li>支付服务监听订单已创建事件，进行支付，并发布订单已支付事件</li>
<li>主业务逻辑监听订单已支付事件并处理。</li>
</ol>
</blockquote>
<p>事件/编排是实现 Saga 模式的自然方式，它很简单，容易理解，不需要太多的代码来构建。如果事务涉及 2 至 4 个步骤，则可能是非常合适的。</p>
<h3 id="方案总结-6"><a class="markdownIt-Anchor" href="#方案总结-6"></a> 方案总结</h3>
<p><strong>命令协调设计的优点和缺点：</strong></p>
<p>优点如下：</p>
<ul>
<li>服务之间关系简单，避免服务之间的循环依赖关系，因为 Saga 协调器会调用 Saga 参与者，但参与者不会调用协调器</li>
<li>程序开发简单，只需要执行命令/回复(其实回复消息也是一种事件消息)，降低参与者的复杂性。</li>
<li>易维护扩展，在添加新步骤时，事务复杂性保持线性，回滚更容易管理，更容易实施和测试</li>
</ul>
<p>缺点如下：</p>
<ul>
<li>中央协调器容易处理逻辑容易过于复杂，导致难以维护。</li>
<li>存在协调器单点故障风险。</li>
</ul>
<p><strong>事件/编排设计的优点和缺点</strong></p>
<p>优点如下：</p>
<ul>
<li>避免中央协调器单点故障风险。</li>
<li>当涉及的步骤较少服务开发简单，容易实现。</li>
</ul>
<p>缺点如下：</p>
<ul>
<li>服务之间存在循环依赖的风险。</li>
<li>当涉及的步骤较多，服务间关系混乱，难以追踪调测。</li>
</ul>
<p>值得补充的是，由于 Saga 模型中没有 Prepare 阶段，因此事务间不能保证隔离性，当多个 Saga 事务操作同一资源时，就会产生更新丢失、脏数据读取等问题，这时需要在业务层控制并发，例如：在应用层面加锁，或者应用层面预先冻结资源。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<h3 id="各方案使用场景"><a class="markdownIt-Anchor" href="#各方案使用场景"></a> 各方案使用场景</h3>
<p>介绍完分布式事务相关理论和常见解决方案后，最终的目的在实际项目中运用，因此，总结一下各个方案的常见的使用场景。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/12/10/1679817dc68ae74d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="方案比较" /></p>
<ul>
<li>2PC/3PC 依赖于数据库，能够很好的提供强一致性和强事务性，但相对来说延迟比较高，比较适合传统的单体应用，在同一个方法中存在跨库操作的情况，不适合高并发和高性能要求的场景。</li>
<li>TCC 适用于执行时间确定且较短，实时性要求高，对数据一致性要求高，比如互联网金融企业最核心的三个服务：交易、支付、账务。</li>
<li>本地消息表/MQ 事务 都适用于事务中参与方支持操作幂等，对一致性要求不高，业务上能容忍数据不一致到一个人工检查周期，事务涉及的参与方、参与环节较少，业务上有对账/校验系统兜底。</li>
<li>Saga 事务 由于 Saga 事务不能保证隔离性，需要在业务层控制并发，适合于业务场景事务并发操作同一资源较少的情况。 Saga 相比缺少预提交动作，导致补偿动作的实现比较麻烦，例如业务是发送短信，补偿动作则得再发送一次短信说明撤销，用户体验比较差。Saga 事务较适用于补偿动作容易处理的场景。</li>
</ul>
<h3 id="分布式事务方案设计"><a class="markdownIt-Anchor" href="#分布式事务方案设计"></a> 分布式事务方案设计</h3>
<p>本文介绍的偏向于原理，业界已经有不少开源的或者收费的解决方案，篇幅所限，就不再展开介绍。</p>
<p>实际运用理论时进行架构设计时，许多人容易犯“手里有了锤子，看什么都觉得像钉子”的错误，设计方案时考虑的问题场景过多，各种重试，各种补偿机制引入系统，导致设计出来的系统过于复杂，落地遥遥无期。</p>
<blockquote>
<p>世界上解决一个计算机问题最简单的方法：“恰好”不需要解决它！—— 阿里中间件技术专家沈询</p>
</blockquote>
<p>有些问题，看起来很重要，但实际上我们可以通过<strong>合理的设计</strong>或者将<strong>问题分解</strong>来规避。设计分布式事务系统也不是需要考虑所有异常情况，不必过度设计各种回滚，补偿机制。如果硬要把时间花在解决问题本身，实际上不仅效率低下，而且也是一种浪费。</p>
<p>如果系统要实现回滚流程的话，有可能系统复杂度将大大提升，且很容易出现 Bug，估计出现 Bug 的概率会比需要事务回滚的概率大很多。在设计系统时，我们需要衡量是否值得花这么大的代价来解决这样一个出现概率非常小的问题，可以考虑当出现这个概率很小的问题，能否采用<strong>人工解决</strong>的方式，这也是大家在解决疑难问题时需要多多思考的地方。</p>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><a href="https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html" target="_blank" rel="noopener">聊聊分布式事务，再说说解决方案</a></li>
<li><a href="https://juejin.im/post/5c0e5bf8e51d45063322fe50" target="_blank" rel="noopener">理解分布式事务</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/distributed/distributed-session-theory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/distributed/distributed-session-theory/" class="post-title-link" itemprop="url">分布式会话基本原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-04 23:42:00" itemprop="dateCreated datePublished" datetime="2019-06-04T23:42:00+08:00">2019-06-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-04 09:57:24" itemprop="dateModified" datetime="2020-02-04T09:57:24+08:00">2020-02-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/distributed/distributed-session-theory/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="distributed/distributed-session-theory/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="分布式会话基本原理"><a class="markdownIt-Anchor" href="#分布式会话基本原理"></a> 分布式会话基本原理</h1>
<blockquote>
<p>📦 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p>
<p>由于 Http 是一种无状态的协议，服务器单单从网络连接上无从知道客户身份。</p>
<p>会话跟踪是 Web 程序中常用的技术，用来跟踪用户的整个会话。常用会话跟踪技术是 Cookie 与 Session。</p>
</blockquote>
<h2 id="1-简介"><a class="markdownIt-Anchor" href="#1-简介"></a> 1. 简介</h2>
<h3 id="11-什么是-cookie"><a class="markdownIt-Anchor" href="#11-什么是-cookie"></a> 1.1. 什么是 Cookie</h3>
<p>Cookie 实际上是存储在用户浏览器上的文本信息，并保留了各种跟踪的信息。</p>
<p>Cookie 工作步骤：</p>
<ol>
<li>客户端请求服务器，如果服务器需要记录该用户的状态，就是用 response 向客户端浏览器颁发一个 Cookie。</li>
<li>客户端浏览器会把 Cookie 保存下来。</li>
<li>当浏览器再请求该网站时，浏览器把该请求的网址连同 Cookie 一同提交给服务器。服务器检查该 Cookie，以此来辨认用户状态。</li>
</ol>
<p>Cookie 主要用于以下三个方面：</p>
<ul>
<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>
</ul>
<p><strong><em>注：Cookie 功能需要浏览器的支持，如果浏览器不支持 Cookie 或者 Cookie 禁用了，Cookie 功能就会失效。</em></strong></p>
<h3 id="12-什么是-session"><a class="markdownIt-Anchor" href="#12-什么是-session"></a> 1.2. 什么是 Session</h3>
<p>Session 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。</p>
<h3 id="13-cookie-和-session-的区别"><a class="markdownIt-Anchor" href="#13-cookie-和-session-的区别"></a> 1.3. Cookie 和 Session 的区别</h3>
<ul>
<li><strong>作用范围不同</strong>，Cookie 保存在客户端（浏览器），Session 保存在服务器端。</li>
<li><strong>存取方式的不同</strong>，Cookie 只能保存 ASCII，Session 可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。</li>
<li><strong>有效期不同</strong>，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。</li>
<li><strong>隐私策略不同</strong>，Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。</li>
<li><strong>存储大小不同</strong>， 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie。</li>
</ul>
<h3 id="14-为什么需要-cookie-和-session他们有什么关联"><a class="markdownIt-Anchor" href="#14-为什么需要-cookie-和-session他们有什么关联"></a> 1.4. 为什么需要 Cookie 和 Session，他们有什么关联？</h3>
<p>说起来为什么需要 Cookie ，这就需要从浏览器开始说起，我们都知道浏览器是没有状态的(HTTP 协议无状态)，这意味着浏览器并不知道是张三还是李四在和服务端打交道。这个时候就需要有一个机制来告诉服务端，本次操作用户是否登录，是哪个用户在执行的操作，那这套机制的实现就需要 Cookie 和 Session 的配合。</p>
<p>那么 Cookie 和 Session 是如何配合的呢？我画了一张图大家可以先了解下。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/5/13/16aafb5d90f398e2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" /></p>
<p>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建创建对应的 Session ，请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器，浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名。</p>
<p>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。</p>
<p>根据以上流程可知，SessionID 是连接 Cookie 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。</p>
<h3 id="15-如果浏览器禁用-cookie-怎么办"><a class="markdownIt-Anchor" href="#15-如果浏览器禁用-cookie-怎么办"></a> 1.5. 如果浏览器禁用 Cookie 怎么办</h3>
<p>既然服务端是根据 Cookie 中的信息判断用户是否登录，那么如果浏览器中禁止了 Cookie，如何保障整个机制的正常运转。</p>
<p>第一种方案，每次请求中都携带一个 SessionID 的参数，也可以 Post 的方式提交，也可以在请求的地址后面拼接 <code>xxx?SessionID=123456...</code>。</p>
<p>第二种方案，Token 机制。Token 机制多用于 App 客户端和服务器交互的模式，也可以用于 Web 端做用户状态管理。</p>
<p>Token 的意思是“令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。Token 机制和 Cookie 和 Session 的使用机制比较类似。</p>
<p>当用户第一次登录后，服务器根据提交的用户信息生成一个 Token，响应时将 Token 返回给客户端，以后客户端只需带上这个 Token 前来请求数据即可，无需再次登录验证。</p>
<h2 id="2-分布式-session"><a class="markdownIt-Anchor" href="#2-分布式-session"></a> 2. 分布式 Session</h2>
<p>在分布式场景下，一个用户的 Session 如果只存储在一个服务器上，那么当负载均衡器把用户的下一个请求转发到另一个服务器上，该服务器没有用户的 Session，就可能导致用户需要重新进行登录等操作。</p>
<p>分布式 Session 的几种实现策略：</p>
<ol>
<li>粘性 session</li>
<li>应用服务器间的 session 复制共享</li>
<li>基于缓存的 session 共享 ✅</li>
</ol>
<blockquote>
<p>推荐：基于缓存的 session 共享</p>
</blockquote>
<h3 id="21-粘性-session"><a class="markdownIt-Anchor" href="#21-粘性-session"></a> 2.1. 粘性 Session</h3>
<blockquote>
<p>粘性 Session（Sticky Sessions）<strong>需要配置负载均衡器，使得一个用户的所有请求都路由到一个服务器节点上</strong>，这样就可以把用户的 Session 存放在该服务器节点中。</p>
<p>缺点：<strong>当服务器节点宕机时，将丢失该服务器节点上的所有 Session</strong>。</p>
</blockquote>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/MultiNode-StickySessions.jpg!zp" />
</div>
<h3 id="22-session-复制共享"><a class="markdownIt-Anchor" href="#22-session-复制共享"></a> 2.2. Session 复制共享</h3>
<blockquote>
<p>Session 复制共享（Session Replication）<strong>在服务器节点之间进行 Session 同步操作</strong>，这样的话用户可以访问任何一个服务器节点。</p>
<p>缺点：<strong>占用过多内存</strong>；<strong>同步过程占用网络带宽以及服务器处理器时间</strong>。</p>
</blockquote>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/MultiNode-SessionReplication.jpg!zp" />
</div>
<h3 id="23-基于缓存的-session-共享"><a class="markdownIt-Anchor" href="#23-基于缓存的-session-共享"></a> 2.3. 基于缓存的 session 共享</h3>
<blockquote>
<p><strong>使用一个单独的存储服务器存储 Session 数据</strong>，可以存在 MySQL 数据库上，也可以存在 Redis 或者 Memcached 这种内存型数据库。</p>
<p>缺点：需要去实现存取 Session 的代码。</p>
</blockquote>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/MultiNode-SpringSession.jpg!zp" />
</div>
<h2 id="3-具体实现"><a class="markdownIt-Anchor" href="#3-具体实现"></a> 3. 具体实现</h2>
<h3 id="31-jwt-token"><a class="markdownIt-Anchor" href="#31-jwt-token"></a> 3.1. JWT Token</h3>
<p>使用 JWT Token 储存用户身份，然后再从数据库或者 cache 中获取其他的信息。这样无论请求分配到哪个服务器都无所谓。</p>
<h3 id="32-tomcat-redis"><a class="markdownIt-Anchor" href="#32-tomcat-redis"></a> 3.2. tomcat + redis</h3>
<p>这个其实还挺方便的，就是使用 session 的代码，跟以前一样，还是基于 tomcat 原生的 session 支持即可，然后就是用一个叫做 <code>Tomcat RedisSessionManager</code> 的东西，让所有我们部署的 tomcat 都将 session 数据存储到 redis 即可。</p>
<p>在 tomcat 的配置文件中配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"com.orangefunction.tomcat.redissessions.RedisSessionHandlerValve"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Manager</span> <span class="attr">className</span>=<span class="string">"com.orangefunction.tomcat.redissessions.RedisSessionManager"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">host</span>=<span class="string">"&#123;redis.host&#125;"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">port</span>=<span class="string">"&#123;redis.port&#125;"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">database</span>=<span class="string">"&#123;redis.dbnum&#125;"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">maxInactiveInterval</span>=<span class="string">"60"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后指定 redis 的 host 和 port 就 ok 了。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"com.orangefunction.tomcat.redissessions.RedisSessionHandlerValve"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Manager</span> <span class="attr">className</span>=<span class="string">"com.orangefunction.tomcat.redissessions.RedisSessionManager"</span></span></span><br><span class="line"><span class="tag">	 <span class="attr">sentinelMaster</span>=<span class="string">"mymaster"</span></span></span><br><span class="line"><span class="tag">	 <span class="attr">sentinels</span>=<span class="string">"&lt;sentinel1-ip&gt;:26379,&lt;sentinel2-ip&gt;:26379,&lt;sentinel3-ip&gt;:26379"</span></span></span><br><span class="line"><span class="tag">	 <span class="attr">maxInactiveInterval</span>=<span class="string">"60"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>还可以用上面这种方式基于 redis 哨兵支持的 redis 高可用集群来保存 session 数据，都是 ok 的。</p>
<h3 id="33-spring-session-redis"><a class="markdownIt-Anchor" href="#33-spring-session-redis"></a> 3.3. spring session + redis</h3>
<p>上面那种 tomcat + redis 的方式好用，但是会<strong>严重依赖于 web 容器</strong>，不好将代码移植到其他 web 容器上去，尤其是你要是换了技术栈咋整？比如换成了 spring cloud 或者是 spring boot 之类的呢？</p>
<p>所以现在比较好的还是基于 Java 一站式解决方案，也就是 spring。人家 spring 基本上承包了大部分我们需要使用的框架，spirng cloud 做微服务，spring boot 做脚手架，所以用 <a href="https://github.com/spring-projects/spring-session" target="_blank" rel="noopener">sping session</a> 是一个很好的选择。</p>
<p>在 pom.xml 中配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 spring 配置文件中配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"redisHttpSessionConfiguration"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">class</span>=<span class="string">"org.springframework.session.data.redis.config.annotation.web.http.RedisHttpSessionConfiguration"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxInactiveIntervalInSeconds"</span> <span class="attr">value</span>=<span class="string">"600"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jedisPoolConfig"</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.JedisPoolConfig"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxTotal"</span> <span class="attr">value</span>=<span class="string">"100"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxIdle"</span> <span class="attr">value</span>=<span class="string">"10"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jedisConnectionFactory"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"org.springframework.data.redis.connection.jedis.JedisConnectionFactory"</span> <span class="attr">destroy-method</span>=<span class="string">"destroy"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hostName"</span> <span class="attr">value</span>=<span class="string">"$&#123;redis_hostname&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"port"</span> <span class="attr">value</span>=<span class="string">"$&#123;redis_port&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;redis_pwd&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"timeout"</span> <span class="attr">value</span>=<span class="string">"3000"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"usePool"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"poolConfig"</span> <span class="attr">ref</span>=<span class="string">"jedisPoolConfig"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 web.xml 中配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>springSessionRepositoryFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>springSessionRepositoryFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/putIntoSession"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">putIntoSession</span><span class="params">(HttpServletRequest request, String username)</span> </span>&#123;</span><br><span class="line">        request.getSession().setAttribute(<span class="string">"name"</span>,  <span class="string">"leo"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"ok"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/getFromSession"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFromSession</span><span class="params">(HttpServletRequest request, Model model)</span></span>&#123;</span><br><span class="line">        String name = request.getSession().getAttribute(<span class="string">"name"</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码就是 ok 的，给 sping session 配置基于 redis 来存储 session 数据，然后配置了一个 spring session 的过滤器，这样的话，session 相关操作都会交给 spring session 来管了。接着在代码中，就用原生的 session 操作，就是直接基于 spring sesion 从 redis 中获取数据了。</p>
<p>实现分布式的会话有很多种方式，我说的只不过是比较常见的几种方式，tomcat + redis 早期比较常用，但是会重耦合到 tomcat 中；近些年，通过 spring session 来实现。</p>
<h2 id="4-参考资料"><a class="markdownIt-Anchor" href="#4-参考资料"></a> 4. 参考资料</h2>
<ul>
<li><a href="https://github.com/L316476844/distributed-session" target="_blank" rel="noopener">集群/分布式环境 Session 的几种策略</a></li>
<li><a href="https://juejin.im/post/5cd9037ee51d456e5c5babca" target="_blank" rel="noopener">你真的了解 Cookie 和 Session 吗</a></li>
<li><a href="https://juejin.im/post/5aede266f265da0ba266e0ef" target="_blank" rel="noopener">聊一聊 session 和 cookie</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/distributed/distributed-lock-theory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/distributed/distributed-lock-theory/" class="post-title-link" itemprop="url">分布式锁基本原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-04 23:42:00" itemprop="dateCreated datePublished" datetime="2019-06-04T23:42:00+08:00">2019-06-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-02 18:07:05" itemprop="dateModified" datetime="2020-02-02T18:07:05+08:00">2020-02-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/distributed/distributed-lock-theory/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="distributed/distributed-lock-theory/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="分布式锁基本原理"><a class="markdownIt-Anchor" href="#分布式锁基本原理"></a> 分布式锁基本原理</h1>
<blockquote>
<p>📦 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#1-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%80%9D%E8%B7%AF">1. 分布式锁思路</a></li>
<li><a href="#2-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">2. 数据库分布式锁</a>
<ul>
<li><a href="#21-%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0">2.1. 具体实现</a></li>
<li><a href="#22-%E9%97%AE%E9%A2%98">2.2. 问题</a></li>
<li><a href="#23-%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95">2.3. 解决办法</a></li>
<li><a href="#24-%E5%B0%8F%E7%BB%93">2.4. 小结</a></li>
</ul>
</li>
<li><a href="#3-redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">3. Redis 分布式锁</a>
<ul>
<li><a href="#31-%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF">3.1. 实现思路</a></li>
<li><a href="#32-%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0">3.2. 具体实现</a></li>
<li><a href="#33-%E5%B0%8F%E7%BB%93">3.3. 小结</a></li>
<li><a href="#34-redlock-%E7%AE%97%E6%B3%95">3.4. RedLock 算法</a></li>
</ul>
</li>
<li><a href="#4-zookeeper-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">4. ZooKeeper 分布式锁</a>
<ul>
<li><a href="#41-%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF">4.1. 实现思路</a></li>
<li><a href="#42-%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0">4.2. 具体实现</a></li>
<li><a href="#43-%E5%B0%8F%E7%BB%93">4.3. 小结</a></li>
</ul>
</li>
<li><a href="#5-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94">5. 分布式锁方案对比</a></li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- /TOC -->
<p>Java 原生 API 虽然有并发锁，但并没有提供分布式锁的能力，所以针对分布式场景中的锁需要解决的方案。</p>
<p>分布式锁的解决方案大致有以下几种：</p>
<ul>
<li>基于数据库实现</li>
<li>基于缓存（redis，memcached 等）实现</li>
<li>基于 Zookeeper 实现 ✅</li>
</ul>
<blockquote>
<p>注：推荐基于 ZooKeeper 实现分布式锁，具体原因看完本文即可明了。</p>
</blockquote>
<h2 id="1-分布式锁思路"><a class="markdownIt-Anchor" href="#1-分布式锁思路"></a> 1. 分布式锁思路</h2>
<p>分布式锁的总体思路大同小异，仅在实现细节上有所不同。</p>
<p>分布式锁的主要思路如下：</p>
<ul>
<li><strong>互斥</strong> - 创建锁必须是唯一的，表现形式为向数据存储服务器或容器插入一个唯一的 key，一旦有一个线程插入这个 key，其他线程就不能再插入了。</li>
<li><strong>避免永远不释放锁</strong> - 数据库分布式锁和缓存分布式锁（Redis）的思路都是引入超时机制，即成功申请锁后，超过一定时间，锁失效（删除 key），原因在于它们无法感知申请锁的客户端节点状态。而 ZooKeeper 由于其 znode 以目录、文件形式组织，天然就存在物理空间隔离，只要 znode 存在，即表示客户端节点还在工作，所以不存在这种问题。</li>
<li><strong>容错</strong>（只要大部分 redis 节点创建了这把锁就可以）</li>
</ul>
<h2 id="2-数据库分布式锁"><a class="markdownIt-Anchor" href="#2-数据库分布式锁"></a> 2. 数据库分布式锁</h2>
<h3 id="21-具体实现"><a class="markdownIt-Anchor" href="#21-具体实现"></a> 2.1. 具体实现</h3>
<p>（1）创建表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`methodLock`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">  <span class="string">`method_name`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'锁定的方法名'</span>,</span><br><span class="line">  <span class="string">`desc`</span> <span class="built_in">varchar</span>(<span class="number">1024</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'备注信息'</span>,</span><br><span class="line">  <span class="string">`update_time`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'保存数据时间，自动生成'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`uidx_method_name`</span> (<span class="string">`method_name `</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'锁定中的方法'</span>;</span><br></pre></td></tr></table></figure>
<p>（2）获取锁</p>
<p>想要锁住某个方法时，执行以下 SQL：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> methodLock(method_name,<span class="keyword">desc</span>) <span class="keyword">values</span> (‘method_name’,‘<span class="keyword">desc</span>’)</span><br></pre></td></tr></table></figure>
<p>因为我们对 <code>method_name</code> 做了唯一性约束，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，可以执行方法体内容。</p>
<p>成功插入则获取锁。</p>
<p>（3）释放锁</p>
<p>当方法执行完毕之后，想要释放锁的话，需要执行以下 Sql:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> methodLock <span class="keyword">where</span> method_name =<span class="string">'method_name'</span></span><br></pre></td></tr></table></figure>
<h3 id="22-问题"><a class="markdownIt-Anchor" href="#22-问题"></a> 2.2. 问题</h3>
<ul>
<li>这把锁强依赖数据库的可用性。如果数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。</li>
<li>这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。</li>
<li>这把锁只能是非阻塞的，因为数据的 insert 操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。</li>
<li>这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。</li>
</ul>
<h3 id="23-解决办法"><a class="markdownIt-Anchor" href="#23-解决办法"></a> 2.3. 解决办法</h3>
<ul>
<li>单点问题可以用多数据库实例，同时塞 N 个表，N/2+1 个成功就任务锁定成功</li>
<li>写一个定时任务，隔一段时间清除一次过期的数据。</li>
<li>写一个 while 循环，不断的重试插入，直到成功。</li>
<li>在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。</li>
</ul>
<h3 id="24-小结"><a class="markdownIt-Anchor" href="#24-小结"></a> 2.4. 小结</h3>
<ul>
<li>优点: 直接借助数据库，容易理解。</li>
<li>缺点: 会有各种各样的问题，在解决问题的过程中会使整个方案变得越来越复杂。操作数据库需要一定的开销，性能问题需要考虑。</li>
</ul>
<h2 id="3-redis-分布式锁"><a class="markdownIt-Anchor" href="#3-redis-分布式锁"></a> 3. Redis 分布式锁</h2>
<p>相比于用数据库来实现分布式锁，基于缓存实现的分布式锁的性能会更好一些。目前有很多成熟的分布式产品，包括 Redis、memcache、Tair 等。这里以 Redis 举例。</p>
<h3 id="31-实现思路"><a class="markdownIt-Anchor" href="#31-实现思路"></a> 3.1. 实现思路</h3>
<p>这个分布式锁有 3 个重要的考量点：</p>
<ol>
<li>互斥（只能有一个客户端获取锁）</li>
<li>不能死锁</li>
<li>容错（只要大部分 redis 节点创建了这把锁就可以）</li>
</ol>
<p>对应的 Redis 指令如下：</p>
<ul>
<li><code>setnx</code> - <code>setnx key val</code>：当且仅当 key 不存在时，set 一个 key 为 val 的字符串，返回 1；若 key 存在，则什么都不做，返回 0。</li>
<li><code>expire</code> - <code>expire key timeout</code>：为 key 设置一个超时时间，单位为 second，超过这个时间锁会自动释放，避免死锁。</li>
<li><code>delete</code> - <code>delete key</code>：删除 key</li>
</ul>
<h3 id="32-具体实现"><a class="markdownIt-Anchor" href="#32-具体实现"></a> 3.2. 具体实现</h3>
<p>（1）申请锁</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> resource_name <span class="comment">my_random_value NX PX 30000</span></span><br></pre></td></tr></table></figure>
<p>执行这个命令就 ok。</p>
<ul>
<li><code>NX</code>：表示只有 <code>key</code> 不存在的时候才会设置成功。（如果此时 redis 中存在这个 key，那么设置失败，返回 <code>nil</code>）</li>
<li><code>PX 30000</code>：意思是 30s 后锁自动释放。别人创建的时候如果发现已经有了就不能加锁了。</li>
</ul>
<p>（2）释放锁</p>
<p>释放锁就是删除 key ，但是一般可以用 <code>lua</code> 脚本删除，判断 value 一样才删除：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">-- 删除锁的时候，找到 key 对应的 value，跟自己传过去的 value 做比较，如果是一样的才删除。</span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">"get"</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] then</span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">"del"</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h3 id="33-小结"><a class="markdownIt-Anchor" href="#33-小结"></a> 3.3. 小结</h3>
<p>为啥要用 <code>random_value</code> 随机值呢？因为如果某个客户端获取到了锁，但是阻塞了很长时间才执行完，比如说超过了 30s，此时可能已经自动释放锁了，此时可能别的客户端已经获取到了这个锁，要是你这个时候直接删除 key 的话会有问题，所以得用随机值加上面的 <code>lua</code> 脚本来释放锁。</p>
<p>但是这样是肯定不行的。因为如果是普通的 redis 单实例，那就是单点故障。或者是 redis 普通主从，那 redis 主从异步复制，如果主节点挂了（key 就没有了），key 还没同步到从节点，此时从节点切换为主节点，别人就可以 set key，从而拿到锁。</p>
<h3 id="34-redlock-算法"><a class="markdownIt-Anchor" href="#34-redlock-算法"></a> 3.4. RedLock 算法</h3>
<p>这个场景是假设有一个 redis cluster，有 5 个 redis master 实例。然后执行如下步骤获取一把锁：</p>
<ol>
<li>获取当前时间戳，单位是毫秒；</li>
<li>跟上面类似，轮流尝试在每个 master 节点上创建锁，过期时间较短，一般就几十毫秒；</li>
<li>尝试在<strong>大多数节点</strong>上建立一个锁，比如 5 个节点就要求是 3 个节点 <code>n / 2 + 1</code>；</li>
<li>客户端计算建立好锁的时间，如果建立锁的时间小于超时时间，就算建立成功了；</li>
<li>要是锁建立失败了，那么就依次之前建立过的锁删除；</li>
<li>只要别人建立了一把分布式锁，你就得<strong>不断轮询去尝试获取锁</strong>。</li>
</ol>
<p><a href="https://redis.io/" target="_blank" rel="noopener">Redis 官方</a>给出了以上两种基于 Redis 实现分布式锁的方法，详细说明可以查看：<a href="https://redis.io/topics/distlock" target="_blank" rel="noopener">https://redis.io/topics/distlock</a> 。</p>
<h2 id="4-zookeeper-分布式锁"><a class="markdownIt-Anchor" href="#4-zookeeper-分布式锁"></a> 4. ZooKeeper 分布式锁</h2>
<h3 id="41-实现思路"><a class="markdownIt-Anchor" href="#41-实现思路"></a> 4.1. 实现思路</h3>
<p>这也是 ZooKeeper 客户端 curator 的分布式锁实现。</p>
<ol>
<li>创建一个目录 mylock；</li>
<li>线程 A 想获取锁就在 mylock 目录下创建临时顺序节点；</li>
<li>获取 mylock 目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；</li>
<li>线程 B 获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；</li>
<li>线程 A 处理完，删除自己的节点，线程 B 监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。</li>
</ol>
<h3 id="42-具体实现"><a class="markdownIt-Anchor" href="#42-具体实现"></a> 4.2. 具体实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ZooKeeperSession</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> bingo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018/11/29</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZooKeeperSession</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch connectedSemaphore = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zookeeper;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZooKeeperSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.zookeeper = <span class="keyword">new</span> ZooKeeper(<span class="string">"192.168.31.187:2181,192.168.31.19:2181,192.168.31.227:2181"</span>, <span class="number">50000</span>, <span class="keyword">new</span> ZooKeeperWatcher());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                connectedSemaphore.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"ZooKeeper session established......"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取分布式锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> productId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">acquireDistributedLock</span><span class="params">(Long productId)</span> </span>&#123;</span><br><span class="line">        String path = <span class="string">"/product-lock-"</span> + productId;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zookeeper.create(path, <span class="string">""</span>.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 相当于是给node注册一个监听器，去看看这个监听器是否存在</span></span><br><span class="line">                    Stat stat = zk.exists(path, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (stat != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">this</span>.latch.await(waitTime, TimeUnit.MILLISECONDS);</span><br><span class="line">                        <span class="keyword">this</span>.latch = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    zookeeper.create(path, <span class="string">""</span>.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ee) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放掉一个分布式锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> productId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseDistributedLock</span><span class="params">(Long productId)</span> </span>&#123;</span><br><span class="line">        String path = <span class="string">"/product-lock-"</span> + productId;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zookeeper.delete(path, -<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">"release the lock for product[id="</span> + productId + <span class="string">"]......"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 建立zk session的watcher</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> bingo</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 2018/11/29</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ZooKeeperWatcher</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Receive watched event: "</span> + event.getState());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (KeeperState.SyncConnected == event.getState()) &#123;</span><br><span class="line">                connectedSemaphore.countDown();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.latch != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 封装单例的静态内部类</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> bingo</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 2018/11/29</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> ZooKeeperSession instance;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> ZooKeeperSession();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ZooKeeperSession <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取单例</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ZooKeeperSession <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Singleton.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化单例的便捷方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以采用另一种方式，创建临时顺序节点：</p>
<p>如果有一把锁，被多个人给竞争，此时多个人会排队，第一个拿到锁的人会执行，然后释放锁；后面的每个人都会去监听<strong>排在自己前面</strong>的那个人创建的 node 上，一旦某个人释放了锁，排在自己后面的人就会被 zookeeper 给通知，一旦被通知了之后，就 ok 了，自己就获取到了锁，就可以执行代码了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZooKeeperDistributedLock</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zk;</span><br><span class="line">    <span class="keyword">private</span> String locksRoot = <span class="string">"/locks"</span>;</span><br><span class="line">    <span class="keyword">private</span> String productId;</span><br><span class="line">    <span class="keyword">private</span> String waitNode;</span><br><span class="line">    <span class="keyword">private</span> String lockNode;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch connectedLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sessionTimeout = <span class="number">30000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZooKeeperDistributedLock</span><span class="params">(String productId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.productId = productId;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String address = <span class="string">"192.168.31.187:2181,192.168.31.19:2181,192.168.31.227:2181"</span>;</span><br><span class="line">            zk = <span class="keyword">new</span> ZooKeeper(address, sessionTimeout, <span class="keyword">this</span>);</span><br><span class="line">            connectedLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LockException(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LockException(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LockException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event.getState() == KeeperState.SyncConnected) &#123;</span><br><span class="line">            connectedLatch.countDown();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.latch != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.latch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireDistributedLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                waitForLock(waitNode, sessionTimeout);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LockException(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LockException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"> 		    <span class="comment">// 传入进去的locksRoot + “/” + productId</span></span><br><span class="line">		    <span class="comment">// 假设productId代表了一个商品id，比如说1</span></span><br><span class="line">		    <span class="comment">// locksRoot = locks</span></span><br><span class="line">		    <span class="comment">// /locks/10000000000，/locks/10000000001，/locks/10000000002</span></span><br><span class="line">            lockNode = zk.create(locksRoot + <span class="string">"/"</span> + productId, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 看看刚创建的节点是不是最小的节点</span></span><br><span class="line">	 	    <span class="comment">// locks：10000000000，10000000001，10000000002</span></span><br><span class="line">            List&lt;String&gt; locks = zk.getChildren(locksRoot, <span class="keyword">false</span>);</span><br><span class="line">            Collections.sort(locks);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(lockNode.equals(locksRoot+<span class="string">"/"</span>+ locks.get(<span class="number">0</span>)))&#123;</span><br><span class="line">                <span class="comment">//如果是最小的节点,则表示取得锁</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果不是最小的节点，找到比自己小1的节点</span></span><br><span class="line">	  <span class="keyword">int</span> previousLockIndex = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; locks.size(); i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(lockNode.equals(locksRoot + “/” + locks.get(i))) &#123;</span><br><span class="line">	         	    previousLockIndex = i - <span class="number">1</span>;</span><br><span class="line">		    <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	   &#125;</span><br><span class="line"></span><br><span class="line">	   <span class="keyword">this</span>.waitNode = locks.get(previousLockIndex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LockException(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LockException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">waitForLock</span><span class="params">(String waitNode, <span class="keyword">long</span> waitTime)</span> <span class="keyword">throws</span> InterruptedException, KeeperException </span>&#123;</span><br><span class="line">        Stat stat = zk.exists(locksRoot + <span class="string">"/"</span> + waitNode, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (stat != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">this</span>.latch.await(waitTime, TimeUnit.MILLISECONDS);</span><br><span class="line">            <span class="keyword">this</span>.latch = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 删除/locks/10000000000节点</span></span><br><span class="line">            <span class="comment">// 删除/locks/10000000001节点</span></span><br><span class="line">            System.out.println(<span class="string">"unlock "</span> + lockNode);</span><br><span class="line">            zk.delete(lockNode, -<span class="number">1</span>);</span><br><span class="line">            lockNode = <span class="keyword">null</span>;</span><br><span class="line">            zk.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LockException</span><span class="params">(String e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LockException</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="43-小结"><a class="markdownIt-Anchor" href="#43-小结"></a> 4.3. 小结</h3>
<p>ZooKeeper 版本的分布式锁问题相对比较来说少。</p>
<ul>
<li>锁的占用时间限制：redis 就有占用时间限制，而 ZooKeeper 则没有，最主要的原因是 redis 目前没有办法知道已经获取锁的客户端的状态，是已经挂了呢还是正在执行耗时较长的业务逻辑。而 ZooKeeper 通过临时节点就能清晰知道，如果临时节点存在说明还在执行业务逻辑，如果临时节点不存在说明已经执行完毕释放锁或者是挂了。由此看来 redis 如果能像 ZooKeeper 一样添加一些与客户端绑定的临时键，也是一大好事。</li>
<li>是否单点故障：redis 本身有很多中玩法，如客户端一致性 hash，服务器端 sentinel 方案或者 cluster 方案，很难做到一种分布式锁方式能应对所有这些方案。而 ZooKeeper 只有一种玩法，多台机器的节点数据是一致的，没有 redis 的那么多的麻烦因素要考虑。</li>
</ul>
<p>总体上来说 ZooKeeper 实现分布式锁更加的简单，可靠性更高。但 ZooKeeper 因为需要频繁的创建和删除节点，性能上不如 Redis 方式。</p>
<h2 id="5-分布式锁方案对比"><a class="markdownIt-Anchor" href="#5-分布式锁方案对比"></a> 5. 分布式锁方案对比</h2>
<ul>
<li>
<p>数据库分布式锁，问题比较多，解决起来比较麻烦，不推荐</p>
</li>
<li>
<p>redis 分布式锁，其实<strong>需要自己不断去尝试获取锁</strong>，比较消耗性能。</p>
</li>
<li>
<p>zk 分布式锁，获取不到锁，注册个监听器即可，不需要不断主动尝试获取锁，性能开销较小。</p>
</li>
</ul>
<p>另外一点就是，如果是 redis 获取锁的那个客户端出现 bug 挂了，那么只能等待超时时间之后才能释放锁；而 zk 的话，因为创建的是临时 znode，只要客户端挂了，znode 就没了，此时就自动释放锁。</p>
<p>总体上来说，ZooKeeper 实现分布式锁更加的简单，可靠性更高。</p>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><a href="https://juejin.im/post/5a20cd8bf265da43163cdd9a" target="_blank" rel="noopener">分布式锁实现汇总</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/network/network-interview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/network/network-interview/" class="post-title-link" itemprop="url">网络通信知识点面经</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-02 00:00:00" itemprop="dateCreated datePublished" datetime="2019-06-02T00:00:00+08:00">2019-06-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-03 10:54:27" itemprop="dateModified" datetime="2020-02-03T10:54:27+08:00">2020-02-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/network/network-interview/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="network/network-interview/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="网络通信知识点面经"><a class="markdownIt-Anchor" href="#网络通信知识点面经"></a> 网络通信知识点面经</h1>
<blockquote>
<p>📦 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p>
<p>如果你不是从事于通信领域，面试时问及计算机网络的知识，一般也就限定在：HTTP（含 HTTPS、Cookie、Session）、TCP、UDP、Socket 这些</p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#1-%E7%BB%BC%E5%90%88">1. 综合</a>
<ul>
<li><a href="#11-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A6%82%E4%BD%95%E5%88%86%E5%B1%82">1.1. 计算机网络如何分层？</a></li>
</ul>
</li>
<li><a href="#2-http">2. HTTP</a></li>
<li><a href="#3-dns">3. DNS</a></li>
<li><a href="#4-tcpudp">4. TCP/UDP</a>
<ul>
<li><a href="#41-%E4%BB%80%E4%B9%88%E6%98%AF-tcp">4.1. 什么是 TCP？</a></li>
<li><a href="#42-tcp-%E7%9A%84%E7%89%B9%E6%80%A7%E6%98%AF%E4%BB%80%E4%B9%88">4.2. TCP 的特性是什么？</a></li>
<li><a href="#43-tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B">4.3. TCP 三次握手</a></li>
<li><a href="#44-tcp-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B">4.4. TCP 四次挥手</a></li>
<li><a href="#45-tcp-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">4.5. TCP 滑动窗口</a></li>
<li><a href="#46-tcp-%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6">4.6. TCP 重传机制</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h2 id="1-综合"><a class="markdownIt-Anchor" href="#1-综合"></a> 1. 综合</h2>
<h3 id="11-计算机网络如何分层"><a class="markdownIt-Anchor" href="#11-计算机网络如何分层"></a> 1.1. 计算机网络如何分层？</h3>
<blockquote>
<p>❓ 问题：计算机网络如何分层？各层的作用是什么？各层的主要协议、设备分别是什么？</p>
<p>这是学习计算机网络知识宏观层面必须要了解的核心点。知道了这些，对于网络的体系结构就基本上了解了。</p>
</blockquote>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/overview/network-layers.png!zp"/></div>
计算机网络分层一般有三种划分体系：OSI 分层；五层协议分层；TCP/IP 协议分层。
<ul>
<li>OSI 的七层体系结构概念清楚，理论完整，但是比较复杂且不实用，所以并不流行。</li>
<li>五层协议分层是一种折中方案，在现实中更为流行。</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/overview/网络分层架构图.png!zp"/></div>
**物理层**
<blockquote>
<p>物理层（Physical Layer）只接收和发送一串比特(bit)流，不考虑信息的意义和信息结构。</p>
<p>扩展阅读：<a href="network-physical.md">计算机网络之物理层</a></p>
</blockquote>
<ul>
<li>关键词：调制、解调、数字信号、模拟信号、通信媒介、信道复用</li>
<li>数据单元：比特流。</li>
<li>典型设备：光纤、同轴电缆、双绞线、中继器和集线器。</li>
</ul>
<p><strong>数据链路层</strong></p>
<blockquote>
<p>网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，数据链路层（Data Link Layer）就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。</p>
<p>扩展阅读：<a href="network-data-link.md">计算机网络之数据链路层</a></p>
</blockquote>
<ul>
<li>关键词：点对点信道、广播信道、<code>PPP</code>、<code>CSMA/CD</code>、局域网、以太网、<code>MAC</code>、适配器、集线器、网桥、交换机</li>
<li>主要协议：<code>PPP</code>、<code>CSMA/CD</code> 等。</li>
<li>数据单元：帧（frame）。</li>
<li>典型设备：二层交换机、网桥、网卡。</li>
</ul>
<p><strong>网络层</strong></p>
<blockquote>
<p>网络层（network layer）为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。</p>
<p>扩展阅读：<a href="network-network.md">计算机网络之网络层</a></p>
</blockquote>
<ul>
<li>关键词：<code>IP</code>、<code>ICMP</code>、<code>ARP</code>、路由</li>
<li>主要协议：<code>IP</code>。</li>
<li>数据单元：IP 数据报（packet）。</li>
<li>典型设备：网关、路由器。</li>
</ul>
<p><strong>传输层</strong></p>
<blockquote>
<p>传输层（transport layer）为两台主机中进程间的通信提供通用的数据传输服务。</p>
<p>扩展阅读：<a href="network-network.md">计算机网络之网络层</a></p>
</blockquote>
<ul>
<li>关键词：<code>UDP</code>、<code>TCP</code>、滑动窗口、拥塞控制、三次握手</li>
<li>主要协议：<code>TCP</code>、<code>UDP</code>。</li>
<li>数据单元：报文段（segment）或用户数据报。</li>
</ul>
<p><sub>~**会话层**~</sub></p>
<blockquote>
<p>~~会话层（Session Layer）不参与具体的传输，它提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制。~~</p>
</blockquote>
<p><sub>~**表示层**~</sub></p>
<blockquote>
<p>~~表示层（Presentation Layer）是为在应用过程之间传送的信息提供表示方法的服务，它关心的只是发出信息的语法与语义。表示层要完成某些特定的功能，主要有不同数据编码格式的转换，提供数据压缩、解压缩服务，对数据进行加密、解密。~~</p>
</blockquote>
<p><strong>应用层</strong></p>
<blockquote>
<p>应用层（application layer）通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程间通信和交互的规则。</p>
<p>扩展阅读：<a href="network-application.md">计算机网络之应用层</a></p>
</blockquote>
<ul>
<li>关键词：<code>HTTP</code>、<code>DNS</code>、<code>FTP</code>、<code>TELNET</code>、<code>DHCP</code></li>
<li>主要协议：<code>HTTP</code>、<code>DNS</code>、<code>SMTP</code>、<code>Telnet</code>、<code>FTP</code>、<code>SNMP</code> 等。</li>
<li>数据单元：报文（message）。</li>
</ul>
<h2 id="2-http"><a class="markdownIt-Anchor" href="#2-http"></a> 2. HTTP</h2>
<blockquote>
<p>扩展阅读：<a href="http.md">超文本传输协议 HTTP</a></p>
</blockquote>
<h2 id="3-dns"><a class="markdownIt-Anchor" href="#3-dns"></a> 3. DNS</h2>
<blockquote>
<p>扩展阅读：<a href="dns.md">域名系统 DNS</a></p>
</blockquote>
<h2 id="4-tcpudp"><a class="markdownIt-Anchor" href="#4-tcpudp"></a> 4. TCP/UDP</h2>
<blockquote>
<p>扩展阅读：<a href="tcp.md">传输控制协议 TCP</a>，<a href="udp.md">用户数据报协议 UDP</a></p>
</blockquote>
<h3 id="41-什么是-tcp"><a class="markdownIt-Anchor" href="#41-什么是-tcp"></a> 4.1. 什么是 TCP？</h3>
<p><strong>TCP（Transmission Control Protocol），即传输控制协议，它是一种<code>面向连接的</code>、<code>可靠的</code>、<code>基于字节流的</code>传输层通信协议</strong>。</p>
<h3 id="42-tcp-的特性是什么"><a class="markdownIt-Anchor" href="#42-tcp-的特性是什么"></a> 4.2. TCP 的特性是什么？</h3>
<ul>
<li><code>面向连接的</code> - 面向连接是指 TCP 需要通过三次握手、四次挥手原则建立和断开双向连接。</li>
<li><code>可靠的</code> - 可靠是指 TCP 传输的数据包保证以原始顺序到达目的地，且数据包不被损坏。为了实现这点，TCP 通过以下技术来保证：
<ul>
<li>数据包的序列号和校验码</li>
<li>确认包和自动重传
<ul>
<li>如果发送者没有收到正确的响应，它将重新发送数据包。如果多次超时，连接就会断开。</li>
<li>TCP 实行流量控制和拥塞控制。这些确保措施会导致延迟，而且通常导致传输效率比 UDP 低。</li>
</ul>
</li>
</ul>
</li>
<li><code>基于字节流的</code>
<ul>
<li>虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序看成是一连串的无结构的字节流。TCP 有一个缓冲，当应用程序传送的数据块太长，TCP 就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP 也可以等待积累有足够多的字节后再构成报文段发送出去。</li>
<li>在 TCP 建立连接前两次握手的 SYN 报文中选项字段的 MSS 值，通信双方商定通信的最大报文长度。如果应用层交付下来的数据过大，就会对数据分段，然后发送；否则通过滑动窗口来控制通信双发的数据。</li>
</ul>
</li>
</ul>
<h3 id="43-tcp-三次握手"><a class="markdownIt-Anchor" href="#43-tcp-三次握手"></a> 4.3. TCP 三次握手</h3>
<blockquote>
<p>❓ 问题：三次握手有什么用？什么是三次握手？为什么需要三次握手？</p>
</blockquote>
<p>（1）三次握手有什么用？</p>
<ul>
<li>三次握手负责建立 TCP 双向连接。</li>
</ul>
<p>（2）什么是三次握手？</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/transport/三次握手.gif!zp"/></div>
如上图所示，三次握手流程如下：
<ol>
<li>第一次握手 - 客户端向服务端发送带有 SYN 标志的数据包。</li>
<li>第二次握手 - 服务端向客户端发送带有 SYN/ACK 标志的数据包。</li>
<li>第三次握手 - 客户端向服务端发送带有带有 ACK 标志的数据包。</li>
</ol>
<p>至此，TCP 三次握手完成，客户端与服务端已建立双向连接。</p>
<blockquote>
<p>💡 说明：SYN 为 synchronize 的缩写，ACK 为 acknowledgment 的缩写。</p>
</blockquote>
<p>（3）为什么需要三次握手？</p>
<p>为了便于说明，假设客户端为 A, 服务端为 B。</p>
<ol>
<li>第一次握手，A 向 B 发同步消息。B 收到消息后，B 认为：A 发消息没问题；B 收消息没问题。</li>
<li>第二次握手，B 向 A 发同步消息和确认消息。A 收到消息后，A 认为：A 发消息、收消息都没问题；B 发消息、收消息都没问题。<strong>但是，此时 B 不确定自己发消息是否没问题</strong>，所以就需要第三次握手。</li>
<li>第三次握手，A 向 B 发确认消息。B 收到消息后。B 认为：B 发消息没问题。</li>
</ol>
<h3 id="44-tcp-四次挥手"><a class="markdownIt-Anchor" href="#44-tcp-四次挥手"></a> 4.4. TCP 四次挥手</h3>
<blockquote>
<p>❓ 问题：四次挥手有什么用？什么是四次挥手？为什么建立连接是三次握手，关闭连接确是四次挥手呢？</p>
</blockquote>
<p>（1）四次挥手有什么用？</p>
<ul>
<li>四次挥手负责断开 TCP 连接。</li>
</ul>
<p>（2）什么是四次挥手？</p>
<p>如上图所示，四次挥手流程如下：</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/transport/四次挥手.gif!zp"/></div>
1. 第一次挥手 - 客户端向服务端发送一个 FIN 包，用来关闭客户端到服务端的数据传送。
2. 第二次挥手 - 服务端收到这个 FIN 包，向客户端发送一个 ACK 包，确认序号为收到的序号加 1。和 SYN 一样，一个 FIN 将占用一个序号。
3. 第三次挥手 - 服务端关闭与客户端的连接，向客户端发送一个 FIN 包。
4. 第四次挥手 - 客户端向服务端发送 ACK 包，并将确认序号设置为收到序号加 1。
<p>（3）为什么建立连接是三次握手，关闭连接确是四次挥手呢？</p>
<ul>
<li>建立连接的时候， 服务器在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。</li>
<li>而关闭连接时，服务器收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接，因此，己方 ACK 和 FIN 一般都会分开发送，从而导致多了一次。</li>
</ul>
<h3 id="45-tcp-滑动窗口"><a class="markdownIt-Anchor" href="#45-tcp-滑动窗口"></a> 4.5. TCP 滑动窗口</h3>
<blockquote>
<p>❓ 问题：什么是滑动窗口？滑动窗口原理是什么？</p>
</blockquote>
<p>什么是滑动窗口？</p>
<p><strong>滑动窗口是 TCP 的一种控制网络流量的技术。</strong></p>
<p><strong>TCP 必需要解决的可靠传输以及包乱序（reordering）的问题</strong>，所以，TCP 必需要知道网络实际的数据处理带宽或是数据处理速度，这样才不会引起网络拥塞，导致丢包。</p>
<p>TCP 头里有一个字段叫 Window，又叫 Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。<strong>于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来</strong>。</p>
<p>滑动窗口原理是什么？</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/snap/1559265819762.png!zp"/></div>
1. 已发送已确认 - 数据流中最早的字节已经发送并得到确认。这些数据是站在发送端的角度来看的。上图中的 31 个字节已经发送并确认。
2. 已发送但尚未确认 - 已发送但尚未得到确认的字节。发送方在确认之前，不认为这些数据已经被处理。上图中的 32 \~ 45 字节为第 2 类。
3. 未发送而接收方已 Ready - 设备尚未将数据发出 ，但接收方根据最近一次关于发送方一次要发送多少字节确认自己有足够空间。发送方会立即尝试发送。上图中的 46 \~ 51 字节为第 3 类。
4. 未发送而接收方 Not Ready - 由于接收方 not ready，还不允许将这部分数据发出。上图中的 52 以后的字节为第 4 类。
<div align="center"><img src="http://dunwu.test.upcdn.net/snap/1559265927658.png!zp"/></div>
这张图片相对于上一张图片，滑动窗口偏移了 5 个字节，意味着有 5 个已发送的字节得到了确认。
<h3 id="46-tcp-重传机制"><a class="markdownIt-Anchor" href="#46-tcp-重传机制"></a> 4.6. TCP 重传机制</h3>
<blockquote>
<p>❓ 问题：为什么需要重传机制？TCP 有哪些重传机制，原理是什么？</p>
</blockquote>
<p>TCP 要保证所有的数据包都可以到达，所以，必需要有重传机制。</p>
<p>TCP 重传机制主要有两种：</p>
<ul>
<li>超时重传机制</li>
<li>快速重传机制</li>
</ul>
<p>（1）超时重传机制</p>
<p>超时重传机制是指：发送数据包在一定的时间周期内没有收到相应的 ACK，等待一定的时间，超时之后就认为这个数据包丢失，就会重新发送。这个等待时间被称为 RTO(Retransmission TimeOut)，即重传超时时间。</p>
<p>没有确认的数据包不会从窗口中移走，定时器在重传时间到期内，每个片段的位置不变。</p>
<p>这种机制的重点是 RTO 的设置：</p>
<ul>
<li>RTO 设长了，重发就慢，丢了老半天才重发，没有效率，性能差；</li>
<li>RTO 设短了，会导致可能并没有丢就重发。于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发</li>
</ul>
<p>（2）快速重传机制</p>
<p>快速重传机制，实现了另外的一种丢包评定标准，即如果连续收到 3 次重复 ACK，发送方就认为这个 seq 的包丢失了，立刻进行重传。</p>
<p>当接收方收到乱序片段时，需要重复发送 ACK。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/network/udp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/network/udp/" class="post-title-link" itemprop="url">网络协议之 UDP</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-31 11:51:00" itemprop="dateCreated datePublished" datetime="2019-05-31T11:51:00+08:00">2019-05-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-03 10:29:58" itemprop="dateModified" datetime="2020-02-03T10:29:58+08:00">2020-02-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/network/udp/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="network/udp/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>762</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="网络协议之-udp"><a class="markdownIt-Anchor" href="#网络协议之-udp"></a> 网络协议之 UDP</h1>
<blockquote>
<p>📦 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#%E7%AE%80%E4%BB%8B">简介</a>
<ul>
<li><a href="#udp-%E7%89%B9%E7%82%B9">UDP 特点</a></li>
<li><a href="#udp-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">UDP 应用场景</a></li>
</ul>
</li>
<li><a href="#udp-%E6%8A%A5%E6%96%87">UDP 报文</a></li>
</ul>
<!-- /TOC -->
<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<div align="center"><img src="http://dunwu.test.upcdn.net/snap/1559263939493.png!zp"/></div>
<p>UDP 是无连接的。数据报（类似于数据包）只在数据报级别有保证。数据报可能会无序的到达目的地，也有可能会遗失。UDP 不支持拥塞控制。虽然不如 TCP 那样有保证，但 UDP 通常效率更高。</p>
<p>UDP 可以通过广播将数据报发送至子网内的所有设备。这对 <a href="https://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol" target="_blank" rel="noopener">DHCP</a> 很有用，因为子网内的设备还没有分配 IP 地址，而 IP 对于 TCP 是必须的。</p>
<p>UDP 可靠性更低但适合用在网络电话、视频聊天，流媒体和实时多人游戏上。</p>
<p>以下情况使用 UDP 代替 TCP：</p>
<ul>
<li>你需要低延迟</li>
<li>相对于数据丢失更糟的是数据延迟</li>
<li>你想实现自己的错误校正方法</li>
</ul>
<h3 id="udp-特点"><a class="markdownIt-Anchor" href="#udp-特点"></a> UDP 特点</h3>
<ol>
<li><strong>无连接的</strong>，即发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延。</li>
<li><strong>不保证可靠交付</strong>，因此主机不需要为此复杂的连接状态表</li>
<li><strong>面向报文的</strong>，意思是 UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界，在添加首部后向下交给 IP 层。</li>
<li><strong>没有阻塞控制</strong>，因此网络出现的拥塞不会使发送方的发送速率降低。</li>
<li><strong>支持一对一、一对多、多对一和多对多的交互通信</strong>，也即是提供广播和多播的功能。</li>
<li><strong>首部开销小</strong>，首部只有 8 个字节，分为四部分。</li>
</ol>
<h3 id="udp-应用场景"><a class="markdownIt-Anchor" href="#udp-应用场景"></a> UDP 应用场景</h3>
<ol>
<li>名字转换（DNS）</li>
<li>文件传送（TFTP）</li>
<li>路由选择协议（RIP）</li>
<li>IP 地址配置（BOOTP，DHTP）</li>
<li>网络管理（SNMP）</li>
<li>远程文件服务（NFS）</li>
<li>IP 电话</li>
<li>流式多媒体通信</li>
</ol>
<h2 id="udp-报文"><a class="markdownIt-Anchor" href="#udp-报文"></a> UDP 报文</h2>
<p>UDP 数据报分为数据字段和首部字段。<br />
首部字段只有 8 个字节，由四个字段组成，每个字段的长度是 2 个字节。</p>
<p><strong>首部各字段意义</strong>：</p>
<ol>
<li><strong>源端口</strong>：源端口号，在需要对方回信时选用，不需要时可全 0.</li>
<li><strong>目的端口</strong>：目的端口号，在终点交付报文时必须要使用到。</li>
<li><strong>长度</strong>：UDP 用户数据报的长度，在只有首部的情况，其最小值是 8 。</li>
<li><strong>检验和</strong>：检测 UDP 用户数据报在传输中是否有错，有错就丢弃。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/network/websocket/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/network/websocket/" class="post-title-link" itemprop="url">网络协议之 Websocket</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-31 11:51:00" itemprop="dateCreated datePublished" datetime="2019-05-31T11:51:00+08:00">2019-05-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-03 10:29:40" itemprop="dateModified" datetime="2020-02-03T10:29:40+08:00">2020-02-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/network/websocket/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="network/websocket/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="socket-和-websocket"><a class="markdownIt-Anchor" href="#socket-和-websocket"></a> Socket 和 WebSocket</h1>
<blockquote>
<p>📦 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#socket">Socket</a>
<ul>
<li><a href="#socket-%E7%94%A8%E6%B3%95">Socket 用法</a></li>
<li><a href="#socket-%E9%95%BF%E8%BF%9E%E6%8E%A5">Socket 长连接</a></li>
</ul>
</li>
<li><a href="#websocket">WebSocket</a>
<ul>
<li><a href="#websocket-%E7%AE%80%E4%BB%8B">WebSocket 简介</a></li>
<li><a href="#websocket-%E4%BD%BF%E7%94%A8">WebSocket 使用</a></li>
</ul>
</li>
<li><a href="#faq">FAQ</a>
<ul>
<li><a href="#http-vs-socket">Http vs. Socket</a></li>
<li><a href="#http-%E5%92%8C-websocket-%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB">HTTP 和 WebSocket 有什么关系？</a></li>
<li><a href="#html-%E5%92%8C-http-%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB">Html 和 HTTP 有什么关系？</a></li>
</ul>
</li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="socket"><a class="markdownIt-Anchor" href="#socket"></a> Socket</h2>
<p>Socket 作为一种抽象层，应用程序通过它来发送和接收数据，使用 Socket 可以将应用程序与处于同一网络中的其他应用程序进行通信交互。简而言之，Socket 提供了应用程序内部与外界通信的端口以及为通信双方提供了数据传输的通道。</p>
<h3 id="socket-用法"><a class="markdownIt-Anchor" href="#socket-用法"></a> Socket 用法</h3>
<p>很多编程语言都支持 Socket。这里以 Java 的 Socket 用法为例。</p>
<p>在 Java 的 SDK 中，socket 的共有两个接口：用于监听客户连接的 <code>ServerSocket</code> 和用于通信的 <code>Socket</code>。使用 socket 的步骤如下：</p>
<ul>
<li>创建 <code>ServerSocket</code> 并监听客户连接</li>
<li>使用 <code>Socket</code> 连接服务端</li>
<li>通过 <code>Socket</code> 获取输入输出流进行通信</li>
</ul>
<h3 id="socket-长连接"><a class="markdownIt-Anchor" href="#socket-长连接"></a> Socket 长连接</h3>
<p>Socket 长连接，指的是在客户和服务端之间保持一个 socket 连接长时间不断开。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">socket.set<span class="constructor">KeepAlive(<span class="params">true</span>)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="websocket"><a class="markdownIt-Anchor" href="#websocket"></a> WebSocket</h2>
<h3 id="websocket-简介"><a class="markdownIt-Anchor" href="#websocket-简介"></a> WebSocket 简介</h3>
<h4 id="websocket-是什么"><a class="markdownIt-Anchor" href="#websocket-是什么"></a> WebSocket 是什么</h4>
<p><a href="http://websocket.org/" target="_blank" rel="noopener">WebSocket</a> 是一种网络通信协议。<a href="https://tools.ietf.org/html/rfc6455" target="_blank" rel="noopener">RFC6455</a> 定义了它的通信标准。</p>
<p>WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。</p>
<h4 id="为什么需要-websocket"><a class="markdownIt-Anchor" href="#为什么需要-websocket"></a> 为什么需要 WebSocket</h4>
<p>了解计算机网络协议的人，应该都知道：HTTP 协议是一种无状态的、无连接的、单向的应用层协议。它采用了请求/响应模型。通信请求只能由客户端发起，服务端对请求做出应答处理。</p>
<p>这种通信模型有一个弊端：HTTP 协议无法实现服务器主动向客户端发起消息。</p>
<p>这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。大多数 Web 应用程序将通过频繁的异步 JavaScript 和 XML（AJAX）请求实现长轮询。轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/java/spring/web/ajax-long-polling.png!zp"/></div>
因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的。WebSocket 连接允许客户端和服务器之间进行全双工通信，以便任一方都可以通过建立的连接将数据推送到另一端。WebSocket 只需要建立一次连接，就可以一直保持连接状态。这相比于轮询方式的不停建立连接显然效率要大大提高。
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/java/spring/web/websockets-flow.png!zp"/></div>
#### WebSocket 如何工作
<p>Web 浏览器和服务器都必须实现 WebSockets 协议来建立和维护连接。由于 WebSockets 连接长期存在，与典型的 HTTP 连接不同，对服务器有重要的影响。</p>
<p>基于多线程或多进程的服务器无法适用于 WebSockets，因为它旨在打开连接，尽可能快地处理请求，然后关闭连接。任何实际的 WebSockets 服务器端实现都需要一个异步服务器。</p>
<h3 id="websocket-使用"><a class="markdownIt-Anchor" href="#websocket-使用"></a> WebSocket 使用</h3>
<h4 id="websocket-客户端"><a class="markdownIt-Anchor" href="#websocket-客户端"></a> WebSocket 客户端</h4>
<p>在客户端，没有必要为 WebSockets 使用 JavaScript 库。实现 WebSockets 的 Web 浏览器将通过 WebSockets 对象公开所有必需的客户端功能（主要指支持 Html5 的浏览器）。</p>
<p>以下 API 用于创建 WebSocket 对象。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">var Socket = <span class="keyword">new</span> <span class="constructor">WebSocket(<span class="params">url</span>, [<span class="params">protocol</span>] )</span>;</span><br></pre></td></tr></table></figure>
<p>以上代码中的第一个参数 url, 指定连接的 URL。第二个参数 protocol 是可选的，指定了可接受的子协议。</p>
<h5 id="websocket-属性"><a class="markdownIt-Anchor" href="#websocket-属性"></a> WebSocket 属性</h5>
<p>以下是 WebSocket 对象的属性。假定我们使用了以上代码创建了 Socket 对象：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Socket.readyState</td>
<td>只读属性 <strong>readyState</strong> 表示连接状态，可以是以下值：0 - 表示连接尚未建立。1 - 表示连接已建立，可以进行通信。2 - 表示连接正在进行关闭。3 - 表示连接已经关闭或者连接不能打开。</td>
</tr>
<tr>
<td>Socket.bufferedAmount</td>
<td>只读属性 <strong>bufferedAmount</strong> 已被 send() 放入正在队列中等待传输，但是还没有发出的 UTF-8 文本字节数。</td>
</tr>
</tbody>
</table>
<h5 id="websocket-事件"><a class="markdownIt-Anchor" href="#websocket-事件"></a> WebSocket 事件</h5>
<p>以下是 WebSocket 对象的相关事件。假定我们使用了以上代码创建了 Socket 对象：</p>
<table>
<thead>
<tr>
<th>事件</th>
<th>事件处理程序</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>open</td>
<td>Socket.onopen</td>
<td>连接建立时触发</td>
</tr>
<tr>
<td>message</td>
<td>Socket.onmessage</td>
<td>客户端接收服务端数据时触发</td>
</tr>
<tr>
<td>error</td>
<td>Socket.onerror</td>
<td>通信发生错误时触发</td>
</tr>
<tr>
<td>close</td>
<td>Socket.onclose</td>
<td>连接关闭时触发</td>
</tr>
</tbody>
</table>
<h5 id="websocket-方法"><a class="markdownIt-Anchor" href="#websocket-方法"></a> WebSocket 方法</h5>
<p>以下是 WebSocket 对象的相关方法。假定我们使用了以上代码创建了 Socket 对象：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Socket.send()</td>
<td>使用连接发送数据</td>
</tr>
<tr>
<td>Socket.close()</td>
<td>关闭连接</td>
</tr>
</tbody>
</table>
<p>WebSocket 客户端代码示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化一个 WebSocket 对象</span></span><br><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:9998/echo'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立 web socket 连接成功触发事件</span></span><br><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 使用 send() 方法发送数据</span></span><br><span class="line">  ws.send(<span class="string">'发送数据'</span>)</span><br><span class="line">  alert(<span class="string">'数据发送中...'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收服务端数据时触发事件</span></span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> received_msg = evt.data</span><br><span class="line">  alert(<span class="string">'数据已接收...'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 断开 web socket 连接成功触发事件</span></span><br><span class="line">ws.onclose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'连接已关闭...'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="websocket-服务端"><a class="markdownIt-Anchor" href="#websocket-服务端"></a> WebSocket 服务端</h4>
<p>WebSocket 在服务端的实现非常丰富。Node.js、Java、C++、Python 等多种语言都有自己的解决方案。</p>
<p>以下，介绍我在学习 WebSocket 过程中接触过的 WebSocket 服务端解决方案。</p>
<h5 id="nodejs"><a class="markdownIt-Anchor" href="#nodejs"></a> Node.js</h5>
<p>常用的 Node 实现有以下三种。</p>
<ul>
<li><a href="https://github.com/uWebSockets/uWebSockets" target="_blank" rel="noopener">µWebSockets</a></li>
<li><a href="http://socket.io/" target="_blank" rel="noopener">Socket.IO</a></li>
<li><a href="https://github.com/theturtle32/WebSocket-Node" target="_blank" rel="noopener">WebSocket-Node</a></li>
</ul>
<h5 id="java"><a class="markdownIt-Anchor" href="#java"></a> Java</h5>
<p>Java 的 web 一般都依托于 servlet 容器。</p>
<p>我使用过的 servlet 容器有：Tomcat、Jetty、Resin。其中 Tomcat7、Jetty7 及以上版本均开始支持 WebSocket（推荐较新的版本，因为随着版本的更迭，对 WebSocket 的支持可能有变更）。</p>
<p>此外，Spring 框架对 WebSocket 也提供了支持。</p>
<p>虽然，以上应用对于 WebSocket 都有各自的实现。但是，它们都遵循<a href="https://tools.ietf.org/html/rfc6455" target="_blank" rel="noopener">RFC6455</a> 的通信标准，并且 Java API 统一遵循 <a href="http://www.jcp.org/en/jsr/detail?id=356" target="_blank" rel="noopener">JSR 356 - JavaTM API for WebSocket </a> 规范。所以，在实际编码中，API 差异不大。</p>
<h5 id="spring"><a class="markdownIt-Anchor" href="#spring"></a> Spring</h5>
<p>Spring 对于 WebSocket 的支持基于下面的 jar 包：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 Spring 实现 WebSocket 服务器大概分为以下几步：</p>
<p><strong>创建 WebSocket 处理器</strong></p>
<p>扩展 <code>TextWebSocketHandler</code> 或 <code>BinaryWebSocketHandler</code> ，你可以覆写指定的方法。Spring 在收到 WebSocket 事件时，会自动调用事件对应的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.socket.WebSocketHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.WebSocketSession;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.TextMessage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">TextWebSocketHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleTextMessage</span><span class="params">(WebSocketSession session, TextMessage message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>WebSocketHandler</code> 源码如下，这意味着你的处理器大概可以处理哪些 WebSocket 事件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WebSocketHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 建立连接后触发的回调</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">afterConnectionEstablished</span><span class="params">(WebSocketSession session)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 收到消息时触发的回调</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(WebSocketSession session, WebSocketMessage&lt;?&gt; message)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 传输消息出错时触发的回调</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">handleTransportError</span><span class="params">(WebSocketSession session, Throwable exception)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 断开连接后触发的回调</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">afterConnectionClosed</span><span class="params">(WebSocketSession session, CloseStatus closeStatus)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 是否处理分片消息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">supportsPartialMessages</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>配置 WebSocket</strong></p>
<p>配置有两种方式：注解和 xml 。其作用就是将 WebSocket 处理器添加到注册中心。</p>
<ol>
<li>实现 <code>WebSocketConfigurer</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.EnableWebSocket;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.WebSocketConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocket</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title">WebSocketConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerWebSocketHandlers</span><span class="params">(WebSocketHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addHandler(myHandler(), <span class="string">"/myHandler"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebSocketHandler <span class="title">myHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>xml 方式</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:websocket</span>=<span class="string">"http://www.springframework.org/schema/websocket"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/websocket</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/websocket/spring-websocket.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">websocket:handlers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">websocket:mapping</span> <span class="attr">path</span>=<span class="string">"/myHandler"</span> <span class="attr">handler</span>=<span class="string">"myHandler"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">websocket:handlers</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myHandler"</span> <span class="attr">class</span>=<span class="string">"org.springframework.samples.MyHandler"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>更多配置细节可以参考：<a href="https://docs.spring.io/spring/docs/4.3.12.RELEASE/spring-framework-reference/htmlsingle/#websocket" target="_blank" rel="noopener">Spring WebSocket 文档</a></p>
</blockquote>
<p>javax.websocket</p>
<p>如果不想使用 Spring 框架的 WebSocket API，你也可以选择基本的 javax.websocket。</p>
<p>首先，需要引入 API jar 包。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- To write basic javax.websocket against --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.websocket<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.websocket-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果使用嵌入式 jetty，你还需要引入它的实现包：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- To run javax.websocket in embedded server --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty.websocket<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax-websocket-server-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jetty-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- To run javax.websocket client --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty.websocket<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax-websocket-client-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jetty-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>@ServerEndpoint</strong></p>
<p>这个注解用来标记一个类是 WebSocket 的处理器。</p>
<p>然后，你可以在这个类中使用下面的注解来表明所修饰的方法是触发事件的回调</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 收到消息触发事件</span></span><br><span class="line"><span class="meta">@OnMessage</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String message, Session session)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开连接触发事件</span></span><br><span class="line"><span class="meta">@OnOpen</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpen</span><span class="params">(Session session, EndpointConfig config, @PathParam(<span class="string">"id"</span>)</span> String id) </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭连接触发事件</span></span><br><span class="line"><span class="meta">@OnClose</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">(Session session, CloseReason closeReason)</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传输消息错误触发事件</span></span><br><span class="line"><span class="meta">@OnError</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable error)</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ServerEndpointConfig.Configurator</strong></p>
<p>编写完处理器，你需要扩展 ServerEndpointConfig.Configurator 类完成配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketServerConfigurator</span> <span class="keyword">extends</span> <span class="title">ServerEndpointConfig</span>.<span class="title">Configurator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modifyHandshake</span><span class="params">(ServerEndpointConfig sec, HandshakeRequest request, HandshakeResponse response)</span> </span>&#123;</span><br><span class="line">        HttpSession httpSession = (HttpSession) request.getHttpSession();</span><br><span class="line">        sec.getUserProperties().put(HttpSession<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>(), <span class="title">httpSession</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就没有然后了，就是这么简单。</p>
<h4 id="websocket-代理"><a class="markdownIt-Anchor" href="#websocket-代理"></a> WebSocket 代理</h4>
<p>如果把 WebSocket 的通信看成是电话连接，Nginx 的角色则像是电话接线员，负责将发起电话连接的电话转接到指定的客服。</p>
<p>Nginx 从 <a href="http://nginx.com/blog/websocket-nginx/" target="_blank" rel="noopener">1.3 版</a>开始正式支持 WebSocket 代理。如果你的 web 应用使用了代理服务器 Nginx，那么你还需要为 Nginx 做一些配置，使得它开启 WebSocket 代理功能。</p>
<p>以下为参考配置：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">  <span class="comment"># this section is specific to the WebSockets proxying</span></span><br><span class="line">  <span class="attribute">location</span> /socket.io &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://app_server_wsgiapp/socket.io;</span><br><span class="line">    <span class="attribute">proxy_redirect</span> <span class="literal">off</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> Connection <span class="string">"upgrade"</span>;</span><br><span class="line">    <span class="attribute">proxy_read_timeout</span> <span class="number">600</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>更多配置细节可以参考：<a href="http://nginx.org/en/docs/http/websocket.html" target="_blank" rel="noopener">Nginx 官方的 websocket 文档</a></p>
</blockquote>
<h4 id="websocket-应用示例"><a class="markdownIt-Anchor" href="#websocket-应用示例"></a> WebSocket 应用示例</h4>
<p>如果需要完整示例代码，可以参考我的 Github 代码：</p>
<ul>
<li><a href="https://github.com/dunwu/spring-notes/tree/master/codes/web/websocket" target="_blank" rel="noopener">Spring 对 WebSocket 支持的示例</a></li>
<li><a href="https://github.com/dunwu/javaee-notes/tree/master/codes/websocket" target="_blank" rel="noopener">嵌入式 Jetty 服务器的 WebSocket 示例</a></li>
</ul>
<p>spring-websocket 和 jetty 9.3 版本似乎存在兼容性问题，Tomcat 则木有问题。</p>
<p>我尝试了好几次，没有找到解决方案，只好使用 Jetty 官方的嵌入式示例在 Jetty 中使用 WebSocket 。</p>
<h2 id="faq"><a class="markdownIt-Anchor" href="#faq"></a> FAQ</h2>
<h3 id="http-vs-socket"><a class="markdownIt-Anchor" href="#http-vs-socket"></a> Http vs. Socket</h3>
<p>Http 通信与 Socket 通信方式有何差异？</p>
<ul>
<li>Http
<ul>
<li>基于请求/响应模式，采取一问一答方式（客户端请求，服务端才会响应）</li>
</ul>
</li>
<li>Socket
<ul>
<li>客户端和服务端建立双向连接。连接成功后，任意一方都可主动发送消息。</li>
<li>数据丢失率低，使用简单，易于移植。</li>
</ul>
</li>
</ul>
<h3 id="http-和-websocket-有什么关系"><a class="markdownIt-Anchor" href="#http-和-websocket-有什么关系"></a> HTTP 和 WebSocket 有什么关系？</h3>
<p>Websocket 其实是一个新协议，跟 HTTP 协议基本没有关系，只是为了兼容现有浏览器的握手规范而已，也就是说它是 HTTP 协议上的一种补充。</p>
<h3 id="html-和-http-有什么关系"><a class="markdownIt-Anchor" href="#html-和-http-有什么关系"></a> Html 和 HTTP 有什么关系？</h3>
<p>Html 是超文本标记语言，是一种用于创建网页的标准标记语言。它是一种技术标准。Html5 是它的最新版本。</p>
<p>Http 是一种网络通信协议。其本身和 Html 没有直接关系。</p>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><a href="https://www.zhihu.com/question/20215561" target="_blank" rel="noopener">知乎高票答案——WebSocket 是什么原理</a> - 对 WebSocket 原理的阐述简单易懂。</li>
<li><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" rel="noopener">WebSocket 教程</a> - 阮一峰大神的科普一如既往的浅显易懂。</li>
<li><a href="https://www.fullstackpython.com/websockets.html" target="_blank" rel="noopener">WebSockets</a> - by <em>fullstackpython</em></li>
<li><a href="http://nginx.org/en/docs/http/websocket.html" target="_blank" rel="noopener">Nginx 官方的 websocket 文档</a></li>
<li><a href="https://docs.spring.io/spring/docs/4.3.12.RELEASE/spring-framework-reference/htmlsingle/#websocket" target="_blank" rel="noopener">Spring WebSocket 文档</a></li>
<li><a href="http://tomcat.apache.org/tomcat-7.0-doc/web-socket-howto.html" target="_blank" rel="noopener">Tomcat7 WebSocket 文档</a></li>
<li><a href="https://www.eclipse.org/jetty/documentation/9.4.7.v20170914/websocket-intro.html" target="_blank" rel="noopener">Jetty WebSocket 文档</a></li>
<li><a href="https://juejin.im/post/57f885370bd1d00058b37d74" target="_blank" rel="noopener">Socket，你需要知道的事儿</a></li>
<li><a href="https://juejin.im/post/5b3649d751882552f052703b" target="_blank" rel="noopener">手把手教你写 Socket 长连接</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/blog/">1</a><span class="page-number current">2</span><a class="page-number" href="/blog/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/8/">8</a><a class="extend next" rel="next" href="/blog/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="Zhang Peng"
    src="/blog/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Zhang Peng</p>
  <div class="site-description" itemprop="description">Dunwu's Blog</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">74</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">47</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/dunwu" title="GitHub &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;dunwu" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/blog/mailto:forbreak@163.com" title="E-Mail &amp;rarr; mailto:forbreak@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/blog/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-paper-plane"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhang Peng</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">384k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">5:49</span>
</div>

        












        
      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest.min.js"></script>
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>
<script src="/blog/js/utils.js"></script><script src="/blog/js/motion.js"></script>
<script src="/blog/js/schemes/pisces.js"></script>
<script src="/blog/js/next-boot.js"></script><script src="/blog/js/bookmark.js"></script>



  




  <script src="/blog/js/local-search.js"></script>













  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://blog-ajay4qmfci.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>

</body>
</html>

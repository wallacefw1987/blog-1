<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dunwu</title>
  
  <subtitle>大道至简，知易行难</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://dunwu.github.io/blog/"/>
  <updated>2020-01-27T15:30:00.166Z</updated>
  <id>https://dunwu.github.io/blog/</id>
  
  <author>
    <name>Zhang Peng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Markdown Cheat Sheet</title>
    <link href="https://dunwu.github.io/blog/efficiency/style/markdown-cheatsheet/"/>
    <id>https://dunwu.github.io/blog/efficiency/style/markdown-cheatsheet/</id>
    <published>2021-01-26T16:00:00.000Z</published>
    <updated>2020-01-27T15:30:00.166Z</updated>
    
    <content type="html"><![CDATA[<h1 id="markdown-cheat-sheet"><a class="markdownIt-Anchor" href="#markdown-cheat-sheet"></a> Markdown Cheat Sheet</h1><blockquote><p>📦 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p></blockquote><h2 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h2><!-- TOC depthFrom:2 depthTo:2 --><ul><li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li><li><a href="#%E6%A0%87%E9%A2%98">标题</a></li><li><a href="#%E6%96%87%E6%9C%AC%E6%A0%B7%E5%BC%8F">文本样式</a></li><li><a href="#%E5%88%97%E8%A1%A8">列表</a></li><li><a href="#%E5%88%86%E5%89%B2%E7%BA%BF">分割线</a></li><li><a href="#%E9%93%BE%E6%8E%A5">链接</a></li><li><a href="#%E5%BC%95%E7%94%A8">引用</a></li><li><a href="#%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE">代码高亮</a></li><li><a href="#%E8%A1%A8%E6%A0%BC">表格</a></li><li><a href="#emoji-%E8%A1%A8%E6%83%85">Emoji 表情</a></li><li><a href="#%E6%B3%A8%E8%84%9A">注脚</a></li><li><a href="#%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F">数学公式</a></li><li><a href="#diff">Diff</a></li><li><a href="#%E6%B5%81%E7%A8%8B%E5%9B%BE">流程图</a></li><li><a href="#html">HTML</a></li><li><a href="#%E7%BC%96%E8%BE%91%E5%99%A8">编辑器</a></li><li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li></ul><!-- /TOC --><h2 id="标题"><a class="markdownIt-Anchor" href="#标题"></a> 标题</h2><p>Markdown 支持六个级别的标题。</p><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><h2 id="文本样式"><a class="markdownIt-Anchor" href="#文本样式"></a> 文本样式</h2><blockquote><p>💡 粗体、斜体、删除线可以混合使用。</p><p>在 Markdown 中，粗体文本、斜体文本可以使用 <code>*</code> 或 <code>_</code> 符号标记。建议统一风格，始终只用一种符号。</p></blockquote><table><thead><tr><th>语法</th><th>效果</th></tr></thead><tbody><tr><td>普通文本</td><td>普通文本</td></tr><tr><td><code>*斜体文本*</code> <code>_斜体文本_</code></td><td><em>斜体文本</em> <em>斜体文本</em></td></tr><tr><td><code>**粗体文本**</code> <code>__粗体文本__</code></td><td><strong>粗体文本</strong> <strong>粗体文本</strong></td></tr><tr><td><code>~~删除文本~~</code></td><td><s>删除文本</s></td></tr><tr><td><code>***粗斜体文本***</code> <code>___粗斜体文本___</code></td><td><em><strong>粗斜体文本</strong></em> <em><strong>粗斜体文本</strong></em></td></tr></tbody></table><h2 id="列表"><a class="markdownIt-Anchor" href="#列表"></a> 列表</h2><h3 id="无序列表"><a class="markdownIt-Anchor" href="#无序列表"></a> 无序列表</h3><ul><li>RED</li><li>YELLOW</li><li>BLUE</li></ul><h3 id="有序列表"><a class="markdownIt-Anchor" href="#有序列表"></a> 有序列表</h3><ol><li>第一步</li><li>第二步</li><li>第三步</li></ol><h3 id="任务列表"><a class="markdownIt-Anchor" href="#任务列表"></a> 任务列表</h3><ul><li>[x] 完成任务</li><li>[ ] 计划任务</li></ul><h3 id="多级列表"><a class="markdownIt-Anchor" href="#多级列表"></a> 多级列表</h3><ul><li>数据结构<ul><li>线性表<ul><li>顺序表</li><li>链表<ul><li>单链表</li><li>双链表</li></ul></li></ul></li><li>树<ul><li>二叉树<ul><li>二叉平衡树</li></ul></li></ul></li></ul></li></ul><h2 id="分割线"><a class="markdownIt-Anchor" href="#分割线"></a> 分割线</h2><p><code>***</code>、<code>---</code>、<code>___</code> 都可以作为分割线。</p><hr /><hr /><hr /><h2 id="链接"><a class="markdownIt-Anchor" href="#链接"></a> 链接</h2><h3 id="普通链接"><a class="markdownIt-Anchor" href="#普通链接"></a> 普通链接</h3><p>语法：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">我的博客</span>](<span class="link">https://dunwu.github.io/blog/</span>)</span><br></pre></td></tr></table></figure><ul><li><code>[]</code> 中标记链接名。类似 HTML 中 <code>&lt;a&gt;</code> 元素的 <code>title</code> 属性。</li><li><code>()</code> 中标记链接的 url，也支持相对路径（前提是资源可以访问）。类似 HTML 中 <code>&lt;a&gt;</code> 元素的 <code>href</code> 属性。</li></ul><p>效果：</p><ul><li><a href="https://dunwu.github.io/blog/" title="blog">我的博客</a></li></ul><h3 id="图片"><a class="markdownIt-Anchor" href="#图片"></a> 图片</h3><p>Markdown 引用图片的语法：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">alt</span>](<span class="link">url title</span>)</span><br></pre></td></tr></table></figure><p>alt 和 title 即对应 HTML 中 img 元素的 alt 和 title 属性（都可省略）：</p><ul><li><p>alt - 表示图片显示失败时的替换文本。</p></li><li><p>title - 表示鼠标悬停在图片时的显示文本（注意这里要加引号）</p></li><li><p>url - 即图片的 url 地址</p></li></ul><p><img src="http://dunwu.test.upcdn.net/common/logo/zp.png" alt="logo" title="logo" /></p><h3 id="图片链接"><a class="markdownIt-Anchor" href="#图片链接"></a> 图片链接</h3><p>可以将图片和链接混合使用。</p><p><a href="https://dunwu.github.io/blog/"><img src="http://dunwu.test.upcdn.net/common/logo/zp.png" alt="logo" title="logo" /></a></p><h3 id="锚点"><a class="markdownIt-Anchor" href="#锚点"></a> 锚点</h3><p>其实呢，每一个标题都是一个锚点，和 HTML 的锚点（<code>#</code>）类似，比如：<a href="#Markdown-%E5%BA%94%E7%94%A8%E6%8C%87%E5%8D%97">回到顶部</a></p><h2 id="引用"><a class="markdownIt-Anchor" href="#引用"></a> 引用</h2><p>普通引用：</p><blockquote><p>❓ 什么是 <code>Markdown</code></p><p><strong>Markdown</strong>是一种<a href="https://zh.wikipedia.org/wiki/%E8%BD%BB%E9%87%8F%E7%BA%A7%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener">轻量级标记语言</a>，创始人为<a href="https://zh.wikipedia.org/wiki/%E7%B4%84%E7%BF%B0%C2%B7%E6%A0%BC%E9%AD%AF%E4%BC%AF" target="_blank" rel="noopener">约翰·格鲁伯</a>（英语：John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的<a href="https://zh.wikipedia.org/wiki/XHTML" target="_blank" rel="noopener">XHTML</a>（或者<a href="https://zh.wikipedia.org/wiki/HTML" target="_blank" rel="noopener">HTML</a>）文档”。[<a href="https://zh.wikipedia.org/wiki/Markdown#cite_note-md-4" target="_blank" rel="noopener">4]</a>这种语言吸收了很多在<a href="https://zh.wikipedia.org/wiki/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6" target="_blank" rel="noopener">电子邮件</a>中已有的纯文本标记的特性。 —— 摘自 Wiki</p></blockquote><p>嵌套引用：</p><blockquote><p>数据结构</p><blockquote><p>树</p><blockquote><p>二叉树</p><blockquote><p>平衡二叉树</p><blockquote><p>满二叉树</p></blockquote></blockquote></blockquote></blockquote></blockquote><h2 id="代码高亮"><a class="markdownIt-Anchor" href="#代码高亮"></a> 代码高亮</h2><h3 id="标签"><a class="markdownIt-Anchor" href="#标签"></a> 标签</h3><p>语法：</p><figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">`Markdown` `Doc`</span><br></pre></td></tr></table></figure><p>效果：</p><p><code>Markdown</code>, <code>Doc</code></p><h3 id="代码块"><a class="markdownIt-Anchor" href="#代码块"></a> 代码块</h3><p>语法一：在文本前后都使用三个反引号进行标记。【✔️ 推荐】</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这是一个文本块。</span><br><span class="line">这是一个文本块。</span><br><span class="line">这是一个文本块。</span><br></pre></td></tr></table></figure><p>语法二：在连续几行的文本开头加入 1 个 Tab 或者 4 个空格。【❌ 不推荐】</p><pre><code>这是一个文本块。这是一个文本块。这是一个文本块。</code></pre><h3 id="语法"><a class="markdownIt-Anchor" href="#语法"></a> 语法</h3><p>在三个反引号后面加上编程语言的名字，另起一行开始写代码，最后一行再加上三个反引号。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;&#125; <span class="comment">//Java</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> <span class="comment">//C</span></span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"hello GitHub"</span> <span class="comment">#Bash</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'myH1'</span>).innerHTML = <span class="string">'Welcome to my Homepage'</span> <span class="comment">//javascipt</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> &amp;<span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="built_in">string</span>&amp; A,<span class="keyword">const</span> <span class="built_in">string</span>&amp; B) <span class="comment">//cpp</span></span><br></pre></td></tr></table></figure><h2 id="表格"><a class="markdownIt-Anchor" href="#表格"></a> 表格</h2><p>一般表格：</p><table><thead><tr><th>表头 1</th><th>表头 2</th></tr></thead><tbody><tr><td>表格单元</td><td>表格单元</td></tr><tr><td>表格单元</td><td>表格单元</td></tr></tbody></table><p>表格可以指定对齐方式：</p><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:left">商品</th><th style="text-align:right">价格</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:left">电脑</td><td style="text-align:right">6000.0</td></tr><tr><td style="text-align:center">2</td><td style="text-align:left">鼠标</td><td style="text-align:right">100.0</td></tr><tr><td style="text-align:center">3</td><td style="text-align:left">键盘</td><td style="text-align:right">200.0</td></tr></tbody></table><h2 id="emoji-表情"><a class="markdownIt-Anchor" href="#emoji-表情"></a> Emoji 表情</h2><p>Markdown 引擎一般都支持 Emoji。</p><p>合理使用 Emoji 表情，往往可以使得文章内容更加丰富生动。例如：✔️ ❌ 💡 🔔 ❗️ ❓</p><blockquote><p>更多 Emoji 表情请参考：</p><ul><li><a href="http://emojihomepage.com/" target="_blank" rel="noopener">http://emojihomepage.com/</a></li><li><a href="http://www.emoji-cheat-sheet.com" target="_blank" rel="noopener">http://www.emoji-cheat-sheet.com</a></li></ul></blockquote><h2 id="注脚"><a class="markdownIt-Anchor" href="#注脚"></a> 注脚</h2><p>一个具有注脚的文本。<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><h2 id="数学公式"><a class="markdownIt-Anchor" href="#数学公式"></a> 数学公式</h2><p>很多文档中，需要引入一些数学符号、特殊符号，其排版问题比较头疼。这种问题，可以用 Latex 来解决，大部分 Markdown 引擎都支持 Latex。</p><p>Latex 可以使用 <code>$</code> 符号来标记 Latex 表达式，下面是一个数学公式示例：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Γ</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>∫</mo><mn>0</mn><mi mathvariant="normal">∞</mi></msubsup><msup><mi>t</mi><mrow><mi>z</mi><mo>−</mo><mn>1</mn></mrow></msup><msup><mi>e</mi><mrow><mo>−</mo><mi>t</mi></mrow></msup><mi>d</mi><mi>t</mi><mtext> </mtext><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\Gamma(z) = \int_0^\infty t^{z-1}e^{-t}dt\,.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Γ</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.326242em;vertical-align:-0.9119499999999999em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.414292em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">∞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.843556em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathdefault mtight">t</span></span></span></span></span></span></span></span></span><span class="mord mathdefault">d</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span></span></span></span></span></p><p>列举一些常用数学符号：</p><table><thead><tr><th style="text-align:center">符号</th><th>语法</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\leq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span></span></span></span></td><td><code>$\leq$</code></td><td>小于等于</td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≥</mo></mrow><annotation encoding="application/x-tex">\geq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≥</span></span></span></span></td><td><code>$\geq$</code></td><td>大于等于</td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">≠</mi></mrow><annotation encoding="application/x-tex">\neq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span></span></span></span></td><td><code>$\neq$</code></td><td>不等于</td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≈</mo></mrow><annotation encoding="application/x-tex">\approx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.48312em;vertical-align:0em;"></span><span class="mrel">≈</span></span></span></span></td><td><code>$\approx$</code></td><td>约等于</td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord">∞</span></span></span></span></td><td><code>$\infty$</code></td><td>无穷</td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∏</mo><mi>x</mi><mi>y</mi></msubsup></mrow><annotation encoding="application/x-tex">\prod_{x}^{y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span style="top:-3.2029000000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span></span></span></span></td><td><code>$\prod_{x}^{y}$</code></td><td>累乘</td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>n</mi></msubsup></mrow><annotation encoding="application/x-tex">\sum_{i=0}^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span></span></span></span></td><td><code>$\sum_{i=0}^n$</code></td><td>求和</td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∫</mo></mrow><annotation encoding="application/x-tex">\int</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.11112em;vertical-align:-0.30612em;"></span><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0005599999999999772em;">∫</span></span></span></span></td><td><code>$\int$</code></td><td>积分</td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∬</mo></mrow><annotation encoding="application/x-tex">\iint</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.111em;vertical-align:-0.306em;"></span><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0004999999999999727em;">∬</span></span></span></span></td><td><code>$\iint$</code></td><td>双重积分</td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mo><mi>log</mi><mo>⁡</mo></mo><mi>x</mi></msub><mi>y</mi></mrow><annotation encoding="application/x-tex">\log_x{y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93858em;vertical-align:-0.24414em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.057252em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span></span></td><td><code>$\log_x{y}$</code></td><td>对数</td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mrow><mi>y</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">x^{y+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></td><td><code>$x^{y+1}$</code></td><td>上标</td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mrow><mi>y</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">x_{y+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></td><td><code>$x_{y+1}$</code></td><td>下标</td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>x</mi><mi>y</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{x}{y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1764999999999999em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></td><td><code>$\frac{x}{y}$</code></td><td>分数</td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mroot><mi>x</mi><mi>y</mi></mroot></mrow><annotation encoding="application/x-tex">\sqrt[y]{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.23972em;"></span><span class="mord sqrt"><span class="root"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.5516160000000001em;"><span style="top:-2.836336em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size6 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span></span></span></span></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">x</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span></span></span></span></td><td><code>$\sqrt[y]{x}$</code></td><td>开方</td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>sin</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\sin</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66786em;vertical-align:0em;"></span><span class="mop">sin</span></span></span></span></td><td><code>$\sin$</code></td><td>正弦</td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>cos</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\cos</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mop">cos</span></span></span></span></td><td><code>$\cos$</code></td><td>余弦</td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>tan</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\tan</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mop">tan</span></span></span></span></td><td><code>$\tan$</code></td><td>正切</td></tr></tbody></table><blockquote><p>更多数学符号支持请参考：</p><ul><li><a href="https://github.com/luong-komorebi/Begin-Latex-in-minutes" target="_blank" rel="noopener">Begin-Latex-in-minutes</a></li><li><a href="https://blog.csdn.net/Katherine_hsr/article/details/79179622" target="_blank" rel="noopener">Markdown 数学符号&amp;公式</a></li></ul></blockquote><h2 id="diff"><a class="markdownIt-Anchor" href="#diff"></a> Diff</h2><p>版本控制的系统中都少不了 diff 的功能，即展示一个文件内容的增加与删除。<br />GFM 中可以显示的展示 diff 效果。可以用 <code>+</code> 开头表示新增，<code>-</code> 开头表示删除。</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="addition">+ 新增内容</span></span><br><span class="line"><span class="deletion">- 删除内容</span></span><br></pre></td></tr></table></figure><h2 id="uml-图"><a class="markdownIt-Anchor" href="#uml-图"></a> UML 图</h2><blockquote><p>部分 Markdown 引擎支持 <a href="https://mermaid-js.github.io/mermaid/" target="_blank" rel="noopener">mermaid</a> 提供的各种 UML 图。详情请参考：<a href="https://mermaidjs.github.io/" target="_blank" rel="noopener">mermaid 文档</a></p></blockquote><h3 id="流程图"><a class="markdownIt-Anchor" href="#流程图"></a> 流程图</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A[Hard edge] --&gt;|Link text| B(Round edge)</span><br><span class="line">    B --&gt; C&#123;Decision&#125;</span><br><span class="line">    C --&gt;|One| D[Result one]</span><br><span class="line">    C --&gt;|Two| E[Result two]</span><br></pre></td></tr></table></figure><h3 id="时序图"><a class="markdownIt-Anchor" href="#时序图"></a> 时序图</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    Alice-&gt;&gt;Bob: Hello Bob, how are you?</span><br><span class="line">    alt is sick</span><br><span class="line">        Bob-&gt;&gt;Alice: Not so good :(</span><br><span class="line">    else is well</span><br><span class="line">        Bob-&gt;&gt;Alice: Feeling fresh like a daisy</span><br><span class="line">    end</span><br><span class="line">    opt Extra response</span><br><span class="line">        Bob-&gt;&gt;Alice: Thanks for asking</span><br><span class="line">    end</span><br></pre></td></tr></table></figure><h3 id="甘特图"><a class="markdownIt-Anchor" href="#甘特图"></a> 甘特图</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gantt</span><br><span class="line">       dateFormat  YYYY-MM-DD</span><br><span class="line">       title Adding GANTT diagram functionality to mermaid</span><br><span class="line"></span><br><span class="line">       section A section</span><br><span class="line">       Completed task            :done,    des1, 2014-01-06,2014-01-08</span><br><span class="line">       Active task               :active,  des2, 2014-01-09, 3d</span><br><span class="line">       Future task               :         des3, after des2, 5d</span><br><span class="line">       Future task2              :         des4, after des3, 5d</span><br><span class="line"></span><br><span class="line">       section Critical tasks</span><br><span class="line">       Completed task in the critical line :crit, done, 2014-01-06,24h</span><br><span class="line">       Implement parser and jison          :crit, done, after des1, 2d</span><br><span class="line">       Create tests for parser             :crit, active, 3d</span><br><span class="line">       Future task in critical line        :crit, 5d</span><br><span class="line">       Create tests for renderer           :2d</span><br><span class="line">       Add to mermaid                      :1d</span><br><span class="line"></span><br><span class="line">       section Documentation</span><br><span class="line">       Describe gantt syntax               :active, a1, after des1, 3d</span><br><span class="line">       Add gantt diagram to demo page      :after a1  , 20h</span><br><span class="line">       Add another diagram to demo page    :doc1, after a1  , 48h</span><br><span class="line"></span><br><span class="line">       section Last section</span><br><span class="line">       Describe gantt syntax               :after doc1, 3d</span><br><span class="line">       Add gantt diagram to demo page      :20h</span><br><span class="line">       Add another diagram to demo page    :48h</span><br></pre></td></tr></table></figure><h2 id="html"><a class="markdownIt-Anchor" href="#html"></a> HTML</h2><p>有些 Markdown 引擎支持在文档中嵌入的 html 元素。</p><p>有些 Markdown 语法所不支持的特性，可以使用 html 元素来支持。</p><h3 id="折叠"><a class="markdownIt-Anchor" href="#折叠"></a> 折叠</h3><details>  <summary>折叠内容一</summary>  <p>展开才能看到的内容</p></details><details>  <summary>折叠内容二</summary>  <p>展开才能看到的内容</p></details><h3 id="居中"><a class="markdownIt-Anchor" href="#居中"></a> 居中</h3><div align="center"><p>居中显示的文本</p></div>### 图片尺寸<div align="center"><img width="100px" src="http://dunwu.test.upcdn.net/common/logo/zp.png" /></div>## 编辑器<p>推荐 Markdown 编辑器</p><ul><li><a href="https://www.typora.io/" target="_blank" rel="noopener">Typora</a> - 个人认为是功能最强的 Markdown 编辑器。</li><li><a href="https://github.com/microsoft/vscode" target="_blank" rel="noopener">Visual Studio Code</a> - 可以通过安装插件，量身打造 Markdown 编辑器。</li><li><a href="https://github.com/marktext/marktext" target="_blank" rel="noopener">marktext</a> - 一款简单优雅的 Markdown 编辑器。</li><li><a href="https://stackedit.io/" target="_blank" rel="noopener">StackEdit</a> - 在线 Markdown 编辑器。</li><li><a href="https://pandao.github.io/editor.md/" target="_blank" rel="noopener">Editor.md</a> - 在线 Markdown 编辑器。</li><li><a href="https://maxiang.io/" target="_blank" rel="noopener">Marxico</a> - 一款专为印象笔记（Evernote）打造的 Markdown 编辑器。</li></ul><blockquote><p>想了解更多 Markdown 编辑器可以参考：<a href="https://zhuanlan.zhihu.com/p/69210764" target="_blank" rel="noopener">主流 Markdown 编辑器推荐</a></p></blockquote><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ul><li><a href="https://zh.wikipedia.org/wiki/Markdown" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Markdown</a></li><li><a href="https://github.com/guodongxiaren/README" target="_blank" rel="noopener">https://github.com/guodongxiaren/README</a></li><li><a href="https://github.com/tchapi/markdown-cheatsheet" target="_blank" rel="noopener">markdown-cheatsheet</a></li><li><a href="https://github.com/luong-komorebi/Begin-Latex-in-minutes" target="_blank" rel="noopener">Begin-Latex-in-minutes</a></li><li><a href="https://github.com/mermaid-js/mermaid" target="_blank" rel="noopener">https://github.com/mermaid-js/mermaid</a></li></ul><hr class="footnotes-sep" /><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>注脚的解释 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;markdown-cheat-sheet&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#markdown-cheat-sheet&quot;&gt;&lt;/a&gt; Markdown Cheat Sheet&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;📦 本文
      
    
    </summary>
    
    
      <category term="效率提升" scheme="https://dunwu.github.io/blog/categories/%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87/"/>
    
      <category term="规范" scheme="https://dunwu.github.io/blog/categories/%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87/%E8%A7%84%E8%8C%83/"/>
    
    
      <category term="效率提升" scheme="https://dunwu.github.io/blog/tags/%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87/"/>
    
      <category term="规范" scheme="https://dunwu.github.io/blog/tags/%E8%A7%84%E8%8C%83/"/>
    
      <category term="markdown" scheme="https://dunwu.github.io/blog/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>限流基本原理</title>
    <link href="https://dunwu.github.io/blog/design/theory/flow-limit-theory/"/>
    <id>https://dunwu.github.io/blog/design/theory/flow-limit-theory/</id>
    <published>2020-01-20T03:06:00.000Z</published>
    <updated>2020-01-25T14:49:22.053Z</updated>
    
    <content type="html"><![CDATA[<h1 id="限流基本原理"><a class="markdownIt-Anchor" href="#限流基本原理"></a> 限流基本原理</h1><!-- TOC depthFrom:2 depthTo:3 --><ul><li><a href="#%E9%99%90%E6%B5%81%E6%96%B9%E6%B3%95">限流方法</a><ul><li><a href="#%E8%AE%A1%E6%95%B0%E5%99%A8">计数器</a></li><li><a href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">滑动窗口</a></li><li><a href="#%E4%BB%A4%E7%89%8C%E6%A1%B6token-bucket">令牌桶（Token Bucket）</a></li><li><a href="#%E6%BC%8F%E6%A1%B6">漏桶</a></li></ul></li><li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li></ul><!-- /TOC --><p>限流可以认为是服务降级的一种。限流就是<strong>限制系统的输入和输出流量已达到保护系统的目的</strong>。一般来说系统的吞吐量是可以被测算的，为了保证系统的稳定运行，一旦达到的需要限制的阈值，就需要限制流量并采取一些措施以完成限制流量的目的。比如：延迟处理，拒绝处理，或者部分拒绝处理等等。</p><h2 id="限流方法"><a class="markdownIt-Anchor" href="#限流方法"></a> 限流方法</h2><h3 id="计数器"><a class="markdownIt-Anchor" href="#计数器"></a> 计数器</h3><p>控制单位时间的请求数量。使用 <code>AtomicInteger</code> 进行统计。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大访问数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> limit = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 访问时间差</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timeout = <span class="number">1000</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> time;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前计数器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger reqCount = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">limit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">if</span> (now &lt; time + timeout) &#123;</span><br><span class="line">            <span class="comment">// 单位时间内</span></span><br><span class="line">            reqCount.addAndGet(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> reqCount.get() &lt;= limit;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 超出单位时间</span></span><br><span class="line">            time = now;</span><br><span class="line">            reqCount = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="滑动窗口"><a class="markdownIt-Anchor" href="#滑动窗口"></a> 滑动窗口</h3><p>滑动窗口是对计数器方式的改进，增加一个时间粒度的度量单位 。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentLinkedQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeWindow</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ConcurrentLinkedQueue&lt;Long&gt; queue = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;Long&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 间隔秒数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> seconds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大限流</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> max;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TimeWindow</span><span class="params">(<span class="keyword">int</span> max, <span class="keyword">int</span> seconds)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.seconds = seconds;</span><br><span class="line">        <span class="keyword">this</span>.max = max;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 永续线程执行清理queue 任务</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 等待 间隔秒数-1 执行清理操作</span></span><br><span class="line">                    Thread.sleep((seconds - <span class="number">1</span>) * <span class="number">1000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                clean();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> TimeWindow timeWindow = <span class="keyword">new</span> TimeWindow(<span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试3个线程</span></span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">3</span>).forEach((i) -&gt; &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">20</span>) * <span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    timeWindow.take();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;).start();</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取令牌，并且添加时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">take</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> size = sizeOfValid();</span><br><span class="line">            <span class="keyword">if</span> (size &gt; max) &#123;</span><br><span class="line">                System.err.println(<span class="string">"超限"</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sizeOfValid() &gt; max) &#123;</span><br><span class="line">                    System.err.println(<span class="string">"超限"</span>);</span><br><span class="line">                    System.err.println(<span class="string">"queue中有 "</span> + queue.size() + <span class="string">" 最大数量 "</span> + max);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">this</span>.queue.offer(System.currentTimeMillis());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"queue中有 "</span> + queue.size() + <span class="string">" 最大数量 "</span> + max);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sizeOfValid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Iterator&lt;Long&gt; it = queue.iterator();</span><br><span class="line">        Long ms = System.currentTimeMillis() - seconds * <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">long</span> t = it.next();</span><br><span class="line">            <span class="keyword">if</span> (t &gt; ms) &#123;</span><br><span class="line">                <span class="comment">// 在当前的统计时间范围内</span></span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清理过期的时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Long c = System.currentTimeMillis() - seconds * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">        Long tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((tl = queue.peek()) != <span class="keyword">null</span> &amp;&amp; tl &lt; c) &#123;</span><br><span class="line">            System.out.println(<span class="string">"清理数据"</span>);</span><br><span class="line">            queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="令牌桶token-bucket"><a class="markdownIt-Anchor" href="#令牌桶token-bucket"></a> 令牌桶（Token Bucket）</h3><p>规定固定容量的桶,token 以固定速度往桶内填充,当桶满时 token 不会被继续放入,每过来一个请求把 token 从桶中移除,如果桶中没有 token 不能请求。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenBucket</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> time;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 总量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Double total;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * token 放入速度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Double rate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前总量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Double nowSize;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">limit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">        nowSize = Math.min(total, nowSize + (now - time) * rate);</span><br><span class="line">        time = now;</span><br><span class="line">        <span class="keyword">if</span> (nowSize &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 桶里没有token</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 存在token</span></span><br><span class="line">            nowSize -= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="漏桶"><a class="markdownIt-Anchor" href="#漏桶"></a> 漏桶</h3><p>规定固定容量的桶，有水进入，有水流出。对于流进的水我们无法估计进来的数量、速度，对于流出的水我们可以控制速度。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeakBucket</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> time;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 总量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Double total;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 水流出去的速度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Double rate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前总量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Double nowSize;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">limit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">        nowSize = Math.max(<span class="number">0</span>, (nowSize - (now - time) * rate));</span><br><span class="line">        time = now;</span><br><span class="line">        <span class="keyword">if</span> ((nowSize + <span class="number">1</span>) &lt; total) &#123;</span><br><span class="line">            nowSize++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ul><li>《大型网站技术架构》</li><li><a href="https://www.jianshu.com/p/76cc8ba5ca91" target="_blank" rel="noopener">谈谈限流算法的几种实现</a></li><li><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/huifer-how-to-limit-current.md" target="_blank" rel="noopener">如何限流？在工作中是怎么做的？说一下具体的实现？</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;限流基本原理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#限流基本原理&quot;&gt;&lt;/a&gt; 限流基本原理&lt;/h1&gt;
&lt;!-- TOC depthFrom:2 depthTo:3 --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E9%99%90
      
    
    </summary>
    
    
      <category term="设计" scheme="https://dunwu.github.io/blog/categories/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="系统原理" scheme="https://dunwu.github.io/blog/categories/%E8%AE%BE%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="设计" scheme="https://dunwu.github.io/blog/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="系统原理" scheme="https://dunwu.github.io/blog/tags/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    
      <category term="限流" scheme="https://dunwu.github.io/blog/tags/%E9%99%90%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>测试技术原理</title>
    <link href="https://dunwu.github.io/blog/design/architecture/test-architecture/"/>
    <id>https://dunwu.github.io/blog/design/architecture/test-architecture/</id>
    <published>2019-12-10T09:00:00.000Z</published>
    <updated>2019-12-10T09:44:07.210Z</updated>
    
    <content type="html"><![CDATA[<h1 id="测试技术原理"><a class="markdownIt-Anchor" href="#测试技术原理"></a> 测试技术原理</h1><blockquote><p>软件测试描述一种用来促进鉴定软件的正确性、完整性、安全性和质量的过程。软件测试的经典定义是：在规定的条件下对程序进行操作，以发现程序错误，衡量软件质量，并对其是否能满足设计要求进行评估的过程。</p><p>现代软件开发项目中，分工明确，基本上都会有研发、测试、QA 等角色。不同角色由于关注的视角不同，测试目标和测试方法也不完全相同。本文主要从研发、测试的视角去考量软件测试技术。</p><p>注意：</p><ul><li>为了方便，只有测试人员需要关注的测试点用【测试】标注；</li><li>而只有研发人员需要关注的测试点用【研发】标注；</li><li>都需要关注的测试点则不作标注。</li></ul></blockquote><h2 id="测试方法分类"><a class="markdownIt-Anchor" href="#测试方法分类"></a> 测试方法分类</h2><h3 id="从测试设计方法分类"><a class="markdownIt-Anchor" href="#从测试设计方法分类"></a> 从测试设计方法分类</h3><ul><li><strong>黑盒测试【测试】</strong> - 把软件系统当作一个“黑箱”，无法了解或使用系统的内部结构及知识。从软件的行为，而不是内部结构出发来设计测试。</li><li><strong>白盒测试【研发】</strong> - 设计者可以看到软件系统的内部结构，并且使用软件的内部知识来指导测试数据及方法的选择。</li><li><strong>灰盒测试</strong> - 介于黑盒和白盒之间。</li></ul><blockquote><p>小结：</p><ul><li>黑河测试通常针对的是软件的行为或功能，一般是测试人员主要关注的。</li><li>白盒测试通常则需要对软件有一定程度的了解，一般是开发人员所关注的。</li><li>灰盒测试通常是为了测试软件在特定的场景下的表现，而非主场景。</li></ul></blockquote><h3 id="从测试的目的分类"><a class="markdownIt-Anchor" href="#从测试的目的分类"></a> 从测试的目的分类</h3><h4 id="功能测试"><a class="markdownIt-Anchor" href="#功能测试"></a> 功能测试</h4><ul><li><strong>单元测试（Unit Test）</strong> - 在最低粒度的功能/参数上验证程序的准确性，比如测试一个函数的正确性。【研发】<ul><li>常用技术：<a href="https://github.com/junit-team/junit4" target="_blank" rel="noopener"><strong>junit4</strong></a>、<a href="https://github.com/junit-team/junit5" target="_blank" rel="noopener"><strong>junit5</strong></a>、<a href="https://github.com/mockito/mockito" target="_blank" rel="noopener"><strong>mockito</strong></a>、<a href="https://github.com/joel-costigliola/assertj-core" target="_blank" rel="noopener"><strong>assertj-core</strong></a></li></ul></li><li><strong>功能测试（Functional Test）</strong> - 验证模块的功能。【测试】</li><li><strong>集成测试（Integration Test）</strong> - 验证几个互相有依赖关系的模块的功能。【测试】</li><li><strong>场景测试（Scenario Test）</strong>- 验证几个模块是否能完成一个用户场景。【测试】</li><li><strong>系统测试（System Test）</strong> - 对于整个系统功能的测试。【测试】</li><li><strong>Alpha 测试</strong> - 软件测试人员在真实用户环境中对软件进行全面的测试。【测试】</li><li><strong>Beta 测试</strong> - 也叫公测，是真实的用户在真实的环境中进行的测试。</li></ul><h4 id="非功能测试"><a class="markdownIt-Anchor" href="#非功能测试"></a> 非功能测试</h4><ul><li><strong>压力测试（Stress test）</strong> - 验证软件在超过负载设计的情况下仍能返回正确的结果，没有崩溃</li><li><strong>负载测试（Load test）</strong> - 测试软件在负载情况下能否正常工作</li><li><strong>性能测试（Performance test）</strong> - 测试软件的效能，是否提供满意的服务质量。<ul><li>常用技术：<a href="https://jmeter.apache.org/" target="_blank" rel="noopener"><strong>JMeter</strong></a>、JMH。</li></ul></li><li><strong>软件辅助功能测试（Accessibility test</strong>） - 测试软件是否向残疾用户提供足够的辅助功能</li><li><strong>本地化/全球化测试（Localization/Globalization</strong>）</li><li><strong>兼容性测试（Compatibility Test）</strong></li><li><strong>配置测试（Configuration Test）</strong> - 测试软件在各种配置下能否正常工作</li><li><strong>可用性测试（Usability Test）</strong> – 测试软件是否好用</li><li><strong>安全性测试（Security Test）</strong></li></ul><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ul><li><a href="https://www.cnblogs.com/TankXiao/archive/2012/02/20/2347016.html" target="_blank" rel="noopener">软件测试 (一) 软件测试方法大汇总</a></li><li><a href="https://www.xncoding.com/2018/01/07/java/jmh.html" target="_blank" rel="noopener">Java微基准测试框架JMH</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;测试技术原理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#测试技术原理&quot;&gt;&lt;/a&gt; 测试技术原理&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;软件测试描述一种用来促进鉴定软件的正确性、完整性、安全性和质量的过程。软件测试的经典定义是：在
      
    
    </summary>
    
    
      <category term="设计" scheme="https://dunwu.github.io/blog/categories/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="系统原理" scheme="https://dunwu.github.io/blog/categories/%E8%AE%BE%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="设计" scheme="https://dunwu.github.io/blog/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="系统原理" scheme="https://dunwu.github.io/blog/tags/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    
      <category term="测试" scheme="https://dunwu.github.io/blog/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>design/architecture/system-architecture-interview</title>
    <link href="https://dunwu.github.io/blog/design/architecture/system-architecture-interview/"/>
    <id>https://dunwu.github.io/blog/design/architecture/system-architecture-interview/</id>
    <published>2019-10-25T06:31:53.508Z</published>
    <updated>2019-12-03T11:01:16.940Z</updated>
    
    <content type="html"><![CDATA[<h1 id="系统架构面试"><a class="markdownIt-Anchor" href="#系统架构面试"></a> 系统架构面试</h1><h2 id="如何设计一个秒杀系统"><a class="markdownIt-Anchor" href="#如何设计一个秒杀系统"></a> 如何设计一个秒杀系统？</h2><h3 id="秒杀系统的挑战"><a class="markdownIt-Anchor" href="#秒杀系统的挑战"></a> 秒杀系统的挑战</h3><p>秒杀的核心问题就是<strong>极高并发处理</strong>，由于系统要在瞬时承受平时数十倍甚至上百倍的流量，这往往超出系统上限，因此处理秒杀的<strong>核心思路是限流和缓存</strong>。</p><h3 id="秒杀系统的解决思路"><a class="markdownIt-Anchor" href="#秒杀系统的解决思路"></a> 秒杀系统的解决思路</h3><ul><li>系统上有拦截流量：尽可能在上游拦截和限制请求，限制流入后端的量，保证后端系统正常。 因为无论多少人参与秒杀，实际成交往往是有限的，而且远小于参加秒杀的人数，因此可以通过前端系统进行拦截，限制最终流入系统的请求数量，来保证系统正常进行。</li><li>充分利用缓存：这是一个典型的读多写少的应用场景（一趟火车其实只有2000张票，200w个人来买，最多2000个人下单成功，其他人都是查询库存，写比例只有0.1%，读比例占99.9%），非常适合使用缓存。</li></ul><h3 id="秒杀系统的解决方案"><a class="markdownIt-Anchor" href="#秒杀系统的解决方案"></a> 秒杀系统的解决方案</h3><p>秒杀系统具体方案如下：</p><p><strong>（1）浏览器、客户端拦截重复请求</strong></p><ul><li>用户点击查询或购买按钮后，禁用按钮，避免用户重复提交请求。</li><li>JS 代码中限制用户在限定时间内只允许提交一次请求</li></ul><p>基于此，大部分流量已被拦截。</p><p><strong>（2）应用层拦截请求</strong></p><p>浏览器、客户端拦截重复请求只能应付通过浏览器访问的用户。如果有人通过程序发送 http 请求，则无法拦截。针对这种情况的方案是：</p><p>以页面缓存的方式，针对短时间内的同一个访问源（如同一个IP、同一个 Session、同一个用户 ID多次发送HTTP请求）或同样的查询请求（如大量请求都是查询某类商品的库存），都返回相同的展示页面。</p><p>如此限流，又有大部分的流量被拦截</p><p>（3）服务层请求拦截与数据缓存</p><p>加入有黑客，控制了10w台肉鸡（并且假设买票不需要实名认证），前面的的限制都不起作用了。这时应该怎么办？</p><ul><li><p>读请求（查库存） - 对于读请求，直接使用缓存即可，一般缓存服务器单机处理每秒10w个请求应该没什么问题。</p></li><li><p>写请求（下单） - 由于服务层清楚的知道库存数量，所以完全可以根据库存数量进行限流。具体来说，就是把所有下单请求都丢该消息队列中，每次只取有限的写请求去数据层处理。当这些写请求处理完，更新一下缓存中的库存数，再去取下一批写请求，如果库存数不够，则消息队列的写请求全部返回&quot;已售罄&quot;的结果。</p></li></ul><blockquote><p>参考：</p><ul><li><a href="https://www.zhihu.com/question/54895548/answer/146924420" target="_blank" rel="noopener">如何设计秒杀系统？ - 阿里云云栖社区的回答 - 知乎</a></li><li><a href="https://www.zhihu.com/question/54895548/answer/259218876" target="_blank" rel="noopener">如何设计秒杀系统？ - 网易云的回答 - 知乎</a></li></ul></blockquote><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ul><li><a href="https://www.zhihu.com/question/54895548/answer/146924420" target="_blank" rel="noopener">如何设计秒杀系统？ - 阿里云云栖社区的回答 - 知乎</a></li><li><a href="https://www.zhihu.com/question/54895548/answer/259218876" target="_blank" rel="noopener">如何设计秒杀系统？ - 网易云的回答 - 知乎</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;系统架构面试&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#系统架构面试&quot;&gt;&lt;/a&gt; 系统架构面试&lt;/h1&gt;
&lt;h2 id=&quot;如何设计一个秒杀系统&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#如何设计一个秒
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>bigdata/README</title>
    <link href="https://dunwu.github.io/blog/bigdata/README/"/>
    <id>https://dunwu.github.io/blog/bigdata/README/</id>
    <published>2019-10-25T06:31:53.460Z</published>
    <updated>2019-10-21T09:38:25.519Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大数据"><a class="markdownIt-Anchor" href="#大数据"></a> 大数据</h1><h2 id="知识点"><a class="markdownIt-Anchor" href="#知识点"></a> 📝 知识点</h2><ul><li><a href="MapReduce.md">MapReduce</a></li><li><a href="HDFS.md">HDFS</a></li><li><a href="YARN.md">YARN</a></li><li><a href="hbase">HBase</a><ul><li><a href="hbase/hbase-cli.md">HBase 命令</a></li><li><a href="hbase/hbase-ops.md">HBase 配置</a></li></ul></li></ul><h2 id="学习资源"><a class="markdownIt-Anchor" href="#学习资源"></a> 📚 学习资源</h2><h3 id="书"><a class="markdownIt-Anchor" href="#书"></a> 书</h3><p><a href="https://book.douban.com/subject/6523762/" target="_blank" rel="noopener">Hadoop 权威指南</a></p><h2 id="传送门"><a class="markdownIt-Anchor" href="#传送门"></a> 🚪 传送门</h2><p>| <a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">回首頁</a> |</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;大数据&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#大数据&quot;&gt;&lt;/a&gt; 大数据&lt;/h1&gt;
&lt;h2 id=&quot;知识点&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#知识点&quot;&gt;&lt;/a&gt; 📝 知识点&lt;/h2&gt;
&lt;
      
    
    </summary>
    
    
    
      <category term="hide" scheme="https://dunwu.github.io/blog/tags/hide/"/>
    
  </entry>
  
  <entry>
    <title>分库分表基本原理</title>
    <link href="https://dunwu.github.io/blog/design/theory/sharding-theory/"/>
    <id>https://dunwu.github.io/blog/design/theory/sharding-theory/</id>
    <published>2019-10-16T12:54:00.000Z</published>
    <updated>2019-11-27T07:59:25.224Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分库分表基本原理"><a class="markdownIt-Anchor" href="#分库分表基本原理"></a> 分库分表基本原理</h1><p>分片（Sharding）的基本思想就要把一个数据库切分成多个部分，存储在不同的数据库(server)上，从而缓解单一数据库的性能问题。</p><h2 id="1-数据分片"><a class="markdownIt-Anchor" href="#1-数据分片"></a> 1. 数据分片</h2><p>数据分片指按照某个维度将存放在单一数据库中的数据分散地存放至多个数据库或表中以达到提升性能瓶颈以及可用性的效果。 数据分片的有效手段是对关系型数据库进行分库和分表。分库和分表均可以有效的避免由数据量超过可承受阈值而产生的查询瓶颈。 除此之外，分库还能够用于有效的分散对数据库单点的访问量；分表虽然无法缓解数据库压力，但却能够提供尽量将分布式事务转化为本地事务的可能，一旦涉及到跨库的更新操作，分布式事务往往会使问题变得复杂。 使用多主多从的分片方式，可以有效的避免数据单点，从而提升数据架构的可用性。</p><p>通过分库和分表进行数据的拆分来使得各个表的数据量保持在阈值以下，以及对流量进行疏导应对高访问量，是应对高并发和海量数据系统的有效手段。 数据分片的拆分方式又分为垂直分片和水平分片。</p><h3 id="11-垂直分片"><a class="markdownIt-Anchor" href="#11-垂直分片"></a> 1.1. 垂直分片</h3><p><strong>按照业务拆分的方式称为垂直分片</strong>，又称为纵向拆分，它的核心理念是专库专用。</p><p>在拆分之前，一个数据库由多个数据表构成，每个表对应着不同的业务。而拆分之后，则是<strong>按照业务将表进行归类，分布到不同的数据库中</strong>，从而将压力分散至不同的数据库。下图展示了根据业务需要，将用户表和订单表垂直分片到不同的数据库的方案。</p><p><img src="https://shardingsphere.apache.org/document/current/img/sharding/vertical_sharding.png" alt="垂直分片" /></p><p>垂直分片往往需要对架构和设计进行调整。通常来讲，是来不及应对互联网业务需求快速变化的；而且，它也并无法真正的解决单点瓶颈。<strong>垂直拆分可以缓解数据量和访问量带来的问题，但无法根治。如果垂直拆分之后，表中的数据量依然超过单节点所能承载的阈值，则需要水平分片来进一步处理</strong>。</p><h3 id="12-水平分片"><a class="markdownIt-Anchor" href="#12-水平分片"></a> 1.2. 水平分片</h3><p>水平分片又称为横向拆分。 相对于垂直分片，<strong>水平分片不再将数据根据业务逻辑分类，而是通过某个字段（或某几个字段），根据某种规则将数据分散至多个库或表中，每个分片仅包含数据的一部分</strong>。 例如：根据主键分片，偶数主键的记录放入 0 库（或表），奇数主键的记录放入 1 库（或表），如下图所示。</p><p><img src="https://shardingsphere.apache.org/document/current/img/sharding/horizontal_sharding.png" alt="水平分片" /></p><p><strong>水平分片从理论上突破了单机数据量处理的瓶颈，并且扩展相对自由，是分库分表的标准解决方案</strong>。</p><h2 id="2-分库分表的问题"><a class="markdownIt-Anchor" href="#2-分库分表的问题"></a> 2. 分库分表的问题</h2><h3 id="21-事务问题"><a class="markdownIt-Anchor" href="#21-事务问题"></a> 2.1. 事务问题</h3><p>解决事务问题目前有两种可行的方案：分布式事务和通过应用程序与数据库共同控制实现事务下面对两套方案进行一个简单的对比。</p><ul><li>方案一：使用分布式事务<ul><li>优点：交由数据库管理，简单有效</li><li>缺点：性能代价高，特别是 sharding 越来越多时</li></ul></li><li>方案二：由应用程序和数据库共同控制<ul><li>原理：将一个跨多个数据库的分布式事务分拆成多个仅处于单个数据库上面的小事务，并通过应用程序来总控各个小事务。</li><li>优点：性能上有优势</li><li>缺点：需要应用程序在事务控制上做灵活设计。如果使用 了<a href="http://lib.csdn.net/base/javaee" target="_blank" rel="noopener">spring</a>的事务管理，改动起来会面临一定的困难。</li></ul></li></ul><p>跨库事务也是分布式的数据库集群要面对的棘手事情。 合理采用分表，可以在降低单表数据量的情况下，尽量使用本地事务，善于使用同库不同表可有效避免分布式事务带来的麻烦。在不能避免跨库事务的场景，有些业务仍然需要保持事务的一致性。 而基于 XA 的分布式事务由于在并发度高的场景中性能无法满足需要，并未被互联网巨头大规模使用，他们大多采用最终一致性的柔性事务代替强一致事务。</p><h3 id="22-跨节点-join-的问题"><a class="markdownIt-Anchor" href="#22-跨节点-join-的问题"></a> 2.2. 跨节点 Join 的问题</h3><p>只要是进行切分，跨节点 Join 的问题是不可避免的。但是良好的设计和切分却可以减少此类情况的发生。解决这一问题的普遍做法是分两次查询实现。在第一次查询的结果集中找出关联数据的 id，根据这些 id 发起第二次请求得到关联数据。</p><h3 id="23-跨节点的-countorder-bygroup-by-以及聚合函数问题"><a class="markdownIt-Anchor" href="#23-跨节点的-countorder-bygroup-by-以及聚合函数问题"></a> 2.3. 跨节点的 count,order by,group by 以及聚合函数问题</h3><p>这些是一类问题，因为它们都需要基于全部数据集合进行计算。多数的代理都不会自动处理合并工作。解决方案：与解决跨节点 join 问题的类似，分别在各个节点上得到结果后在应用程序端进行合并。和 join 不同的是每个结点的查询可以并行执行，因此很多时候它的速度要比单一大表快很多。但如果结果集很大，对应用程序内存的消耗是一个问题。</p><h3 id="24-数据迁移容量规划扩容等问题"><a class="markdownIt-Anchor" href="#24-数据迁移容量规划扩容等问题"></a> 2.4. 数据迁移，容量规划，扩容等问题</h3><p>来自淘宝综合业务平台团队，它利用对 2 的倍数取余具有向前兼容的特性（如对 4 取余得 1 的数对 2 取余也是 1）来分配数据，避免了<strong>行级别的数据迁移</strong>，但是依然需要进行<strong>表级别的迁移</strong>，同时对扩容规模和分表数量都有限制。总得来说，这些方案都不是十分的理想，多多少少都存在一些缺点，这也从一个侧面反映出了 Sharding 扩容的难度。</p><h3 id="25-id-问题"><a class="markdownIt-Anchor" href="#25-id-问题"></a> 2.5. ID 问题</h3><p>一旦数据库被切分到多个物理结点上，我们将不能再依赖数据库自身的主键生成机制。一方面，某个分区数据库自生成的 ID 无法保证在全局上是唯一的；另一方面，应用程序在插入数据之前需要先获得 ID,以便进行 SQL 路由. 一些常见的主键生成策略</p><h4 id="251-uuid"><a class="markdownIt-Anchor" href="#251-uuid"></a> 2.5.1. UUID</h4><p>使用 UUID 作主键是最简单的方案，但是缺点也是非常明显的。由于 UUID 非常的长，除占用大量存储空间外，最主要的问题是在索引上，在建立索引和基于索引进行查询时都存在性能问题。</p><h4 id="252-结合数据库维护一个-sequence-表"><a class="markdownIt-Anchor" href="#252-结合数据库维护一个-sequence-表"></a> 2.5.2. 结合数据库维护一个 Sequence 表</h4><p>此方案的思路也很简单，在数据库中建立一个 Sequence 表，表的结构类似于：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`SEQUENCE`</span> (</span><br><span class="line">    <span class="string">`table_name`</span> <span class="built_in">varchar</span>(<span class="number">18</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`nextid`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`table_name`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span></span><br></pre></td></tr></table></figure><p>每当需要为某个表的新纪录生成 ID 时就从 Sequence 表中取出对应表的 nextid,并将 nextid 的值加 1 后更新到数据库中以备下次使用。此方案也较简单，但缺点同样明显：由于所有插入任何都需要访问该表，该表很容易成为系统性能瓶颈，同时它也存在单点问题，一旦该表数据库失效，整个应用程序将无法工作。有人提出使用 Master-Slave 进行主从同步，但这也只能解决单点问题，并不能解决读写比为 1:1 的访问压力问题。</p><h4 id="253-twitter-的分布式自增-id-算法-snowflake"><a class="markdownIt-Anchor" href="#253-twitter-的分布式自增-id-算法-snowflake"></a> 2.5.3. <a href="http://blog.sina.com.cn/s/blog_6b7c2e660102vbi2.html" target="_blank" rel="noopener">Twitter 的分布式自增 ID 算法 Snowflake</a></h4><p>在分布式系统中，需要生成全局 UID 的场合还是比较多的，twitter 的 snowflake 解决了这种需求，实现也还是很简单的，除去配置信息，核心代码就是毫秒级时间 41 位 机器 ID 10 位 毫秒内序列 12 位。</p><ul><li>10—0000000000 0000000000 0000000000 0000000000 0 — 00000 —00000 —000000000000 在上面的字符串中，第一位为未使用（实际上也可作为 long 的符号位），接下来的 41 位为毫秒级时间，然后 5 位 datacenter 标识位，5 位机器 ID（并不算标识符，实际是为线程标识），然后 12 位该毫秒内的当前毫秒内的计数，加起来刚好 64 位，为一个 Long 型。</li></ul><p>这样的好处是，整体上按照时间自增排序，并且整个分布式系统内不会产生 ID 碰撞（由 datacenter 和机器 ID 作区分），并且效率较高，经测试，snowflake 每秒能够产生 26 万 ID 左右，完全满足需要。</p><h3 id="26-跨分片的排序分页"><a class="markdownIt-Anchor" href="#26-跨分片的排序分页"></a> 2.6. 跨分片的排序分页</h3><p>一般来讲，分页时需要按照指定字段进行排序。当排序字段就是分片字段的时候，我们通过分片规则可以比较容易定位到指定的分片，而当排序字段非分片字段的时候，情况就会变得比较复杂了。为了最终结果的准确性，我们需要在不同的分片节点中将数据进行排序并返回，并将不同分片返回的结果集进行汇总和再次排序，最后再返回给用户。如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/3710706-925381b9a478c8df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640/format/webp" alt="img" /></p><p>上面图中所描述的只是最简单的一种情况（取第一页数据），看起来对性能的影响并不大。但是，如果想取出第 10 页数据，情况又将变得复杂很多，如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/3710706-9a7cfbdb95bb9b70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640/format/webp" alt="img" /></p><p>有些读者可能并不太理解，为什么不能像获取第一页数据那样简单处理（排序取出前 10 条再合并、排序）。其实并不难理解，因为各分片节点中的数据可能是随机的，为了排序的准确性，必须把所有分片节点的前 N 页数据都排序好后做合并，最后再进行整体的排序。很显然，这样的操作是比较消耗资源的，用户越往后翻页，系统性能将会越差。</p><p>那如何解决分库情况下的分页问题呢？有以下几种办法：</p><p>如果是在前台应用提供分页，则限定用户只能看前面 n 页，这个限制在业务上也是合理的，一般看后面的分页意义不大（如果一定要看，可以要求用户缩小范围重新查询）。</p><p>如果是后台批处理任务要求分批获取数据，则可以加大 page size，比如每次获取 5000 条记录，有效减少分页数（当然离线访问一般走备库，避免冲击主库）。</p><p>分库设计时，一般还有配套大数据平台汇总所有分库的记录，有些分页查询可以考虑走大数据平台。</p><h3 id="27-分库策略"><a class="markdownIt-Anchor" href="#27-分库策略"></a> 2.7. 分库策略</h3><ul><li>根据数值范围，比如用户 Id 为 1-9999 的记录分到第一个库，10000-20000 的分到第二个库，以此类推。</li><li>根据数值取模，比如用户 Id mod n，余数为 0 的记录放到第一个库，余数为 1 的放到第二个库，以此类推。</li></ul><p>优劣比较：评价指标按照范围分库按照 Mod 分库库数量前期数目比较小，可以随用户/业务按需增长前期即根据 mode 因子确定库数量，数目一般比较大访问性能前期库数量小，全库查询消耗资源少，单库查询性能略差前期库数量大，全库查询消耗资源多，单库查询性能略好调整库数量比较容易，一般只需为新用户增加库，老库拆分也只影响单个库困难，改变 mod 因子导致数据在所有库之间迁移数据热点新旧用户购物频率有差异，有数据热点问题新旧用户均匀到分布到各个库，无热点实践中，为了处理简单，选择 mod 分库的比较多。同时二次分库时，为了数据迁移方便，一般是按倍数增加，比如初始 4 个库，二次分裂为 8 个，再 16 个。这样对于某个库的数据，一半数据移到新库，剩余不动，对比每次只增加一个库，所有数据都要大规模变动。补充下，mod 分库一般每个库记录数比较均匀，但也有些数据库，存在超级 Id，这些 Id 的记录远远超过其他 Id，比如在广告场景下，某个大广告主的广告数可能占总体很大比例。如果按照广告主 Id 取模分库，某些库的记录数会特别多，对于这些超级 Id，需要提供单独库来存储记录。</p><h3 id="28-分库数量"><a class="markdownIt-Anchor" href="#28-分库数量"></a> 2.8. 分库数量</h3><p>分库数量首先和单库能处理的记录数有关，一般来说，Mysql 单库超过 5000 万条记录，Oracle 单库超过 1 亿条记录，DB 压力就很大(当然处理能力和字段数量/访问模式/记录长度有进一步关系)。</p><p>在满足上述前提下，如果分库数量少，达不到分散存储和减轻 DB 性能压力的目的；如果分库的数量多，好处是每个库记录少，单库访问性能好，但对于跨多个库的访问，应用程序需要访问多个库，如果是并发模式，要消耗宝贵的线程资源；如果是串行模式，执行时间会急剧增加。</p><p>最后分库数量还直接影响硬件的投入，一般每个分库跑在单独物理机上，多一个库意味多一台设备。所以具体分多少个库，要综合评估，一般初次分库建议分 4-8 个库。</p><h2 id="3-读写分离"><a class="markdownIt-Anchor" href="#3-读写分离"></a> 3. 读写分离</h2><p>面对日益增加的系统访问量，数据库的吞吐量面临着巨大瓶颈。 对于同一时刻有大量并发读操作和较少写操作类型的应用系统来说，将数据库拆分为主库和从库，主库负责处理事务性的增删改操作，从库负责处理查询操作，能够有效的避免由数据更新导致的行锁，使得整个系统的查询性能得到极大的改善。</p><p>通过一主多从的配置方式，可以将查询请求均匀的分散到多个数据副本，能够进一步的提升系统的处理能力。 使用多主多从的方式，不但能够提升系统的吞吐量，还能够提升系统的可用性，可以达到在任何一个数据库宕机，甚至磁盘物理损坏的情况下仍然不影响系统的正常运行。</p><p>与将数据根据分片键打散至各个数据节点的水平分片不同，读写分离则是根据 SQL 语义的分析，将读操作和写操作分别路由至主库与从库。</p><p><img src="https://shardingsphere.apache.org/document/current/img/read-write-split/read-write-split.png" alt="读写分离" /></p><p>读写分离的数据节点中的数据内容是一致的，而水平分片的每个数据节点的数据内容却并不相同。将水平分片和读写分离联合使用，能够更加有效的提升系统性能。</p><h3 id="31-挑战"><a class="markdownIt-Anchor" href="#31-挑战"></a> 3.1. 挑战</h3><p>读写分离虽然可以提升系统的吞吐量和可用性，但同时也带来了数据不一致的问题。 这包括多个主库之间的数据一致性，以及主库与从库之间的数据一致性的问题。 并且，读写分离也带来了与数据分片同样的问题，它同样会使得应用开发和运维人员对数据库的操作和运维变得更加复杂。 下图展现了将分库分表与读写分离一同使用时，应用程序与数据库集群之间的复杂拓扑关系。</p><p><img src="https://shardingsphere.apache.org/document/current/img/read-write-split/sharding-read-write-split.png" alt="数据分片 + 读写分离" /></p><h2 id="4-参考资料"><a class="markdownIt-Anchor" href="#4-参考资料"></a> 4. 参考资料</h2><ul><li><a href="https://shardingsphere.apache.org/document/current/cn/overview/" target="_blank" rel="noopener">ShardingSphere 官方文档</a></li><li><a href="https://juejin.im/post/5bf778ef5188251b8a26ed8b" target="_blank" rel="noopener">“分库分表&quot; ？选型和流程要慎重，否则会失控</a></li><li><a href="https://www.jianshu.com/p/32b3e91aa22c" target="_blank" rel="noopener">分库分表需要考虑的问题及方案</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分库分表基本原理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#分库分表基本原理&quot;&gt;&lt;/a&gt; 分库分表基本原理&lt;/h1&gt;
&lt;p&gt;分片（Sharding）的基本思想就要把一个数据库切分成多个部分，存储在不同的数据库(server)上，从而
      
    
    </summary>
    
    
      <category term="设计" scheme="https://dunwu.github.io/blog/categories/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="系统原理" scheme="https://dunwu.github.io/blog/categories/%E8%AE%BE%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="设计" scheme="https://dunwu.github.io/blog/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="系统原理" scheme="https://dunwu.github.io/blog/tags/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    
      <category term="分片" scheme="https://dunwu.github.io/blog/tags/%E5%88%86%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>分布式存储基本原理</title>
    <link href="https://dunwu.github.io/blog/design/theory/distributed-storage-theory/"/>
    <id>https://dunwu.github.io/blog/design/theory/distributed-storage-theory/</id>
    <published>2019-08-21T03:30:00.000Z</published>
    <updated>2019-11-27T08:34:35.875Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式存储基本原理"><a class="markdownIt-Anchor" href="#分布式存储基本原理"></a> 分布式存储基本原理</h1><h2 id="1-分区规则"><a class="markdownIt-Anchor" href="#1-分区规则"></a> 1. 分区规则</h2><p><strong>分布式数据库</strong> 首先要解决把 <strong>整个数据集</strong> 按照 <strong>分区规则</strong> 映射到 <strong>多个节点</strong> 的问题，即把 <strong>数据集</strong> 划分到 <strong>多个节点</strong> 上，每个节点负责 <strong>整体数据</strong> 的一个 <strong>子集</strong>。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/architecture/partition-rule.png!zp" /></div><p>数据分布通常有 <strong>哈希分区</strong> 和 <strong>顺序分区</strong> 两种方式，对比如下：</p><table><thead><tr><th style="text-align:left">分区方式</th><th style="text-align:left">特点</th><th style="text-align:left">相关产品</th></tr></thead><tbody><tr><td style="text-align:left">哈希分区</td><td style="text-align:left">离散程度好，数据分布与业务无关，无法顺序访问</td><td style="text-align:left">Redis Cluster，Cassandra，Dynamo</td></tr><tr><td style="text-align:left">顺序分区</td><td style="text-align:left">离散程度易倾斜，数据分布与业务相关，可以顺序访问</td><td style="text-align:left">BigTable，HBase，Hypertable</td></tr></tbody></table><p>由于 <code>Redis Cluster</code> 采用 <strong>哈希分区规则</strong>，这里重点讨论 <strong>哈希分区</strong>。常见的 <strong>哈希分区</strong> 规则有几种，下面分别介绍：</p><h3 id="11-节点取余分区"><a class="markdownIt-Anchor" href="#11-节点取余分区"></a> 1.1. 节点取余分区</h3><p>使用特定的数据，如 <code>Redis</code> 的 <strong>键</strong> 或 <strong>用户</strong> <code>ID</code>，再根据 <strong>节点数量</strong> <code>N</code> 使用公式：<code>hash（key）% N</code> 计算出 <strong>哈希值</strong>，用来决定数据 <strong>映射</strong> 到哪一个节点上。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/architecture/partition-hash-mod.png!zp" /></div><ul><li><strong>优点</strong></li></ul><p>这种方式的突出优点是 <strong>简单性</strong>，常用于 <strong>数据库</strong> 的 <strong>分库分表规则</strong>。一般采用 <strong>预分区</strong> 的方式，提前根据 <strong>数据量</strong> 规划好 <strong>分区数</strong>，比如划分为 <code>512</code> 或 <code>1024</code> 张表，保证可支撑未来一段时间的 <strong>数据容量</strong>，再根据 <strong>负载情况</strong> 将 <strong>表</strong> 迁移到其他 <strong>数据库</strong> 中。扩容时通常采用 <strong>翻倍扩容</strong>，避免 <strong>数据映射</strong> 全部被 <strong>打乱</strong>，导致 <strong>全量迁移</strong> 的情况。</p><ul><li><strong>缺点</strong></li></ul><p>当 <strong>节点数量</strong> 变化时，如 <strong>扩容</strong> 或 <strong>收缩</strong> 节点，数据节点 <strong>映射关系</strong> 需要重新计算，会导致数据的 <strong>重新迁移</strong>。</p><h3 id="12-一致性哈希分区"><a class="markdownIt-Anchor" href="#12-一致性哈希分区"></a> 1.2. 一致性哈希分区</h3><p><strong>一致性哈希</strong> 可以很好的解决 <strong>稳定性问题</strong>，可以将所有的 <strong>存储节点</strong> 排列在 <strong>首尾相接</strong> 的 <code>Hash</code> 环上，每个 <code>key</code> 在计算 <code>Hash</code> 后会 <strong>顺时针</strong> 找到 <strong>临接</strong> 的 <strong>存储节点</strong> 存放。而当有节点 <strong>加入</strong> 或 <strong>退出</strong> 时，仅影响该节点在 <code>Hash</code> 环上 <strong>顺时针相邻</strong> 的 <strong>后续节点</strong>。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/architecture/partition-consistent-hash.png!zp" /></div><ul><li><strong>优点</strong></li></ul><p><strong>加入</strong> 和 <strong>删除</strong> 节点只影响 <strong>哈希环</strong> 中 <strong>顺时针方向</strong> 的 <strong>相邻的节点</strong>，对其他节点无影响。</p><ul><li><strong>缺点</strong></li></ul><p><strong>加减节点</strong> 会造成 <strong>哈希环</strong> 中部分数据 <strong>无法命中</strong>。当使用 <strong>少量节点</strong> 时，<strong>节点变化</strong> 将大范围影响 <strong>哈希环</strong> 中 <strong>数据映射</strong>，不适合 <strong>少量数据节点</strong> 的分布式方案。<strong>普通</strong> 的 <strong>一致性哈希分区</strong> 在增减节点时需要 <strong>增加一倍</strong> 或 <strong>减去一半</strong> 节点才能保证 <strong>数据</strong> 和 <strong>负载的均衡</strong>。</p><blockquote><p><strong>注意</strong>：因为 <strong>一致性哈希分区</strong> 的这些缺点，一些分布式系统采用 <strong>虚拟槽</strong> 对 <strong>一致性哈希</strong> 进行改进，比如 <code>Dynamo</code> 系统。</p></blockquote><h3 id="13-虚拟槽分区"><a class="markdownIt-Anchor" href="#13-虚拟槽分区"></a> 1.3. 虚拟槽分区</h3><p><strong>虚拟槽分区</strong> 巧妙地使用了 <strong>哈希空间</strong>，使用 <strong>分散度良好</strong> 的 <strong>哈希函数</strong> 把所有数据 <strong>映射</strong> 到一个 <strong>固定范围</strong> 的 <strong>整数集合</strong> 中，整数定义为 <strong>槽</strong>（<code>slot</code>）。这个范围一般 <strong>远远大于</strong> 节点数，比如 <code>Redis Cluster</code> 槽范围是 <code>0 ~ 16383</code>。<strong>槽</strong> 是集群内 <strong>数据管理</strong> 和 <strong>迁移</strong> 的 <strong>基本单位</strong>。采用 <strong>大范围槽</strong> 的主要目的是为了方便 <strong>数据拆分</strong> 和 <strong>集群扩展</strong>。每个节点会负责 <strong>一定数量的槽</strong>，如图所示：</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/architecture/partition-hash-slot.png!zp" /></div>当前集群有 `3` 个节点，每个节点平均大约负责 `5460` 个 **槽**。由于采用 **高质量** 的 **哈希算法**，每个槽所映射的数据通常比较 **均匀**，将数据平均划分到 `3` 个节点进行 **数据分区**。`Redis Cluster` 就是采用 **虚拟槽分区**。<p>集群中的每个节点负责一部分哈希槽，比如集群中有３个节点，则：</p><ul><li>节点Ａ存储的哈希槽范围是：0 – 5460</li><li>节点Ｂ存储的哈希槽范围是：5461 – 10922</li><li>节点Ｃ存储的哈希槽范围是：10923 – 16383</li></ul><p>这种结构很容易 <strong>添加</strong> 或者 <strong>删除</strong> 节点。如果 <strong>增加</strong> 一个节点 <code>4</code>，就需要从节点 <code>1 ~ 3</code> 获得部分 <strong>槽</strong> 分配到节点 <code>4</code> 上。如果想 <strong>移除</strong> 节点 <code>1</code>，需要将节点 <code>1</code> 中的 <strong>槽</strong> 移到节点 <code>2 ~ 3</code> 上，然后将 <strong>没有任何槽</strong> 的节点 <code>1</code> 从集群中 <strong>移除</strong> 即可。</p><blockquote><p>由于从一个节点将 <strong>哈希槽</strong> 移动到另一个节点并不会 <strong>停止服务</strong>，所以无论 <strong>添加删除</strong> 或者 <strong>改变</strong> 某个节点的 <strong>哈希槽的数量</strong> 都不会造成 <strong>集群不可用</strong> 的状态.</p></blockquote><h2 id="2-参考资料"><a class="markdownIt-Anchor" href="#2-参考资料"></a> 2. 参考资料</h2><ul><li><a href="https://juejin.im/post/5b8fc5536fb9a05d2d01fb11" target="_blank" rel="noopener">深入剖析 Redis 系列(三) - Redis 集群模式搭建与原理详解</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分布式存储基本原理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#分布式存储基本原理&quot;&gt;&lt;/a&gt; 分布式存储基本原理&lt;/h1&gt;
&lt;h2 id=&quot;1-分区规则&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-
      
    
    </summary>
    
    
      <category term="设计" scheme="https://dunwu.github.io/blog/categories/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="系统原理" scheme="https://dunwu.github.io/blog/categories/%E8%AE%BE%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="设计" scheme="https://dunwu.github.io/blog/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="系统原理" scheme="https://dunwu.github.io/blog/tags/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    
      <category term="存储" scheme="https://dunwu.github.io/blog/tags/%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>分布式 ID 基本原理</title>
    <link href="https://dunwu.github.io/blog/design/theory/distributed-id-theory/"/>
    <id>https://dunwu.github.io/blog/design/theory/distributed-id-theory/</id>
    <published>2019-07-24T03:55:00.000Z</published>
    <updated>2020-01-19T13:56:17.671Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式-id-基本原理"><a class="markdownIt-Anchor" href="#分布式-id-基本原理"></a> 分布式 ID 基本原理</h1><blockquote><p>传统数据库软件开发中，主键自动生成技术是基本需求。而各个数据库对于该需求也提供了相应的支持，比如 MySQL 的自增键，Oracle 的自增序列等。</p><p>数据分片后，不同数据节点生成全局唯一主键是非常棘手的问题。同一个逻辑表内的不同实际表之间的自增键由于无法互相感知而产生重复主键。 虽然可通过约束自增主键初始值和步长的方式避免碰撞，但需引入额外的运维规则，使解决方案缺乏完整性和可扩展性。</p><p>为此，需要使用分布式 ID 来解决此问题。本文总结业界常用的分布式 ID 解决方案。</p></blockquote><!-- TOC depthFrom:2 depthTo:3 --><ul><li><a href="#1-%E7%AE%80%E4%BB%8B">1. 简介</a></li><li><a href="#2-uuid">2. UUID</a><ul><li><a href="#21-uuid-%E7%9A%84%E4%BC%98%E7%82%B9">2.1. UUID 的优点</a></li><li><a href="#22-uuid-%E7%9A%84%E7%BC%BA%E7%82%B9">2.2. UUID 的缺点</a></li><li><a href="#23-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">2.3. 适用场景</a></li></ul></li><li><a href="#3-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%87%AA%E5%A2%9E%E9%94%AE">3. 数据库自增键</a><ul><li><a href="#31-%E4%BC%98%E7%82%B9">3.1. 优点</a></li><li><a href="#32-%E7%BC%BA%E7%82%B9">3.2. 缺点</a></li><li><a href="#33-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">3.3. 适用场景</a></li><li><a href="#34-%E6%94%B9%E8%BF%9B">3.4. 改进</a></li></ul></li><li><a href="#4-%E5%88%A9%E7%94%A8-redis-%E7%94%9F%E6%88%90%E9%94%AE">4. 利用 Redis 生成键</a><ul><li><a href="#41-%E4%BC%98%E7%82%B9">4.1. 优点</a></li><li><a href="#42-%E7%BC%BA%E7%82%B9">4.2. 缺点</a></li><li><a href="#43-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">4.3. 适用场景</a></li></ul></li><li><a href="#5-%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95snowflake">5. 雪花算法（Snowflake）</a><ul><li><a href="#51-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86">5.1. 基本原理</a></li><li><a href="#52-%E4%BC%98%E7%82%B9">5.2. 优点</a></li><li><a href="#53-%E7%BC%BA%E7%82%B9">5.3. 缺点</a></li><li><a href="#54-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">5.4. 适用场景</a></li><li><a href="#55-%E9%98%B2%E6%AD%A2%E6%97%B6%E9%92%9F%E5%9B%9E%E6%8B%A8">5.5. 防止时钟回拨</a></li></ul></li><li><a href="#6-leaf">6. Leaf</a><ul><li><a href="#61-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86">6.1. 基本原理</a></li><li><a href="#62-%E4%BC%98%E7%82%B9">6.2. 优点</a></li><li><a href="#63-%E7%BC%BA%E7%82%B9">6.3. 缺点</a></li><li><a href="#64-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">6.4. 适用场景</a></li></ul></li><li><a href="#7-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">7. 参考资料</a></li></ul><!-- /TOC --><h2 id="1-简介"><a class="markdownIt-Anchor" href="#1-简介"></a> 1. 简介</h2><p>首先，分布式 ID 应该具备哪些特性呢？</p><ol><li><strong>全局唯一性</strong> - 不能出现重复的 ID 号，既然是唯一标识，这是最基本的要求。</li><li><strong>趋势递增</strong> - 在 MySQL InnoDB 引擎中使用的是聚集索引，由于多数 RDBMS 使用 B-tree 的数据结构来存储索引数据，在主键的选择上面我们应该尽量使用有序的主键保证写入性能。</li><li><strong>单调递增</strong> - 保证下一个 ID 一定大于上一个 ID，例如事务版本号、IM 增量消息、排序等特殊需求。</li><li><strong>信息安全</strong> - 如果 ID 是连续的，恶意用户的扒取工作就非常容易做了，直接按照顺序下载指定 URL 即可；如果是订单号就更危险了，竞对可以直接知道我们一天的单量。所以在一些应用场景下，会需要 ID 无规则、不规则。</li></ol><h2 id="2-uuid"><a class="markdownIt-Anchor" href="#2-uuid"></a> 2. UUID</h2><p>UUID 是通用唯一识别码（Universally Unique Identifier)的缩写，开放软件基金会(OSF)规范定义了包括网卡 MAC 地址、时间戳、名字空间（Namespace）、随机或伪随机数、时序等元素。利用这些元素来生成 UUID。</p><p>UUID 是由 128 位二进制组成，一般转换成十六进制，然后用 String 表示。在 java 中有个 UUID 类,在他的注释中我们看见这里有 4 种不同的 UUID 的生成策略:</p><ul><li>random - 基于随机数生成 UUID，由于 Java 中的随机数是伪随机数，其重复的概率是可以被计算出来的。这个一般我们用下面的代码获取基于随机数的 UUID:</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String id = UUID.randomUUID().toString();</span><br></pre></td></tr></table></figure><ul><li>time-based - 基于时间的 UUID,这个一般是通过当前时间，随机数，和本地 Mac 地址来计算出来，自带的 JDK 包并没有这个算法的我们在一些 UUIDUtil 中，比如我们的 log4j.core.util，会重新定义 UUID 的高位和低位。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UUID <span class="title">getTimeBasedUuid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> time = System.currentTimeMillis() * <span class="number">10000L</span> + <span class="number">122192928000000000L</span> + (<span class="keyword">long</span>)(COUNT.incrementAndGet() % <span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">long</span> timeLow = (time &amp; <span class="number">4294967295L</span>) &lt;&lt; <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">long</span> timeMid = (time &amp; <span class="number">281470681743360L</span>) &gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">long</span> timeHi = (time &amp; <span class="number">1152640029630136320L</span>) &gt;&gt; <span class="number">48</span>;</span><br><span class="line">    <span class="keyword">long</span> most = timeLow | timeMid | <span class="number">4096L</span> | timeHi;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UUID(most, LEAST);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>DCE security - DCE 安全的 UUID。</p></li><li><p>name-based - 基于名字的 UUID，通过计算名字和名字空间的 MD5 来计算 UUID。</p></li></ul><h3 id="21-uuid-的优点"><a class="markdownIt-Anchor" href="#21-uuid-的优点"></a> 2.1. UUID 的优点</h3><ul><li>通过本地生成，没有经过网络 I/O，性能较快</li></ul><h3 id="22-uuid-的缺点"><a class="markdownIt-Anchor" href="#22-uuid-的缺点"></a> 2.2. UUID 的缺点</h3><ul><li><strong>长度过长</strong> - UUID 太长，16 字节 128 位，通常以 36 长度的字符串表示，很多场景不适用。例如：Mysql 官方明确建议主键越短越好，36 个字符长度的 UUID 不符合要求。</li><li><strong>信息不安全</strong> - 基于 MAC 地址生成 UUID 的算法可能会造成 MAC 地址泄露，这个漏洞曾被用于寻找梅丽莎病毒的制作者位置。</li><li><strong>无序性</strong> - 不能生成递增有序的数字。这对于一些特定场景不利。例如：如果作为数据库主键，在 InnoDB 引擎下，UUID 的无序性可能会引起数据位置频繁变动，严重影响性能。</li></ul><h3 id="23-适用场景"><a class="markdownIt-Anchor" href="#23-适用场景"></a> 2.3. 适用场景</h3><p>UUID 的适用场景可以为不需要担心过多的空间占用，以及不需要生成有递增趋势的数字。在 Log4j 里 <code>UuidPatternConverter</code> 中加入了 UUID 来标识每一条日志。</p><h2 id="3-数据库自增键"><a class="markdownIt-Anchor" href="#3-数据库自增键"></a> 3. 数据库自增键</h2><p>提到自增键，最先想到的肯定是直接使用数据库自增键。<em>各数据库对于该需求也提供了相应的支持，比如 MySQL 的自增键，Oracle 的自增序列等</em>。</p><h3 id="31-优点"><a class="markdownIt-Anchor" href="#31-优点"></a> 3.1. 优点</h3><ul><li>非常简单，利用现有数据库的功能实现，成本小，有 DBA 专业维护</li><li>有序递增</li><li>方便排序和分页</li></ul><h3 id="32-缺点"><a class="markdownIt-Anchor" href="#32-缺点"></a> 3.2. 缺点</h3><ul><li>强依赖数据库，当数据库异常时整个系统不可用。配置主从复制可以尽可能的增加可用性，但是数据一致性在特殊情况下难以保证。主从切换时的不一致可能会导致重复发号。</li><li>生成 ID 性能瓶颈限制在单台 MySQL 的读写性能。</li><li>简单递增容易被其他人分析利用<ul><li>比如根据用户 ID 来分析注册人数，猜测出服务的一个大概状况。</li></ul></li></ul><h3 id="33-适用场景"><a class="markdownIt-Anchor" href="#33-适用场景"></a> 3.3. 适用场景</h3><p>数据量不大，并发不高的场景。</p><h3 id="34-改进"><a class="markdownIt-Anchor" href="#34-改进"></a> 3.4. 改进</h3><p>对于 MySQL 性能问题，可用如下方案解决：在分布式系统中我们可以多部署几台机器，每台机器设置不同的初始值，且步长和机器数相等。比如有两台机器。设置步长 step 为 2，TicketServer1 的初始值为 1（1，3，5，7，9，11…）、TicketServer2 的初始值为 2（2，4，6，8，10…）。这是 Flickr 团队在 2010 年撰文介绍的一种主键生成策略（<a href="http://code.flickr.net/2010/02/08/ticket-servers-distributed-unique-primary-keys-on-the-cheap/" target="_blank" rel="noopener">Ticket Servers: Distributed Unique Primary Keys on the Cheap </a>）。如下所示，为了实现上述方案分别设置两台机器对应的参数，TicketServer1 从 1 开始发号，TicketServer2 从 2 开始发号，两台机器每次发号之后都递增 2。</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">TicketServer1:</span><br><span class="line">auto-<span class="keyword">increment</span>-<span class="keyword">increment</span> = <span class="number">2</span></span><br><span class="line">auto-<span class="keyword">increment</span>-offset = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">TicketServer2:</span><br><span class="line">auto-<span class="keyword">increment</span>-<span class="keyword">increment</span> = <span class="number">2</span></span><br><span class="line">auto-<span class="keyword">increment</span>-offset = <span class="number">2</span></span><br></pre></td></tr></table></figure><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/6d2c9ec8.png" alt="image" /></p><p>这种架构存在以下缺点：</p><ul><li>系统水平扩展比较困难，比如定义好了步长和机器台数之后，如果要添加机器该怎么做？假设现在只有一台机器发号是 1,2,3,4,5（步长是 1），这个时候需要扩容机器一台。可以这样做：把第二台机器的初始值设置得比第一台超过很多，比如 14（假设在扩容时间之内第一台不可能发到 14），同时设置步长为 2，那么这台机器下发的号码都是 14 以后的偶数。然后摘掉第一台，把 ID 值保留为奇数，比如 7，然后修改第一台的步长为 2。让它符合我们定义的号段标准，对于这个例子来说就是让第一台以后只能产生奇数。扩容方案看起来复杂吗？貌似还好，现在想象一下如果我们线上有 100 台机器，这个时候要扩容该怎么做？简直是噩梦。所以系统水平扩展方案复杂难以实现。</li><li>ID 没有了单调递增的特性，只能趋势递增，这个缺点对于一般业务需求不是很重要，可以容忍。</li><li>数据库压力还是很大，每次获取 ID 都得读写一次数据库，只能靠堆机器来提高性能。</li></ul><h2 id="4-利用-redis-生成键"><a class="markdownIt-Anchor" href="#4-利用-redis-生成键"></a> 4. 利用 Redis 生成键</h2><p>Redis 中有两个命令 <code>Incr</code>，<code>IncrBy</code>。</p><p>因为 Redis 是单线程的，所以能保证原子性。</p><h3 id="41-优点"><a class="markdownIt-Anchor" href="#41-优点"></a> 4.1. 优点</h3><ul><li>性能比数据库好</li><li>能满足有序递增</li></ul><h3 id="42-缺点"><a class="markdownIt-Anchor" href="#42-缺点"></a> 4.2. 缺点</h3><ul><li>由于 Redis 是内存数据库，即使支持持久化（AOF 和 RDB），但是依然可能丢失数据，造成 ID 重复。</li><li>依赖于 Redis 生成键，如果 Redis 服务不稳定，会影响 ID 生成。</li></ul><h3 id="43-适用场景"><a class="markdownIt-Anchor" href="#43-适用场景"></a> 4.3. 适用场景</h3><p>Redis 性能比数据库好，但是有可能会出现 ID 重复和不稳定。如果可以接受，那么就可以使用这种方案。</p><h2 id="5-雪花算法snowflake"><a class="markdownIt-Anchor" href="#5-雪花算法snowflake"></a> 5. 雪花算法（Snowflake）</h2><p>雪花算法（Snowflake）是由 Twitter 公布的分布式主键生成算法，<strong>它会生成一个 <code>64 bit</code> 的整数</strong>，可以保证不同进程主键的不重复性，以及相同进程主键的有序性。</p><p>在同一个进程中，它首先是通过时间位保证不重复，如果时间相同则是通过序列位保证。 同时由于时间位是单调递增的，且各个服务器如果大体做了时间同步，那么生成的主键在分布式环境可以认为是总体有序的，这就保证了对索引字段的插入的高效性。</p><h3 id="51-基本原理"><a class="markdownIt-Anchor" href="#51-基本原理"></a> 5.1. 基本原理</h3><h4 id="键的组成"><a class="markdownIt-Anchor" href="#键的组成"></a> 键的组成</h4><p>使用<strong>雪花算法生成的主键，二进制表示形式包含 4 部分</strong>，从高位到低位分表为：1bit 符号位、41bit 时间戳位、10bit 工作进程位以及 12bit 序列号位。</p><ul><li><strong>符号位(1bit)</strong></li></ul><p>预留的符号位，恒为零。</p><ul><li><strong>时间戳位(41bit)</strong></li></ul><p>41 位的时间戳可以容纳的毫秒数是 2 的 41 次幂，一年所使用的毫秒数是：<code>365 * 24 * 60 * 60 * 1000</code>。通过计算可知：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Math.pow(<span class="number">2</span>, <span class="number">41</span>) / (<span class="number">365</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000L</span>);</span><br></pre></td></tr></table></figure><p>结果约等于 69.73 年。ShardingSphere 的雪花算法的时间纪元从 2016 年 11 月 1 日零点开始，可以使用到 2086 年，相信能满足绝大部分系统的要求。</p><ul><li><strong>工作进程位(10bit)</strong></li></ul><p>该标志在 Java 进程内是唯一的，如果是分布式应用部署应保证每个工作进程的 id 是不同的。该值默认为 0，可通过属性设置。</p><ul><li><strong>序列号位(12bit)</strong></li></ul><p>该序列是用来在同一个毫秒内生成不同的 ID。如果在这个毫秒内生成的数量超过 4096(2 的 12 次幂)，那么生成器会等待到下个毫秒继续生成。</p><p>雪花算法主键的详细结构见下图：</p><p><img src="https://shardingsphere.apache.org/document/current/img/sharding/snowflake_cn_v2.png" alt="雪花算法" /></p><h4 id="时钟回拨"><a class="markdownIt-Anchor" href="#时钟回拨"></a> 时钟回拨</h4><p>服务器时钟回拨会导致产生重复序列，因此默认分布式主键生成器提供了一个最大容忍的时钟回拨毫秒数。 如果时钟回拨的时间超过最大容忍的毫秒数阈值，则程序报错；如果在可容忍的范围内，默认分布式主键生成器会等待时钟同步到最后一次主键生成的时间后再继续工作。 最大容忍的时钟回拨毫秒数的默认值为 0，可通过属性设置。</p><h4 id="灵活定制"><a class="markdownIt-Anchor" href="#灵活定制"></a> 灵活定制</h4><p>上面只是一个将 <code>64bit</code> 划分的标准，当然也不一定这么做，可以根据不同业务的具体场景来划分，比如下面给出一个业务场景：</p><ul><li>服务目前 QPS10 万，预计几年之内会发展到百万。</li><li>当前机器三地部署，上海，北京，深圳都有。</li><li>当前机器 10 台左右，预计未来会增加至百台。</li></ul><p>这个时候我们根据上面的场景可以再次合理的划分 62bit，QPS 几年之内会发展到百万，那么每毫秒就是千级的请求，目前 10 台机器那么每台机器承担百级的请求，为了保证扩展，后面的循环位可以限制到 1024，也就是 2^10，那么循环位 10 位就足够了。</p><p>机器三地部署我们可以用 3bit 总共 8 来表示机房位置，当前的机器 10 台，为了保证扩展到百台那么可以用 7bit 128 来表示，时间位依然是 41bit，那么还剩下 64-10-3-7-41-1 = 2bit，还剩下 2bit 可以用来进行扩展。</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/29/16624909d2007c22?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="" /></p><h3 id="52-优点"><a class="markdownIt-Anchor" href="#52-优点"></a> 5.2. 优点</h3><ul><li>生成的 ID 都是趋势递增的。</li><li>不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成 ID 的性能也是非常高的。</li><li>可以根据自身业务特性分配 bit 位，非常灵活。</li></ul><h3 id="53-缺点"><a class="markdownIt-Anchor" href="#53-缺点"></a> 5.3. 缺点</h3><ul><li>强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。</li></ul><h3 id="54-适用场景"><a class="markdownIt-Anchor" href="#54-适用场景"></a> 5.4. 适用场景</h3><p>当我们需要无序不能被猜测的 ID，并且需要一定高性能，且需要 long 型，那么就可以使用我们雪花算法。比如常见的订单 ID，用雪花算法别人就无法猜测你每天的订单量是多少。</p><h3 id="55-防止时钟回拨"><a class="markdownIt-Anchor" href="#55-防止时钟回拨"></a> 5.5. 防止时钟回拨</h3><p>雪花算法是强依赖于时间的，而如果机器时间发生回拨，有可能会生成重复的 ID。</p><p>我们可以针对算法做一些优化，来防止时钟回拨生成重复 ID。</p><p>用当前时间和上一次的时间进行判断，如果当前时间小于上一次的时间那么肯定是发生了回拨。普通的算法会直接抛出异常，这里我们可以对其进行优化，一般分为两个情况:</p><ul><li>如果时间回拨时间较短，比如配置 <code>5ms</code> 以内，那么可以直接等待一定的时间，让机器的时间追上来。</li><li>如果时间的回拨时间较长，我们不能接受这么长的阻塞等待，那么又有两个策略:<ul><li>直接拒绝，抛出异常。打日志，通知 RD 时钟回滚。</li><li>利用扩展位。上面我们讨论过，不同业务场景位数可能用不到那么多比特位，那么我们可以把扩展位数利用起来。比如：当这个时间回拨比较长的时候，我们可以不需要等待，直接在扩展位加 1。两位的扩展位允许我们有三次大的时钟回拨，一般来说就够了，如果其超过三次我们还是选择抛出异常，打日志。</li></ul></li></ul><h2 id="6-leaf"><a class="markdownIt-Anchor" href="#6-leaf"></a> 6. Leaf</h2><blockquote><p>美团提供了一种分布式 ID 解决方案 Leaf，其本质可以视为数据库分段+服务缓存 ID。</p><p>详情可以参考 <a href="https://tech.meituan.com/2017/04/21/mt-leaf.html" target="_blank" rel="noopener">Leaf——美团点评分布式 ID 生成系统</a></p></blockquote><h3 id="61-基本原理"><a class="markdownIt-Anchor" href="#61-基本原理"></a> 6.1. 基本原理</h3><p>使用数据库生成 ID，但是做了如下改进：</p><p>原方案每次获取 ID 都得读写一次数据库，造成数据库压力大。改为利用 proxy server 批量获取，每次获取一个 segment(step 决定大小)号段的值。用完之后再去数据库获取新的号段，可以大大的减轻数据库的压力。 - 各个业务不同的发号需求用 biz_tag 字段来区分，每个 biz-tag 的 ID 获取相互隔离，互不影响。如果以后有性能需求需要对数据库扩容，不需要上述描述的复杂的扩容操作，只需要对 biz_tag 分库分表就行。</p><p>数据库表设计如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">+<span class="comment">-------------+--------------+------+-----+-------------------+-----------------------------+</span></span><br><span class="line">| Field       | Type         | Null | Key | Default           | Extra                       |</span><br><span class="line">+<span class="comment">-------------+--------------+------+-----+-------------------+-----------------------------+</span></span><br><span class="line">| biz_tag     | varchar(128) | NO   | PRI |                   |                             |</span><br><span class="line">| max_id      | bigint(20)   | NO   |     | 1                 |                             |</span><br><span class="line">| step        | int(11)      | NO   |     | NULL              |                             |</span><br><span class="line">| desc        | varchar(256) | YES  |     | NULL              |                             |</span><br><span class="line">| update_time | timestamp    | NO   |     | CURRENT_TIMESTAMP | on <span class="keyword">update</span> <span class="keyword">CURRENT_TIMESTAMP</span> |</span><br><span class="line">+<span class="comment">-------------+--------------+------+-----+-------------------+-----------------------------+</span></span><br></pre></td></tr></table></figure><p>重要字段说明：</p><ul><li><code>biz_tag</code> 用来区分业务</li><li><code>max_id</code> 表示该 <code>biz_tag</code> 目前所被分配的 ID 号段的最大值</li><li><code>step</code> 表示每次分配的号段长度。原来获取 ID 每次都需要写数据库，现在只需要把 <code>step</code> 设置得足够大，比如 1000。那么只有当 1000 个号被消耗完了之后才会去重新读写一次数据库。读写数据库的频率从 1 减小到了 1/step。</li></ul><p>大致架构如下图所示：</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/5e4ff128.png" alt="image" /></p><p>test_tag 在第一台 Leaf 机器上是 <code>1~1000</code> 的号段，当这个号段用完时，会去加载另一个长度为 step=1000 的号段，假设另外两台号段都没有更新，这个时候第一台机器新加载的号段就应该是 <code>3001~4000</code>。同时数据库对应的 biz_tag 这条数据的 max_id 会从 3000 被更新成 4000，更新号段的 SQL 语句如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Begin</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">table</span> <span class="keyword">SET</span> max_id=max_id+step <span class="keyword">WHERE</span> biz_tag=xxx</span><br><span class="line"><span class="keyword">SELECT</span> tag, max_id, step <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> biz_tag=xxx</span><br><span class="line"><span class="keyword">Commit</span></span><br></pre></td></tr></table></figure><h3 id="62-优点"><a class="markdownIt-Anchor" href="#62-优点"></a> 6.2. 优点</h3><ul><li>比数据库自增键性能高</li><li>能保证键趋势递增。</li><li>如果数据库宕机，由于 proxServer 有缓存，依然可以坚持一段时间。</li></ul><h3 id="63-缺点"><a class="markdownIt-Anchor" href="#63-缺点"></a> 6.3. 缺点</h3><ul><li>和主键递增一样，容易被人猜测。</li><li>数据库宕机后，虽然能支撑一段时间，但是仍然会造成系统不可用。</li></ul><h3 id="64-适用场景"><a class="markdownIt-Anchor" href="#64-适用场景"></a> 6.4. 适用场景</h3><p>需要趋势递增，并且 ID 大小可控制的，可以使用这套方案。</p><p>当然这个方案也可以通过一些手段避免被人猜测，把 ID 变成是无序的，比如把我们生成的数据是一个递增的 long 型，把这个 Long 分成几个部分，比如可以分成几组三位数，几组四位数，然后在建立一个映射表，将我们的数据变成无序。</p><h2 id="7-参考资料"><a class="markdownIt-Anchor" href="#7-参考资料"></a> 7. 参考资料</h2><ul><li><a href="https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md" target="_blank" rel="noopener">百度分布式 ID</a></li><li><a href="https://juejin.im/post/5bb0217ef265da0ac2567b42" target="_blank" rel="noopener">如果再有人问你分布式 ID，这篇文章丢给他</a></li><li><a href="https://segmentfault.com/a/1190000011282426" target="_blank" rel="noopener">理解分布式 id 生成算法 SnowFlake</a></li><li><a href="https://tech.meituan.com/2017/04/21/mt-leaf.html" target="_blank" rel="noopener">Leaf——美团点评分布式 ID 生成系统</a></li><li><a href="https://www.ietf.org/rfc/rfc4122.txt" target="_blank" rel="noopener">UUID 规范</a></li><li><a href="https://shardingsphere.apache.org/document/current/cn/features/sharding/other-features/key-generator/" target="_blank" rel="noopener">ShardingSphere 分布式主键</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分布式-id-基本原理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#分布式-id-基本原理&quot;&gt;&lt;/a&gt; 分布式 ID 基本原理&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;传统数据库软件开发中，主键自动生成技术是基本需求。而各个数据库对
      
    
    </summary>
    
    
      <category term="设计" scheme="https://dunwu.github.io/blog/categories/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="系统原理" scheme="https://dunwu.github.io/blog/categories/%E8%AE%BE%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="设计" scheme="https://dunwu.github.io/blog/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="系统原理" scheme="https://dunwu.github.io/blog/tags/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    
      <category term="分布式 ID" scheme="https://dunwu.github.io/blog/tags/%E5%88%86%E5%B8%83%E5%BC%8F-ID/"/>
    
  </entry>
  
  <entry>
    <title>消息队列基本原理</title>
    <link href="https://dunwu.github.io/blog/design/theory/mq-theory/"/>
    <id>https://dunwu.github.io/blog/design/theory/mq-theory/</id>
    <published>2019-07-05T07:11:00.000Z</published>
    <updated>2020-01-20T03:26:54.204Z</updated>
    
    <content type="html"><![CDATA[<h1 id="消息队列基本原理"><a class="markdownIt-Anchor" href="#消息队列基本原理"></a> 消息队列基本原理</h1><blockquote><p>消息队列（Message Queue，简称 MQ）技术是分布式应用间交换信息的一种技术。</p><p>消息队列主要解决应用耦合，异步消息，流量削锋等问题，实现高性能，高可用，可伸缩和最终一致性架构。是大型分布式系统不可缺少的中间件。</p><p>注意：<em>为了简便，下文中除了文章标题，一律使用 MQ 简称</em>。</p></blockquote><h2 id="1-为什么要使用-mq"><a class="markdownIt-Anchor" href="#1-为什么要使用-mq"></a> 1. 为什么要使用 MQ</h2><p>MQ 比较核心的优点有 3 个：<strong>解耦</strong>、<strong>异步</strong>、<strong>削峰</strong>。</p><h3 id="11-解耦"><a class="markdownIt-Anchor" href="#11-解耦"></a> 1.1. 解耦</h3><p>不同系统如果要建立通信，传统的做法是：调用接口。</p><p>如果需要和新的系统建立通信或删除已建立的通信，都需要修改代码，这种方案显然耦合度很高。</p><p><img src="http://dunwu.test.upcdn.net/cs/design/theory/mq/mq_1.png" alt="" /></p><p>如果使用 MQ，系统间的通信只需要通过发布/订阅（Pub/Sub）模型即可，彼此没有直接联系，也就不需要相互感知，从而达到 <strong>解耦</strong>。</p><p><img src="http://dunwu.test.upcdn.net/cs/design/theory/mq/mq_2.png" alt="" /></p><h3 id="12-异步"><a class="markdownIt-Anchor" href="#12-异步"></a> 1.2. 异步</h3><p>假设这样一个场景，用户向系统 A 发起请求，系统 A 处理计算只需要 10 ms，然后通知系统 BCD 写库，系统 BCD 写库耗时分别为：100ms、200ms、300ms。最终总耗时为： 10+100ms+200ms+300ms=610ms。此外，加上请求和响应的网络传输时间，从用户角度看，可能要等待将近 1s 才能得到结果。</p><p><img src="http://dunwu.test.upcdn.net/cs/design/theory/mq/mq_3.png" alt="" /></p><p>如果使用 MQ，系统 A 接到请求后，耗时 10ms 处理计算，然后向系统 BCD 连续发送消息，假设耗时 5ms。那么 这一过程的总耗时为 3ms + 5ms = 8ms，这相比于 610 ms，大大缩短了响应时间。至于系统 BCD 的写库操作，只要自行消费 MQ 后处理即可，用户无需关注。</p><p><img src="http://dunwu.test.upcdn.net/cs/design/theory/mq/mq_4.png" alt="" /></p><h3 id="13-削峰"><a class="markdownIt-Anchor" href="#13-削峰"></a> 1.3. 削峰</h3><p>假设某个系统读写数据库的稳定性能为每秒处理 1000 条数据。平常情况下，远远达不到这么大的处理量。假设，因为因为做活动，系统的瞬时请求量剧增，达到每秒 10000 个并发请求，数据库根本承受不了，可能直接就把数据库给整崩溃了，这样系统服务就不可用了。</p><p><img src="http://dunwu.test.upcdn.net/cs/design/theory/mq/mq_5.png" alt="" /></p><p>如果使用 MQ，每秒写入 10000 条请求，但是系统 A 每秒只从 MQ 中消费 1000 条请求，然后写入数据库。这样，就不会超过数据库的承受能力，而是把请求积压在 MQ 中。只要高峰期一过，系统 A 就会很快把积压的消息给处理掉。</p><p><img src="http://dunwu.test.upcdn.net/cs/design/theory/mq/mq_6.png" alt="" /></p><h2 id="2-mq-引入的问题"><a class="markdownIt-Anchor" href="#2-mq-引入的问题"></a> 2. MQ 引入的问题</h2><p>凡事有利有弊，使用 MQ 给系统带来很多好处，也会付出一定的代价。</p><p>它引入了以下问题：</p><ul><li><strong>系统可用性降低</strong> - 引入了 MQ 后，通信需要基于 MQ 完成，如果 MQ 宕机，则服务不可用。因此，MQ 要保证是高可用的，详情参考：<a href="#MQ-%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8">MQ 的高可用</a></li><li><strong>系统复杂度提高</strong> - 使用 MQ，需要关注一些新的问题：<ul><li>如何保证消息没有重复消费？</li><li>如何处理消息丢失的问题？</li><li>如何保证消息传递的顺序性？</li><li>如何处理大量消息积压的问题？</li></ul></li><li><strong>一致性问题</strong> - 假设系统 A 处理完直接返回成功的结果给用户，用户认为请求成功。但如果此时，系统 BCD 中只要有任意一个写库失败，那么数据就不一致了。这种情况如何处理？</li></ul><h3 id="21-重复消费"><a class="markdownIt-Anchor" href="#21-重复消费"></a> 2.1. 重复消费</h3><p><strong>如何保证消息不被重复消费</strong> 和 <strong>如何保证消息消费的幂等性</strong> 是同一个问题。</p><p>必须先明确产生重复消费的原因，才能对症下药。</p><h4 id="211-重复消费问题原因"><a class="markdownIt-Anchor" href="#211-重复消费问题原因"></a> 2.1.1. 重复消费问题原因</h4><p>重复消费问题通常不是 MQ 来处理，而是由开发来处理的。</p><p>以 Kafka 举例：Kafka 每个 Partition 都是一个有序的、不可变的记录序列，不断追加到结构化的提交日志中。Partition 中的记录每个分配一个连续的 id 号，称为偏移量（Offset），用于唯一标识 Partition 内的每条记录。</p><p><img src="http://kafka.apachecn.org/10/images/log_consumer.png" alt="" /></p><p>Kafka 的客户端和 Broker 都会保存 Offset。客户端消费消息后，每隔一段时间，就把已消费的 Offset 提交给 Kafka Broker，表示已消费。</p><p>在这个过程中，如果客户端应用消费消息后，因为宕机、重启等情况而没有提交已消费的 Offset 。当系统恢复后，会继续消费消息，由于 Offset 未提交，就会出现重复消费的问题。</p><p><img src="http://upload-images.jianshu.io/upload_images/3101171-75abe308f9cf21f8.png" alt="" /></p><h4 id="212-重复消费解决方案"><a class="markdownIt-Anchor" href="#212-重复消费解决方案"></a> 2.1.2. 重复消费解决方案</h4><p>应对重复消费问题，就要通过幂等性来解决。</p><p>这个问题可以从业务层面来解决。</p><p>MQ 重复消费不可怕，可怕的是没有应对机制，可以借鉴的思路有：</p><ul><li>如果是写库，可以先根据主键查询，判断数据是否已存在，存在则更新，不存在则插入；</li><li>如果是写 Redis，set 操作，由于天然具有幂等性，大可放心；</li><li>如果是根据消息做较复杂的逻辑处理，可以在消息中加入全局唯一 ID，例如：订单 ID 等。在客户端存储中（Mysql、Redis 等）保存已消费消息的 ID。一旦接受到新消息，先判断消息中的 ID 是否在已消费消息 ID 表中存在，存在则不再处理，不存在则处理。</li></ul><h3 id="22-消息丢失"><a class="markdownIt-Anchor" href="#22-消息丢失"></a> 2.2. 消息丢失</h3><p><strong>如何处理消息丢失的问题</strong> 和 <strong>如何保证消息不被重复消费</strong> 是同一个问题。关注点有按个：</p><ul><li>Kafka 丢失数据</li><li>消费方丢失数据</li><li>生产方丢失数据</li></ul><h4 id="221-消费方丢失数据"><a class="markdownIt-Anchor" href="#221-消费方丢失数据"></a> 2.2.1. 消费方丢失数据</h4><p>唯一可能导致消费方丢失数据的情况，就是：消费方设置了<strong>自动提交 Offset</strong>。设置了自动提交 Offset，接受到消息后就会自动提交 Offset 给 Kafka ，Kafka 就认为消息已被消费。如果此时，消费方尚未来得及处理消息就挂了，那么消息就丢了。</p><p>解决方法就是消费方关闭自动提交 Offset，处理完消息后手动提交 Offset。但这种情况下可能会出现重复消费的情形，需要自行保证幂等性。</p><h4 id="222-kafka-丢失数据"><a class="markdownIt-Anchor" href="#222-kafka-丢失数据"></a> 2.2.2. Kafka 丢失数据</h4><p>当 Kafka 某个 Broker 宕机，需要重新选举 Partition 的 Leader。若此时其他的 Follower 尚未同步 Leader 的数据，那么新选某个 Follower 为 Leader 后，就丢失了部分数据。</p><p>为此，一般要求至少设置 4 个参数：</p><ul><li>给 Topic 设置 <code>replication.factor</code> 参数 - 这个值必须大于 1，要求每个 Partition 必须有至少 2 个副本。</li><li>在 Kafka 服务端设置 <code>min.insync.replicas</code> 参数 - 这个值必须大于 1，这是要求一个 Leader 需要和至少一个 Follower 保持通信，这样才能确保 Leader 挂了还有替补。</li><li>在 Producer 端设置 <code>acks=all</code> - 这意味着：要求每条数据，必须是<strong>写入所有 replica 之后，才能认为是写成功了</strong>。</li><li>在 Producer 端设置 <code>retries=MAX</code>（很大很大很大的一个值，无限次重试的意思） - 这意味着<strong>要求一旦写入失败，就无限重试</strong>，卡在这里了。</li></ul><h4 id="223-生产方丢失数据"><a class="markdownIt-Anchor" href="#223-生产方丢失数据"></a> 2.2.3. 生产方丢失数据</h4><p>如果按照上述的思路设置了 <code>acks=all</code>，生产方一定不会丢数据。</p><p>要求是，你的 Leader 接收到消息，所有的 Follower 都同步到了消息之后，才认为本生产消息成功了。如果未满足这个条件，生产者会自动不断的重试，重试无限次。</p><h3 id="23-消息的顺序性"><a class="markdownIt-Anchor" href="#23-消息的顺序性"></a> 2.3. 消息的顺序性</h3><blockquote><p>以 Kafka 为例</p></blockquote><p>要保证 MQ 的顺序性，势必要付出一定的代价，所以实施方案前，要先明确业务场景是不是有必要保证消息的顺序性。只有那些明确对消息处理顺序有要求的业务场景才值得去保证消息顺序性。</p><p>方案一</p><p>一个 Topic，一个 Partition，一个 Consumer，内部单线程消费，单线程吞吐量太低，一般不会用这个。</p><p>方案二</p><ul><li>写入数据到 Partition 时指定一个唯一的 Key，例如订单 ID。由发送方保证相同 Key 的消息只能发送到同一个 Partition 并且这个 Partition 中的数据一定是顺序的。</li><li>基于上一点，消费方从 Kafka Partition 中消费消息时，此刻一定是顺序的。但如果消费方式以并发方式消费消息，顺序就可能会被打乱。为此，还有做到以下几点：<ul><li>消费方维护 N 个缓存队列，具有相同 key 的数据都写入同一个队列中；</li><li>创建 N 个线程，每个线程只负责从指定的一个队列中取数据。</li></ul></li></ul><p><img src="http://dunwu.test.upcdn.net/cs/design/theory/mq/mq_7.png" alt="" /></p><h3 id="24-消息积压"><a class="markdownIt-Anchor" href="#24-消息积压"></a> 2.4. 消息积压</h3><p>假设一个 MQ 消费者可以一秒处理 1000 条消息，三个 MQ 消费者可以一秒处理 3000 条消息，那么一分钟的处理量是 18 万条。如果 MQ 中积压了几百万到上千万的数据，即使消费者恢复了，也需要大概很长的时间才能恢复过来。</p><p>对于产线环境来说，漫长的等待是不可接受的，所以面临这种窘境时，只能临时紧急扩容以应对了，具体操作步骤和思路如下：</p><ul><li>先修复 Consumer 的问题，确保其恢复消费速度，然后将现有 Consumer 都停掉。</li><li>新建一个 Topic，Partition 是原来的 10 倍，临时建立好原先 10 倍的 Queue 数量。</li><li>然后写一个临时的分发数据的 Consumer 程序，这个程序部署上去消费积压的数据，<strong>消费之后不做耗时的处理</strong>，直接均匀轮询写入临时建立好的 10 倍数量的 Queue。</li><li>接着临时征用 10 倍的机器来部署 Consumer ，每一批 Consumer 消费一个临时 Queue 的数据。这种做法相当于是临时将 Queue 资源和 Consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。</li><li>等快速消费完积压数据之后，<strong>得恢复原先部署的架构</strong>，<strong>重新</strong>用原先的 consumer 机器来消费消息。</li></ul><h2 id="3-mq-的高可用"><a class="markdownIt-Anchor" href="#3-mq-的高可用"></a> 3. MQ 的高可用</h2><p>不同 MQ 实现高可用的原理各不相同。因为 Kafka 比较具有代表性，所以这里以 Kafka 为例。</p><h3 id="31-kafka-的高可用"><a class="markdownIt-Anchor" href="#31-kafka-的高可用"></a> 3.1. Kafka 的高可用</h3><h4 id="311-kafka-的核心概念"><a class="markdownIt-Anchor" href="#311-kafka-的核心概念"></a> 3.1.1. Kafka 的核心概念</h4><p>了解 Kafka，必须先了解 Kafka 的核心概念：</p><ul><li><p><strong>Broker</strong> - Kafka 集群包含一个或多个节点，这种节点被称为 Broker。</p></li><li><p><strong>Topic</strong> - 每条发布到 Kafka 集群的消息都有一个类别，这个类别被称为 Topic。（不同 Topic 的消息是物理隔离的；同一个 Topic 的消息保存在一个或多个 Broker 上，但用户只需指定消息的 Topic 即可生产或消费数据而不必关心数据存于何处）。对于每一个 Topic， Kafka 集群都会维持一个分区日志。</p></li><li><p><strong>Partition</strong> - 了提高 Kafka 的吞吐率，每个 Topic 包含一个或多个 Partition，每个 Partition 在物理上对应一个文件夹，该文件夹下存储这个 Partition 的所有消息和索引文件。</p><ul><li>Kafka 日志的分区（Partition）分布在 Kafka 集群的节点上。每个节点在处理数据和请求时，共享这些分区。每一个分区都会在已配置的节点上进行备份，确保容错性。</li></ul></li></ul><p><img src="http://dunwu.test.upcdn.net/cs/java/javaweb/distributed/mq/kafka/kafka-cluster-roles.png" alt="" /></p><h4 id="312-kafka-的副本机制"><a class="markdownIt-Anchor" href="#312-kafka-的副本机制"></a> 3.1.2. Kafka 的副本机制</h4><p>Kafka 是如何实现高可用的呢？</p><p>Kafka 在 0.8 以前的版本中，如果一个 Broker 宕机了，其上面的 Partition 都不能用了，这自然不是高可用的。</p><p>为了实现高可用，Kafka 引入了复制功能。</p><p>简单来说，就是副本机制（ Replicate ）。</p><p>每个 Partition 都有一个 Broker 作为 Leader，零个或者多个 Broker 作为 Follower。每个 Broker 都会成为某些分区的 Leader 和某些分区的 Follower，因此集群的负载是平衡的。</p><ul><li><strong>Leader 处理一切对 Partition （分区）的读写请求</strong>；</li><li><strong>而 Follower 只需被动的同步 Leader 上的数据</strong>。</li></ul><p>同一个 Topic 的不同 Partition 会分布在多个 Broker 上，而且一个 Partition 还会在其他的 Broker 上面进行备份，Producer 在发布消息到某个 Partition 时，先找到该 Partition 的 Leader，然后向这个 Leader 推送消息；每个 Follower 都从 Leader 拉取消息，拉取消息成功之后，向 Leader 发送一个 ACK 确认。</p><p><img src="http://dunwu.test.upcdn.net/cs/java/javaweb/distributed/mq/kafka/kafka-replication.png" alt="" /></p><blockquote><p>FAQ</p><p>问：为什么让 Leader 处理一切对对 Partition （分区）的读写请求？</p><p>答：因为如果允许所有 Broker 都可以处理读写请求，就可能产生数据一致性问题。</p></blockquote><h4 id="313-kafka-选举-leader"><a class="markdownIt-Anchor" href="#313-kafka-选举-leader"></a> 3.1.3. Kafka 选举 Leader</h4><p>由上文可知，Partition 在多个 Broker 上存在副本。</p><p>如果某个 Follower 宕机，啥事儿没有，正常工作。</p><p>如果 Leader 宕机了，会从 Follower 中<strong>重新选举</strong>一个新的 Leader。</p><h2 id="4-mq-的通信模式"><a class="markdownIt-Anchor" href="#4-mq-的通信模式"></a> 4. MQ 的通信模式</h2><p>MQ 可驻留在内存或磁盘上，队列存储消息直到它们被应用程序读取。通过 MQ，应用程序可独立地执行，它们不需要知道彼此的位置，不需要等待接收程序接收此消息。在分布式计算环境中，为了集成分布式应用，开发者需要对异构网络环境下的分布式应用提供有效的通信手段。为了管理需要共享的信息，对应用提供公共的信息交换机制是重要的。</p><ul><li><strong>点对点</strong> - 点对点方式是最为传统和常见的通讯方式，它支持一对一、一对多、多对多、多对一等多种配置方式，支持树状、网状等多种拓扑结构。</li><li><strong>多点广播</strong> - MQ 适用于不同类型的应用。其中重要的，也是正在发展中的是&quot;多点广播&quot;应用，即能够将消息发送到多个目标站点 (Destination List)。可以使用一条 MQ 指令将单一消息发送到多个目标站点，并确保为每一站点可靠地提供信息。MQ 不仅提供了多点广播的功能，而且还拥有智能消息分发功能，在将一条消息发送到同一系统上的多个用户时，MQ 将消息的一个复制版本和该系统上接收者的名单发送到目标 MQ 系统。目标 MQ 系统在本地复制这些消息，并将它们发送到名单上的队列，从而尽可能减少网络的传输量。</li><li><strong>发布/订阅 (Publish/Subscribe)</strong> - 发布/订阅模式使消息的分发可以突破目的队列地理位置的限制，使消息按照特定的主题甚至内容进行分发，用户或应用程序可以根据主题或内容接收到所需要的消息。发布/订阅模式使得发送者和接收者之间的耦合关系变得更为松散，发送者不必关心接收者的目的地址，而接收者也不必关心消息的发送地址，而只是根据消息的主题进行消息的收发。</li><li><strong>集群 (Cluster)</strong> - 为了简化点对点通讯模式中的系统配置，MQ 提供 Cluster(集群) 的解决方案。集群类似于一个域 (Domain)，集群内部的队列管理器之间通讯时，不需要两两之间建立消息通道，而是采用集群 (Cluster) 通道与其它成员通讯，从而大大简化了系统配置。此外，集群中的队列管理器之间能够自动进行负载均衡，当某一队列管理器出现故障时，其它队列管理器可以接管它的工作，从而大大提高系统的高可靠性。</li></ul><h2 id="5-常用-mq-对比"><a class="markdownIt-Anchor" href="#5-常用-mq-对比"></a> 5. 常用 MQ 对比</h2><table><thead><tr><th>特性</th><th>ActiveMQ</th><th>RabbitMQ</th><th>RocketMQ</th><th>Kafka</th></tr></thead><tbody><tr><td>单机吞吐量</td><td>万级，比 RocketMQ、Kafka 低一个数量级</td><td>同 ActiveMQ</td><td>10 万级，支撑高吞吐</td><td>10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td></tr><tr><td>topic 数量对吞吐量的影响</td><td></td><td></td><td>topic 可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic</td><td>topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源</td></tr><tr><td>时效性</td><td>ms 级</td><td>微秒级，这是 RabbitMQ 的一大特点，延迟最低</td><td>ms 级</td><td>延迟在 ms 级以内</td></tr><tr><td>可用性</td><td>高，基于主从架构实现高可用</td><td>同 ActiveMQ</td><td>非常高，分布式架构</td><td>非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td></tr><tr><td>消息可靠性</td><td>有较低的概率丢失数据</td><td>基本不丢</td><td>经过参数优化配置，可以做到 0 丢失</td><td>同 RocketMQ</td></tr><tr><td>功能支持</td><td>MQ 领域的功能极其完备</td><td>基于 erlang 开发，并发能力很强，性能极好，延时很低</td><td>MQ 功能较为完善，还是分布式的，扩展性好</td><td>功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用</td></tr></tbody></table><p>综上，各种对比之后，有如下建议：</p><ul><li>一般的业务系统要引入 MQ，最早大家都用 ActiveMQ，但是现在确实大家用的不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃，所以大家还是算了吧，我个人不推荐用这个了；</li><li>后来大家开始用 RabbitMQ，但是确实 erlang 语言阻止了大量的 Java 工程师去深入研究和掌控它，对公司而言，几乎处于不可控的状态，但是确实人家是开源的，比较稳定的支持，活跃度也高；</li><li>不过现在确实越来越多的公司会去用 RocketMQ，确实很不错，毕竟是阿里出品，但社区可能有突然黄掉的风险（目前 RocketMQ 已捐给 <a href="https://github.com/apache/rocketmq" target="_blank" rel="noopener">Apache</a>，但 GitHub 上的活跃度其实不算高）对自己公司技术实力有绝对自信的，推荐用 RocketMQ，否则回去老老实实用 RabbitMQ 吧，人家有活跃的开源社区，绝对不会黄。</li><li>所以<strong>中小型公司</strong>，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是不错的选择；<strong>大型公司</strong>，基础架构研发实力较强，用 RocketMQ 是很好的选择。</li><li>如果是<strong>大数据领域</strong>的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</li></ul><h2 id="6-jms"><a class="markdownIt-Anchor" href="#6-jms"></a> 6. JMS</h2><p>谈 MQ 就不得不提一下 JMS 。</p><p><strong>JMS（JAVA Message Service，java 消息服务）API 是一个消息服务的标准/规范，允许应用程序组件基于 JavaEE 平台创建、发送、接收和读取消息</strong>。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。</p><p>在 EJB 架构中，有消息 bean 可以无缝的与 JM 消息服务集成。在 J2EE 架构模式中，有消息服务者模式，用于实现消息与应用直接的解耦。</p><h3 id="61-消息模型"><a class="markdownIt-Anchor" href="#61-消息模型"></a> 6.1. 消息模型</h3><p>在 JMS 标准中，有两种消息模型：</p><ul><li>P2P(Point to Point)</li><li>Pub/Sub(Publish/Subscribe)</li></ul><h4 id="611-p2p-模式"><a class="markdownIt-Anchor" href="#611-p2p-模式"></a> 6.1.1. P2P 模式</h4><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-2adc66e2367cd2c2.png"/></div>P2P 模式包含三个角色：MQ（Queue），发送者(Sender)，接收者(Receiver)。每个消息都被发送到一个特定的队列，接收者从队列中获取消息。队列保留着消息，直到他们被消费或超时。<p>P2P 的特点</p><ul><li>每个消息只有一个消费者（Consumer）(即一旦被消费，消息就不再在 MQ 中)</li><li>发送者和接收者之间在时间上没有依赖性，也就是说当发送者发送了消息之后，不管接收者有没有正在运行，它不会影响到消息被发送到队列</li><li>接收者在成功接收消息之后需向队列应答成功</li></ul><p>如果希望发送的每个消息都会被成功处理的话，那么需要 P2P 模式。</p><h4 id="612-pubsub-模式"><a class="markdownIt-Anchor" href="#612-pubsub-模式"></a> 6.1.2. Pub/sub 模式</h4><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-12afe9581da889ea.png"/></div>包含三个角色主题（Topic），发布者（Publisher），订阅者（Subscriber） 。多个发布者将消息发送到 Topic,系统将这些消息传递给多个订阅者。<p>Pub/Sub 的特点</p><ul><li>每个消息可以有多个消费者</li><li>发布者和订阅者之间有时间上的依赖性。针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息。</li><li>为了消费消息，订阅者必须保持运行的状态。</li></ul><p>为了缓和这样严格的时间相关性，JMS 允许订阅者创建一个可持久化的订阅。这样，即使订阅者没有被激活（运行），它也能接收到发布者的消息。</p><p>如果希望发送的消息可以不被做任何处理、或者只被一个消息者处理、或者可以被多个消费者处理的话，那么可以采用 Pub/Sub 模型。</p><h3 id="62-消息消费"><a class="markdownIt-Anchor" href="#62-消息消费"></a> 6.2. 消息消费</h3><p>在 JMS 中，消息的产生和消费都是异步的。对于消费来说，JMS 的消息者可以通过两种方式来消费消息。</p><ul><li><strong>同步</strong> - 订阅者或接收者通过 <code>receive</code> 方法来接收消息，<code>receive</code> 方法在接收到消息之前（或超时之前）将一直阻塞；</li><li><strong>异步</strong> - 订阅者或接收者可以注册为一个消息监听器。当消息到达之后，系统自动调用监听器的 <code>onMessage</code> 方法。</li></ul><p><code>JNDI</code> - Java 命名和目录接口,是一种标准的 Java 命名系统接口。可以在网络上查找和访问服务。通过指定一个资源名称，该名称对应于数据库或命名服务中的一个记录，同时返回资源连接建立所必须的信息。</p><p>JNDI 在 JMS 中起到查找和访问发送目标或消息来源的作用。</p><h3 id="63-jms-编程模型"><a class="markdownIt-Anchor" href="#63-jms-编程模型"></a> 6.3. JMS 编程模型</h3><h4 id="631-connectionfactory"><a class="markdownIt-Anchor" href="#631-connectionfactory"></a> 6.3.1. ConnectionFactory</h4><p>创建 Connection 对象的工厂，针对两种不同的 jms 消息模型，分别有 QueueConnectionFactory 和 TopicConnectionFactory 两种。可以通过 JNDI 来查找 ConnectionFactory 对象。</p><h4 id="632-destination"><a class="markdownIt-Anchor" href="#632-destination"></a> 6.3.2. Destination</h4><p>Destination 的意思是消息生产者的消息发送目标或者说消息消费者的消息来源。对于消息生产者来说，它的 Destination 是某个队列（Queue）或某个主题（Topic）;对于消息消费者来说，它的 Destination 也是某个队列或主题（即消息来源）。</p><p>所以，Destination 实际上就是两种类型的对象：Queue、Topic。可以通过 JNDI 来查找 Destination。</p><h4 id="633-3-connection"><a class="markdownIt-Anchor" href="#633-3-connection"></a> 6.3.3. (3) Connection</h4><p>Connection 表示在客户端和 JMS 系统之间建立的链接（对 TCP/IP socket 的包装）。Connection 可以产生一个或多个 Session。跟 ConnectionFactory 一样，Connection 也有两种类型：QueueConnection 和 TopicConnection。</p><h4 id="634-4-session"><a class="markdownIt-Anchor" href="#634-4-session"></a> 6.3.4. (4) Session</h4><p>Session 是操作消息的接口。可以通过 session 创建生产者、消费者、消息等。Session 提供了事务的功能。当需要使用 session 发送/接收多个消息时，可以将这些发送/接收动作放到一个事务中。同样，也分 QueueSession 和 TopicSession。</p><h4 id="635-消息的生产者"><a class="markdownIt-Anchor" href="#635-消息的生产者"></a> 6.3.5. 消息的生产者</h4><p>消息生产者由 Session 创建，并用于将消息发送到 Destination。同样，消息生产者分两种类型：QueueSender 和 TopicPublisher。可以调用消息生产者的方法（send 或 publish 方法）发送消息。</p><h4 id="636-消息消费者"><a class="markdownIt-Anchor" href="#636-消息消费者"></a> 6.3.6. 消息消费者</h4><p>消息消费者由 Session 创建，用于接收被发送到 Destination 的消息。两种类型：QueueReceiver 和 TopicSubscriber。可分别通过 session 的 createReceiver(Queue)或 createSubscriber(Topic)来创建。当然，也可以 session 的 creatDurableSubscriber 方法来创建持久化的订阅者。</p><h4 id="637-messagelistener"><a class="markdownIt-Anchor" href="#637-messagelistener"></a> 6.3.7. MessageListener</h4><p>消息监听器。如果注册了消息监听器，一旦消息到达，将自动调用监听器的 onMessage 方法。EJB 中的 MDB（Message-Driven Bean）就是一种 MessageListener。</p><p>深入学习 JMS 对掌握 JAVA 架构，EJB 架构有很好的帮助，消息中间件也是大型分布式系统必须的组件。本次分享主要做全局性介绍，具体的深入需要大家学习，实践，总结，领会。</p><h2 id="7-参考资料"><a class="markdownIt-Anchor" href="#7-参考资料"></a> 7. 参考资料</h2><ul><li><a href="https://www.cnblogs.com/itfly8/p/5155983.html" target="_blank" rel="noopener">大型网站架构系列：分布式 MQ（一）</a></li><li><a href="https://www.cnblogs.com/itfly8/p/5156155.html" target="_blank" rel="noopener">大型网站架构系列：MQ（二）</a></li><li><a href="https://www.jianshu.com/p/453c6e7ff81c" target="_blank" rel="noopener">分布式开放 MQ(RocketMQ)的原理与实践</a></li><li><a href="https://juejin.im/entry/5a0abfb5f265da43062a4a91" target="_blank" rel="noopener">阿里 RocketMQ 优势对比</a></li><li><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/mq-interview.md" target="_blank" rel="noopener">advanced-java 之 MQ</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;消息队列基本原理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#消息队列基本原理&quot;&gt;&lt;/a&gt; 消息队列基本原理&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;消息队列（Message Queue，简称 MQ）技术是分布式应用间交换信息的一种
      
    
    </summary>
    
    
      <category term="设计" scheme="https://dunwu.github.io/blog/categories/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="系统原理" scheme="https://dunwu.github.io/blog/categories/%E8%AE%BE%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="设计" scheme="https://dunwu.github.io/blog/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="系统原理" scheme="https://dunwu.github.io/blog/tags/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    
      <category term="消息队列" scheme="https://dunwu.github.io/blog/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>缓存基本原理</title>
    <link href="https://dunwu.github.io/blog/design/theory/cache-theory/"/>
    <id>https://dunwu.github.io/blog/design/theory/cache-theory/</id>
    <published>2019-06-27T07:36:00.000Z</published>
    <updated>2020-01-25T14:48:34.959Z</updated>
    
    <content type="html"><![CDATA[<h1 id="缓存基本原理"><a class="markdownIt-Anchor" href="#缓存基本原理"></a> 缓存基本原理</h1><!-- TOC depthFrom:2 depthTo:3 --><ul><li><a href="#1-%E7%BC%93%E5%AD%98%E6%A6%82%E8%BF%B0">1. 缓存概述</a><ul><li><a href="#11-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98">1.1. 什么是缓存</a></li><li><a href="#12-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%95%E5%85%A5%E7%BC%93%E5%AD%98">1.2. 为什么引入缓存</a></li><li><a href="#13-%E7%BC%93%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86">1.3. 缓存的基本原理</a></li><li><a href="#14-%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95">1.4. 缓存淘汰算法</a></li><li><a href="#15-%E7%BC%93%E5%AD%98%E7%9A%84%E5%88%86%E7%B1%BB">1.5. 缓存的分类</a></li><li><a href="#16-%E7%BC%93%E5%AD%98%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84">1.6. 缓存整体架构</a></li></ul></li><li><a href="#2-cdn-%E7%BC%93%E5%AD%98">2. CDN 缓存</a><ul><li><a href="#21-cdn-%E5%8E%9F%E7%90%86">2.1. CDN 原理</a></li><li><a href="#22-cdn-%E7%89%B9%E7%82%B9">2.2. CDN 特点</a></li></ul></li><li><a href="#3-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98">3. 反向代理缓存</a><ul><li><a href="#31-%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86">3.1. 缓存原理</a></li><li><a href="#32-%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98%E6%AF%94%E8%BE%83">3.2. 代理缓存比较</a></li></ul></li><li><a href="#4-%E8%BF%9B%E7%A8%8B%E5%86%85%E7%BC%93%E5%AD%98">4. 进程内缓存</a><ul><li><a href="#41-concurrenthashmap">4.1. ConcurrentHashMap</a></li><li><a href="#42-lruhashmap">4.2. LRUHashMap</a></li><li><a href="#43-guava-cache">4.3. Guava Cache</a></li><li><a href="#44-caffeine">4.4. Caffeine</a></li><li><a href="#45-%E9%80%89%E6%8B%A9%E8%BF%9B%E7%A8%8B%E5%86%85%E7%BC%93%E5%AD%98">4.5. 选择进程内缓存</a></li></ul></li><li><a href="#5-%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98">5. 分布式缓存</a><ul><li><a href="#51-memcache">5.1. Memcache</a></li><li><a href="#52-redis">5.2. Redis</a></li><li><a href="#53-%E9%80%89%E6%8B%A9%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98">5.3. 选择分布式缓存</a></li></ul></li><li><a href="#6-%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98">6. 多级缓存</a><ul><li><a href="#61-%E4%BD%BF%E7%94%A8%E8%BF%9B%E7%A8%8B%E5%86%85%E7%BC%93%E5%AD%98">6.1. 使用进程内缓存</a></li><li><a href="#62-%E4%BD%BF%E7%94%A8%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98">6.2. 使用分布式缓存</a></li><li><a href="#63-%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98">6.3. 使用多级缓存</a></li></ul></li><li><a href="#7-%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98">7. 缓存问题</a><ul><li><a href="#71-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9">7.1. 缓存雪崩</a></li><li><a href="#72-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F">7.2. 缓存穿透</a></li><li><a href="#73-%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF">7.3. 缓存击穿</a></li><li><a href="#74-%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0">7.4. 缓存更新</a></li><li><a href="#75-%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD">7.5. 缓存预热</a></li><li><a href="#76-%E7%BC%93%E5%AD%98%E9%99%8D%E7%BA%A7">7.6. 缓存降级</a></li></ul></li><li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li></ul><!-- /TOC --><h2 id="1-缓存概述"><a class="markdownIt-Anchor" href="#1-缓存概述"></a> 1. 缓存概述</h2><h3 id="11-什么是缓存"><a class="markdownIt-Anchor" href="#11-什么是缓存"></a> 1.1. 什么是缓存</h3><p><strong>缓存就是数据交换的缓冲区</strong>。</p><p>缓存是用于存储数据的硬件或软件的组成部分，以使得后续更快访问相应的数据。缓存中的数据可能是提前计算好的结果、数据的副本等。典型的应用场景：有 cpu cache, 磁盘 cache 等。本文中提及到缓存主要是指互联网应用中所使用的缓存组件。</p><h3 id="12-为什么引入缓存"><a class="markdownIt-Anchor" href="#12-为什么引入缓存"></a> 1.2. 为什么引入缓存</h3><p>传统的后端业务场景中，访问量以及对响应时间的要求均不高，通常只使用数据库即可满足要求。这种架构简单，便于快速部署，很多网站发展初期均考虑使用这种架构。但是随着访问量的上升，以及对响应时间的要求提升，一个数据库服务已无法再满足要求。这时候通常会考虑数据库拆分(sharding)、读写分离、甚至硬件升级(SSD)等以满足新的业务需求。但是这种方式仍然会面临很多问题，主要体现在：</p><ul><li>性能提升有限，很难达到数量级上的提升，尤其在互联网业务场景下，随着网站的发展，访问量经常会面临十倍、百倍的上涨。</li><li>成本高昂，为了承载 N 倍的访问量，通常需要 N 倍的机器，这个代价难以接受。</li></ul><p>在数据层引入缓存，有以下几个好处：</p><ul><li>提升数据读取速度。</li><li>提升系统扩展能力，通过扩展缓存，提升系统承载能力。</li><li>降低存储成本，Cache+DB 的方式可以承担原有需要多台 DB 才能承担的请求量，节省机器成本。</li></ul><p>根据业务场景，通常缓存有以下几种使用方式：</p><ul><li>懒汉式(读时触发)：写入 DB 后, 然后把相关的数据也写入 Cache。</li><li>饥饿式(写时触发)：先查询 DB 里的数据, 然后把相关的数据写入 Cache。</li><li>定期刷新：适合周期性的跑数据的任务，或者列表型的数据，而且不要求绝对实时性。</li></ul><h3 id="13-缓存的基本原理"><a class="markdownIt-Anchor" href="#13-缓存的基本原理"></a> 1.3. 缓存的基本原理</h3><ol><li>将数据写入/读取速度更快的存储（设备）；</li><li>将数据缓存到离应用最近的位置；</li><li>将数据缓存到离用户最近的位置。</li></ol><h3 id="14-缓存淘汰算法"><a class="markdownIt-Anchor" href="#14-缓存淘汰算法"></a> 1.4. 缓存淘汰算法</h3><p>常见的缓存淘汰算法有以下几种：</p><ul><li><strong>FIFO</strong> - 先进先出，在这种淘汰算法中，先进入缓存的会先被淘汰。这种可谓是最简单的了，但是会导致我们命中率很低。试想一下我们如果有个访问频率很高的数据是所有数据第一个访问的，而那些不是很高的是后面再访问的，那这样就会把我们的首个数据但是他的访问频率很高给挤出。</li><li><strong>LRU</strong> - 最近最少使用算法。在这种算法中避免了上面的问题，每次访问数据都会将其放在我们的队尾，如果需要淘汰数据，就只需要淘汰队首即可。但是这个依然有个问题，如果有个数据在 1 个小时的前 59 分钟访问了 1 万次(可见这是个热点数据),再后一分钟没有访问这个数据，但是有其他的数据访问，就导致了我们这个热点数据被淘汰。</li><li><strong>LFU</strong> - 最近最少频率使用。在这种算法中又对上面进行了优化，利用额外的空间记录每个数据的使用频率，然后选出频率最低进行淘汰。这样就避免了 LRU 不能处理时间段的问题。</li></ul><p>这三种缓存淘汰算法，实现复杂度一个比一个高，同样的命中率也是一个比一个好。而我们一般来说选择的方案居中即可，即实现成本不是太高，而命中率也还行的 LRU。</p><h3 id="15-缓存的分类"><a class="markdownIt-Anchor" href="#15-缓存的分类"></a> 1.5. 缓存的分类</h3><p>在分布式系统中，缓存的应用非常广泛，从部署角度有以下几个方面的缓存应用。</p><ul><li><strong>CDN 缓存</strong> - 存放 HTML、CSS、JS 等静态资源。</li><li><strong>反向代理缓存</strong> - 动静分离，只缓存用户请求的静态资源。</li><li><strong>进程内缓存</strong> - 缓存应用字典等常用数据。</li><li><strong>分布式缓存</strong> - 缓存数据库中的热点数据。</li></ul><h3 id="16-缓存整体架构"><a class="markdownIt-Anchor" href="#16-缓存整体架构"></a> 1.6. 缓存整体架构</h3><p>通常，网站的缓存整体架构如下图所示：</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/java/javaweb/technology/cache/缓存整体架构.png!zp" /></div>请求过程：<ol><li>浏览器向客户端发起请求，如果 CDN 有缓存则直接返回；</li><li>如果 CDN 无缓存，则访问反向代理服务器；</li><li>如果反向代理服务器有缓存则直接返回；</li><li>如果反向代理服务器无缓存或动态请求，则访问应用服务器；</li><li>应用服务器访问进程内缓存；如果有缓存，则返回代理服务器，并缓存数据；（动态请求不缓存）</li><li>如果进程内缓存无数据，则读取分布式缓存；并返回应用服务器；应用服务器将数据缓存到本地缓存（部分）；</li><li>如果分布式缓存无数据，则应用程序读取数据库数据，并放入分布式缓存；</li></ol><h2 id="2-cdn-缓存"><a class="markdownIt-Anchor" href="#2-cdn-缓存"></a> 2. CDN 缓存</h2><blockquote><p><strong>CDN 将数据缓存到离用户物理距离最近的服务器，使得用户可以就近获取请求内容。CDN 一般缓存静态资源文件（页面，脚本，图片，视频，文件等）</strong>。</p><p>国内网络异常复杂，跨运营商的网络访问会很慢。为了解决跨运营商或各地用户访问问题，可以在重要的城市，部署 CDN 应用。使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。</p></blockquote><div align="center"><img src="http://dunwu.test.upcdn.net/snap/1559138689425.png!zp"/></div>### 2.1. CDN 原理<p>CDN 的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。</p><p>（1）未部署 CDN 应用前的网络路径：</p><ul><li>请求：本机网络（局域网）=&gt; 运营商网络 =&gt; 应用服务器机房</li><li>响应：应用服务器机房 =&gt; 运营商网络 =&gt; 本机网络（局域网）</li></ul><p>在不考虑复杂网络的情况下，从请求到响应需要经过 3 个节点，6 个步骤完成一次用户访问操作。</p><p>（2）部署 CDN 应用后网络路径：</p><ul><li>请求：本机网络（局域网） =&gt; 运营商网络</li><li>响应：运营商网络 =&gt; 本机网络（局域网）</li></ul><p>在不考虑复杂网络的情况下，从请求到响应需要经过 2 个节点，2 个步骤完成一次用户访问操作。</p><p>与不部署 CDN 服务相比，减少了 1 个节点，4 个步骤的访问。极大的提高的系统的响应速度。</p><h3 id="22-cdn-特点"><a class="markdownIt-Anchor" href="#22-cdn-特点"></a> 2.2. CDN 特点</h3><ul><li><strong>优点</strong><ul><li><strong>本地 Cache 加速</strong> - 提升访问速度，尤其含有大量图片和静态页面站点；</li><li><strong>镜像服务</strong> - 消除了不同运营商之间互联的瓶颈造成的影响，实现了跨运营商的网络加速，保证不同网络中的用户都能得到良好的访问质量；</li><li><strong>远程加速</strong> - 远程访问用户根据 DNS 负载均衡技术智能自动选择 Cache 服务器，选择最快的 Cache 服务器，加快远程访问的速度；</li><li><strong>带宽优化</strong> - 自动生成服务器的远程 Mirror（镜像）cache 服务器，远程用户访问时从 cache 服务器上读取数据，减少远程访问的带宽、分担网络流量、减轻原站点 WEB 服务器负载等功能。</li><li><strong>集群抗攻击</strong> - 广泛分布的 CDN 节点加上节点之间的智能冗余机制，可以有效地预防黑客入侵以及降低各种 D.D.o.S 攻击对网站的影响，同时保证较好的服务质量。</li></ul></li><li><strong>缺点</strong><ul><li><strong>不适宜缓存动态资源</strong><ul><li>解决方案：主要缓存静态资源，动态资源建立多级缓存或准实时同步；</li></ul></li><li><strong>存在数据的一致性问题</strong><ul><li>解决方案（主要是在性能和数据一致性二者间寻找一个平衡）<ul><li>设置缓存失效时间（1 个小时，过期后同步数据）。</li><li>针对资源设置版本号。</li></ul></li></ul></li></ul></li></ul><h2 id="3-反向代理缓存"><a class="markdownIt-Anchor" href="#3-反向代理缓存"></a> 3. 反向代理缓存</h2><blockquote><p><strong>反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</strong></p></blockquote><div align="center"><img src="http://dunwu.test.upcdn.net/cs/web/nginx/reverse-proxy.png!zp"/></div>### 3.1. 缓存原理<p>反向代理位于应用服务器同一网络，处理所有对 WEB 服务器的请求。</p><p>反向代理缓存的原理：</p><ul><li>如果用户请求的页面在代理服务器上有缓存的话，代理服务器直接将缓存内容发送给用户。</li><li>如果没有缓存则先向 WEB 服务器发出请求，取回数据，本地缓存后再发送给用户。</li></ul><p>这种方式通过降低向 WEB 服务器的请求数，从而降低了 WEB 服务器的负载。</p><p><strong>反向代理缓存一般针对的是静态资源，而将动态资源请求转发到应用服务器处理</strong>。常用的缓存应用服务器有 Varnish，Ngnix，Squid。</p><h3 id="32-代理缓存比较"><a class="markdownIt-Anchor" href="#32-代理缓存比较"></a> 3.2. 代理缓存比较</h3><p>常用的代理缓存有 Varnish，Squid，Ngnix，简单比较如下：</p><ul><li>Varnish 和 Squid 是专业的 cache 服务，Ngnix 需要第三方模块支持；</li><li>Varnish 采用内存型缓存，避免了频繁在内存、磁盘中交换文件，性能比 Squid 高；</li><li>Varnish 由于是内存 cache，所以对小文件如 css、js、小图片的支持很棒，后端的持久化缓存可以采用的是 Squid 或 ATS；</li><li>Squid 功能全而大，适合于各种静态的文件缓存，一般会在前端挂一个 HAProxy 或 Ngnix 做负载均衡跑多个实例；</li><li>Nginx 采用第三方模块 ncache 做的缓冲，性能基本达到 Varnish，一般作为反向代理使用，可以实现简单的缓存。</li></ul><h2 id="4-进程内缓存"><a class="markdownIt-Anchor" href="#4-进程内缓存"></a> 4. 进程内缓存</h2><blockquote><p>进程内缓存是指应用内部的缓存，标准的分布式系统，一般有多级缓存构成。本地缓存是离应用最近的缓存，一般可以将数据缓存到硬盘或内存。</p></blockquote><ul><li><code>硬盘缓存</code> - 将数据缓存到硬盘到，读取时从硬盘读取。原理是直接读取本机文件，减少了网络传输消耗，比通过网络读取数据库速度更快。可以应用在对速度要求不是很高，但需要大量缓存存储的场景。</li><li><code>内存缓存</code> - 直接将数据存储到本机内存中，通过程序直接维护缓存对象，是访问速度最快的方式。</li></ul><p>常见的本地缓存实现方案：HashMap、Guava Cache、Caffeine、Ehcache。</p><h3 id="41-concurrenthashmap"><a class="markdownIt-Anchor" href="#41-concurrenthashmap"></a> 4.1. ConcurrentHashMap</h3><p>最简单的进程内缓存可以通过 JDK 自带的 <code>HashMap</code> 或 <code>ConcurrentHashMap</code> 实现。</p><p>适用场景：不需要淘汰的缓存数据。</p><p>缺点：无法进行缓存淘汰，内存会无限制的增长。</p><h3 id="42-lruhashmap"><a class="markdownIt-Anchor" href="#42-lruhashmap"></a> 4.2. LRUHashMap</h3><p>可以通过继承 <code>LinkedHashMap</code> 来实现一个简单的 <code>LRUHashMap</code>。重写 <code>removeEldestEntry</code> 方法，即可完成一个简单的最近最少使用算法。</p><ul><li>缺点：<ul><li>锁竞争严重，性能比较低。</li><li>不支持过期时间</li><li>不支持自动刷新</li></ul></li></ul><h3 id="43-guava-cache"><a class="markdownIt-Anchor" href="#43-guava-cache"></a> 4.3. Guava Cache</h3><p>解决了 <code>LRUHashMap</code> 中的几个缺点。</p><p>Guava Cache 采用了类似 <code>ConcurrentHashMap</code> 的思想，分段加锁，减少锁竞争。</p><p>Guava Cache 对于过期的 Entry 并没有马上过期(也就是并没有后台线程一直在扫)，而是通过进行读写操作的时候进行过期处理，这样做的好处是避免后台线程扫描的时候进行全局加锁。</p><p>直接通过查询，判断其是否满足刷新条件，进行刷新。</p><h3 id="44-caffeine"><a class="markdownIt-Anchor" href="#44-caffeine"></a> 4.4. Caffeine</h3><p>Caffeine 实现了 W-TinyLFU(LFU+LRU 算法的变种)，其命中率和读写吞吐量大大优于 Guava Cache。</p><p>其实现原理较复杂，可以参考<a href="https://juejin.im/post/5b7593496fb9a009b62904fa#comment" target="_blank" rel="noopener">你应该知道的缓存进化史</a>。</p><h3 id="45-选择进程内缓存"><a class="markdownIt-Anchor" href="#45-选择进程内缓存"></a> 4.5. 选择进程内缓存</h3><table><thead><tr><th>比较项</th><th>ConcurrentHashMap</th><th>LRUMap</th><th>Ehcache</th><th>Guava Cache</th><th>Caffeine</th></tr></thead><tbody><tr><td>读写性能</td><td>很好，分段锁</td><td>一般，全局加锁</td><td>好</td><td>好，需要做淘汰操作</td><td>很好</td></tr><tr><td>淘汰算法</td><td>无</td><td>LRU，一般</td><td>支持多种淘汰算法,LRU,LFU,FIFO</td><td>LRU，一般</td><td>W-TinyLFU, 很好</td></tr><tr><td>功能丰富程度</td><td>功能比较简单</td><td>功能比较单一</td><td>功能很丰富</td><td>功能很丰富，支持刷新和虚引用等</td><td>功能和 Guava Cache 类似</td></tr><tr><td>工具大小</td><td>jdk 自带类，很小</td><td>基于 LinkedHashMap，较小</td><td>很大，最新版本 1.4MB</td><td>是 Guava 工具类中的一个小部分，较小</td><td>一般，最新版本 644KB</td></tr><tr><td>是否持久化</td><td>否</td><td>否</td><td>是</td><td>否</td><td>否</td></tr><tr><td>是否支持集群</td><td>否</td><td>否</td><td>是</td><td>否</td><td>否</td></tr></tbody></table><ul><li><strong><code>ConcurrentHashMap</code></strong> - 比较适合缓存比较固定不变的元素，且缓存的数量较小的。虽然从上面表格中比起来有点逊色，但是其由于是 JDK 自带的类，在各种框架中依然有大量的使用，比如我们可以用来缓存我们反射的 Method，Field 等等；也可以缓存一些链接，防止其重复建立。在 Caffeine 中也是使用的 <code>ConcurrentHashMap</code> 来存储元素。</li><li><strong><code>LRUMap</code></strong> - 如果不想引入第三方包，又想使用淘汰算法淘汰数据，可以使用这个。</li><li><strong><code>Ehcache</code></strong> - 由于其 jar 包很大，较重量级。对于需要持久化和集群的一些功能的，可以选择 Ehcache。笔者没怎么使用过这个缓存，如果要选择的话，可以选择分布式缓存来替代 Ehcache。</li><li><strong><code>Guava Cache</code></strong> - Guava 这个 jar 包在很多 Java 应用程序中都有大量的引入，所以很多时候其实是直接用就好了，并且其本身是轻量级的而且功能较为丰富，在不了解 Caffeine 的情况下可以选择 Guava Cache。</li><li><strong><code>Caffeine</code></strong> - 其在命中率，读写性能上都比 Guava Cache 好很多，并且其 API 和 Guava cache 基本一致，甚至会多一点。在真实环境中使用 Caffeine，取得过不错的效果。</li></ul><p>总结一下：如果不需要淘汰算法则选择 <code>ConcurrentHashMap</code>，如果需要淘汰算法和一些丰富的 API，推荐选择 Caffeine。</p><h2 id="5-分布式缓存"><a class="markdownIt-Anchor" href="#5-分布式缓存"></a> 5. 分布式缓存</h2><blockquote><p><strong>分布式缓存解决了进程内缓存最大的问题：如果应用是分布式系统，节点之间无法共享彼此的进程内缓存</strong>。</p><p>分布式缓存的应用场景：</p><ul><li>缓存经过复杂计算得到的数据</li><li>缓存系统中频繁访问的热点数据，减轻数据库压力</li></ul></blockquote><p>不同分布式缓存的实现原理往往有比较大的差异。本文主要针对 Memcached 和 Redis 进行说明。</p><h3 id="51-memcache"><a class="markdownIt-Anchor" href="#51-memcache"></a> 5.1. Memcache</h3><blockquote><p><a href="https://memcached.org/" target="_blank" rel="noopener">Memcache</a> 是一个高性能，分布式内存对象缓存系统，通过在内存里维护一个统一的巨大的 hash 表，它能够用来存储各种格式的数据，包括图像、视频、文件以及数据库检索的结果等。</p><p>简单的说就是：将数据缓存到内存中，然后从内存中读取，从而大大提高读取速度。</p></blockquote><h4 id="memcache-特性"><a class="markdownIt-Anchor" href="#memcache-特性"></a> Memcache 特性</h4><ul><li><strong>使用物理内存作为缓存区，可独立运行在服务器上</strong>。每个进程最大 2G，如果想缓存更多的数据，可以开辟更多的 Memcache 进程（不同端口）或者使用分布式 Memcache 进行缓存，将数据缓存到不同的物理机或者虚拟机上。</li><li><strong>使用 key-value 的方式来存储数据</strong>。这是一种单索引的结构化数据组织形式，可使数据项查询时间复杂度为 O(1)。</li><li><strong>协议简单，基于文本行的协议</strong>。直接通过 telnet 在 Memcached 服务器上可进行存取数据操作，简单，方便多种缓存参考此协议；</li><li><strong>基于 libevent 高性能通信</strong>。Libevent 是一套利用 C 开发的程序库，它将 BSD 系统的 kqueue,Linux 系统的 epoll 等事件处理功能封装成一个接口，与传统的 select 相比，提高了性能。</li><li><strong>分布式能力取决于 Memcache 客户端，服务器之间互不通信</strong>。各个 Memcached 服务器之间互不通信，各自独立存取数据，不共享任何信息。服务器并不具有分布式功能，分布式部署取决于 Memcached 客户端。</li><li><strong>采用 LRU 缓存淘汰策略</strong>。在 Memcached 内存储数据项时，可以指定它在缓存的失效时间，默认为永久。当 Memcached 服务器用完分配的内时，失效的数据被首先替换，然后也是最近未使用的数据。在 LRU 中，Memcached 使用的是一种 Lazy Expiration 策略，自己不会监控存入的 key/vlue 对是否过期，而是在获取 key 值时查看记录的时间戳，检查 key/value 对空间是否过期，这样可减轻服务器的负载。</li><li><strong>内置了一套高效的内存管理算法</strong>。这套内存管理效率很高，而且不会造成内存碎片，但是它最大的缺点就是会导致空间浪费。当内存满后，通过 LRU 算法自动删除不使用的缓存。</li><li><strong>不支持持久化</strong>。Memcached 没有考虑数据的容灾问题，重启服务，所有数据会丢失。</li></ul><h4 id="memcache-工作原理"><a class="markdownIt-Anchor" href="#memcache-工作原理"></a> Memcache 工作原理</h4><p>（1）内存管理</p><p>Memcached 利用 <strong>slab allocation</strong> 机制来分配和管理内存，它按照预先规定的大小，将分配的内存分割成特定长度的内存块，再把尺寸相同的内存块分成组，数据在存放时，根据键值 大小去匹配 slab 大小，找就近的 slab 存放，所以存在空间浪费现象。</p><p>这套内存管理效率很高，而且不会造成内存碎片，但是它最大的缺点就是会导致空间浪费。</p><p>（2）缓存淘汰策略</p><p>Memcached 的缓存淘汰策略是 <strong>LRU</strong> + 到期失效策略。</p><p>当你在 Memcached 内存储数据项时，你有可能会指定它在缓存的失效时间，默认为永久。当 Memcached 服务器用完分配的内时，失效的数据被首先替换，然后是最近未使用的数据。</p><p>在 LRU 中，Memcached 使用的是一种 Lazy Expiration 策略：<strong>Memcached 不会监控存入的 key/vlue 对是否过期</strong>，而是在获取 key 值时查看记录的时间戳，<strong>检查 key/value 对空间是否过期</strong>，这样可减轻服务器的负载。</p><p>（3）分区</p><p>Memcached 服务器之间彼此不通信，它的分布式能力是依赖客户端来实现。</p><p>具体来说，就是在客户端实现一种算法，根据 key 来计算出数据应该向哪个服务器节点读/写。</p><p>而这种选取集群节点的算法常见的有三种：</p><ul><li><strong>哈希取余算法</strong> - 使用公式：<code>hash（key）% N</code> 计算出 <strong>哈希值</strong> 来决定数据映射到哪一个节点。</li><li><strong>一致性哈希算法</strong> - 可以很好的解决 <strong>稳定性问题</strong>，可以将所有的 <strong>存储节点</strong> 排列在 <strong>首尾相接</strong> 的 <code>Hash</code> 环上，每个 <code>key</code> 在计算 <code>Hash</code> 后会 <strong>顺时针</strong> 找到 <strong>临接</strong> 的 <strong>存储节点</strong> 存放。而当有节点 <strong>加入</strong> 或 <strong>退出</strong> 时，仅影响该节点在 <code>Hash</code> 环上 <strong>顺时针相邻</strong> 的 <strong>后续节点</strong>。</li><li><strong>虚拟 Hash 槽算法</strong> - 使用 <strong>分散度良好</strong> 的 <strong>哈希函数</strong> 把所有数据 <strong>映射</strong> 到一个 <strong>固定范围</strong> 的 <strong>整数集合</strong> 中，整数定义为 <strong>槽</strong>（<code>slot</code>），这个范围一般 <strong>远远大于</strong> 节点数。<strong>槽</strong> 是集群内 <strong>数据管理</strong> 和 <strong>迁移</strong> 的 <strong>基本单位</strong>。采用 <strong>大范围槽</strong> 的主要目的是为了方便 <strong>数据拆分</strong> 和 <strong>集群扩展</strong>。每个节点会负责 <strong>一定数量的槽</strong>。</li></ul><h3 id="52-redis"><a class="markdownIt-Anchor" href="#52-redis"></a> 5.2. Redis</h3><blockquote><p>Redis 是一个开源（BSD 许可）的，基于内存的，多数据结构存储系统。可以用作数据库、缓存和消息中间件。</p><p>Redis 还可以使用客户端分片来扩展写性能。内置了 复制（replication），LUA 脚本（Lua scripting），LRU 驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis 哨兵（Sentinel）和自动分区（Cluster）提供高可用性（high availability）。</p></blockquote><h4 id="redis-特性"><a class="markdownIt-Anchor" href="#redis-特性"></a> Redis 特性</h4><ul><li><p>支持多种数据类型 - string、hash、list、set、sorted set。</p></li><li><p>支持多种数据淘汰策略</p><ul><li><strong>volatile-lru</strong> - 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</li><li><strong>volatile-ttl</strong> - 从已设置过期时间的数据集中挑选将要过期的数据淘汰</li><li><strong>volatile-random</strong> - 从已设置过期时间的数据集中任意选择数据淘汰</li><li><strong>allkeys-lru</strong> - 从所有数据集中挑选最近最少使用的数据淘汰</li><li><strong>allkeys-random</strong> - 从所有数据集中任意选择数据进行淘汰</li><li><strong>noeviction</strong> - 禁止驱逐数据</li></ul></li><li><p>提供两种持久化方式 - RDB 和 AOF</p></li><li><p>通过 Redis cluster 提供集群模式。</p></li></ul><h4 id="redis-原理"><a class="markdownIt-Anchor" href="#redis-原理"></a> Redis 原理</h4><ul><li>缓存淘汰<ul><li>Redis 有两种数据淘汰实现<ul><li>消极方式 - 访问 Redis key 时，如果发现它已经失效，则删除它</li><li>积极方式 - 周期性从设置了失效时间的 key 中，根据淘汰策略，选择一部分失效的 key 进行删除。</li></ul></li></ul></li><li>分区<ul><li>Redis Cluster 集群包含 16384 个虚拟 Hash 槽，它通过一个高效的算法来计算 key 属于哪个 Hash 槽。</li><li>Redis Cluster 支持请求分发 - 节点在接到一个命令请求时，会先检测这个命令请求要处理的键所在的槽是否由自己负责，如果不是的话，节点将向客户端返回一个 MOVED 错误，MOVED 错误携带的信息可以指引客户端将请求重定向至正在负责相关槽的节点。</li></ul></li><li>主从复制<ul><li>Redis 2.8 后支持异步复制。它有两种模式：<ul><li><code>完整重同步（full resychronization）</code> - 用于初次复制。执行步骤与 <code>SYNC</code> 命令基本一致。</li><li><code>部分重同步（partial resychronization）</code> - 用于断线后重复制。如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只需接收并执行这些写命令，即可将主从服务器的数据库状态保持一致。</li></ul></li><li>集群中每个节点都会定期向集群中的其他节点发送 PING 消息，以此来检测对方是否在线。</li><li>如果一个主节点被认为下线，则在其从节点中，根据 Raft 算法，选举出一个节点，升级为主节点。</li></ul></li><li>数据一致性<ul><li>Redis 不保证强一致性，因为这会使得集群性能大大降低。</li><li>Redis 是通过异步复制来实现最终一致性。</li></ul></li></ul><h3 id="53-选择分布式缓存"><a class="markdownIt-Anchor" href="#53-选择分布式缓存"></a> 5.3. 选择分布式缓存</h3><p>不同的分布式缓存功能特性和实现原理方面有很大的差异，因此他们所适应的场景也有所不同。</p><p>这里选取三个比较出名的分布式缓存（MemCache，Redis，Tair）来作为比较：</p><table><thead><tr><th>比较项</th><th>MemCache</th><th>Redis</th><th>Tair</th></tr></thead><tbody><tr><td>数据结构</td><td>只支持简单的 Key-Value 结构</td><td>String,Hash, List, Set, Sorted Set</td><td>String,HashMap, List，Set</td></tr><tr><td>持久化</td><td>不支持</td><td>支持</td><td>支持</td></tr><tr><td>容量大小</td><td>数据纯内存，数据存储不宜过多</td><td>数据全内存，资源成本考量不宜超过 100GB</td><td>可以配置全内存或内存+磁盘引擎，数据容量可无限扩充</td></tr><tr><td>读写性能</td><td>很高</td><td>很高(RT0.5ms 左右)</td><td>String 类型比较高(RT1ms 左右)，复杂类型比较慢(RT5ms 左右)</td></tr><tr><td>过期策略</td><td>过期后，不删除缓存</td><td>有六种策略来处理过期数据</td><td>支持</td></tr></tbody></table><ul><li><code>MemCache</code> - 这一块接触得比较少，不做过多的推荐。其吞吐量较大，但是支持的数据结构较少，并且不支持持久化。</li><li><code>Redis</code> - 支持丰富的数据结构，读写性能很高，但是数据全内存，必须要考虑资源成本，支持持久化。</li><li><code>Tair</code> - 支持丰富的数据结构，读写性能较高，部分类型比较慢，理论上容量可以无限扩充。</li></ul><p>总结：如果服务对延迟比较敏感，Map/Set 数据也比较多的话，比较适合 Redis。如果服务需要放入缓存量的数据很大，对延迟又不是特别敏感的话，那就可以选择 Tair。</p><h2 id="6-多级缓存"><a class="markdownIt-Anchor" href="#6-多级缓存"></a> 6. 多级缓存</h2><h3 id="61-使用进程内缓存"><a class="markdownIt-Anchor" href="#61-使用进程内缓存"></a> 6.1. 使用进程内缓存</h3><p>如果应用服务不是分布式系统，那么进程内缓存当然是缓存的首选方案。</p><p>对于进程内缓存，其本来受限于内存的大小的限制，以及进程缓存更新后其他缓存无法得知，所以一般来说进程缓存适用于:</p><ol><li>数据量不是很大且更新频率较低的数据。</li><li>如果更新频繁的数据，也想使用进程内缓存，那么可以将其过期时间设置为较短的时间，或者设置较短的自动刷新时间。</li></ol><p>这种方案存在以下问题：</p><ul><li>如果应用服务是分布式系统，应用节点之间无法共享缓存，存在数据不一致问题。</li><li>由于进程内缓存受限于内存大小的限制，所以缓存不能无限扩展。</li></ul><h3 id="62-使用分布式缓存"><a class="markdownIt-Anchor" href="#62-使用分布式缓存"></a> 6.2. 使用分布式缓存</h3><p>如果应用服务是分布式系统，那么最简单的缓存方案就是直接使用分布式缓存。</p><p>其应用场景如图所示：</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/java/javaweb/technology/cache/多级缓存1.png!zp" width="600px"/></div>Redis 用来存储热点数据，如果缓存不命中，则去查询数据库，并更新缓存。<p>这种方案存在以下问题：</p><ol><li>缓存服务如果挂了，这时应用只能访问数据库，容易造成缓存雪崩。</li><li>访问分布式缓存服务会有一定的 I/O 以及序列化反序列化的开销，虽然性能很高，但是其终究没有在内存中查询快。</li></ol><h3 id="63-使用多级缓存"><a class="markdownIt-Anchor" href="#63-使用多级缓存"></a> 6.3. 使用多级缓存</h3><p>单纯使用进程内缓存和分布式缓存都存在各自的不足。如果需要更高的性能以及更好的可用性，我们可以将缓存设计为多级结构。将最热的数据使用进程内缓存存储在内存中，进一步提升访问速度。</p><p>这个设计思路在计算机系统中也存在，比如 CPU 使用 L1、L2、L3 多级缓存，用来减少对内存的直接访问，从而加快访问速度。</p><p>一般来说，多级缓存架构使用二级缓存已可以满足大部分业务需求，过多的分级会增加系统的复杂度以及维护的成本。因此，多级缓存不是分级越多越好，需要根据实际情况进行权衡。</p><p>一个典型的二级缓存架构，可以使用进程内缓存（如： Caffeine/Google Guava/Ehcache/HashMap）作为一级缓存；使用分布式缓存（如：Redis/Memcached）作为二级缓存。</p><h4 id="多级缓存查询"><a class="markdownIt-Anchor" href="#多级缓存查询"></a> 多级缓存查询</h4><div align="center"><img src="http://dunwu.test.upcdn.net/cs/java/javaweb/technology/cache/多级缓存2.png!zp" width="600" /></div>多级缓存查询流程如下：<ol><li>首先，查询 L1 缓存，如果缓存命中，直接返回结果；如果没有命中，执行下一步。</li><li>接下来，查询 L2 缓存，如果缓存命中，直接返回结果并回填 L1 缓存；如果没有命中，执行下一步。</li><li>最后，查询数据库，返回结果并依次回填 L2 缓存、L1 缓存。</li></ol><h4 id="多级缓存更新"><a class="markdownIt-Anchor" href="#多级缓存更新"></a> 多级缓存更新</h4><p>对于 L1 缓存，如果有数据更新，只能删除并更新所在机器上的缓存，其他机器只能通过超时机制来刷新缓存。超时设定可以有两种策略:</p><ul><li>设置成写入后多少时间后过期</li><li>设置成写入后多少时间刷新</li></ul><p>对于 L1 缓存，如果有数据更新，其他机器立马可见。但是，也必须要设置超时时间，其时间应该比 L1 缓存的有效时间长。</p><p>为了解决进程内缓存不一致的问题，设计可以进一步优化:</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/java/javaweb/technology/cache/多级缓存3.png!zp" /></div>通过消息队列的发布、订阅机制，可以通知其他应用节点对进程内缓存进行更新。使用这种方案，即使消息队列服务挂了或不可靠，由于先执行了数据库更新，但进程内缓存过期，刷新缓存时，也能保证数据的最终一致性。<h2 id="7-缓存问题"><a class="markdownIt-Anchor" href="#7-缓存问题"></a> 7. 缓存问题</h2><h3 id="71-缓存雪崩"><a class="markdownIt-Anchor" href="#71-缓存雪崩"></a> 7.1. 缓存雪崩</h3><blockquote><p><strong>缓存雪崩是指缓存不可用或者大量缓存由于超时时间相同在同一时间段失效，大量请求直接访问数据库，数据库压力过大导致系统雪崩</strong>。</p></blockquote><p>解决方案：</p><ul><li>增加缓存系统可用性。通过监控关注缓存的健康程度，根据业务量适当的扩容缓存。</li><li>采用多级缓存。不同级别缓存设置的超时时间不同，即使某个级别缓存都过期，也有其他级别缓存兜底。</li><li>缓存的过期时间可以取个随机值。比如以前是设置 10 分钟的超时时间，那每个 Key 都可以随机 8-13 分钟过期，尽量让不同 Key 的过期时间不同。</li><li>对数据库进行过载保护或应用层限流。</li></ul><h3 id="72-缓存穿透"><a class="markdownIt-Anchor" href="#72-缓存穿透"></a> 7.2. 缓存穿透</h3><blockquote><p><strong>缓存穿透是指：查询的数据在数据库中不存在，那么缓存中自然也不存在。所以，应用在缓存中查不到，则会去查询数据库。当这样的请求多了后，数据库的压力就会增大。</strong></p></blockquote><p>解决缓存穿透，一般有两种方法：</p><ul><li><strong>对于返回为 NULL 的依然缓存，对于抛出异常的返回不进行缓存</strong>。</li></ul><div align="center"><img src="http://dunwu.test.upcdn.net/cs/java/javaweb/technology/cache/缓存穿透1.png!zp" width="350px"/></div>采用这种手段的会增加我们缓存的维护成本，需要在插入缓存的时候删除这个空缓存，当然我们可以通过设置较短的超时时间来解决这个问题。<ul><li><strong>过滤不可能存在的数据</strong></li></ul><div align="center"><img src="http://dunwu.test.upcdn.net/cs/java/javaweb/technology/cache/缓存穿透2.png!zp" width="350px"/></div>**制定一些规则过滤一些不可能存在的数据**。小数据用 BitMap，大数据可以用布隆过滤器，比如你的订单 ID 明显是在一个范围 1-1000，如果不是 1-1000 之内的数据那其实可以直接给过滤掉。<h3 id="73-缓存击穿"><a class="markdownIt-Anchor" href="#73-缓存击穿"></a> 7.3. 缓存击穿</h3><p>对于某些 key 设置了过期时间，但是其是热点数据，如果某个 key 失效，可能大量的请求打过来，缓存未命中，然后去数据库访问，此时数据库访问量会急剧增加。</p><p>为了避免这个问题，我们可以采取下面的两个手段:</p><ul><li><strong>分布式锁</strong> - 锁住热点数据的 key，避免大量线程同时访问同一个 key。</li><li><strong>异步加载</strong> - 可以对部分数据采取到期自动刷新的策略，而不是到期自动淘汰。淘汰其实也是为了数据的时效性，所以采用自动刷新也可以。</li></ul><h3 id="74-缓存更新"><a class="markdownIt-Anchor" href="#74-缓存更新"></a> 7.4. 缓存更新</h3><p>一般来说缓存的更新有两种情况:</p><ul><li>先删除缓存，再更新数据库。</li><li>先更新数据库，再删除缓存。</li></ul><blockquote><p><strong>为什么是删除缓存，而不是更新缓存呢？</strong></p><p>你可以想想当有多个并发的请求更新数据，你并不能保证更新数据库的顺序和更新缓存的顺序一致，那就会出现数据库中和缓存中数据不一致的情况。所以一般来说考虑删除缓存。</p></blockquote><ul><li><strong>先删除缓存，再更新数据库</strong></li></ul><p>对于一个更新操作简单来说，就是先去各级缓存进行删除，然后更新数据库。</p><p>这个操作有一个比较大的问题，在对缓存删除完之后，有一个读请求，这个时候由于缓存被删除所以直接会读库，读操作的数据是老的并且会被加载进入缓存当中，后续读请求全部访问的老数据。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/java/javaweb/technology/cache/缓存更新.png!zp" width="400px"/></div>对缓存的操作不论成功失败都不能阻塞我们对数据库的操作，那么很多时候删除缓存可以用异步的操作，但是先删除缓存不能很好的适用于这个场景。<p>先删除缓存也有一个好处是，如果对数据库操作失败了，那么由于先删除的缓存，最多只是造成 Cache Miss。</p><ul><li><strong>先更新数据库，再删除缓存</strong></li></ul><blockquote><p>注：更推荐使用这种策略</p></blockquote><p>如果我们使用更新数据库，再删除缓存就能避免上面的问题。</p><p>但是同样的引入了新的问题：假设执行更新操作时，又接收到查询请求，此时就会返回缓存中的老数据。更麻烦的是，如果数据库更新操作执行失败，则缓存中可能永远是脏数据。</p><ul><li>应该选择哪种更新测录</li></ul><p>通过上面的内容，我们知道，两种更新策略都存在并发问题。</p><p>但是建议选择先更新数据库，再删除缓存，因为其并发问题出现的概率可能非常低，因为这个条件需要发生在读缓存时缓存失效，而且并发着有一个写操作。而实际上数据库的写操作会比读操作慢得多，而且还要锁表，而读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存，所有的这些条件都具备的概率基本并不大。</p><p>如果需要数据库和缓存保证强一致性，则可以通过 2PC 或 Paxos 协议来实现。但是 2PC 太慢，而 Paxos 太复杂，所以如果不是非常重要的数据，不建议使用强一致性方案。</p><h3 id="75-缓存预热"><a class="markdownIt-Anchor" href="#75-缓存预热"></a> 7.5. 缓存预热</h3><p>缓存预热是指系统启动后，将常用的数据直接缓存。这样就可以避免用户请求的时候，先查询数据库，然后再更新缓存的问题。</p><p>解决方案：</p><ul><li>直接写个缓存刷新页面，上线时手工操作下。</li><li>数据量不大，可以在项目启动的时候自动进行加载。</li><li>定时刷新缓存。</li></ul><h3 id="76-缓存降级"><a class="markdownIt-Anchor" href="#76-缓存降级"></a> 7.6. 缓存降级</h3><p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</p><p>降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。</p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ul><li>《大型网站技术架构》</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fjuejin.im%2Fpost%2F5b7593496fb9a009b62904fa">你应该知道的缓存进化史</a></li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fjuejin.im%2Fpost%2F5b849878e51d4538c77a974a">如何优雅的设计和使用缓存？</a></li><li><a href="https://www.jianshu.com/p/73ce0ef820f9" target="_blank" rel="noopener">理解分布式系统中的缓存架构(上)</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;缓存基本原理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#缓存基本原理&quot;&gt;&lt;/a&gt; 缓存基本原理&lt;/h1&gt;
&lt;!-- TOC depthFrom:2 depthTo:3 --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-%E7%BC%
      
    
    </summary>
    
    
      <category term="设计" scheme="https://dunwu.github.io/blog/categories/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="系统原理" scheme="https://dunwu.github.io/blog/categories/%E8%AE%BE%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="设计" scheme="https://dunwu.github.io/blog/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="系统原理" scheme="https://dunwu.github.io/blog/tags/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    
      <category term="缓存" scheme="https://dunwu.github.io/blog/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务基本原理</title>
    <link href="https://dunwu.github.io/blog/design/theory/distributed-transaction-theory/"/>
    <id>https://dunwu.github.io/blog/design/theory/distributed-transaction-theory/</id>
    <published>2019-06-21T03:30:00.000Z</published>
    <updated>2020-01-25T15:30:02.724Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式事务基本原理"><a class="markdownIt-Anchor" href="#分布式事务基本原理"></a> 分布式事务基本原理</h1><blockquote><p><strong>分布式事务指的是事务操作跨越多个节点，并且要求满足事务的 ACID 特性。</strong></p></blockquote><p>分布式事务的实现主要有以下 5 种方案：</p><ul><li>XA 方案</li><li>TCC 方案</li><li>本地消息表</li><li>可靠消息最终一致性方案</li><li>最大努力通知方案</li></ul><h2 id="1-两阶段提交"><a class="markdownIt-Anchor" href="#1-两阶段提交"></a> 1. 两阶段提交</h2><blockquote><p>两阶段提交（Two-phase Commit，2PC）通过引入协调者（Coordinator）来调度参与者的行为，并最终决定这些参与者是否要真正执行事务。</p><p>参考实现：<a href="https://github.com/changmingxie/tcc-transaction" target="_blank" rel="noopener">https://github.com/changmingxie/tcc-transaction</a></p></blockquote><h3 id="11-运行过程"><a class="markdownIt-Anchor" href="#11-运行过程"></a> 1.1. 运行过程</h3><h4 id="111-准备阶段"><a class="markdownIt-Anchor" href="#111-准备阶段"></a> 1.1.1. 准备阶段</h4><p>协调者询问参与者事务是否执行成功，参与者发回事务执行结果。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/architecture/分布式事务两阶段提交-01.jpg!zp" /></div><h4 id="112-提交阶段"><a class="markdownIt-Anchor" href="#112-提交阶段"></a> 1.1.2. 提交阶段</h4><p>如果事务在每个参与者上都执行成功，事务协调者发送通知让参与者提交事务；否则，协调者发送通知让参与者回滚事务。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/architecture/分布式事务两阶段提交-02.jpg!zp" /></div><p>需要注意的是，在准备阶段，参与者执行了事务，但是还未提交。只有在提交阶段接收到协调者发来的通知后，才进行提交或者回滚。</p><h3 id="12-问题"><a class="markdownIt-Anchor" href="#12-问题"></a> 1.2. 问题</h3><ul><li><strong>同步阻塞</strong> - 所有事务参与者在等待其它参与者响应的时候都处于同步阻塞状态，无法进行其它操作。</li><li><strong>单点问题</strong> - 协调者在 2PC 中起到非常大的作用，发生故障将会造成很大影响，特别是在阶段二发生故障，所有参与者会一直等待状态，无法完成其它操作。</li><li><strong>数据不一致</strong> - 在阶段二，如果协调者只发送了部分 Commit 消息，此时网络发生异常，那么只有部分参与者接收到 Commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。</li><li><strong>太过保守</strong> - 任意一个节点失败就会导致整个事务失败，没有完善的容错机制。</li></ul><h3 id="13-优缺点"><a class="markdownIt-Anchor" href="#13-优缺点"></a> 1.3. 优缺点</h3><ul><li>优点：尽量保证了数据的强一致，适合对数据强一致要求很高的关键领域。（其实也不能 100%保证强一致</li><li>缺点：实现复杂，牺牲了可用性，对性能影响较大，不适合高并发高性能场景。</li></ul><h2 id="2-补偿事务"><a class="markdownIt-Anchor" href="#2-补偿事务"></a> 2. 补偿事务</h2><blockquote><p>补偿事务（TCC），全称是：<code>Try</code>、<code>Confirm</code>、<code>Cancel</code>。</p><p>其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。它分为三个阶段：</p><p>TCC 的。</p><ul><li>Try 阶段：这个阶段说的是对各个服务的资源做检测以及对资源进行<strong>锁定或者预留</strong>。</li><li>Confirm 阶段：这个阶段说的是在各个服务中<strong>执行实际的操作</strong>。</li><li>Cancel 阶段：如果任何一个服务的业务方法执行出错，那么这里就需要<strong>进行补偿</strong>，就是执行已经执行成功的业务逻辑的回滚操作。（把那些执行成功的回滚）</li></ul></blockquote><p>举个例子，假设 Bob 要向 Smith 转账，思路大概是：</p><ol><li>首先在 Try 阶段，要先调用远程接口把 Smith 和 Bob 的钱给冻结起来。</li><li>在 Confirm 阶段，执行远程调用的转账的操作，转账成功进行解冻。</li><li>如果第 2 步执行成功，那么转账成功，如果第二步执行失败，则调用远程冻结接口对应的解冻方法 (Cancel)。</li></ol><p>优缺点：</p><ul><li>优点：跟 2PC 比起来，实现以及流程相对简单了一些，但数据的一致性比 2PC 也要差一些。</li><li>缺点：缺点还是比较明显的，在 2,3 步中都有可能失败。TCC 属于应用层的一种补偿方式，所以需要程序员在实现的时候多写很多补偿的代码，在一些场景中，一些业务流程可能用 TCC 不太好定义及处理。</li></ul><p>这种方案几乎很少人使用，因为<strong>事务回滚</strong>实际上是<strong>严重依赖于自己写代码来回滚和补偿</strong>了，会造成补偿代码巨大。</p><p>但是，也有特殊的使用场景：一般来说跟<strong>钱</strong>相关的，跟钱打交道的，<strong>支付</strong>、<strong>交易</strong>相关的场景，会用 TCC，严格保证分布式事务要么全部成功，要么全部自动回滚，严格保证资金的正确性，保证在资金上不会出现问题。</p><p>而且最好是你的各个业务执行的时间都比较短。</p><p>但是说实话，一般尽量别这么搞，自己手写回滚逻辑，或者是补偿逻辑，实在太恶心了，那个业务代码是很难维护的。</p><h2 id="3-本地消息表异步确保"><a class="markdownIt-Anchor" href="#3-本地消息表异步确保"></a> 3. 本地消息表（异步确保）</h2><blockquote><p>本地消息表与业务数据表处于同一个数据库中，这样就能利用本地事务来保证在对这两个表的操作满足事务特性。</p><ol><li>在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送一个消息，本地事务能保证这个消息一定会被写入本地消息表中。</li><li>之后将本地消息表中的消息转发到 Kafka 等消息队列（MQ）中，如果转发成功则将消息从本地消息表中删除，否则继续重新转发。</li><li>在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作。</li></ol></blockquote><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/architecture/分布式事务本地消息.jpg!zp" /></div><p>这种方案遵循 BASE 理论，采用的是最终一致性。</p><p>本地消息表利用了本地事务来实现分布式事务，并且使用了消息队列来保证最终一致性。</p><h3 id="31-优缺点"><a class="markdownIt-Anchor" href="#31-优缺点"></a> 3.1. 优缺点</h3><ul><li>优点：一种非常经典的实现，避免了分布式事务，实现了最终一致性。</li><li>缺点：消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。</li></ul><h2 id="4-mq-事务消息"><a class="markdownIt-Anchor" href="#4-mq-事务消息"></a> 4. MQ 事务消息</h2><p>有一些第三方的 MQ 是支持事务消息的，比如 RocketMQ，他们支持事务消息的方式也是类似于采用的二阶段提交。但是市面上一些主流的 MQ 都是不支持事务消息的，比如 RabbitMQ 和 Kafka 都不支持。</p><p>以阿里的 RocketMQ 中间件为例，其思路大致为：</p><ol><li>Prepared 消息，会拿到消息的地址。</li><li>执行本地事务。</li><li>通过第一阶段拿到的地址去访问消息，并修改状态。</li></ol><p>也就是说在业务方法内要想消息队列提交两次请求，一次发送消息和一次确认消息。如果确认消息发送失败了 RocketMQ 会定期扫描消息集群中的事务消息，这时候发现了 Prepared 消息，它会向消息发送者确认，所以生产方需要实现一个 check 接口，RocketMQ 会根据发送端设置的策略来决定是回滚还是继续发送确认消息。这样就保证了消息发送与本地事务同时成功或同时失败。</p><h3 id="41-优缺点"><a class="markdownIt-Anchor" href="#41-优缺点"></a> 4.1. 优缺点</h3><ul><li>优点：实现了最终一致性，不需要依赖本地数据库事务。</li><li>缺点：实现难度大，主流 MQ 不支持。</li></ul><h3 id="42-两阶段提交方案xa-方案"><a class="markdownIt-Anchor" href="#42-两阶段提交方案xa-方案"></a> 4.2. 两阶段提交方案/XA 方案</h3><p>所谓的 XA 方案，即：两阶段提交，有一个<strong>事务管理器</strong>的概念，负责协调多个数据库（资源管理器）的事务，事务管理器先问问各个数据库你准备好了吗？如果每个数据库都回复 ok，那么就正式提交事务，在各个数据库上执行操作；如果任何其中一个数据库回答不 ok，那么就回滚事务。</p><p>这种分布式事务方案，比较适合单块应用里，跨多个库的分布式事务，而且因为严重依赖于数据库层面来搞定复杂的事务，效率很低，绝对不适合高并发的场景。如果要玩儿，那么基于 <code>Spring + JTA</code> 就可以搞定，自己随便搜个 demo 看看就知道了。</p><p>这个方案，我们很少用，一般来说<strong>某个系统内部如果出现跨多个库</strong>的这么一个操作，是<strong>不合规</strong>的。我可以给大家介绍一下， 现在微服务，一个大的系统分成几十个甚至几百个服务。一般来说，我们的规定和规范，是要求<strong>每个服务只能操作自己对应的一个数据库</strong>。</p><p>如果你要操作别的服务对应的库，不允许直连别的服务的库，违反微服务架构的规范，你随便交叉胡乱访问，几百个服务的话，全体乱套，这样的一套服务是没法管理的，没法治理的，可能会出现数据被别人改错，自己的库被别人写挂等情况。</p><p>如果你要操作别人的服务的库，你必须是通过<strong>调用别的服务的接口</strong>来实现，绝对不允许交叉访问别人的数据库。</p><div align="center"><img src="https://github.com/doocs/advanced-java/blob/master/images/distributed-transaction-XA.png"/></div>### 4.3. 本地消息表<p>本地消息表其实是国外的 ebay 搞出来的这么一套思想。</p><p>这个大概意思是这样的：</p><ol><li>A 系统在自己本地一个事务里操作同时，插入一条数据到消息表；</li><li>接着 A 系统将这个消息发送到 MQ 中去；</li><li>B 系统接收到消息之后，在一个事务里，往自己本地消息表里插入一条数据，同时执行其他的业务操作，如果这个消息已经被处理过了，那么此时这个事务会回滚，这样<strong>保证不会重复处理消息</strong>；</li><li>B 系统执行成功之后，就会更新自己本地消息表的状态以及 A 系统消息表的状态；</li><li>如果 B 系统处理失败了，那么就不会更新消息表状态，那么此时 A 系统会定时扫描自己的消息表，如果有未处理的消息，会再次发送到 MQ 中去，让 B 再次处理；</li><li>这个方案保证了最终一致性，哪怕 B 事务失败了，但是 A 会不断重发消息，直到 B 那边成功为止。</li></ol><p>这个方案说实话最大的问题就在于<strong>严重依赖于数据库的消息表来管理事务</strong>啥的，如果是高并发场景咋办呢？咋扩展呢？所以一般确实很少用。</p><div align="center"><img src="https://github.com/doocs/advanced-java/blob/master/images/distributed-transaction-local-message-table.png"/></div>### 4.4. 可靠消息最终一致性方案<p>这个的意思，就是干脆不要用本地的消息表了，直接基于 MQ 来实现事务。比如阿里的 RocketMQ 就支持消息事务。</p><p>大概的意思就是：</p><ol><li>A 系统先发送一个 prepared 消息到 mq，如果这个 prepared 消息发送失败那么就直接取消操作别执行了；</li><li>如果这个消息发送成功过了，那么接着执行本地事务，如果成功就告诉 mq 发送确认消息，如果失败就告诉 mq 回滚消息；</li><li>如果发送了确认消息，那么此时 B 系统会接收到确认消息，然后执行本地的事务；</li><li>mq 会自动<strong>定时轮询</strong>所有 prepared 消息回调你的接口，问你，这个消息是不是本地事务处理失败了，所有没发送确认的消息，是继续重试还是回滚？一般来说这里你就可以查下数据库看之前本地事务是否执行，如果回滚了，那么这里也回滚吧。这个就是避免可能本地事务执行成功了，而确认消息却发送失败了。</li><li>这个方案里，要是系统 B 的事务失败了咋办？重试咯，自动不断重试直到成功，如果实在是不行，要么就是针对重要的资金类业务进行回滚，比如 B 系统本地回滚后，想办法通知系统 A 也回滚；或者是发送报警由人工来手工回滚和补偿。</li><li>这个还是比较合适的，目前国内互联网公司大都是这么玩儿的，要不你举用 RocketMQ 支持的，要不你就自己基于类似 ActiveMQ？RabbitMQ？自己封装一套类似的逻辑出来，总之思路就是这样子的。</li></ol><div align="center"><img src="https://github.com/doocs/advanced-java/blob/master/images/distributed-transaction-reliable-message.png"/></div>### 4.5. 最大努力通知方案<p>这个方案的大致意思就是：</p><ol><li>系统 A 本地事务执行完之后，发送个消息到 MQ；</li><li>这里会有个专门消费 MQ 的<strong>最大努力通知服务</strong>，这个服务会消费 MQ 然后写入数据库中记录下来，或者是放入个内存队列也可以，接着调用系统 B 的接口；</li><li>要是系统 B 执行成功就 ok 了；要是系统 B 执行失败了，那么最大努力通知服务就定时尝试重新调用系统 B，反复 N 次，最后还是不行就放弃。</li></ol><h3 id="46-你们公司是如何处理分布式事务的"><a class="markdownIt-Anchor" href="#46-你们公司是如何处理分布式事务的"></a> 4.6. 你们公司是如何处理分布式事务的？</h3><p>如果你真的被问到，可以这么说，我们某某特别严格的场景，用的是 TCC 来保证强一致性；然后其他的一些场景基于阿里的 RocketMQ 来实现分布式事务。</p><p>你找一个严格资金要求绝对不能错的场景，你可以说你是用的 TCC 方案；如果是一般的分布式事务场景，订单插入之后要调用库存服务更新库存，库存数据没有资金那么的敏感，可以用可靠消息最终一致性方案。</p><p>友情提示一下，RocketMQ 3.2.6 之前的版本，是可以按照上面的思路来的，但是之后接口做了一些改变，我这里不再赘述了。</p><p>当然如果你愿意，你可以参考可靠消息最终一致性方案来自己实现一套分布式事务，比如基于 RocketMQ 来玩儿。</p><h2 id="5-参考资料"><a class="markdownIt-Anchor" href="#5-参考资料"></a> 5. 参考资料</h2><ul><li><a href="https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html" target="_blank" rel="noopener">聊聊分布式事务，再说说解决方案</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分布式事务基本原理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#分布式事务基本原理&quot;&gt;&lt;/a&gt; 分布式事务基本原理&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;分布式事务指的是事务操作跨越多个节点，并且要求满足事务的 A
      
    
    </summary>
    
    
      <category term="设计" scheme="https://dunwu.github.io/blog/categories/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="系统原理" scheme="https://dunwu.github.io/blog/categories/%E8%AE%BE%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="设计" scheme="https://dunwu.github.io/blog/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="系统原理" scheme="https://dunwu.github.io/blog/tags/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    
      <category term="事务" scheme="https://dunwu.github.io/blog/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>分布式会话基本原理</title>
    <link href="https://dunwu.github.io/blog/design/theory/distributed-session-theory/"/>
    <id>https://dunwu.github.io/blog/design/theory/distributed-session-theory/</id>
    <published>2019-06-04T15:42:00.000Z</published>
    <updated>2020-01-19T11:43:25.924Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式会话基本原理"><a class="markdownIt-Anchor" href="#分布式会话基本原理"></a> 分布式会话基本原理</h1><blockquote><p>由于 Http 是一种无状态的协议，服务器单单从网络连接上无从知道客户身份。</p><p>会话跟踪是 Web 程序中常用的技术，用来跟踪用户的整个会话。常用会话跟踪技术是 Cookie 与 Session。</p></blockquote><h2 id="1-简介"><a class="markdownIt-Anchor" href="#1-简介"></a> 1. 简介</h2><h3 id="11-什么是-cookie"><a class="markdownIt-Anchor" href="#11-什么是-cookie"></a> 1.1. 什么是 Cookie</h3><p>Cookie 实际上是存储在用户浏览器上的文本信息，并保留了各种跟踪的信息。</p><p>Cookie 工作步骤：</p><ol><li>客户端请求服务器，如果服务器需要记录该用户的状态，就是用 response 向客户端浏览器颁发一个 Cookie。</li><li>客户端浏览器会把 Cookie 保存下来。</li><li>当浏览器再请求该网站时，浏览器把该请求的网址连同 Cookie 一同提交给服务器。服务器检查该 Cookie，以此来辨认用户状态。</li></ol><p>Cookie 主要用于以下三个方面：</p><ul><li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li>个性化设置（如用户自定义设置、主题等）</li><li>浏览器行为跟踪（如跟踪分析用户行为等）</li></ul><p><strong><em>注：Cookie 功能需要浏览器的支持，如果浏览器不支持 Cookie 或者 Cookie 禁用了，Cookie 功能就会失效。</em></strong></p><h3 id="12-什么是-session"><a class="markdownIt-Anchor" href="#12-什么是-session"></a> 1.2. 什么是 Session</h3><p>Session 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。</p><h3 id="13-cookie-和-session-的区别"><a class="markdownIt-Anchor" href="#13-cookie-和-session-的区别"></a> 1.3. Cookie 和 Session 的区别</h3><ul><li><strong>作用范围不同</strong>，Cookie 保存在客户端（浏览器），Session 保存在服务器端。</li><li><strong>存取方式的不同</strong>，Cookie 只能保存 ASCII，Session 可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。</li><li><strong>有效期不同</strong>，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。</li><li><strong>隐私策略不同</strong>，Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。</li><li><strong>存储大小不同</strong>， 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie。</li></ul><h3 id="14-为什么需要-cookie-和-session他们有什么关联"><a class="markdownIt-Anchor" href="#14-为什么需要-cookie-和-session他们有什么关联"></a> 1.4. 为什么需要 Cookie 和 Session，他们有什么关联？</h3><p>说起来为什么需要 Cookie ，这就需要从浏览器开始说起，我们都知道浏览器是没有状态的(HTTP 协议无状态)，这意味着浏览器并不知道是张三还是李四在和服务端打交道。这个时候就需要有一个机制来告诉服务端，本次操作用户是否登录，是哪个用户在执行的操作，那这套机制的实现就需要 Cookie 和 Session 的配合。</p><p>那么 Cookie 和 Session 是如何配合的呢？我画了一张图大家可以先了解下。</p><p><img src="https://user-gold-cdn.xitu.io/2019/5/13/16aafb5d90f398e2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" /></p><p>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建创建对应的 Session ，请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器，浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名。</p><p>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。</p><p>根据以上流程可知，SessionID 是连接 Cookie 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。</p><h3 id="15-如果浏览器禁用-cookie-怎么办"><a class="markdownIt-Anchor" href="#15-如果浏览器禁用-cookie-怎么办"></a> 1.5. 如果浏览器禁用 Cookie 怎么办</h3><p>既然服务端是根据 Cookie 中的信息判断用户是否登录，那么如果浏览器中禁止了 Cookie，如何保障整个机制的正常运转。</p><p>第一种方案，每次请求中都携带一个 SessionID 的参数，也可以 Post 的方式提交，也可以在请求的地址后面拼接 <code>xxx?SessionID=123456...</code>。</p><p>第二种方案，Token 机制。Token 机制多用于 App 客户端和服务器交互的模式，也可以用于 Web 端做用户状态管理。</p><p>Token 的意思是“令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。Token 机制和 Cookie 和 Session 的使用机制比较类似。</p><p>当用户第一次登录后，服务器根据提交的用户信息生成一个 Token，响应时将 Token 返回给客户端，以后客户端只需带上这个 Token 前来请求数据即可，无需再次登录验证。</p><h2 id="2-分布式-session"><a class="markdownIt-Anchor" href="#2-分布式-session"></a> 2. 分布式 Session</h2><p>在分布式场景下，一个用户的 Session 如果只存储在一个服务器上，那么当负载均衡器把用户的下一个请求转发到另一个服务器上，该服务器没有用户的 Session，就可能导致用户需要重新进行登录等操作。</p><p>分布式 Session 的几种实现策略：</p><ol><li>粘性 session</li><li>应用服务器间的 session 复制共享</li><li>基于缓存的 session 共享 ✅</li></ol><blockquote><p>推荐：基于缓存的 session 共享</p></blockquote><h3 id="21-粘性-session"><a class="markdownIt-Anchor" href="#21-粘性-session"></a> 2.1. 粘性 Session</h3><blockquote><p>粘性 Session（Sticky Sessions）<strong>需要配置负载均衡器，使得一个用户的所有请求都路由到一个服务器节点上</strong>，这样就可以把用户的 Session 存放在该服务器节点中。</p><p>缺点：<strong>当服务器节点宕机时，将丢失该服务器节点上的所有 Session</strong>。</p></blockquote><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/architecture/MultiNode-StickySessions.jpg!zp" /></div><h3 id="22-session-复制共享"><a class="markdownIt-Anchor" href="#22-session-复制共享"></a> 2.2. Session 复制共享</h3><blockquote><p>Session 复制共享（Session Replication）<strong>在服务器节点之间进行 Session 同步操作</strong>，这样的话用户可以访问任何一个服务器节点。</p><p>缺点：<strong>占用过多内存</strong>；<strong>同步过程占用网络带宽以及服务器处理器时间</strong>。</p></blockquote><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/architecture/MultiNode-SessionReplication.jpg!zp" /></div><h3 id="23-基于缓存的-session-共享"><a class="markdownIt-Anchor" href="#23-基于缓存的-session-共享"></a> 2.3. 基于缓存的 session 共享</h3><blockquote><p><strong>使用一个单独的存储服务器存储 Session 数据</strong>，可以存在 MySQL 数据库上，也可以存在 Redis 或者 Memcached 这种内存型数据库。</p><p>缺点：需要去实现存取 Session 的代码。</p></blockquote><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/architecture/MultiNode-SpringSession.jpg!zp" /></div><h2 id="3-具体实现"><a class="markdownIt-Anchor" href="#3-具体实现"></a> 3. 具体实现</h2><h3 id="31-jwt-token"><a class="markdownIt-Anchor" href="#31-jwt-token"></a> 3.1. JWT Token</h3><p>使用 JWT Token 储存用户身份，然后再从数据库或者 cache 中获取其他的信息。这样无论请求分配到哪个服务器都无所谓。</p><h3 id="32-tomcat-redis"><a class="markdownIt-Anchor" href="#32-tomcat-redis"></a> 3.2. tomcat + redis</h3><p>这个其实还挺方便的，就是使用 session 的代码，跟以前一样，还是基于 tomcat 原生的 session 支持即可，然后就是用一个叫做 <code>Tomcat RedisSessionManager</code> 的东西，让所有我们部署的 tomcat 都将 session 数据存储到 redis 即可。</p><p>在 tomcat 的配置文件中配置：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"com.orangefunction.tomcat.redissessions.RedisSessionHandlerValve"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Manager</span> <span class="attr">className</span>=<span class="string">"com.orangefunction.tomcat.redissessions.RedisSessionManager"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">host</span>=<span class="string">"&#123;redis.host&#125;"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">port</span>=<span class="string">"&#123;redis.port&#125;"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">database</span>=<span class="string">"&#123;redis.dbnum&#125;"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">maxInactiveInterval</span>=<span class="string">"60"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>然后指定 redis 的 host 和 port 就 ok 了。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"com.orangefunction.tomcat.redissessions.RedisSessionHandlerValve"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Manager</span> <span class="attr">className</span>=<span class="string">"com.orangefunction.tomcat.redissessions.RedisSessionManager"</span></span></span><br><span class="line"><span class="tag"> <span class="attr">sentinelMaster</span>=<span class="string">"mymaster"</span></span></span><br><span class="line"><span class="tag"> <span class="attr">sentinels</span>=<span class="string">"&lt;sentinel1-ip&gt;:26379,&lt;sentinel2-ip&gt;:26379,&lt;sentinel3-ip&gt;:26379"</span></span></span><br><span class="line"><span class="tag"> <span class="attr">maxInactiveInterval</span>=<span class="string">"60"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>还可以用上面这种方式基于 redis 哨兵支持的 redis 高可用集群来保存 session 数据，都是 ok 的。</p><h3 id="33-spring-session-redis"><a class="markdownIt-Anchor" href="#33-spring-session-redis"></a> 3.3. spring session + redis</h3><p>上面那种 tomcat + redis 的方式好用，但是会<strong>严重依赖于 web 容器</strong>，不好将代码移植到其他 web 容器上去，尤其是你要是换了技术栈咋整？比如换成了 spring cloud 或者是 spring boot 之类的呢？</p><p>所以现在比较好的还是基于 Java 一站式解决方案，也就是 spring。人家 spring 基本上承包了大部分我们需要使用的框架，spirng cloud 做微服务，spring boot 做脚手架，所以用 <a href="https://github.com/spring-projects/spring-session" target="_blank" rel="noopener">sping session</a> 是一个很好的选择。</p><p>在 pom.xml 中配置：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 spring 配置文件中配置：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"redisHttpSessionConfiguration"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">class</span>=<span class="string">"org.springframework.session.data.redis.config.annotation.web.http.RedisHttpSessionConfiguration"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxInactiveIntervalInSeconds"</span> <span class="attr">value</span>=<span class="string">"600"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jedisPoolConfig"</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.JedisPoolConfig"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxTotal"</span> <span class="attr">value</span>=<span class="string">"100"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxIdle"</span> <span class="attr">value</span>=<span class="string">"10"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jedisConnectionFactory"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"org.springframework.data.redis.connection.jedis.JedisConnectionFactory"</span> <span class="attr">destroy-method</span>=<span class="string">"destroy"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hostName"</span> <span class="attr">value</span>=<span class="string">"$&#123;redis_hostname&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"port"</span> <span class="attr">value</span>=<span class="string">"$&#123;redis_port&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;redis_pwd&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"timeout"</span> <span class="attr">value</span>=<span class="string">"3000"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"usePool"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"poolConfig"</span> <span class="attr">ref</span>=<span class="string">"jedisPoolConfig"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 web.xml 中配置：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>springSessionRepositoryFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>springSessionRepositoryFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/putIntoSession"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">putIntoSession</span><span class="params">(HttpServletRequest request, String username)</span> </span>&#123;</span><br><span class="line">        request.getSession().setAttribute(<span class="string">"name"</span>,  <span class="string">"leo"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"ok"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/getFromSession"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFromSession</span><span class="params">(HttpServletRequest request, Model model)</span></span>&#123;</span><br><span class="line">        String name = request.getSession().getAttribute(<span class="string">"name"</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码就是 ok 的，给 sping session 配置基于 redis 来存储 session 数据，然后配置了一个 spring session 的过滤器，这样的话，session 相关操作都会交给 spring session 来管了。接着在代码中，就用原生的 session 操作，就是直接基于 spring sesion 从 redis 中获取数据了。</p><p>实现分布式的会话有很多种方式，我说的只不过是比较常见的几种方式，tomcat + redis 早期比较常用，但是会重耦合到 tomcat 中；近些年，通过 spring session 来实现。</p><h2 id="4-参考资料"><a class="markdownIt-Anchor" href="#4-参考资料"></a> 4. 参考资料</h2><ul><li><a href="https://github.com/L316476844/distributed-session" target="_blank" rel="noopener">集群/分布式环境 Session 的几种策略</a></li><li><a href="https://juejin.im/post/5cd9037ee51d456e5c5babca" target="_blank" rel="noopener">你真的了解 Cookie 和 Session 吗</a></li><li><a href="https://juejin.im/post/5aede266f265da0ba266e0ef" target="_blank" rel="noopener">聊一聊 session 和 cookie</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分布式会话基本原理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#分布式会话基本原理&quot;&gt;&lt;/a&gt; 分布式会话基本原理&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;由于 Http 是一种无状态的协议，服务器单单从网络连接上无从知道客户身份。
      
    
    </summary>
    
    
      <category term="设计" scheme="https://dunwu.github.io/blog/categories/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="系统原理" scheme="https://dunwu.github.io/blog/categories/%E8%AE%BE%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="设计" scheme="https://dunwu.github.io/blog/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="系统原理" scheme="https://dunwu.github.io/blog/tags/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    
      <category term="session" scheme="https://dunwu.github.io/blog/tags/session/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁基本原理</title>
    <link href="https://dunwu.github.io/blog/design/theory/distributed-lock-theory/"/>
    <id>https://dunwu.github.io/blog/design/theory/distributed-lock-theory/</id>
    <published>2019-06-04T15:42:00.000Z</published>
    <updated>2020-01-19T13:59:32.983Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式锁基本原理"><a class="markdownIt-Anchor" href="#分布式锁基本原理"></a> 分布式锁基本原理</h1><!-- TOC depthFrom:2 depthTo:3 --><ul><li><a href="#1-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%80%9D%E8%B7%AF">1. 分布式锁思路</a></li><li><a href="#2-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">2. 数据库分布式锁</a><ul><li><a href="#21-%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0">2.1. 具体实现</a></li><li><a href="#22-%E9%97%AE%E9%A2%98">2.2. 问题</a></li><li><a href="#23-%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95">2.3. 解决办法</a></li><li><a href="#24-%E5%B0%8F%E7%BB%93">2.4. 小结</a></li></ul></li><li><a href="#3-redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">3. Redis 分布式锁</a><ul><li><a href="#31-%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF">3.1. 实现思路</a></li><li><a href="#32-%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0">3.2. 具体实现</a></li><li><a href="#33-%E5%B0%8F%E7%BB%93">3.3. 小结</a></li><li><a href="#34-redlock-%E7%AE%97%E6%B3%95">3.4. RedLock 算法</a></li></ul></li><li><a href="#4-zookeeper-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">4. ZooKeeper 分布式锁</a><ul><li><a href="#41-%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF">4.1. 实现思路</a></li><li><a href="#42-%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0">4.2. 具体实现</a></li><li><a href="#43-%E5%B0%8F%E7%BB%93">4.3. 小结</a></li></ul></li><li><a href="#5-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94">5. 分布式锁方案对比</a></li><li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li></ul><!-- /TOC --><p>Java 原生 API 虽然有并发锁，但并没有提供分布式锁的能力，所以针对分布式场景中的锁需要解决的方案。</p><p>分布式锁的解决方案大致有以下几种：</p><ul><li>基于数据库实现</li><li>基于缓存（redis，memcached 等）实现</li><li>基于 Zookeeper 实现 ✅</li></ul><blockquote><p>注：推荐基于 ZooKeeper 实现分布式锁，具体原因看完本文即可明了。</p></blockquote><h2 id="1-分布式锁思路"><a class="markdownIt-Anchor" href="#1-分布式锁思路"></a> 1. 分布式锁思路</h2><p>分布式锁的总体思路大同小异，仅在实现细节上有所不同。</p><p>分布式锁的主要思路如下：</p><ul><li><strong>互斥</strong> - 创建锁必须是唯一的，表现形式为向数据存储服务器或容器插入一个唯一的 key，一旦有一个线程插入这个 key，其他线程就不能再插入了。</li><li><strong>避免永远不释放锁</strong> - 数据库分布式锁和缓存分布式锁（Redis）的思路都是引入超时机制，即成功申请锁后，超过一定时间，锁失效（删除 key），原因在于它们无法感知申请锁的客户端节点状态。而 ZooKeeper 由于其 znode 以目录、文件形式组织，天然就存在物理空间隔离，只要 znode 存在，即表示客户端节点还在工作，所以不存在这种问题。</li><li><strong>容错</strong>（只要大部分 redis 节点创建了这把锁就可以）</li></ul><h2 id="2-数据库分布式锁"><a class="markdownIt-Anchor" href="#2-数据库分布式锁"></a> 2. 数据库分布式锁</h2><h3 id="21-具体实现"><a class="markdownIt-Anchor" href="#21-具体实现"></a> 2.1. 具体实现</h3><p>（1）创建表</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`methodLock`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">  <span class="string">`method_name`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'锁定的方法名'</span>,</span><br><span class="line">  <span class="string">`desc`</span> <span class="built_in">varchar</span>(<span class="number">1024</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'备注信息'</span>,</span><br><span class="line">  <span class="string">`update_time`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'保存数据时间，自动生成'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`uidx_method_name`</span> (<span class="string">`method_name `</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'锁定中的方法'</span>;</span><br></pre></td></tr></table></figure><p>（2）获取锁</p><p>想要锁住某个方法时，执行以下 SQL：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> methodLock(method_name,<span class="keyword">desc</span>) <span class="keyword">values</span> (‘method_name’,‘<span class="keyword">desc</span>’)</span><br></pre></td></tr></table></figure><p>因为我们对 <code>method_name</code> 做了唯一性约束，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，可以执行方法体内容。</p><p>成功插入则获取锁。</p><p>（3）释放锁</p><p>当方法执行完毕之后，想要释放锁的话，需要执行以下 Sql:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> methodLock <span class="keyword">where</span> method_name =<span class="string">'method_name'</span></span><br></pre></td></tr></table></figure><h3 id="22-问题"><a class="markdownIt-Anchor" href="#22-问题"></a> 2.2. 问题</h3><ul><li>这把锁强依赖数据库的可用性。如果数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。</li><li>这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。</li><li>这把锁只能是非阻塞的，因为数据的 insert 操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。</li><li>这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。</li></ul><h3 id="23-解决办法"><a class="markdownIt-Anchor" href="#23-解决办法"></a> 2.3. 解决办法</h3><ul><li>单点问题可以用多数据库实例，同时塞 N 个表，N/2+1 个成功就任务锁定成功</li><li>写一个定时任务，隔一段时间清除一次过期的数据。</li><li>写一个 while 循环，不断的重试插入，直到成功。</li><li>在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。</li></ul><h3 id="24-小结"><a class="markdownIt-Anchor" href="#24-小结"></a> 2.4. 小结</h3><ul><li>优点: 直接借助数据库，容易理解。</li><li>缺点: 会有各种各样的问题，在解决问题的过程中会使整个方案变得越来越复杂。操作数据库需要一定的开销，性能问题需要考虑。</li></ul><h2 id="3-redis-分布式锁"><a class="markdownIt-Anchor" href="#3-redis-分布式锁"></a> 3. Redis 分布式锁</h2><p>相比于用数据库来实现分布式锁，基于缓存实现的分布式锁的性能会更好一些。目前有很多成熟的分布式产品，包括 Redis、memcache、Tair 等。这里以 Redis 举例。</p><h3 id="31-实现思路"><a class="markdownIt-Anchor" href="#31-实现思路"></a> 3.1. 实现思路</h3><p>这个分布式锁有 3 个重要的考量点：</p><ol><li>互斥（只能有一个客户端获取锁）</li><li>不能死锁</li><li>容错（只要大部分 redis 节点创建了这把锁就可以）</li></ol><p>对应的 Redis 指令如下：</p><ul><li><code>setnx</code> - <code>setnx key val</code>：当且仅当 key 不存在时，set 一个 key 为 val 的字符串，返回 1；若 key 存在，则什么都不做，返回 0。</li><li><code>expire</code> - <code>expire key timeout</code>：为 key 设置一个超时时间，单位为 second，超过这个时间锁会自动释放，避免死锁。</li><li><code>delete</code> - <code>delete key</code>：删除 key</li></ul><h3 id="32-具体实现"><a class="markdownIt-Anchor" href="#32-具体实现"></a> 3.2. 具体实现</h3><p>（1）申请锁</p><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> resource_name <span class="comment">my_random_value NX PX 30000</span></span><br></pre></td></tr></table></figure><p>执行这个命令就 ok。</p><ul><li><code>NX</code>：表示只有 <code>key</code> 不存在的时候才会设置成功。（如果此时 redis 中存在这个 key，那么设置失败，返回 <code>nil</code>）</li><li><code>PX 30000</code>：意思是 30s 后锁自动释放。别人创建的时候如果发现已经有了就不能加锁了。</li></ul><p>（2）释放锁</p><p>释放锁就是删除 key ，但是一般可以用 <code>lua</code> 脚本删除，判断 value 一样才删除：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">-- 删除锁的时候，找到 key 对应的 value，跟自己传过去的 value 做比较，如果是一样的才删除。</span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">"get"</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] then</span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">"del"</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="33-小结"><a class="markdownIt-Anchor" href="#33-小结"></a> 3.3. 小结</h3><p>为啥要用 <code>random_value</code> 随机值呢？因为如果某个客户端获取到了锁，但是阻塞了很长时间才执行完，比如说超过了 30s，此时可能已经自动释放锁了，此时可能别的客户端已经获取到了这个锁，要是你这个时候直接删除 key 的话会有问题，所以得用随机值加上面的 <code>lua</code> 脚本来释放锁。</p><p>但是这样是肯定不行的。因为如果是普通的 redis 单实例，那就是单点故障。或者是 redis 普通主从，那 redis 主从异步复制，如果主节点挂了（key 就没有了），key 还没同步到从节点，此时从节点切换为主节点，别人就可以 set key，从而拿到锁。</p><h3 id="34-redlock-算法"><a class="markdownIt-Anchor" href="#34-redlock-算法"></a> 3.4. RedLock 算法</h3><p>这个场景是假设有一个 redis cluster，有 5 个 redis master 实例。然后执行如下步骤获取一把锁：</p><ol><li>获取当前时间戳，单位是毫秒；</li><li>跟上面类似，轮流尝试在每个 master 节点上创建锁，过期时间较短，一般就几十毫秒；</li><li>尝试在<strong>大多数节点</strong>上建立一个锁，比如 5 个节点就要求是 3 个节点 <code>n / 2 + 1</code>；</li><li>客户端计算建立好锁的时间，如果建立锁的时间小于超时时间，就算建立成功了；</li><li>要是锁建立失败了，那么就依次之前建立过的锁删除；</li><li>只要别人建立了一把分布式锁，你就得<strong>不断轮询去尝试获取锁</strong>。</li></ol><p><a href="https://redis.io/" target="_blank" rel="noopener">Redis 官方</a>给出了以上两种基于 Redis 实现分布式锁的方法，详细说明可以查看：<a href="https://redis.io/topics/distlock" target="_blank" rel="noopener">https://redis.io/topics/distlock</a> 。</p><h2 id="4-zookeeper-分布式锁"><a class="markdownIt-Anchor" href="#4-zookeeper-分布式锁"></a> 4. ZooKeeper 分布式锁</h2><h3 id="41-实现思路"><a class="markdownIt-Anchor" href="#41-实现思路"></a> 4.1. 实现思路</h3><p>这也是 ZooKeeper 客户端 curator 的分布式锁实现。</p><ol><li>创建一个目录 mylock；</li><li>线程 A 想获取锁就在 mylock 目录下创建临时顺序节点；</li><li>获取 mylock 目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；</li><li>线程 B 获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；</li><li>线程 A 处理完，删除自己的节点，线程 B 监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。</li></ol><h3 id="42-具体实现"><a class="markdownIt-Anchor" href="#42-具体实现"></a> 4.2. 具体实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ZooKeeperSession</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> bingo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018/11/29</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZooKeeperSession</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch connectedSemaphore = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zookeeper;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZooKeeperSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.zookeeper = <span class="keyword">new</span> ZooKeeper(<span class="string">"192.168.31.187:2181,192.168.31.19:2181,192.168.31.227:2181"</span>, <span class="number">50000</span>, <span class="keyword">new</span> ZooKeeperWatcher());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                connectedSemaphore.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"ZooKeeper session established......"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取分布式锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> productId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">acquireDistributedLock</span><span class="params">(Long productId)</span> </span>&#123;</span><br><span class="line">        String path = <span class="string">"/product-lock-"</span> + productId;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zookeeper.create(path, <span class="string">""</span>.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 相当于是给node注册一个监听器，去看看这个监听器是否存在</span></span><br><span class="line">                    Stat stat = zk.exists(path, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (stat != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">this</span>.latch.await(waitTime, TimeUnit.MILLISECONDS);</span><br><span class="line">                        <span class="keyword">this</span>.latch = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    zookeeper.create(path, <span class="string">""</span>.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ee) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放掉一个分布式锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> productId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseDistributedLock</span><span class="params">(Long productId)</span> </span>&#123;</span><br><span class="line">        String path = <span class="string">"/product-lock-"</span> + productId;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zookeeper.delete(path, -<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">"release the lock for product[id="</span> + productId + <span class="string">"]......"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 建立zk session的watcher</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> bingo</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 2018/11/29</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ZooKeeperWatcher</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Receive watched event: "</span> + event.getState());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (KeeperState.SyncConnected == event.getState()) &#123;</span><br><span class="line">                connectedSemaphore.countDown();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.latch != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 封装单例的静态内部类</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> bingo</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 2018/11/29</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> ZooKeeperSession instance;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> ZooKeeperSession();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ZooKeeperSession <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取单例</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ZooKeeperSession <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Singleton.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化单例的便捷方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以采用另一种方式，创建临时顺序节点：</p><p>如果有一把锁，被多个人给竞争，此时多个人会排队，第一个拿到锁的人会执行，然后释放锁；后面的每个人都会去监听<strong>排在自己前面</strong>的那个人创建的 node 上，一旦某个人释放了锁，排在自己后面的人就会被 zookeeper 给通知，一旦被通知了之后，就 ok 了，自己就获取到了锁，就可以执行代码了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZooKeeperDistributedLock</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zk;</span><br><span class="line">    <span class="keyword">private</span> String locksRoot = <span class="string">"/locks"</span>;</span><br><span class="line">    <span class="keyword">private</span> String productId;</span><br><span class="line">    <span class="keyword">private</span> String waitNode;</span><br><span class="line">    <span class="keyword">private</span> String lockNode;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch connectedLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sessionTimeout = <span class="number">30000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZooKeeperDistributedLock</span><span class="params">(String productId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.productId = productId;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String address = <span class="string">"192.168.31.187:2181,192.168.31.19:2181,192.168.31.227:2181"</span>;</span><br><span class="line">            zk = <span class="keyword">new</span> ZooKeeper(address, sessionTimeout, <span class="keyword">this</span>);</span><br><span class="line">            connectedLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LockException(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LockException(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LockException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event.getState() == KeeperState.SyncConnected) &#123;</span><br><span class="line">            connectedLatch.countDown();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.latch != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.latch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireDistributedLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                waitForLock(waitNode, sessionTimeout);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LockException(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LockException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">// 传入进去的locksRoot + “/” + productId</span></span><br><span class="line">    <span class="comment">// 假设productId代表了一个商品id，比如说1</span></span><br><span class="line">    <span class="comment">// locksRoot = locks</span></span><br><span class="line">    <span class="comment">// /locks/10000000000，/locks/10000000001，/locks/10000000002</span></span><br><span class="line">            lockNode = zk.create(locksRoot + <span class="string">"/"</span> + productId, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 看看刚创建的节点是不是最小的节点</span></span><br><span class="line">     <span class="comment">// locks：10000000000，10000000001，10000000002</span></span><br><span class="line">            List&lt;String&gt; locks = zk.getChildren(locksRoot, <span class="keyword">false</span>);</span><br><span class="line">            Collections.sort(locks);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(lockNode.equals(locksRoot+<span class="string">"/"</span>+ locks.get(<span class="number">0</span>)))&#123;</span><br><span class="line">                <span class="comment">//如果是最小的节点,则表示取得锁</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果不是最小的节点，找到比自己小1的节点</span></span><br><span class="line">  <span class="keyword">int</span> previousLockIndex = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; locks.size(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(lockNode.equals(locksRoot + “/” + locks.get(i))) &#123;</span><br><span class="line">             previousLockIndex = i - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">this</span>.waitNode = locks.get(previousLockIndex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LockException(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LockException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">waitForLock</span><span class="params">(String waitNode, <span class="keyword">long</span> waitTime)</span> <span class="keyword">throws</span> InterruptedException, KeeperException </span>&#123;</span><br><span class="line">        Stat stat = zk.exists(locksRoot + <span class="string">"/"</span> + waitNode, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (stat != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">this</span>.latch.await(waitTime, TimeUnit.MILLISECONDS);</span><br><span class="line">            <span class="keyword">this</span>.latch = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 删除/locks/10000000000节点</span></span><br><span class="line">            <span class="comment">// 删除/locks/10000000001节点</span></span><br><span class="line">            System.out.println(<span class="string">"unlock "</span> + lockNode);</span><br><span class="line">            zk.delete(lockNode, -<span class="number">1</span>);</span><br><span class="line">            lockNode = <span class="keyword">null</span>;</span><br><span class="line">            zk.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LockException</span><span class="params">(String e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LockException</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="43-小结"><a class="markdownIt-Anchor" href="#43-小结"></a> 4.3. 小结</h3><p>ZooKeeper 版本的分布式锁问题相对比较来说少。</p><ul><li>锁的占用时间限制：redis 就有占用时间限制，而 ZooKeeper 则没有，最主要的原因是 redis 目前没有办法知道已经获取锁的客户端的状态，是已经挂了呢还是正在执行耗时较长的业务逻辑。而 ZooKeeper 通过临时节点就能清晰知道，如果临时节点存在说明还在执行业务逻辑，如果临时节点不存在说明已经执行完毕释放锁或者是挂了。由此看来 redis 如果能像 ZooKeeper 一样添加一些与客户端绑定的临时键，也是一大好事。</li><li>是否单点故障：redis 本身有很多中玩法，如客户端一致性 hash，服务器端 sentinel 方案或者 cluster 方案，很难做到一种分布式锁方式能应对所有这些方案。而 ZooKeeper 只有一种玩法，多台机器的节点数据是一致的，没有 redis 的那么多的麻烦因素要考虑。</li></ul><p>总体上来说 ZooKeeper 实现分布式锁更加的简单，可靠性更高。但 ZooKeeper 因为需要频繁的创建和删除节点，性能上不如 Redis 方式。</p><h2 id="5-分布式锁方案对比"><a class="markdownIt-Anchor" href="#5-分布式锁方案对比"></a> 5. 分布式锁方案对比</h2><ul><li><p>数据库分布式锁，问题比较多，解决起来比较麻烦，不推荐</p></li><li><p>redis 分布式锁，其实<strong>需要自己不断去尝试获取锁</strong>，比较消耗性能。</p></li><li><p>zk 分布式锁，获取不到锁，注册个监听器即可，不需要不断主动尝试获取锁，性能开销较小。</p></li></ul><p>另外一点就是，如果是 redis 获取锁的那个客户端出现 bug 挂了，那么只能等待超时时间之后才能释放锁；而 zk 的话，因为创建的是临时 znode，只要客户端挂了，znode 就没了，此时就自动释放锁。</p><p>总体上来说，ZooKeeper 实现分布式锁更加的简单，可靠性更高。</p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ul><li><a href="https://juejin.im/post/5a20cd8bf265da43163cdd9a" target="_blank" rel="noopener">分布式锁实现汇总</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分布式锁基本原理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#分布式锁基本原理&quot;&gt;&lt;/a&gt; 分布式锁基本原理&lt;/h1&gt;
&lt;!-- TOC depthFrom:2 depthTo:3 --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-%
      
    
    </summary>
    
    
      <category term="设计" scheme="https://dunwu.github.io/blog/categories/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="系统原理" scheme="https://dunwu.github.io/blog/categories/%E8%AE%BE%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="设计" scheme="https://dunwu.github.io/blog/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="系统原理" scheme="https://dunwu.github.io/blog/tags/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    
      <category term="分布式锁" scheme="https://dunwu.github.io/blog/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>网络通信知识点面经</title>
    <link href="https://dunwu.github.io/blog/communication/network-interview/"/>
    <id>https://dunwu.github.io/blog/communication/network-interview/</id>
    <published>2019-06-01T16:00:00.000Z</published>
    <updated>2020-01-16T09:48:30.640Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络通信知识点面经"><a class="markdownIt-Anchor" href="#网络通信知识点面经"></a> 网络通信知识点面经</h1><!-- TOC depthFrom:2 depthTo:4 --><ul><li><a href="#1-%E7%BB%BC%E5%90%88">1. 综合</a><ul><li><a href="#11-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A6%82%E4%BD%95%E5%88%86%E5%B1%82">1.1. 计算机网络如何分层？</a></li></ul></li><li><a href="#2-http">2. HTTP</a></li><li><a href="#3-dns">3. DNS</a></li><li><a href="#4-tcpudp">4. TCP/UDP</a><ul><li><a href="#41-%E4%BB%80%E4%B9%88%E6%98%AF-tcp">4.1. 什么是 TCP？</a></li><li><a href="#42-tcp-%E7%9A%84%E7%89%B9%E6%80%A7%E6%98%AF%E4%BB%80%E4%B9%88">4.2. TCP 的特性是什么？</a></li><li><a href="#43-tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B">4.3. TCP 三次握手</a></li><li><a href="#44-tcp-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B">4.4. TCP 四次挥手</a></li><li><a href="#45-tcp-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">4.5. TCP 滑动窗口</a></li><li><a href="#46-tcp-%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6">4.6. TCP 重传机制</a></li></ul></li></ul><!-- /TOC --><h2 id="1-综合"><a class="markdownIt-Anchor" href="#1-综合"></a> 1. 综合</h2><h3 id="11-计算机网络如何分层"><a class="markdownIt-Anchor" href="#11-计算机网络如何分层"></a> 1.1. 计算机网络如何分层？</h3><blockquote><p>❓ 问题：计算机网络如何分层？各层的作用是什么？各层的主要协议、设备分别是什么？</p><p>这是学习计算机网络知识宏观层面必须要了解的核心点。知道了这些，对于网络的体系结构就基本上了解了。</p></blockquote><div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/overview/network-layers.png!zp"/></div><p>计算机网络分层一般有三种划分体系：OSI 分层；五层协议分层；TCP/IP 协议分层。</p><ul><li>OSI 的七层体系结构概念清楚，理论完整，但是比较复杂且不实用，所以并不流行。</li><li>五层协议分层是一种折中方案，在现实中更为流行。</li></ul><div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/overview/网络分层架构图.png!zp"/></div><p><strong>物理层</strong></p><blockquote><p>物理层（Physical Layer）只接收和发送一串比特(bit)流，不考虑信息的意义和信息结构。</p><p>扩展阅读：<a href="network-physical.md">计算机网络之物理层</a></p></blockquote><ul><li>关键词：调制、解调、数字信号、模拟信号、通信媒介、信道复用</li><li>数据单元：比特流。</li><li>典型设备：光纤、同轴电缆、双绞线、中继器和集线器。</li></ul><p><strong>数据链路层</strong></p><blockquote><p>网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，数据链路层（Data Link Layer）就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。</p><p>扩展阅读：<a href="network-data-link.md">计算机网络之数据链路层</a></p></blockquote><ul><li>关键词：点对点信道、广播信道、<code>PPP</code>、<code>CSMA/CD</code>、局域网、以太网、<code>MAC</code>、适配器、集线器、网桥、交换机</li><li>主要协议：<code>PPP</code>、<code>CSMA/CD</code> 等。</li><li>数据单元：帧（frame）。</li><li>典型设备：二层交换机、网桥、网卡。</li></ul><p><strong>网络层</strong></p><blockquote><p>网络层（network layer）为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。</p><p>扩展阅读：<a href="network-network.md">计算机网络之网络层</a></p></blockquote><ul><li>关键词：<code>IP</code>、<code>ICMP</code>、<code>ARP</code>、路由</li><li>主要协议：<code>IP</code>。</li><li>数据单元：IP 数据报（packet）。</li><li>典型设备：网关、路由器。</li></ul><p><strong>传输层</strong></p><blockquote><p>传输层（transport layer）为两台主机中进程间的通信提供通用的数据传输服务。</p><p>扩展阅读：<a href="network-network.md">计算机网络之网络层</a></p></blockquote><ul><li>关键词：<code>UDP</code>、<code>TCP</code>、滑动窗口、拥塞控制、三次握手</li><li>主要协议：<code>TCP</code>、<code>UDP</code>。</li><li>数据单元：报文段（segment）或用户数据报。</li></ul><p><sub>~**会话层**~</sub></p><blockquote><p>~~会话层（Session Layer）不参与具体的传输，它提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制。~~</p></blockquote><p><sub>~**表示层**~</sub></p><blockquote><p>~~表示层（Presentation Layer）是为在应用过程之间传送的信息提供表示方法的服务，它关心的只是发出信息的语法与语义。表示层要完成某些特定的功能，主要有不同数据编码格式的转换，提供数据压缩、解压缩服务，对数据进行加密、解密。~~</p></blockquote><p><strong>应用层</strong></p><blockquote><p>应用层（application layer）通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程间通信和交互的规则。</p><p>扩展阅读：<a href="network-application.md">计算机网络之应用层</a></p></blockquote><ul><li>关键词：<code>HTTP</code>、<code>DNS</code>、<code>FTP</code>、<code>TELNET</code>、<code>DHCP</code></li><li>主要协议：<code>HTTP</code>、<code>DNS</code>、<code>SMTP</code>、<code>Telnet</code>、<code>FTP</code>、<code>SNMP</code> 等。</li><li>数据单元：报文（message）。</li></ul><h2 id="2-http"><a class="markdownIt-Anchor" href="#2-http"></a> 2. HTTP</h2><blockquote><p>扩展阅读：<a href="http.md">超文本传输协议 HTTP</a></p></blockquote><h2 id="3-dns"><a class="markdownIt-Anchor" href="#3-dns"></a> 3. DNS</h2><blockquote><p>扩展阅读：<a href="dns.md">域名系统 DNS</a></p></blockquote><h2 id="4-tcpudp"><a class="markdownIt-Anchor" href="#4-tcpudp"></a> 4. TCP/UDP</h2><blockquote><p>扩展阅读：<a href="tcp.md">传输控制协议 TCP</a>，<a href="udp.md">用户数据报协议 UDP</a></p></blockquote><h3 id="41-什么是-tcp"><a class="markdownIt-Anchor" href="#41-什么是-tcp"></a> 4.1. 什么是 TCP？</h3><p><strong>TCP（Transmission Control Protocol），即传输控制协议，它是一种<code>面向连接的</code>、<code>可靠的</code>、<code>基于字节流的</code>传输层通信协议</strong>。</p><h3 id="42-tcp-的特性是什么"><a class="markdownIt-Anchor" href="#42-tcp-的特性是什么"></a> 4.2. TCP 的特性是什么？</h3><ul><li><code>面向连接的</code> - 面向连接是指 TCP 需要通过三次握手、四次挥手原则建立和断开双向连接。</li><li><code>可靠的</code> - 可靠是指 TCP 传输的数据包保证以原始顺序到达目的地，且数据包不被损坏。为了实现这点，TCP 通过以下技术来保证：<ul><li>数据包的序列号和校验码</li><li>确认包和自动重传<ul><li>如果发送者没有收到正确的响应，它将重新发送数据包。如果多次超时，连接就会断开。</li><li>TCP 实行流量控制和拥塞控制。这些确保措施会导致延迟，而且通常导致传输效率比 UDP 低。</li></ul></li></ul></li><li><code>基于字节流的</code><ul><li>虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序看成是一连串的无结构的字节流。TCP 有一个缓冲，当应用程序传送的数据块太长，TCP 就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP 也可以等待积累有足够多的字节后再构成报文段发送出去。</li><li>在 TCP 建立连接前两次握手的 SYN 报文中选项字段的 MSS 值，通信双方商定通信的最大报文长度。如果应用层交付下来的数据过大，就会对数据分段，然后发送；否则通过滑动窗口来控制通信双发的数据。</li></ul></li></ul><h3 id="43-tcp-三次握手"><a class="markdownIt-Anchor" href="#43-tcp-三次握手"></a> 4.3. TCP 三次握手</h3><blockquote><p>❓ 问题：三次握手有什么用？什么是三次握手？为什么需要三次握手？</p></blockquote><p>（1）三次握手有什么用？</p><ul><li>三次握手负责建立 TCP 双向连接。</li></ul><p>（2）什么是三次握手？</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/transport/三次握手.gif!zp"/></div><p>如上图所示，三次握手流程如下：</p><ol><li>第一次握手 - 客户端向服务端发送带有 SYN 标志的数据包。</li><li>第二次握手 - 服务端向客户端发送带有 SYN/ACK 标志的数据包。</li><li>第三次握手 - 客户端向服务端发送带有带有 ACK 标志的数据包。</li></ol><p>至此，TCP 三次握手完成，客户端与服务端已建立双向连接。</p><blockquote><p>💡 说明：SYN 为 synchronize 的缩写，ACK 为 acknowledgment 的缩写。</p></blockquote><p>（3）为什么需要三次握手？</p><p>为了便于说明，假设客户端为 A, 服务端为 B。</p><ol><li>第一次握手，A 向 B 发同步消息。B 收到消息后，B 认为：A 发消息没问题；B 收消息没问题。</li><li>第二次握手，B 向 A 发同步消息和确认消息。A 收到消息后，A 认为：A 发消息、收消息都没问题；B 发消息、收消息都没问题。<strong>但是，此时 B 不确定自己发消息是否没问题</strong>，所以就需要第三次握手。</li><li>第三次握手，A 向 B 发确认消息。B 收到消息后。B 认为：B 发消息没问题。</li></ol><h3 id="44-tcp-四次挥手"><a class="markdownIt-Anchor" href="#44-tcp-四次挥手"></a> 4.4. TCP 四次挥手</h3><blockquote><p>❓ 问题：四次挥手有什么用？什么是四次挥手？为什么建立连接是三次握手，关闭连接确是四次挥手呢？</p></blockquote><p>（1）四次挥手有什么用？</p><ul><li>四次挥手负责断开 TCP 连接。</li></ul><p>（2）什么是四次挥手？</p><p>如上图所示，四次挥手流程如下：</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/transport/四次挥手.gif!zp"/></div><ol><li>第一次挥手 - 客户端向服务端发送一个 FIN 包，用来关闭客户端到服务端的数据传送。</li><li>第二次挥手 - 服务端收到这个 FIN 包，向客户端发送一个 ACK 包，确认序号为收到的序号加 1。和 SYN 一样，一个 FIN 将占用一个序号。</li><li>第三次挥手 - 服务端关闭与客户端的连接，向客户端发送一个 FIN 包。</li><li>第四次挥手 - 客户端向服务端发送 ACK 包，并将确认序号设置为收到序号加 1。</li></ol><p>（3）为什么建立连接是三次握手，关闭连接确是四次挥手呢？</p><ul><li>建立连接的时候， 服务器在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。</li><li>而关闭连接时，服务器收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接，因此，己方 ACK 和 FIN 一般都会分开发送，从而导致多了一次。</li></ul><h3 id="45-tcp-滑动窗口"><a class="markdownIt-Anchor" href="#45-tcp-滑动窗口"></a> 4.5. TCP 滑动窗口</h3><blockquote><p>❓ 问题：什么是滑动窗口？滑动窗口原理是什么？</p></blockquote><p>什么是滑动窗口？</p><p><strong>滑动窗口是 TCP 的一种控制网络流量的技术。</strong></p><p><strong>TCP 必需要解决的可靠传输以及包乱序（reordering）的问题</strong>，所以，TCP 必需要知道网络实际的数据处理带宽或是数据处理速度，这样才不会引起网络拥塞，导致丢包。</p><p>TCP 头里有一个字段叫 Window，又叫 Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。<strong>于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来</strong>。</p><p>滑动窗口原理是什么？</p><div align="center"><img src="http://dunwu.test.upcdn.net/snap/1559265819762.png!zp"/></div><ol><li>已发送已确认 - 数据流中最早的字节已经发送并得到确认。这些数据是站在发送端的角度来看的。上图中的 31 个字节已经发送并确认。</li><li>已发送但尚未确认 - 已发送但尚未得到确认的字节。发送方在确认之前，不认为这些数据已经被处理。上图中的 32 ~ 45 字节为第 2 类。</li><li>未发送而接收方已 Ready - 设备尚未将数据发出 ，但接收方根据最近一次关于发送方一次要发送多少字节确认自己有足够空间。发送方会立即尝试发送。上图中的 46 ~ 51 字节为第 3 类。</li><li>未发送而接收方 Not Ready - 由于接收方 not ready，还不允许将这部分数据发出。上图中的 52 以后的字节为第 4 类。</li></ol><div align="center"><img src="http://dunwu.test.upcdn.net/snap/1559265927658.png!zp"/></div><p>这张图片相对于上一张图片，滑动窗口偏移了 5 个字节，意味着有 5 个已发送的字节得到了确认。</p><h3 id="46-tcp-重传机制"><a class="markdownIt-Anchor" href="#46-tcp-重传机制"></a> 4.6. TCP 重传机制</h3><blockquote><p>❓ 问题：为什么需要重传机制？TCP 有哪些重传机制，原理是什么？</p></blockquote><p>TCP 要保证所有的数据包都可以到达，所以，必需要有重传机制。</p><p>TCP 重传机制主要有两种：</p><ul><li>超时重传机制</li><li>快速重传机制</li></ul><p>（1）超时重传机制</p><p>超时重传机制是指：发送数据包在一定的时间周期内没有收到相应的 ACK，等待一定的时间，超时之后就认为这个数据包丢失，就会重新发送。这个等待时间被称为 RTO(Retransmission TimeOut)，即重传超时时间。</p><p>没有确认的数据包不会从窗口中移走，定时器在重传时间到期内，每个片段的位置不变。</p><p>这种机制的重点是 RTO 的设置：</p><ul><li>RTO 设长了，重发就慢，丢了老半天才重发，没有效率，性能差；</li><li>RTO 设短了，会导致可能并没有丢就重发。于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发</li></ul><p>（2）快速重传机制</p><p>快速重传机制，实现了另外的一种丢包评定标准，即如果连续收到 3 次重复 ACK，发送方就认为这个 seq 的包丢失了，立刻进行重传。</p><p>当接收方收到乱序片段时，需要重复发送 ACK。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;网络通信知识点面经&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#网络通信知识点面经&quot;&gt;&lt;/a&gt; 网络通信知识点面经&lt;/h1&gt;
&lt;!-- TOC depthFrom:2 depthTo:4 --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="通信" scheme="https://dunwu.github.io/blog/categories/%E9%80%9A%E4%BF%A1/"/>
    
    
      <category term="通信" scheme="https://dunwu.github.io/blog/tags/%E9%80%9A%E4%BF%A1/"/>
    
      <category term="网络" scheme="https://dunwu.github.io/blog/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="application" scheme="https://dunwu.github.io/blog/tags/application/"/>
    
  </entry>
  
  <entry>
    <title>网络协议之 UDP</title>
    <link href="https://dunwu.github.io/blog/communication/udp/"/>
    <id>https://dunwu.github.io/blog/communication/udp/</id>
    <published>2019-05-31T03:51:00.000Z</published>
    <updated>2020-01-16T09:48:30.647Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2><div align="center"><img src="http://dunwu.test.upcdn.net/snap/1559263939493.png!zp"/></div><p>UDP 是无连接的。数据报（类似于数据包）只在数据报级别有保证。数据报可能会无序的到达目的地，也有可能会遗失。UDP 不支持拥塞控制。虽然不如 TCP 那样有保证，但 UDP 通常效率更高。</p><p>UDP 可以通过广播将数据报发送至子网内的所有设备。这对 <a href="https://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol" target="_blank" rel="noopener">DHCP</a> 很有用，因为子网内的设备还没有分配 IP 地址，而 IP 对于 TCP 是必须的。</p><p>UDP 可靠性更低但适合用在网络电话、视频聊天，流媒体和实时多人游戏上。</p><p>以下情况使用 UDP 代替 TCP：</p><ul><li>你需要低延迟</li><li>相对于数据丢失更糟的是数据延迟</li><li>你想实现自己的错误校正方法</li></ul><h3 id="udp-特点"><a class="markdownIt-Anchor" href="#udp-特点"></a> UDP 特点</h3><ol><li><strong>无连接的</strong>，即发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延。</li><li><strong>不保证可靠交付</strong>，因此主机不需要为此复杂的连接状态表</li><li><strong>面向报文的</strong>，意思是 UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界，在添加首部后向下交给 IP 层。</li><li><strong>没有阻塞控制</strong>，因此网络出现的拥塞不会使发送方的发送速率降低。</li><li><strong>支持一对一、一对多、多对一和多对多的交互通信</strong>，也即是提供广播和多播的功能。</li><li><strong>首部开销小</strong>，首部只有 8 个字节，分为四部分。</li></ol><h3 id="udp-应用场景"><a class="markdownIt-Anchor" href="#udp-应用场景"></a> UDP 应用场景</h3><ol><li>名字转换（DNS）</li><li>文件传送（TFTP）</li><li>路由选择协议（RIP）</li><li>IP 地址配置（BOOTP，DHTP）</li><li>网络管理（SNMP）</li><li>远程文件服务（NFS）</li><li>IP 电话</li><li>流式多媒体通信</li></ol><h2 id="udp-报文"><a class="markdownIt-Anchor" href="#udp-报文"></a> UDP 报文</h2><p>UDP 数据报分为数据字段和首部字段。<br />首部字段只有 8 个字节，由四个字段组成，每个字段的长度是 2 个字节。</p><p><strong>首部各字段意义</strong>：</p><ol><li><strong>源端口</strong>：源端口号，在需要对方回信时选用，不需要时可全 0.</li><li><strong>目的端口</strong>：目的端口号，在终点交付报文时必须要使用到。</li><li><strong>长度</strong>：UDP 用户数据报的长度，在只有首部的情况，其最小值是 8 。</li><li><strong>检验和</strong>：检测 UDP 用户数据报在传输中是否有错，有错就丢弃。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简介&quot;&gt;&lt;/a&gt; 简介&lt;/h2&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;http://dunwu.test.upcdn.net/snap/155926393949
      
    
    </summary>
    
    
      <category term="通信" scheme="https://dunwu.github.io/blog/categories/%E9%80%9A%E4%BF%A1/"/>
    
    
      <category term="通信" scheme="https://dunwu.github.io/blog/tags/%E9%80%9A%E4%BF%A1/"/>
    
      <category term="网络" scheme="https://dunwu.github.io/blog/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="协议" scheme="https://dunwu.github.io/blog/tags/%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>网络协议之 Websocket</title>
    <link href="https://dunwu.github.io/blog/communication/websocket/"/>
    <id>https://dunwu.github.io/blog/communication/websocket/</id>
    <published>2019-05-31T03:51:00.000Z</published>
    <updated>2020-01-19T04:32:03.171Z</updated>
    
    <content type="html"><![CDATA[<h1 id="socket-和-websocket"><a class="markdownIt-Anchor" href="#socket-和-websocket"></a> Socket 和 WebSocket</h1><h2 id="socket"><a class="markdownIt-Anchor" href="#socket"></a> Socket</h2><p>Socket 作为一种抽象层，应用程序通过它来发送和接收数据，使用 Socket 可以将应用程序与处于同一网络中的其他应用程序进行通信交互。简而言之，Socket 提供了应用程序内部与外界通信的端口以及为通信双方提供了数据传输的通道。</p><h3 id="socket-用法"><a class="markdownIt-Anchor" href="#socket-用法"></a> Socket 用法</h3><p>很多编程语言都支持 Socket。这里以 Java 的 Socket 用法为例。</p><p>在 Java 的 SDK 中，socket 的共有两个接口：用于监听客户连接的 <code>ServerSocket</code> 和用于通信的 <code>Socket</code>。使用 socket 的步骤如下：</p><ul><li>创建 <code>ServerSocket</code> 并监听客户连接</li><li>使用 <code>Socket</code> 连接服务端</li><li>通过 <code>Socket</code> 获取输入输出流进行通信</li></ul><h3 id="socket-长连接"><a class="markdownIt-Anchor" href="#socket-长连接"></a> Socket 长连接</h3><p>Socket 长连接，指的是在客户和服务端之间保持一个 socket 连接长时间不断开。</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">socket.set<span class="constructor">KeepAlive(<span class="params">true</span>)</span>;</span><br></pre></td></tr></table></figure><h2 id="websocket"><a class="markdownIt-Anchor" href="#websocket"></a> WebSocket</h2><h3 id="websocket-简介"><a class="markdownIt-Anchor" href="#websocket-简介"></a> WebSocket 简介</h3><h4 id="websocket-是什么"><a class="markdownIt-Anchor" href="#websocket-是什么"></a> WebSocket 是什么</h4><p><a href="http://websocket.org/" target="_blank" rel="noopener">WebSocket</a> 是一种网络通信协议。<a href="https://tools.ietf.org/html/rfc6455" target="_blank" rel="noopener">RFC6455</a> 定义了它的通信标准。</p><p>WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。</p><h4 id="为什么需要-websocket"><a class="markdownIt-Anchor" href="#为什么需要-websocket"></a> 为什么需要 WebSocket</h4><p>了解计算机网络协议的人，应该都知道：HTTP 协议是一种无状态的、无连接的、单向的应用层协议。它采用了请求/响应模型。通信请求只能由客户端发起，服务端对请求做出应答处理。</p><p>这种通信模型有一个弊端：HTTP 协议无法实现服务器主动向客户端发起消息。</p><p>这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。大多数 Web 应用程序将通过频繁的异步 JavaScript 和 XML（AJAX）请求实现长轮询。轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/java/spring/web/ajax-long-polling.png!zp"/></div>因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的。WebSocket 连接允许客户端和服务器之间进行全双工通信，以便任一方都可以通过建立的连接将数据推送到另一端。WebSocket 只需要建立一次连接，就可以一直保持连接状态。这相比于轮询方式的不停建立连接显然效率要大大提高。<div align="center"><img src="http://dunwu.test.upcdn.net/cs/java/spring/web/websockets-flow.png!zp"/></div>#### WebSocket 如何工作<p>Web 浏览器和服务器都必须实现 WebSockets 协议来建立和维护连接。由于 WebSockets 连接长期存在，与典型的 HTTP 连接不同，对服务器有重要的影响。</p><p>基于多线程或多进程的服务器无法适用于 WebSockets，因为它旨在打开连接，尽可能快地处理请求，然后关闭连接。任何实际的 WebSockets 服务器端实现都需要一个异步服务器。</p><h3 id="websocket-使用"><a class="markdownIt-Anchor" href="#websocket-使用"></a> WebSocket 使用</h3><h4 id="websocket-客户端"><a class="markdownIt-Anchor" href="#websocket-客户端"></a> WebSocket 客户端</h4><p>在客户端，没有必要为 WebSockets 使用 JavaScript 库。实现 WebSockets 的 Web 浏览器将通过 WebSockets 对象公开所有必需的客户端功能（主要指支持 Html5 的浏览器）。</p><p>以下 API 用于创建 WebSocket 对象。</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">var Socket = <span class="keyword">new</span> <span class="constructor">WebSocket(<span class="params">url</span>, [<span class="params">protocol</span>] )</span>;</span><br></pre></td></tr></table></figure><p>以上代码中的第一个参数 url, 指定连接的 URL。第二个参数 protocol 是可选的，指定了可接受的子协议。</p><h5 id="websocket-属性"><a class="markdownIt-Anchor" href="#websocket-属性"></a> WebSocket 属性</h5><p>以下是 WebSocket 对象的属性。假定我们使用了以上代码创建了 Socket 对象：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>Socket.readyState</td><td>只读属性 <strong>readyState</strong> 表示连接状态，可以是以下值：0 - 表示连接尚未建立。1 - 表示连接已建立，可以进行通信。2 - 表示连接正在进行关闭。3 - 表示连接已经关闭或者连接不能打开。</td></tr><tr><td>Socket.bufferedAmount</td><td>只读属性 <strong>bufferedAmount</strong> 已被 send() 放入正在队列中等待传输，但是还没有发出的 UTF-8 文本字节数。</td></tr></tbody></table><h5 id="websocket-事件"><a class="markdownIt-Anchor" href="#websocket-事件"></a> WebSocket 事件</h5><p>以下是 WebSocket 对象的相关事件。假定我们使用了以上代码创建了 Socket 对象：</p><table><thead><tr><th>事件</th><th>事件处理程序</th><th>描述</th></tr></thead><tbody><tr><td>open</td><td>Socket.onopen</td><td>连接建立时触发</td></tr><tr><td>message</td><td>Socket.onmessage</td><td>客户端接收服务端数据时触发</td></tr><tr><td>error</td><td>Socket.onerror</td><td>通信发生错误时触发</td></tr><tr><td>close</td><td>Socket.onclose</td><td>连接关闭时触发</td></tr></tbody></table><h5 id="websocket-方法"><a class="markdownIt-Anchor" href="#websocket-方法"></a> WebSocket 方法</h5><p>以下是 WebSocket 对象的相关方法。假定我们使用了以上代码创建了 Socket 对象：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>Socket.send()</td><td>使用连接发送数据</td></tr><tr><td>Socket.close()</td><td>关闭连接</td></tr></tbody></table><p>WebSocket 客户端代码示例：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化一个 WebSocket 对象</span></span><br><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:9998/echo'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立 web socket 连接成功触发事件</span></span><br><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 使用 send() 方法发送数据</span></span><br><span class="line">ws.send(<span class="string">'发送数据'</span>)</span><br><span class="line">alert(<span class="string">'数据发送中...'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收服务端数据时触发事件</span></span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> received_msg = evt.data</span><br><span class="line">alert(<span class="string">'数据已接收...'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 断开 web socket 连接成功触发事件</span></span><br><span class="line">ws.onclose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">alert(<span class="string">'连接已关闭...'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="websocket-服务端"><a class="markdownIt-Anchor" href="#websocket-服务端"></a> WebSocket 服务端</h4><p>WebSocket 在服务端的实现非常丰富。Node.js、Java、C++、Python 等多种语言都有自己的解决方案。</p><p>以下，介绍我在学习 WebSocket 过程中接触过的 WebSocket 服务端解决方案。</p><h5 id="nodejs"><a class="markdownIt-Anchor" href="#nodejs"></a> Node.js</h5><p>常用的 Node 实现有以下三种。</p><ul><li><a href="https://github.com/uWebSockets/uWebSockets" target="_blank" rel="noopener">µWebSockets</a></li><li><a href="http://socket.io/" target="_blank" rel="noopener">Socket.IO</a></li><li><a href="https://github.com/theturtle32/WebSocket-Node" target="_blank" rel="noopener">WebSocket-Node</a></li></ul><h5 id="java"><a class="markdownIt-Anchor" href="#java"></a> Java</h5><p>Java 的 web 一般都依托于 servlet 容器。</p><p>我使用过的 servlet 容器有：Tomcat、Jetty、Resin。其中 Tomcat7、Jetty7 及以上版本均开始支持 WebSocket（推荐较新的版本，因为随着版本的更迭，对 WebSocket 的支持可能有变更）。</p><p>此外，Spring 框架对 WebSocket 也提供了支持。</p><p>虽然，以上应用对于 WebSocket 都有各自的实现。但是，它们都遵循<a href="https://tools.ietf.org/html/rfc6455" target="_blank" rel="noopener">RFC6455</a> 的通信标准，并且 Java API 统一遵循 <a href="http://www.jcp.org/en/jsr/detail?id=356" target="_blank" rel="noopener">JSR 356 - JavaTM API for WebSocket </a> 规范。所以，在实际编码中，API 差异不大。</p><h5 id="spring"><a class="markdownIt-Anchor" href="#spring"></a> Spring</h5><p>Spring 对于 WebSocket 的支持基于下面的 jar 包：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 Spring 实现 WebSocket 服务器大概分为以下几步：</p><p><strong>创建 WebSocket 处理器</strong></p><p>扩展 <code>TextWebSocketHandler</code> 或 <code>BinaryWebSocketHandler</code> ，你可以覆写指定的方法。Spring 在收到 WebSocket 事件时，会自动调用事件对应的方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.socket.WebSocketHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.WebSocketSession;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.TextMessage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">TextWebSocketHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleTextMessage</span><span class="params">(WebSocketSession session, TextMessage message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>WebSocketHandler</code> 源码如下，这意味着你的处理器大概可以处理哪些 WebSocket 事件：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WebSocketHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 建立连接后触发的回调</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">afterConnectionEstablished</span><span class="params">(WebSocketSession session)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 收到消息时触发的回调</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(WebSocketSession session, WebSocketMessage&lt;?&gt; message)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 传输消息出错时触发的回调</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">handleTransportError</span><span class="params">(WebSocketSession session, Throwable exception)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 断开连接后触发的回调</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">afterConnectionClosed</span><span class="params">(WebSocketSession session, CloseStatus closeStatus)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 是否处理分片消息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">supportsPartialMessages</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>配置 WebSocket</strong></p><p>配置有两种方式：注解和 xml 。其作用就是将 WebSocket 处理器添加到注册中心。</p><ol><li>实现 <code>WebSocketConfigurer</code></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.EnableWebSocket;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.WebSocketConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocket</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title">WebSocketConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerWebSocketHandlers</span><span class="params">(WebSocketHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addHandler(myHandler(), <span class="string">"/myHandler"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebSocketHandler <span class="title">myHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>xml 方式</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:websocket</span>=<span class="string">"http://www.springframework.org/schema/websocket"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/websocket</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/websocket/spring-websocket.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">websocket:handlers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">websocket:mapping</span> <span class="attr">path</span>=<span class="string">"/myHandler"</span> <span class="attr">handler</span>=<span class="string">"myHandler"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">websocket:handlers</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myHandler"</span> <span class="attr">class</span>=<span class="string">"org.springframework.samples.MyHandler"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>更多配置细节可以参考：<a href="https://docs.spring.io/spring/docs/4.3.12.RELEASE/spring-framework-reference/htmlsingle/#websocket" target="_blank" rel="noopener">Spring WebSocket 文档</a></p></blockquote><p>javax.websocket</p><p>如果不想使用 Spring 框架的 WebSocket API，你也可以选择基本的 javax.websocket。</p><p>首先，需要引入 API jar 包。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- To write basic javax.websocket against --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.websocket<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.websocket-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果使用嵌入式 jetty，你还需要引入它的实现包：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- To run javax.websocket in embedded server --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty.websocket<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax-websocket-server-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jetty-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- To run javax.websocket client --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty.websocket<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax-websocket-client-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jetty-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>@ServerEndpoint</strong></p><p>这个注解用来标记一个类是 WebSocket 的处理器。</p><p>然后，你可以在这个类中使用下面的注解来表明所修饰的方法是触发事件的回调</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 收到消息触发事件</span></span><br><span class="line"><span class="meta">@OnMessage</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String message, Session session)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开连接触发事件</span></span><br><span class="line"><span class="meta">@OnOpen</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpen</span><span class="params">(Session session, EndpointConfig config, @PathParam(<span class="string">"id"</span>)</span> String id) </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭连接触发事件</span></span><br><span class="line"><span class="meta">@OnClose</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">(Session session, CloseReason closeReason)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传输消息错误触发事件</span></span><br><span class="line"><span class="meta">@OnError</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable error)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ServerEndpointConfig.Configurator</strong></p><p>编写完处理器，你需要扩展 ServerEndpointConfig.Configurator 类完成配置：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketServerConfigurator</span> <span class="keyword">extends</span> <span class="title">ServerEndpointConfig</span>.<span class="title">Configurator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modifyHandshake</span><span class="params">(ServerEndpointConfig sec, HandshakeRequest request, HandshakeResponse response)</span> </span>&#123;</span><br><span class="line">        HttpSession httpSession = (HttpSession) request.getHttpSession();</span><br><span class="line">        sec.getUserProperties().put(HttpSession<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>(), <span class="title">httpSession</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就没有然后了，就是这么简单。</p><h4 id="websocket-代理"><a class="markdownIt-Anchor" href="#websocket-代理"></a> WebSocket 代理</h4><p>如果把 WebSocket 的通信看成是电话连接，Nginx 的角色则像是电话接线员，负责将发起电话连接的电话转接到指定的客服。</p><p>Nginx 从 <a href="http://nginx.com/blog/websocket-nginx/" target="_blank" rel="noopener">1.3 版</a>开始正式支持 WebSocket 代理。如果你的 web 应用使用了代理服务器 Nginx，那么你还需要为 Nginx 做一些配置，使得它开启 WebSocket 代理功能。</p><p>以下为参考配置：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">  <span class="comment"># this section is specific to the WebSockets proxying</span></span><br><span class="line">  <span class="attribute">location</span> /socket.io &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://app_server_wsgiapp/socket.io;</span><br><span class="line">    <span class="attribute">proxy_redirect</span> <span class="literal">off</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> Connection <span class="string">"upgrade"</span>;</span><br><span class="line">    <span class="attribute">proxy_read_timeout</span> <span class="number">600</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>更多配置细节可以参考：<a href="http://nginx.org/en/docs/http/websocket.html" target="_blank" rel="noopener">Nginx 官方的 websocket 文档</a></p></blockquote><h4 id="websocket-应用示例"><a class="markdownIt-Anchor" href="#websocket-应用示例"></a> WebSocket 应用示例</h4><p>如果需要完整示例代码，可以参考我的 Github 代码：</p><ul><li><a href="https://github.com/dunwu/spring-notes/tree/master/codes/web/websocket" target="_blank" rel="noopener">Spring 对 WebSocket 支持的示例</a></li><li><a href="https://github.com/dunwu/javaee-notes/tree/master/codes/websocket" target="_blank" rel="noopener">嵌入式 Jetty 服务器的 WebSocket 示例</a></li></ul><p>spring-websocket 和 jetty 9.3 版本似乎存在兼容性问题，Tomcat 则木有问题。</p><p>我尝试了好几次，没有找到解决方案，只好使用 Jetty 官方的嵌入式示例在 Jetty 中使用 WebSocket 。</p><h2 id="faq"><a class="markdownIt-Anchor" href="#faq"></a> FAQ</h2><h3 id="http-vs-socket"><a class="markdownIt-Anchor" href="#http-vs-socket"></a> Http vs. Socket</h3><p>Http 通信与 Socket 通信方式有何差异？</p><ul><li>Http<ul><li>基于请求/响应模式，采取一问一答方式（客户端请求，服务端才会响应）</li></ul></li><li>Socket<ul><li>客户端和服务端建立双向连接。连接成功后，任意一方都可主动发送消息。</li><li>数据丢失率低，使用简单，易于移植。</li></ul></li></ul><h3 id="http-和-websocket-有什么关系"><a class="markdownIt-Anchor" href="#http-和-websocket-有什么关系"></a> HTTP 和 WebSocket 有什么关系？</h3><p>Websocket 其实是一个新协议，跟 HTTP 协议基本没有关系，只是为了兼容现有浏览器的握手规范而已，也就是说它是 HTTP 协议上的一种补充。</p><h3 id="html-和-http-有什么关系"><a class="markdownIt-Anchor" href="#html-和-http-有什么关系"></a> Html 和 HTTP 有什么关系？</h3><p>Html 是超文本标记语言，是一种用于创建网页的标准标记语言。它是一种技术标准。Html5 是它的最新版本。</p><p>Http 是一种网络通信协议。其本身和 Html 没有直接关系。</p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ul><li><a href="https://www.zhihu.com/question/20215561" target="_blank" rel="noopener">知乎高票答案——WebSocket 是什么原理</a> - 对 WebSocket 原理的阐述简单易懂。</li><li><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" rel="noopener">WebSocket 教程</a> - 阮一峰大神的科普一如既往的浅显易懂。</li><li><a href="https://www.fullstackpython.com/websockets.html" target="_blank" rel="noopener">WebSockets</a> - by <em>fullstackpython</em></li><li><a href="http://nginx.org/en/docs/http/websocket.html" target="_blank" rel="noopener">Nginx 官方的 websocket 文档</a></li><li><a href="https://docs.spring.io/spring/docs/4.3.12.RELEASE/spring-framework-reference/htmlsingle/#websocket" target="_blank" rel="noopener">Spring WebSocket 文档</a></li><li><a href="http://tomcat.apache.org/tomcat-7.0-doc/web-socket-howto.html" target="_blank" rel="noopener">Tomcat7 WebSocket 文档</a></li><li><a href="https://www.eclipse.org/jetty/documentation/9.4.7.v20170914/websocket-intro.html" target="_blank" rel="noopener">Jetty WebSocket 文档</a></li><li><a href="https://juejin.im/post/57f885370bd1d00058b37d74" target="_blank" rel="noopener">Socket，你需要知道的事儿</a></li><li><a href="https://juejin.im/post/5b3649d751882552f052703b" target="_blank" rel="noopener">手把手教你写 Socket 长连接</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;socket-和-websocket&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#socket-和-websocket&quot;&gt;&lt;/a&gt; Socket 和 WebSocket&lt;/h1&gt;
&lt;h2 id=&quot;socket&quot;&gt;&lt;a class=&quot;m
      
    
    </summary>
    
    
      <category term="通信" scheme="https://dunwu.github.io/blog/categories/%E9%80%9A%E4%BF%A1/"/>
    
    
      <category term="通信" scheme="https://dunwu.github.io/blog/tags/%E9%80%9A%E4%BF%A1/"/>
    
      <category term="网络" scheme="https://dunwu.github.io/blog/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="协议" scheme="https://dunwu.github.io/blog/tags/%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>网络协议之 TCP</title>
    <link href="https://dunwu.github.io/blog/communication/tcp/"/>
    <id>https://dunwu.github.io/blog/communication/tcp/</id>
    <published>2019-05-31T03:51:00.000Z</published>
    <updated>2020-01-16T09:48:30.646Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2><h3 id="什么是-tcp"><a class="markdownIt-Anchor" href="#什么是-tcp"></a> 什么是 TCP</h3><p><strong>TCP（Transmission Control Protocol），即传输控制协议，它是一种<code>面向连接的</code>、<code>可靠的</code>、<code>基于字节流的</code>传输层通信协议</strong>。TCP 由 RFC 793 定义。</p><div align="center"><img src="http://dunwu.test.upcdn.net/snap/1559263786555.png!zp"/></div><h3 id="tcp-的特性"><a class="markdownIt-Anchor" href="#tcp-的特性"></a> TCP 的特性</h3><ul><li><code>面向连接的</code> - 面向连接是指 TCP 需要通过三次握手、四次挥手原则建立和断开双向连接。</li><li><code>可靠的</code> - 可靠是指 TCP 传输的数据包保证以原始顺序到达目的地，且数据包不被损坏。为了实现这点，TCP 通过以下技术来保证：<ul><li>数据包的序列号和校验码</li><li>确认包和自动重传<ul><li>如果发送者没有收到正确的响应，它将重新发送数据包。如果多次超时，连接就会断开。</li><li>TCP 实行流量控制和拥塞控制。这些确保措施会导致延迟，而且通常导致传输效率比 UDP 低。</li></ul></li></ul></li><li><code>基于字节流的</code><ul><li>虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序看成是一连串的无结构的字节流。TCP 有一个缓冲，当应用程序传送的数据块太长，TCP 就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP 也可以等待积累有足够多的字节后再构成报文段发送出去。</li><li>在 TCP 建立连接前两次握手的 SYN 报文中选项字段的 MSS 值，通信双方商定通信的最大报文长度。如果应用层交付下来的数据过大，就会对数据分段，然后发送；否则通过滑动窗口来控制通信双发的数据。</li></ul></li></ul><h3 id="tcp-的适用场景"><a class="markdownIt-Anchor" href="#tcp-的适用场景"></a> TCP 的适用场景</h3><p>基于以上特性，为了确保高吞吐量，Web 服务器可以保持大量的 TCP 连接，从而导致高内存使用。但要注意的是，在 Web 服务器线程间拥有大量开放连接可能开销巨大，消耗资源过多，这时可以考虑在适用情况下切换到 UDP。</p><p>TCP 对于需要高可靠性但时间紧迫的应用程序很有用。比如包括 Web 服务器，数据库信息，SMTP，FTP 和 SSH。</p><p>以下情况使用 TCP 代替 UDP：</p><ul><li>你需要数据完好无损。</li><li>你想对网络吞吐量自动进行最佳评估。</li></ul><h3 id="tcp-报文"><a class="markdownIt-Anchor" href="#tcp-报文"></a> TCP 报文</h3><div align="center"><img src="http://dunwu.test.upcdn.net/snap/1559264511812.png!zp"/></div><p>报文字段不一一阐述，重点关注以下几点：</p><ul><li>TCP 的包是没有 IP 地址的，那是 IP 层上的事。但是有源端口和目标端口。</li><li>一个 TCP 连接需要四个元组来表示是同一个连接（src_ip, src_port, dst_ip, dst_port）准确说是五元组，还有一个是协议。但因为这里只是说 TCP 协议，所以，这里我只说四元组。</li><li>注意上图中的四个非常重要的东西：<ul><li><strong>Sequence Number</strong>是包的序号，<strong>用来解决网络包乱序（reordering）问题。</strong></li><li><strong>Acknowledgement Number</strong>就是 ACK——用于确认收到，<strong>用来解决不丢包的问题</strong>。</li><li><strong>Window 又叫 Advertised-Window</strong>，也就是著名的滑动窗口（Sliding Window），<strong>用于解决流控的</strong>。</li><li><strong>TCP Flag</strong>，也就是包的类型，<strong>主要是用于操控 TCP 的状态机的</strong>。</li></ul></li></ul><div align="center"><img src="http://dunwu.test.upcdn.net/snap/1559264593860.png!zp"/></div><h2 id="tcp-通信流程"><a class="markdownIt-Anchor" href="#tcp-通信流程"></a> TCP 通信流程</h2><div align="center"><img src="http://dunwu.test.upcdn.net/snap/1559264679371.png!zp"/></div><p>TCP 完整的通信分为三块：</p><ol><li>三次握手建立连接</li><li>数据传输</li><li>四次挥手端口连接</li></ol><h3 id="三次握手"><a class="markdownIt-Anchor" href="#三次握手"></a> 三次握手</h3><p>（1）三次握手有什么用？</p><ul><li>三次握手负责建立 TCP 双向连接。</li></ul><p>（2）什么是三次握手？</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/transport/三次握手.gif!zp"/></div><p>如上图所示，三次握手流程如下：</p><ol><li>第一次握手 - 客户端向服务端发送带有 SYN 标志的数据包。</li><li>第二次握手 - 服务端向客户端发送带有 SYN/ACK 标志的数据包。</li><li>第三次握手 - 客户端向服务端发送带有带有 ACK 标志的数据包。</li></ol><p>至此，TCP 三次握手完成，客户端与服务端已建立双向连接。</p><blockquote><p>💡 说明：SYN 为 synchronize 的缩写，ACK 为 acknowledgment 的缩写。</p></blockquote><p>（3）为什么需要三次握手？</p><p>为了便于说明，假设客户端为 A, 服务端为 B。</p><ol><li>第一次握手，A 向 B 发同步消息。B 收到消息后，B 认为：A 发消息没问题；B 收消息没问题。</li><li>第二次握手，B 向 A 发同步消息和确认消息。A 收到消息后，A 认为：A 发消息、收消息都没问题；B 发消息、收消息都没问题。<strong>但是，此时 B 不确定自己发消息是否没问题</strong>，所以就需要第三次握手。</li><li>第三次握手，A 向 B 发确认消息。B 收到消息后。B 认为：B 发消息没问题。</li></ol><h3 id="四次挥手"><a class="markdownIt-Anchor" href="#四次挥手"></a> 四次挥手</h3><p>（1）四次挥手有什么用？</p><ul><li>四次挥手负责断开 TCP 连接。</li></ul><p>（2）什么是四次挥手？</p><p>如上图所示，四次挥手流程如下：</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/transport/四次挥手.gif!zp"/></div><ol><li>第一次挥手 - 客户端向服务端发送一个 FIN 包，用来关闭客户端到服务端的数据传送。</li><li>第二次挥手 - 服务端收到这个 FIN 包，向客户端发送一个 ACK 包，确认序号为收到的序号加 1。和 SYN 一样，一个 FIN 将占用一个序号。</li><li>第三次挥手 - 服务端关闭与客户端的连接，向客户端发送一个 FIN 包。</li><li>第四次挥手 - 客户端向服务端发送 ACK 包，并将确认序号设置为收到序号加 1。</li></ol><p>（3）为什么建立连接是三次握手，关闭连接确是四次挥手呢？</p><ul><li>建立连接的时候， 服务器在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。</li><li>而关闭连接时，服务器收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接，因此，己方 ACK 和 FIN 一般都会分开发送，从而导致多了一次。</li></ul><h2 id="滑动窗口"><a class="markdownIt-Anchor" href="#滑动窗口"></a> 滑动窗口</h2><p>什么是滑动窗口？</p><p><strong>滑动窗口是 TCP 的一种控制网络流量的技术。</strong></p><p><strong>TCP 必需要解决的可靠传输以及包乱序（reordering）的问题</strong>，所以，TCP 必需要知道网络实际的数据处理带宽或是数据处理速度，这样才不会引起网络拥塞，导致丢包。</p><p>TCP 头里有一个字段叫 Window，又叫 Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。<strong>于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来</strong>。</p><p>滑动窗口原理是什么？</p><div align="center"><img src="http://dunwu.test.upcdn.net/snap/1559265819762.png!zp"/></div><ol><li>已发送已确认 - 数据流中最早的字节已经发送并得到确认。这些数据是站在发送端的角度来看的。上图中的 31 个字节已经发送并确认。</li><li>已发送但尚未确认 - 已发送但尚未得到确认的字节。发送方在确认之前，不认为这些数据已经被处理。上图中的 32 ~ 45 字节为第 2 类。</li><li>未发送而接收方已 Ready - 设备尚未将数据发出 ，但接收方根据最近一次关于发送方一次要发送多少字节确认自己有足够空间。发送方会立即尝试发送。上图中的 46 ~ 51 字节为第 3 类。</li><li>未发送而接收方 Not Ready - 由于接收方 not ready，还不允许将这部分数据发出。上图中的 52 以后的字节为第 4 类。</li></ol><div align="center"><img src="http://dunwu.test.upcdn.net/snap/1559265927658.png!zp"/></div><p>这张图片相对于上一张图片，滑动窗口偏移了 5 个字节，意味着有 5 个已发送的字节得到了确认。</p><h2 id="tcp-重传机制"><a class="markdownIt-Anchor" href="#tcp-重传机制"></a> TCP 重传机制</h2><p>TCP 要保证所有的数据包都可以到达，所以，必需要有重传机制。</p><p>TCP 重传机制主要有两种：</p><ul><li>超时重传机制</li><li>快速重传机制</li></ul><h3 id="超时重传机制"><a class="markdownIt-Anchor" href="#超时重传机制"></a> 超时重传机制</h3><p>超时重传机制是指：发送数据包在一定的时间周期内没有收到相应的 ACK，等待一定的时间，超时之后就认为这个数据包丢失，就会重新发送。这个等待时间被称为 RTO(Retransmission TimeOut)，即重传超时时间。</p><p>没有确认的数据包不会从窗口中移走，定时器在重传时间到期内，每个片段的位置不变。</p><p>这种机制的重点是 RTO 的设置：</p><ul><li>RTO 设长了，重发就慢，丢了老半天才重发，没有效率，性能差；</li><li>RTO 设短了，会导致可能并没有丢就重发。于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发</li></ul><h3 id="快速重传机制"><a class="markdownIt-Anchor" href="#快速重传机制"></a> 快速重传机制</h3><p>快速重传机制，实现了另外的一种丢包评定标准，即如果连续收到 3 次重复 ACK，发送方就认为这个 seq 的包丢失了，立刻进行重传。</p><p>当接收方收到乱序片段时，需要重复发送 ACK。</p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ul><li><a href="https://coolshell.cn/articles/11564.html" target="_blank" rel="noopener">TCP 的那些事儿（上）</a></li><li><a href="https://coolshell.cn/articles/11609.html" target="_blank" rel="noopener">TCP 的那些事儿（下）</a></li><li><a href="https://juejin.im/post/5a7835a46fb9a063606eb801" target="_blank" rel="noopener">图解 TCP 三次握手与四次分手</a></li><li><a href="https://blog.csdn.net/qzcsu/article/details/72861891" target="_blank" rel="noopener">TCP 的三次握手与四次挥手（详解+动图）</a></li><li><a href="https://blog.csdn.net/sinat_36629696/article/details/80740678" target="_blank" rel="noopener">TCP 详解</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简介&quot;&gt;&lt;/a&gt; 简介&lt;/h2&gt;
&lt;h3 id=&quot;什么是-tcp&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#什么是-tcp&quot;&gt;&lt;/a&gt; 什么是 TCP&lt;
      
    
    </summary>
    
    
      <category term="通信" scheme="https://dunwu.github.io/blog/categories/%E9%80%9A%E4%BF%A1/"/>
    
    
      <category term="通信" scheme="https://dunwu.github.io/blog/tags/%E9%80%9A%E4%BF%A1/"/>
    
      <category term="网络" scheme="https://dunwu.github.io/blog/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="协议" scheme="https://dunwu.github.io/blog/tags/%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>网络通信之 CDN</title>
    <link href="https://dunwu.github.io/blog/communication/cdn/"/>
    <id>https://dunwu.github.io/blog/communication/cdn/</id>
    <published>2019-05-29T15:19:00.000Z</published>
    <updated>2020-01-16T09:48:30.632Z</updated>
    
    <content type="html"><![CDATA[<div align="center"><img src="http://dunwu.test.upcdn.net/snap/1559138689425.png!zp"/></div><h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2><h3 id="cdn-是什么"><a class="markdownIt-Anchor" href="#cdn-是什么"></a> CDN 是什么</h3><p>CDN(<strong>Content Delivery Network</strong>)，即<strong>内容分发网络</strong>。</p><p>CDN 是一个全球性的代理服务器分布式网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。它从靠近用户的位置提供内容。通常，HTML/CSS/JS，图片和视频等静态内容由 CDN 提供。CDN 的 DNS 解析会告知客户端连接哪台服务器。CDN 的关键技术主要有内容存储和分发技术。</p><h3 id="cdn-的优缺点"><a class="markdownIt-Anchor" href="#cdn-的优缺点"></a> CDN 的优缺点</h3><ul><li>优点<ul><li><strong>访问加速</strong> - 由于 CDN 就近服务，大大降低了网络传播时延，所以自然提高了访问速度。</li><li><strong>降低负载</strong> - 如果 CDN 已经能获取数据，那么就不必请求源站，这自然降低了源站（服务器）的负载。</li></ul></li><li>缺点<ul><li>CDN 成本可能因流量而异，可能在权衡之后你将不会使用 CDN。</li><li>如果在 TTL 过期之前更新内容，CDN 缓存内容可能会过时。</li><li>CDN 需要更改静态内容的 URL 地址以指向 CDN。</li></ul></li></ul><h2 id="cdn-原理"><a class="markdownIt-Anchor" href="#cdn-原理"></a> CDN 原理</h2><p>CDN 的基本原理是：</p><ul><li>广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中；</li><li>在用户访问网站时，实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息来选择最佳缓存服务器；</li><li>然后，将用户的请求重新导向最佳的缓存服务器上，由缓存服务器直接响应用户请求。</li></ul><p>CDN 网络架构主要由两大部分，分为<strong>中心</strong>和<strong>边缘</strong>两部分：</p><ul><li>中心指 CDN 网管中心和 DNS 重定向解析中心，负责全局负载均衡，设备系统安装在管理中心机房；</li><li>边缘主要指异地节点，CDN 分发的载体，主要由 Cache 和负载均衡器等组成。</li></ul><p>CDN 是一个策略性部署的整体系统，包括<strong>分布式存储</strong>、<strong>负载均衡</strong>、<strong>内容管理</strong>和<strong>网络请求的重定向</strong>４个要件。</p><h3 id="分布式存储"><a class="markdownIt-Anchor" href="#分布式存储"></a> 分布式存储</h3><p>CDN 网络将存储资源分布到各个地理位置、各个网段。存储系统作为 CDN 系统密不可分的一部分，将 CDN 分发的文件和数据库表记录内容存储起来，提供持续服务。存储系统采用三级存储架构，包括核心存储、CDN 服务节点分布式缓存和终端本地缓存。任意一个点的存储崩溃或失效，并不影响系统服务的可用性。</p><div align="center"><img src="http://dunwu.test.upcdn.net/snap/1559140068433.png!zp"/></div><p>如 CDN 系统在 5 大运营商（中国电信、中国网通、中国铁通、中国移动、中国联通）以及 2 大专有网络（中国教育和科研计算机网、中国科技网）都布有 CDN 节点。<strong>这样就消除了不同运营商之间互联的瓶颈造成的影响，实现了跨运营商的网络加速，保证不同网络中的用户都能得到良好的访问质量。</strong></p><h3 id="内容管理"><a class="markdownIt-Anchor" href="#内容管理"></a> 内容管理</h3><p>内容管理和全局的网络流量管理(Traffic Management)是 CDN 的核心所在。<strong>通过用户就近性和服务器负载的判断，CDN 确保内容以一种极为高效的方式为用户的请求提供服务</strong>。总的来说，内容服务基于<strong>缓存服务器</strong>，也称作<strong>代理缓存(Surrogate)</strong>，它位于网络的边缘，距用户仅有&quot;一跳&quot;(Single Hop)之遥。同时，代理缓存是内容提供商源服务器（通常位于 CDN 服务提供商的数据中心）的一个透明镜像。这样的架构使得 CDN 服务提供商能够代表他们客户，即内容供应商，向最终用户提供尽可能好的体验，而这些用户是不能容忍请求响应时间有任何延迟的。据统计，采用 CDN 技术，能处理整个网站页面的 70%～ 95％的内容访问量，减轻服务器的压力，提升了网站的性能和可扩展性。</p><h3 id="负载均衡"><a class="markdownIt-Anchor" href="#负载均衡"></a> 负载均衡</h3><p>CDN 负载均衡系统实现 CDN 的<strong>内容路由功能</strong>。它的作用是将用户的请求导向整个 CDN 网络中的最佳节点。最佳节点的选定可以根据多种策略，例如<strong>距离最近</strong>、<strong>节点负载最轻</strong>等。负载均衡系统是整个 CDN 的核心，负载均衡的准确性和效率直接决定了整个 CDN 的效率和性能。通常负载均衡可以分为两个层次：<strong>全局负载均衡（GSLB）<strong>和</strong>本地负载均衡（SLB）</strong>。</p><h3 id="网络请求的重定向"><a class="markdownIt-Anchor" href="#网络请求的重定向"></a> 网络请求的重定向</h3><p>当用户访问了使用 CDN 服务的资源时，DNS 域名服务器通过 CNAME 方式将最终域名请求重定向到 CDN 系统中的智能 DNS 负载均衡系统。<strong>智能 DNS 负载均衡系统通过一组预先定义好的策略（如内容类型、地理区域、网络负载状况等），将当时能够最快响应用户的节点地址提供给用户，使用户可以得到快速的服务</strong>。</p><p>同时，它还与分布在不同地点的所有 CDN 节点保持通信，搜集各节点的健康状态，确保不将用户的请求分配到任何一个已经不可用的节点上。</p><blockquote><p>参考：</p><ul><li><a href="https://www.cnblogs.com/skynet/archive/2012/12/18/2824141.html" target="_blank" rel="noopener">CDN-内容推送网络</a></li><li><a href="https://zhuanlan.zhihu.com/p/39028766" target="_blank" rel="noopener">闲话 CDN</a></li></ul></blockquote><h2 id="cdn-访问流程"><a class="markdownIt-Anchor" href="#cdn-访问流程"></a> CDN 访问流程</h2><div align="center"><img src="http://dunwu.test.upcdn.net/snap/1559126750010.png!zp"/></div><ol><li>用户在浏览器中访问域名，域名解析的请求被发往网站的 DNS 域名解析服务器；</li><li>由于网站的 DNS 域名解析服务器对此域名的解析设置了 CNAME，请求被指向 CDN 网络中的智能 DNS 负载均衡系统；</li><li>智能 DNS 负载均衡系统对域名进行智能解析，将响应速度最快的节点 IP 返回给用户；浏览器在得到速度最快节点的 IP 地址以后，向 CDN 节点发出访问请求；</li><li>由于是第一次访问，CDN 节点将回到源站取用户请求的数据并发给用户；</li><li>当有其他用户再次访问同样内容时，CDN 将直接将数据返回给客户，完成请求/服务过程。</li></ol><p>同时，它还与分布在不同地点的所有 CDN 节点保持通信，搜集各节点的健康状态，确保不将用户的请求分配到任何一个已经不可用的节点上。</p><blockquote><p>参考：</p><ul><li><a href="https://www.cnblogs.com/skynet/archive/2012/12/18/2824141.html" target="_blank" rel="noopener">CDN-内容推送网络</a></li><li><a href="https://zhuanlan.zhihu.com/p/39028766" target="_blank" rel="noopener">闲话 CDN</a></li></ul></blockquote><h2 id="推送和拉取"><a class="markdownIt-Anchor" href="#推送和拉取"></a> 推送和拉取</h2><p>CDN 服务有推送和拉取两种方式：</p><h3 id="cdn-推送"><a class="markdownIt-Anchor" href="#cdn-推送"></a> CDN 推送</h3><p>当你服务器上内容发生变动时，推送 CDN 接受新内容。直接推送给 CDN 并重写 URL 地址以指向你的内容的 CDN 地址。你可以配置内容到期时间及何时更新。内容只有在更改或新增是才推送，流量最小化，但储存最大化。</p><p>优点在于节省源站带宽，提前将要分发的内容放到 CDN 节点上了，当某个流量高峰来临时，不会把你的源站带宽占满（源站还要留点带宽提供动态 HTML 啊）。</p><p>缺点是需要针对 CDN 做接口开发，在被分发内容生成时主动上传给 CDN。</p><h3 id="cdn-拉取"><a class="markdownIt-Anchor" href="#cdn-拉取"></a> CDN 拉取</h3><p>CDN 拉取是当第一个用户请求该资源时，从服务器上拉取资源。你将内容留在自己的服务器上并重写 URL 指向 CDN 地址。直到内容被缓存在 CDN 上为止，这样请求只会更慢，</p><p><a href="https://en.wikipedia.org/wiki/Time_to_live" target="_blank" rel="noopener">存活时间（TTL）</a>决定缓存多久时间。CDN 拉取方式最小化 CDN 上的储存空间，但如果过期文件并在实际更改之前被拉取，则会导致冗余的流量。</p><p>高流量站点使用 CDN 拉取效果不错，因为只有最近请求的内容保存在 CDN 中，流量才能更平衡地分散。</p><p>优点在于实现简单。</p><blockquote><p>参考：<a href="https://segmentfault.com/q/1010000000119794" target="_blank" rel="noopener">推送式与拉取式 CDN 服务的优劣问题</a></p></blockquote><h2 id="资源"><a class="markdownIt-Anchor" href="#资源"></a> 资源</h2><ul><li>文章<ul><li><a href="https://en.wikipedia.org/wiki/Content_delivery_network" target="_blank" rel="noopener">Wikipedia - CDN</a></li><li><a href="https://www.cnblogs.com/skynet/archive/2012/12/18/2824141.html" target="_blank" rel="noopener">CDN-内容推送网络</a></li><li><a href="https://zhuanlan.zhihu.com/p/39028766" target="_blank" rel="noopener">闲话 CDN</a></li><li><a href="https://www.cnblogs.com/losbyday/p/5843960.html" target="_blank" rel="noopener">CDN 技术详解</a></li><li><a href="https://segmentfault.com/q/1010000000119794" target="_blank" rel="noopener">推送式与拉取式 CDN 服务的优劣问题</a></li></ul></li><li>CDN 资源<ul><li><a href="https://staticfile.org/" target="_blank" rel="noopener">https://staticfile.org/</a></li><li><a href="https://unpkg.com/" target="_blank" rel="noopener">https://unpkg.com/</a></li><li><a href="https://cdnjs.com/" target="_blank" rel="noopener">https://cdnjs.com/</a></li><li><a href="https://github.com/ossrs/srs" target="_blank" rel="noopener">https://github.com/ossrs/srs</a></li><li><a href="https://github.com/jsdelivr/jsdelivr" target="_blank" rel="noopener">https://github.com/jsdelivr/jsdelivr</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;http://dunwu.test.upcdn.net/snap/1559138689425.png!zp&quot;/&gt;&lt;/div&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;
      
    
    </summary>
    
    
      <category term="通信" scheme="https://dunwu.github.io/blog/categories/%E9%80%9A%E4%BF%A1/"/>
    
    
      <category term="通信" scheme="https://dunwu.github.io/blog/tags/%E9%80%9A%E4%BF%A1/"/>
    
      <category term="网络" scheme="https://dunwu.github.io/blog/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Mac 常用技巧总结</title>
    <link href="https://dunwu.github.io/blog/os/mac/"/>
    <id>https://dunwu.github.io/blog/os/mac/</id>
    <published>2019-05-07T12:35:00.000Z</published>
    <updated>2019-11-22T03:31:57.012Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本操作"><a class="markdownIt-Anchor" href="#基本操作"></a> 基本操作</h2><h3 id="软件管理"><a class="markdownIt-Anchor" href="#软件管理"></a> 软件管理</h3><p>dmg 格式：双击安装包，然后拖到 applications 文件夹下即可。</p><h3 id="浏览器"><a class="markdownIt-Anchor" href="#浏览器"></a> 浏览器</h3><h4 id="更改默认搜索引擎"><a class="markdownIt-Anchor" href="#更改默认搜索引擎"></a> 更改默认搜索引擎</h4><p>选择「偏好设置–&gt;搜索–&gt;搜索引擎–&gt;Google」。</p><h4 id="导入-chrome-浏览器的书签"><a class="markdownIt-Anchor" href="#导入-chrome-浏览器的书签"></a> 导入 chrome 浏览器的书签</h4><p>选择「文件–&gt;导入自–&gt; Google Chrome」，然后选择要导入的项目。</p><h4 id="快捷键"><a class="markdownIt-Anchor" href="#快捷键"></a> 快捷键</h4><p>Command + R 刷新</p><h4 id="上方显示书签栏收藏栏"><a class="markdownIt-Anchor" href="#上方显示书签栏收藏栏"></a> 上方显示书签栏／收藏栏</h4><p>选择「显示–&gt; 显示个人收藏栏」。</p><h4 id="关闭软件的右上角通知"><a class="markdownIt-Anchor" href="#关闭软件的右上角通知"></a> 关闭软件的右上角通知</h4><p>在 Mac 系统中有对通知的设置，打开系统偏好设置 — 通知 找到 QQ，然后将 QQ 提示样式设置成无即可。</p><h4 id="复制文件文件夹路径"><a class="markdownIt-Anchor" href="#复制文件文件夹路径"></a> 复制文件/文件夹路径</h4><ul><li>OS X 10.11 系统，选中文件夹，「cmd +Option +c」 复制文件夹路径，cmd+v 粘贴。<br />之前的系统，利用 Administrator 创建一个到右键菜单，然后到设置里面设置快捷键。具体操作请百度。</li></ul><h4 id="打开来自身份不明的开发者的应用程序"><a class="markdownIt-Anchor" href="#打开来自身份不明的开发者的应用程序"></a> 打开来自身份不明的开发者的应用程序</h4><p>在应用程序文件夹，按住 control 键的同时打开应用程序。</p><h4 id="复制文件路径"><a class="markdownIt-Anchor" href="#复制文件路径"></a> 复制文件路径</h4><ul><li><p>选择文件／文件夹按 Command+C 复制，在终端中 Command+V 粘贴即可。</p></li><li><p>如果只是想在 Finder 中看到文件的路径, 并方便切换层级, Finder 内置了「显示路径栏」的功能, 并配置了快捷键(Option+Cmd+P). 如下图所示：</p></li></ul><p>20161124-184148.png</p><p>参考链接：</p><ul><li>[<a href="https://www.zhihu.com/question/22883229" target="_blank" rel="noopener">https://www.zhihu.com/question/22883229</a>]</li></ul><h3 id="隐藏和取消隐藏-mac-app-store-中的已购项目"><a class="markdownIt-Anchor" href="#隐藏和取消隐藏-mac-app-store-中的已购项目"></a> 隐藏和取消隐藏 Mac App Store 中的已购项目</h3><h3 id="mac-同时登陆两个-qq"><a class="markdownIt-Anchor" href="#mac-同时登陆两个-qq"></a> Mac 同时登陆两个 QQ</h3><p>在已经打开的 QQ 中，按住「command + N」即可。</p><h2 id="系统便好设置"><a class="markdownIt-Anchor" href="#系统便好设置"></a> 系统便好设置</h2><h3 id="语音播报"><a class="markdownIt-Anchor" href="#语音播报"></a> 语音播报</h3><p>打开「系统便好设置–&gt;辅助功能–&gt;语音」，即可设置不同国家的语言。</p><p>勾选上图中的红框部分，可以设置全局快捷键。这样的话，在任何一个软件当中，按下「 option+esc」时，就会朗读选中的文本。</p><h3 id="调整字体大小"><a class="markdownIt-Anchor" href="#调整字体大小"></a> 调整字体大小</h3><p>Mac 调整字体大小：「系统偏好设置 -&gt; 显示器 -&gt; 缩放」。如下图：</p><h3 id="如何分别设置-mac-的鼠标和触控板的滚动方向"><a class="markdownIt-Anchor" href="#如何分别设置-mac-的鼠标和触控板的滚动方向"></a> 如何分别设置 Mac 的鼠标和触控板的滚动方向</h3><p>很多人习惯鼠标使用相反的滚动方向，而触控板类似 iPad 那样的自然滚动，问如何设置，当时我的回答是不知道，因为目前 OS X 的系统设置里，鼠标和触控板的设置是统一<br />的。今天发现了一个免费的软件 Scroll Reverser，可以实现鼠标和触控板的分别设置。下载地址：<a href="https://pilotmoon.com/scrollreverser/" target="_blank" rel="noopener">https://pilotmoon.com/scrollreverser/</a><br />启动后程序显示在顶部菜单栏，设置简单明了，有需要的用户体验一下吧。</p><h3 id="touch-bar-自定义"><a class="markdownIt-Anchor" href="#touch-bar-自定义"></a> Touch Bar 自定义</h3><p>打开「系统偏好设置-键盘」，下面有个自定义控制条。</p><h3 id="色温调节夜间模式"><a class="markdownIt-Anchor" href="#色温调节夜间模式"></a> 色温调节：夜间模式</h3><p>iOS9.3 的最明显变化，莫过于苹果在发布会上特意提到的 Night Shift 夜间护眼模式。</p><h3 id="icloud-邮箱"><a class="markdownIt-Anchor" href="#icloud-邮箱"></a> iCloud 邮箱</h3><p>如果您用于设置 iCloud 的 Apple ID 不以“@icloud.com”、“@me.com”或“@mac.com”结尾，您必须先设置一个“@icloud.com”电子邮件地址，然后才能使用 iCloud“邮件”。</p><p>如果您拥有以“@mac.com”或“@me.com”结尾的电子邮件地址，则您已经拥有了名称相同但以“@icloud.com”结尾的等效地址。如果您使用的电子邮件别名以“@mac.com”或“@me.com”结尾，您也将拥有以“@icloud.com”结尾的等效地址。</p><p><strong>操作如下：</strong></p><ul><li><p>在 iOS 设备上，前往“设置”&gt;“iCloud”，开启“邮件”，然后按照屏幕上的说明操作。</p></li><li><p>在 Mac 上，选取 Apple 菜单 &gt;“系统偏好设置”，点按“iCloud”，再选择“邮件”，然后按照屏幕上的说明操作。</p></li></ul><p>PS：创建 iCloud 电子邮件地址后，您无法对其进行更改。</p><p>设置 @icloud.com 电子邮件地址后即可用其登录 iCloud。您也可以用创建 iCloud 帐户时所用的 Apple ID 登录。</p><p>您可以从以下任意地址发送 iCloud 电子邮件：</p><p>您的 iCloud 电子邮件地址（您的帐号名称@icloud.com）</p><p>别名</p><p>参考链接：</p><p><strong>直接注册以@icloud.com 结尾的 Apple ID：</strong></p><p>参考链接：</p><h2 id="podcast"><a class="markdownIt-Anchor" href="#podcast"></a> PodCast</h2><p>PodCast 中文翻译为播客，是一种特殊的音频 or 视频节目。PodCast 这个单词是由 iPod+Broadcast 这两个单词组成的。</p><p>PodCast 可以在 iTunes 中收听。</p><h2 id="others"><a class="markdownIt-Anchor" href="#others"></a> others</h2><h3 id="词典"><a class="markdownIt-Anchor" href="#词典"></a> 词典</h3><p>系统有一个自带应用「词典」，可以进行单词的查询。</p><h3 id="如何解决-mac-软件dmgakpapp出现程序已损坏的提示"><a class="markdownIt-Anchor" href="#如何解决-mac-软件dmgakpapp出现程序已损坏的提示"></a> 如何解决 MAC 软件（dmg，akp，app）出现程序已损坏的提示</h3><p>「xxx.app 已损坏,打不开.你应该将它移到废纸篓」，并非你安装的软件已损坏，而是 Mac 系统的安全设置问题，因为这些应用都是破解或者汉化的,那么解决方法就是临时改变 Mac 系统安全设置。</p><p>出现这个问题的解决方法：修改系统配置：系统偏好设置… -&gt; 安全性与隐私。修改为任何来源。</p><p>如果没有这个选项的话（macOS Sierra 10.12）,打开终端，执行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo spctl --master-disable</span><br></pre></td></tr></table></figure><p>即可。</p><p>参考链接：</p><ul><li><p><a href="http://www.jianshu.com/p/379b49b88df9" target="_blank" rel="noopener">Max OS-[xxx.app 已损坏,打不开.你应该将它移到废纸篓]</a></p></li><li><p><a href="http://www.yunrui.co/25693.html" target="_blank" rel="noopener">如何解决 MAC 软件（dmg，akp，app）出现程序已损坏的提示</a></p></li></ul><p>备注：这个链接里的各种资源都很不错啊。</p><h4 id="终端"><a class="markdownIt-Anchor" href="#终端"></a> 终端</h4><h4 id="在-finder-的当前目录打开终端"><a class="markdownIt-Anchor" href="#在-finder-的当前目录打开终端"></a> 在 Finder 的当前目录打开终端</h4><p>在 Finder 打开 terminal 终端这个功能其实是有的，但是系统默认没有打开。我们可以通过如下方法将其打开：</p><p>进入系统偏好设置-&gt;键盘-&gt;快捷键-&gt;服务。</p><p>在右边新建位于文件夹位置的终端窗口上打勾。</p><p>如此设置后，在 Finder 中右击某文件，在出现的菜单中找到服务，然后点击新建位于文件夹位置的终端窗口即可！</p><h2 id="mac-常用快捷键"><a class="markdownIt-Anchor" href="#mac-常用快捷键"></a> Mac 常用快捷键</h2><h3 id="finder"><a class="markdownIt-Anchor" href="#finder"></a> Finder</h3><table><thead><tr><th style="text-align:left">快捷键</th><th style="text-align:left">作用</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left">Shift + Command + G</td><td style="text-align:left">前往指定路径的文件夹</td><td style="text-align:left">包括隐藏文件夹</td></tr><tr><td style="text-align:left">Shift + Command + .</td><td style="text-align:left">显示隐藏文件、文件夹</td><td style="text-align:left">再按一次，恢复隐藏</td></tr><tr><td style="text-align:left">Command + ↑</td><td style="text-align:left">返回上一层</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Command + ↓</td><td style="text-align:left">进入当前文件夹</td><td style="text-align:left"></td></tr></tbody></table><h3 id="编辑"><a class="markdownIt-Anchor" href="#编辑"></a> 编辑</h3><p><strong>删除文字</strong>：</p><table><thead><tr><th style="text-align:left">快捷键</th><th style="text-align:left">作用</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left">delete</td><td style="text-align:left">删除光标的前一个字符</td><td style="text-align:left">相当于 Windows 键盘上的退格键</td></tr><tr><td style="text-align:left">fn + delete</td><td style="text-align:left">删除光标的后一个字符</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">option + delete</td><td style="text-align:left">删除光标之前的一个单词</td><td style="text-align:left">英文有效</td></tr><tr><td style="text-align:left"><strong>command + delete</strong></td><td style="text-align:left">删除光标之前的整行内容</td><td style="text-align:left">【荐】</td></tr><tr><td style="text-align:left">command + delete</td><td style="text-align:left">在 finder 中删掉该文件</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">shift + command + delete</td><td style="text-align:left">清空回收站</td><td style="text-align:left"></td></tr></tbody></table><p><strong>剪切文件</strong>：</p><p>首先选中文件，按 Command+C 复制文件；然后按「Command ＋ Option ＋ V」剪切文件。</p><p>备注：Command+X 只能剪切文字文本，不要混淆了。</p><h2 id="mac-用户必须知道的-15-组快捷键"><a class="markdownIt-Anchor" href="#mac-用户必须知道的-15-组快捷键"></a> Mac 用户必须知道的 15 组快捷键</h2><blockquote><p>参考链接：<a href="http://v.youku.com/v_show/id_XNDE4MzM0NDgw.html" target="_blank" rel="noopener">《轻松玩 Mac》第 6 期：Mac 用户必须知道的 15 组快捷键</a></p></blockquote><h3 id="space键快速预览"><a class="markdownIt-Anchor" href="#space键快速预览"></a> 「space」键：快速预览</h3><p>选中文件后， 不需要启动任何应用程序，使用「space」空格键可进行快速预览，再次按下「space」空格键取消预览。</p><p>可以预览 mp3、视频、pdf 等文件。</p><p>我们还可以<strong>选中多张图片</strong>， 然后按「space」键，就可以同时对比预览多张图片。这一点，很赞。</p><h3 id="改名"><a class="markdownIt-Anchor" href="#改名"></a> 改名</h3><p>选中文件/文件夹后，按 enter 键，就可以改名了。</p><h3 id="command-i键查看文件属性"><a class="markdownIt-Anchor" href="#command-i键查看文件属性"></a> 「command + I」键：查看文件属性</h3><ul><li><p>选中文件后，按「command + I」键，可以查看文件的各种属性。</p></li><li><p>选中<strong>文件夹</strong>后，按「command + I」键，可以查看文件夹的大小。【荐】</p></li></ul><h3 id="切换输入法"><a class="markdownIt-Anchor" href="#切换输入法"></a> 切换输入法</h3><p>「control + space」</p><h3 id="打开-spotlight-搜索框"><a class="markdownIt-Anchor" href="#打开-spotlight-搜索框"></a> 打开 spotlight 搜索框</h3><p>spotlight 是系统自带的软件，搜索功能不是很强大。我们一般都会用第三方的 Alfred 软件。</p><h3 id="编辑相关"><a class="markdownIt-Anchor" href="#编辑相关"></a> 编辑相关</h3><p>Cmd+C、Cmd+V、Cmd+X、Cmd+A、Cmd+Z。</p><h3 id="翻页和光标"><a class="markdownIt-Anchor" href="#翻页和光标"></a> 翻页和光标</h3><ul><li><p>「control + ↑」：将光标定位到文章的最开头（翻页到文档的最上方）</p></li><li><p>「control + ↓」：将光标定位到文章的最末尾（翻页到文档的最下方）</p></li><li><p>「control + ←」：将光标定位到当前行的最左侧</p></li><li><p>「control + →」：将光标定位到当前行的最右侧</p></li></ul><h3 id="command-shift-y将文字快速保存到便笺"><a class="markdownIt-Anchor" href="#command-shift-y将文字快速保存到便笺"></a> 「command + shift + Y」：将文字快速保存到便笺</h3><p>选中你想要的内容（例如文字、链接等），然后按下 command + shift + Y」，那么你选中的内容就会快速保存到系统自带的「便笺」软件中。</p><p>如果你想临时性的保存一段内容，这个操作很实用。</p><h3 id="程序相关"><a class="markdownIt-Anchor" href="#程序相关"></a> 程序相关</h3><ul><li><p>「command + Q」：快速退出程序</p></li><li><p>「command + tab」：切换程序</p></li><li><p>「command + H」：隐藏当前应用程序。这是一个有趣的快捷键。</p></li><li><p>「command + ，」：打开当前应用程序的「偏好设置」。</p></li></ul><h3 id="窗口相关"><a class="markdownIt-Anchor" href="#窗口相关"></a> 窗口相关</h3><ul><li><p>「command + N」：新建一个当前应用程序的窗口</p></li><li><p>「command + `」：在当前应用程序的不同窗口之间切换【很实用】</p></li></ul><p>我们知道，「command + tab」是在不同的软件之间切换。但你不知道的是，「command + `」是在同一个软件的不同窗口之间切换。</p><ul><li><p>「command + M」：将当前窗口最小化</p></li><li><p>「command + W」：关闭当前窗口</p></li></ul><h3 id="浏览器相关"><a class="markdownIt-Anchor" href="#浏览器相关"></a> 浏览器相关</h3><ul><li><p>「command + T」：浏览器中，新建一个标签</p></li><li><p>「command + W」：关闭当前标签</p></li></ul><ul><li>「command + R」：强制刷新。</li></ul><ul><li>「command + L」：定位到地址栏。【重要】</li></ul><h3 id="截图相关"><a class="markdownIt-Anchor" href="#截图相关"></a> 截图相关</h3><ul><li>「command + shift + 3」：截全屏（对整个屏幕截图）。</li></ul><h3 id="声音相关"><a class="markdownIt-Anchor" href="#声音相关"></a> 声音相关</h3><p>选中文字后，按住「ctrl + esc」键，会将文字进行朗读。（我发现，在触控条版的 mac 上，并没有生效）</p><h3 id="dock-栏相关"><a class="markdownIt-Anchor" href="#dock-栏相关"></a> Dock 栏相关</h3><ul><li>「option + command + D」：隐藏 dock 栏</li></ul><h3 id="强制推出"><a class="markdownIt-Anchor" href="#强制推出"></a> 强制推出</h3><blockquote><p>强制退出的快捷键非常重要</p></blockquote><ul><li>「option + command + esc」：打开强制退出的窗口</li></ul><h3 id="option-相关"><a class="markdownIt-Anchor" href="#option-相关"></a> option 相关</h3><blockquote><p>强烈推荐</p></blockquote><ul><li><p>「option + command + H」：隐藏除当前应用程序之外的其他应用程序</p></li><li><p>在文本中，按住「option」键，配合鼠标的选中，可以进行块状文字选取。</p></li><li><p>「option + command + W」：快速关闭当前应用程序的所有窗口。【很实用】</p></li></ul><p>比如说，你一次性打开了很多文件的详情，然后就可以通过此快捷键，将这些窗口一次性关闭。</p><ul><li>「option + command + I」：查看多个文件的总的属性。</li></ul><ul><li><p>打开 launchpad，按住「option」键，可以快速卸载应用程序。</p></li><li><p>在 dock 栏，右键点击软件图标，同时按住「option」键，就可以<strong>强制退出</strong>该软件。【重要】</p></li></ul><ul><li>在 Safari 浏览器中，按住「option + command + Q」退出 Safari。等下次进入 Safari 的时候，上次退出时的网址会自动被打开。【实用】</li></ul><h3 id="推荐一个软件cheatsheet"><a class="markdownIt-Anchor" href="#推荐一个软件cheatsheet"></a> 推荐一个软件：CheatSheet</h3><p>打开 CheatSheet 后，长按 command 键，会弹出当前应用程序的所有快捷键。我们还可以对这些快捷键进行保存。</p><h2 id="学习资源"><a class="markdownIt-Anchor" href="#学习资源"></a> 📚 学习资源</h2><ul><li><a href="https://github.com/jaywcjlove/awesome-mac" target="_blank" rel="noopener">Awesome Mac</a></li><li><a href="https://github.com/herrbischoff/awesome-macos-command-line" target="_blank" rel="noopener">awesome-macos-command-line</a></li></ul><h2 id="传送门"><a class="markdownIt-Anchor" href="#传送门"></a> 🚪 传送门</h2><p>| <a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">回首頁</a> |</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本操作&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#基本操作&quot;&gt;&lt;/a&gt; 基本操作&lt;/h2&gt;
&lt;h3 id=&quot;软件管理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#软件管理&quot;&gt;&lt;/a&gt; 软件管理&lt;/h3
      
    
    </summary>
    
    
      <category term="操作系统" scheme="https://dunwu.github.io/blog/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://dunwu.github.io/blog/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Mac" scheme="https://dunwu.github.io/blog/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Windows 常用技巧总结</title>
    <link href="https://dunwu.github.io/blog/os/windows/"/>
    <id>https://dunwu.github.io/blog/os/windows/</id>
    <published>2019-05-07T12:35:00.000Z</published>
    <updated>2019-11-22T03:31:33.349Z</updated>
    
    <content type="html"><![CDATA[<h1 id="windows-常用技巧总结"><a class="markdownIt-Anchor" href="#windows-常用技巧总结"></a> Windows 常用技巧总结</h1><!-- TOC depthFrom:2 depthTo:3 --><ul><li><a href="#%E8%BD%AF%E4%BB%B6">软件</a><ul><li><a href="#%E8%A7%86%E9%A2%91%E9%9F%B3%E9%A2%91">视频音频</a></li><li><a href="#%E5%8E%8B%E7%BC%A9">压缩</a></li><li><a href="#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86">文件管理</a></li><li><a href="#%E5%BC%80%E5%8F%91">开发</a></li><li><a href="#%E7%BC%96%E8%BE%91%E5%99%A8">编辑器</a></li><li><a href="#%E6%96%87%E6%A1%A3">文档</a></li><li><a href="#%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87">效率提升</a></li><li><a href="#%E5%8A%9E%E5%85%AC">办公</a></li><li><a href="#%E4%B8%AA%E6%80%A7%E5%8C%96">个性化</a></li></ul></li><li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li></ul><!-- /TOC --><h2 id="软件"><a class="markdownIt-Anchor" href="#软件"></a> 软件</h2><blockquote><p>扩展阅读：</p><ul><li><a href="https://github.com/Awesome-Windows/Awesome/blob/master/README-cn.md" target="_blank" rel="noopener">Awesome Windows</a></li><li><a href="https://github.com/stackia/best-windows-apps" target="_blank" rel="noopener">best-windows-apps</a></li></ul></blockquote><h3 id="视频音频"><a class="markdownIt-Anchor" href="#视频音频"></a> 视频音频</h3><ul><li><a href="http://getmusicbee.com/" target="_blank" rel="noopener">Musicbee</a> - 类似 iTunes，但比 iTunes 更好用。</li><li><a href="http://www.screentogif.com/" target="_blank" rel="noopener">ScreenToGif</a> - 它允许你录制屏幕的一部分区域并保存为 gif 或视频。</li><li><a href="http://potplayer.daum.net/" target="_blank" rel="noopener">PotPlayer</a> - 多媒体播放器，具有广泛的编解码器集合，它还为用户提供大量配置选项。</li><li><a href="http://www.splayer.org/" target="_blank" rel="noopener">射手影音播放器</a> - 来自射手网，小巧开源，首创自动匹配字幕功能。</li></ul><h3 id="压缩"><a class="markdownIt-Anchor" href="#压缩"></a> 压缩</h3><ul><li><a href="http://www.7-zip.org/" target="_blank" rel="noopener">7-Zip</a> - 用于处理压缩包的开源 Windows 实用程序。完美支持 7z，ZIP，GZIP，BZIP2 和 TAR 的全部特性，其他格式也可解压缩。</li><li><a href="http://www.rarlab.com/" target="_blank" rel="noopener">WinRAR</a> - 强大的归档管理器。 它可以备份您的数据并减小电子邮件附件的大小，解压缩 RAR，ZIP 和其他文件。</li></ul><h3 id="文件管理"><a class="markdownIt-Anchor" href="#文件管理"></a> 文件管理</h3><ul><li><a href="http://en.ejie.me/" target="_blank" rel="noopener">Clover</a> - 为资源管理器加上多标签功能。</li><li><a href="http://www.ghisler.com/" target="_blank" rel="noopener">Total Commander</a> - 老牌、功能异常强大的文件管理增强软件。</li><li><a href="http://www.softwareok.com/?seite=Freeware/Q-Dir" target="_blank" rel="noopener">Q-Dir</a> - 轻量级的文件管理器，各种布局视图切换灵活，默认四个小窗口组成一个大窗口，操作快捷。软件虽小，粉丝忠诚。</li><li><a href="https://github.com/Wox-launcher/Wox" target="_blank" rel="noopener">WoX</a> - 新一代文件定位工具，堪称 Windows 上的 Alfred。</li><li><a href="http://www.voidtools.com/" target="_blank" rel="noopener">Everything</a> - 最快的文件/文件夹搜索工具， 通过名称搜索。</li><li><a href="http://www.listary.com/" target="_blank" rel="noopener">Listary</a> - 非常优秀的 Windows 文件浏览和搜索增强工具。</li><li>Beyond Compare - 好用又万能的文件对比工具。</li><li><a href="https://www.piriform.com/ccleaner/download" target="_blank" rel="noopener">CCleaner</a> - 如果你有系统洁癖，那一定要选择一款干净、良心、老牌的清洁软件。</li><li><a href="https://chocolatey.org/" target="_blank" rel="noopener">chocolatey</a> - 包管理器</li><li><a href="https://ninite.com/" target="_blank" rel="noopener">Ninite</a> - 最简单，最快速的更新或安装软件的方式。</li><li><a href="http://www.piriform.com/RECUVA" target="_blank" rel="noopener">Recuva</a> - 来自 piriform 梨子公司产品，免费的数据恢复工具。</li><li><a href="http://www.launchy.net/" target="_blank" rel="noopener">Launchy</a>：自由的跨平台工具，帮助你忘记开始菜单、桌面图标甚至文件管理器。</li></ul><h3 id="开发"><a class="markdownIt-Anchor" href="#开发"></a> 开发</h3><ul><li><a href="http://www.telerik.com/fiddler" target="_blank" rel="noopener">Fiddler</a> - web 调试代理工具。</li><li><a href="https://www.getpostman.com/postman" target="_blank" rel="noopener">Postman</a> - 适合 API 开发的完整工具链，最常用的 REST 客户端。</li><li><a href="https://www.sourcetreeapp.com/" target="_blank" rel="noopener">SourceTree</a> - 一个免费的 Git &amp; Mercurial 客户端。</li><li><a href="https://tortoisesvn.net/" target="_blank" rel="noopener">TortoiseSVN</a> - Subversion(SVN)的图形客户端</li><li><a href="https://www.wireshark.org/" target="_blank" rel="noopener">Wireshark</a> - 一个网络协议分析工具。</li><li>Switchhosts</li><li><a href="https://github.com/cmderdev/cmder" target="_blank" rel="noopener">Cmder</a> - 控制台模拟器包。扩展阅读：<a href="https://www.jeffjade.com/2016/01/13/2016-01-13-windows-software-cmder/" target="_blank" rel="noopener">Win 下必备神器之 Cmder</a></li><li><a href="http://babun.github.io/" target="_blank" rel="noopener">Babun</a> - 基于 Cygwin，用于替代 Windows shell。</li></ul><h3 id="编辑器"><a class="markdownIt-Anchor" href="#编辑器"></a> 编辑器</h3><ul><li><a href="http://www.jetbrains.com/" target="_blank" rel="noopener">JetBrain IDE 系列</a> - 真香！</li><li><a href="https://code.visualstudio.com/" target="_blank" rel="noopener">Visual Studio Code</a> - 用于构建和调试现代 Web 和云应用程序。</li><li><a href="https://eclipse.org/downloads/" target="_blank" rel="noopener">Eclipse</a> - 一款功能强大的 IDE。</li><li><a href="https://www.visualstudio.com/vs/" target="_blank" rel="noopener">Visual Studio</a> - 微软官方的 IDE，通过插件可支持大量编程语言。</li><li><a href="https://netbeans.org/" target="_blank" rel="noopener">NetBeans IDE</a> - 免费开源的 IDE。</li><li><a href="https://www.typora.io/" target="_blank" rel="noopener">Typora</a> - 个人觉得最好用的 Markdown 编辑器。</li><li><a href="https://www.zybuluo.com/cmd/" target="_blank" rel="noopener">Cmd Markdown</a> - 跨平台优秀 Markdown 编辑器，本文即用其所写。</li><li><a href="https://notepad-plus-plus.org/" target="_blank" rel="noopener">Notepad++</a> - 一款支持多种编程语言的源码编辑器。</li><li><a href="http://www.flos-freeware.ch/notepad2.html" target="_blank" rel="noopener">Notepad2</a> - 用于替代默认文本编辑器的轻量快速的编辑器，拥有众多有用的功能。</li><li><a href="http://www.sublimetext.com/3" target="_blank" rel="noopener">Sublime Text 3</a> - 高级文本编辑器。</li><li><a href="https://atom.io/" target="_blank" rel="noopener">Atom</a> - 面向 21 世纪的极客文本编辑器。</li></ul><h3 id="文档"><a class="markdownIt-Anchor" href="#文档"></a> 文档</h3><ul><li><a href="http://www.office.com/" target="_blank" rel="noopener">Microsoft Office</a> - 微软办公软件。</li><li><a href="https://www.wps.com/office-free" target="_blank" rel="noopener">WPS Office</a> - 金山免费办公软件。</li><li><a href="http://calibre-ebook.com/" target="_blank" rel="noopener">Calibre</a> - 用于电子书管理和转换的强大软件。</li><li><a href="http://www.foxitsoftware.cn/products/reader/" target="_blank" rel="noopener">福昕阅读器</a> - 在全球拥有大量用户，最优秀的国产软件之一。Ribbon 界面，支持手写签名、插入印章等。</li></ul><h3 id="效率提升"><a class="markdownIt-Anchor" href="#效率提升"></a> 效率提升</h3><p><strong>【笔记】</strong></p><ul><li><a href="http://www.xmind.net/" target="_blank" rel="noopener">XMind</a> - 优秀的思维导图。</li><li><a href="https://www.onenote.com/" target="_blank" rel="noopener">OneNote</a> - Windows 下综合评价非常高的笔记应用。</li><li><a href="http://www.yinxiang.com/" target="_blank" rel="noopener">印象笔记</a> - 老牌跨平台笔记工具，国际版 Evernote。一家立志于做百年公司的企业，安全、可靠。</li><li><a href="http://www.wiz.cn/index.html" target="_blank" rel="noopener">为知笔记</a> - 越来越好的笔记应用，记录、查阅一切有价值的信息，同样跨平台支持。</li><li><a href="http://note.youdao.com/" target="_blank" rel="noopener">有道云笔记</a> - 网易旗下笔记工具，同样跨主流平台支持，文字、手写、录音、拍照多种记录方式，支持任意附件格式。</li><li><a href="https://getsharex.com/" target="_blank" rel="noopener">ShareX</a> - 你要的所有与截图、录屏相关的功能，这里都有了。</li></ul><p>【快捷键】</p><ul><li><a href="https://autohotkey.com/" target="_blank" rel="noopener">AutoHotkey</a> - Windows 平台的终极自动化脚本语言。</li></ul><blockquote><p>技巧：</p><ul><li><a href="https://www.jeffjade.com/2016/03/11/2016-03-11-autohotkey/" target="_blank" rel="noopener">https://www.jeffjade.com/2016/03/11/2016-03-11-autohotkey/</a></li><li><a href="https://www.autohotkey.com/boards/viewtopic.php?f=29&amp;t=4296" target="_blank" rel="noopener">https://www.autohotkey.com/boards/viewtopic.php?f=29&amp;t=4296</a></li></ul></blockquote><h3 id="办公"><a class="markdownIt-Anchor" href="#办公"></a> 办公</h3><ul><li><a href="http://cidian.youdao.com/index.html" target="_blank" rel="noopener">有道词典</a> - 最好用的免费全能翻译软件。</li><li><a href="http://office.microsoft.com/zh-cn/outlook/" target="_blank" rel="noopener">Outlook</a> - 大名鼎鼎的 Microsoft Office 组件之一，除了电子邮件，还包含了日历、任务管理、联系人、记事本等功能。</li><li><a href="http://www.gmail.com/" target="_blank" rel="noopener">Gmail</a> - 功能上可以称为业界标杆，用户数量世界第一，或许你真的找不到比它更好的邮件系统。</li><li><a href="https://www.google.com/intl/zh-CN/chrome/browser/" target="_blank" rel="noopener">Chrome</a> - 最好的浏览器。</li><li><a href="http://www.teamviewer.com/Zhcn/index.aspx" target="_blank" rel="noopener">Teamviewer</a> - 专业、功能强大的远程控制软件。使用简单，对个人用户免费。</li></ul><h3 id="个性化"><a class="markdownIt-Anchor" href="#个性化"></a> 个性化</h3><ul><li><a href="https://github.com/TranslucentTB/TranslucentTB" target="_blank" rel="noopener">TranslucentTB</a> - 透明化你的 Windows 任务栏。</li><li><a href="http://qttabbar.wikidot.com/" target="_blank" rel="noopener">QTTabBar</a> - 通过多标签和额外的文件夹视图扩展资源管理器的功能。</li><li><a href="https://www.stardock.com/products/fences/" target="_blank" rel="noopener">Fences</a> - 管理桌面快捷方式。</li></ul><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ul><li><a href="https://github.com/Awesome-Windows/Awesome/blob/master/README-cn.md" target="_blank" rel="noopener">https://github.com/Awesome-Windows/Awesome/blob/master/README-cn.md</a></li><li><a href="https://love.appinn.com/" target="_blank" rel="noopener">https://love.appinn.com/</a></li><li><a href="https://github.com/stackia/best-windows-apps" target="_blank" rel="noopener">https://github.com/stackia/best-windows-apps</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;windows-常用技巧总结&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#windows-常用技巧总结&quot;&gt;&lt;/a&gt; Windows 常用技巧总结&lt;/h1&gt;
&lt;!-- TOC depthFrom:2 depthTo:3 --&gt;
&lt;ul&gt;
      
    
    </summary>
    
    
      <category term="操作系统" scheme="https://dunwu.github.io/blog/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://dunwu.github.io/blog/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Windows" scheme="https://dunwu.github.io/blog/tags/Windows/"/>
    
  </entry>
  
</feed>
